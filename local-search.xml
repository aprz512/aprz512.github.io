<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>这学JNI，多是一件美事啊</title>
    <link href="/2022/01/02/blog_bak/Blog/C++/%E8%BF%99%E5%AD%A6JNI%EF%BC%8C%E5%A4%9A%E6%98%AF%E4%B8%80%E4%BB%B6%E7%BE%8E%E4%BA%8B%E5%95%8A/"/>
    <url>/2022/01/02/blog_bak/Blog/C++/%E8%BF%99%E5%AD%A6JNI%EF%BC%8C%E5%A4%9A%E6%98%AF%E4%B8%80%E4%BB%B6%E7%BE%8E%E4%BA%8B%E5%95%8A/</url>
    
    <content type="html"><![CDATA[<h3 id="JNI的定义"><a href="#JNI的定义" class="headerlink" title="JNI的定义"></a>JNI的定义</h3><p>JNI全称：Java Native Interface</p><p>它是Java本身的一种特性，用来在Java里面调用C/C++代码的。</p><p>看下面的一个程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;work&quot;</span>));<br>    System.setOut(ps);<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序比较简单，就是将输出流重定向了一下。但是，我们看一下 System 这个类的 out 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PrintStream out = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>这是一个 final 字段，那么 setOut 方法是如何改变这个 out 的值的呢？</p><p>是因为它调用了一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOut0</span><span class="hljs-params">(PrintStream out)</span></span>;<br></code></pre></td></tr></table></figure><p>在native层就可以绕过限制，改变一个final字段的值。</p><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>下面，看一个native版的 hello world 的例子：</p><p>先写一个 java 类，里面调用一个 native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> HelloWorld().print();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// String path = System.getProperty(&quot;java.library.path&quot;);</span><br>        <span class="hljs-comment">// System.out.println(path);</span><br>        System.loadLibrary(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>print 是一个 native 方法，它会输出 hello world。接下来我们实现这个 native 类。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Apache">/* <span class="hljs-attribute">DO</span> NOT EDIT THIS FILE - it is machine generated */<br><span class="hljs-comment">#include &lt;jni.h&gt;</span><br>/* <span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> for class HelloWorld */<br><br><span class="hljs-comment">#ifndef _Included_HelloWorld</span><br><span class="hljs-comment">#define _Included_HelloWorld</span><br><span class="hljs-comment">#ifdef __cplusplus</span><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-comment">#endif</span><br>/*<br> * <span class="hljs-attribute">Class</span>:     HelloWorld<br> * <span class="hljs-attribute">Method</span>:    print<br> * <span class="hljs-attribute">Signature</span>: ()V<br> */<br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL Java_HelloWorld_print<br>  (<span class="hljs-attribute">JNIEnv</span> *, jobject);<br><br><span class="hljs-comment">#ifdef __cplusplus</span><br>&#125;<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>这个文件是使用javah -jni生成的。 </p><p>头文件里面定义了一个方法，只不过这个方法的名称有点奇特，其实就是由对应的 java 方法的包名+方法名组成。不过如果涉及到特殊字符或者重载，还会有更多变化，具体的可以看 JNI 规范文档。</p><p>先忽略JNIEXPORT和JNICALL宏。你可能有注意到本地方法的C实现接受两个参数。但是HelloWorld.java中定义的 print 方法却没有接受任何参数。</p><p>每一个本地方法实现的第一个参数是一个JNIEnv接口指针。第二个参数是HelloWorld对象本身，类似于this指针。如果是一个静态方法，那么第二个参数是类对象本身，类似 Class 对象。</p><p>extern “C” {} 的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按c语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p><p>JNIECXPORT 的作用是将函数导出，可以被其他库调用。</p><p>JNICALL 的作用暂时不清楚，linux 平台似乎是空定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JNIEXPORT  __attribute__ ((visibility (<span class="hljs-meta-string">&quot;default&quot;</span>)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JNICALL</span><br></code></pre></td></tr></table></figure><p>接下来，我们来实现上面的这个方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-comment">#include &lt;jni.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &quot;HelloWorld.h&quot;</span><br><br><br>// <span class="hljs-attribute">mac</span> 上 loadLibary 方法会找以 .dylib 或者 .jnilib 结尾的库<br>// 编译命令  <span class="hljs-attribute">cc</span> -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -I. -fPIC -shared HelloWorld.c -o libHelloWorld.dylib<br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL Java_HelloWorld_print<br>  (<span class="hljs-attribute">JNIEnv</span> *env, jobject obj)<br>&#123;<br>    <span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-attribute">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现非常的简单，就是调用了一下 printf 方法，输出了 hello world。</p><p>再下面，就是生成 so 文件，不过需要注意的是，不同的平台，System.loadLibrary 方法加载的库文件的规则不一样。在 mac 上默认加载以 .dylib 或者 .jnilib 结尾的库，所以如果你生成了一个 libHelloWorld.so 的文件，是加载不了的，除非使用 load 方法加载绝对路径。</p><p>编译命令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">cc -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -I. -fPIC -shared HelloWorld.c -o libHelloWorld.dylib<br></code></pre></td></tr></table></figure><p>然后使用 javac 生成 class 文件，最后运行 class 文件，就能输出 hello world 了！！！</p><h3 id="JavaVM-JNIEnv"><a href="#JavaVM-JNIEnv" class="headerlink" title="JavaVM / JNIEnv"></a>JavaVM / JNIEnv</h3><p>一个JNIEnv指针仅在其相关联的线程中有效。不能将这个指针从一个线程中传递给另一个线程，或者在多线程中缓存和使用它。</p><p>Java虚拟机在同一个线程传递给本地方法相同的JNIEnv指针，但是从不同线程中调用本地方法时传递的是不同的JNIEnv指针。但是这些JNIEnv 指针的方法都是同一份。</p><p>获取 JNIEnv 有几种方式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">JNIEnv</span> *env;<br>(*<span class="hljs-attribute">jvm</span>)-&gt;AttachCurrentThread(jvm, (void **)&amp;env, NULL); <br><br><br>(*<span class="hljs-attribute">jvm</span>)-&gt;GetEnv((void **) env, JNI_VERSION_<span class="hljs-number">1</span>_<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>写到这一节的时候，多少有点随意，因为这一节的知识大家都知道，但是突然想了一下，为啥JNIEnv无法被线程共享呢？暂时没有找到阐述的很清楚的文章，翻了源码也没有思路，猜测一下，可能JNIEnv 的某些变量就是放在线程相关的缓冲区中的。不深究了。</p><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>上面花了一节来写一个demo，其实主要是想说 JNI 是java的东西，跟 android 关系不大，刚开始接触android的时候，我一直是将JNI当作android的特性来理解的，而且我看了一些 java 相关的书籍中，似乎都没有介绍 JNI 相关的。</p><p>我理解的 NDK 是google官方实现了很多API，提供给开发者来使用，只不过是通过JNI来实现的。</p><h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_Prompt_getLine</span><span class="hljs-params">(JNIEnv *env, jobject obj, jstring prompt)</span> </span>&#123;<br>    <span class="hljs-comment">/* ERROR: incorrect use of jstring as a char* pointer */</span> <br>    printf(<span class="hljs-string">&quot;%s&quot;</span>, prompt); <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当从 java 层传递一个字符串过来之后，它的类型是 jstring。完整的类型映射表如下：</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMyMWM1MDU3ODBlOWJmOTVhOGM3OWQwMWQ1NzVjZTNfdUxvdFRZYkZKakdLd21OMXlTQTFiV2VTdkdmWTA3TGtfVG9rZW46Ym94Y251amVyVmdGaHdQazF5S2dZOHdZNkpoXzE2NDExMzYwODY6MTY0MTEzOTY4Nl9WNA" alt="img"></p><p>如果，我们想打印一下这个字符串，那么可以使用 GetStringUTFChars 这个函数，它会返回一个 const char * 类型（编码是 MUTF 类型，具体看参考文档 JNI TIPS），我们就可以使用 printf 来打印它了。为啥要是 const 的呢？是因为java中的string是不可变的，不允许更改。</p><p>还有一个 GetStringChars 函数，它返回 jchar* 类型，我们不能直接打印。Java 中的字符都是 Unicode 编码，显然这个 jchar * 指向的是 unicode 编码的字符串。</p><p>有一个需要注意的地方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> x ;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *chars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(hello, &amp;x);<br><br><span class="hljs-keyword">if</span>(x)<br></code></pre></td></tr></table></figure><p>我们经常会用到这个方法，但是第二个参数经常会让我疑惑，查了一些文档后，终于弄明白了：</p><p>这个方法会返回字符串的utf形式，由于虚拟机内部以及本地内存的一些原因，在调用这个方法的时候，有可能会将字符串拷贝一遍。如果返回的字符串是原来的 java.lang.String 的一份拷贝， 在方法返回之后，isCopy指向的内存地址将会被设置为JNI_TRUE。而如果返回的字符串指针直接指向原来的java.lang.String对象，则该地址会被设置为JNI_FALSE。如果返回了JNI_FALSE, 则原生代码将不能改变返回的字符串，因为改变了这个字符串，原来的java字符串也会被修改，这违背了java.lang.String实例不可改变的原则。通常你可以直接传递NULL给isCopy来告诉Java虚拟机你不在乎返回的字符串是否拷贝了。</p><p>同样的，基于上面的原因，在调用完这个方法之后，就需要调用一个对应的ReleaseStringUTFChars 方法，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">str = (*env)-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(env, prompt, <span class="hljs-literal">NULL</span>);<br>(*env)-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(env, prompt, str);<br></code></pre></td></tr></table></figure><p>否则会造成内存泄漏。</p><p>ReleaseStringUTFChars 的实现比较有意思：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseStringUTFChars</span><span class="hljs-params">(JNIEnv*, jstring, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* chars)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span>[] chars;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看 GetStringUTFChars 的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">GetStringUTFChars</span><span class="hljs-params">(JNIEnv* env, jstring java_string, jboolean* is_copy)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (java_string == <span class="hljs-literal">nullptr</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (is_copy != <span class="hljs-literal">nullptr</span>) &#123;<br>     *is_copy = JNI_TRUE;<br>   &#125;<br><br>   <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>   ObjPtr&lt;mirror::String&gt; s = soa.Decode&lt;mirror::String&gt;(java_string);<br>   <span class="hljs-keyword">size_t</span> length = s-&gt;<span class="hljs-built_in">GetLength</span>();<br>   <span class="hljs-keyword">size_t</span> byte_count =<br>       s-&gt;<span class="hljs-built_in">IsCompressed</span>() ? length : <span class="hljs-built_in">GetUncompressedStringUTFLength</span>(s-&gt;<span class="hljs-built_in">GetValue</span>(), length);<br>   <span class="hljs-keyword">char</span>* bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[byte_count + <span class="hljs-number">1</span>];<br>   <span class="hljs-built_in">CHECK</span>(bytes != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// bionic aborts anyway.</span><br>   <span class="hljs-keyword">if</span> (s-&gt;<span class="hljs-built_in">IsCompressed</span>()) &#123;<br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* src = s-&gt;<span class="hljs-built_in">GetValueCompressed</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; byte_count; ++i) &#123;<br>       bytes[i] = src[i];<br>     &#125;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">char</span>* end = <span class="hljs-built_in">GetUncompressedStringUTFChars</span>(s-&gt;<span class="hljs-built_in">GetValue</span>(), length, bytes);<br>     <span class="hljs-built_in">DCHECK_EQ</span>(byte_count, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(end - bytes));<br>   &#125;<br>   bytes[byte_count] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>   <span class="hljs-keyword">return</span> bytes;<br> &#125;<br></code></pre></td></tr></table></figure><p>看第6行，是必定会执行拷贝的，所以 JNI 在 ART里面的实现，是一定会拷贝。</p><p>对于字符串的创建还有一对函数：NewStringUTF/NewString ，这个是类似的，不说了，看文档吧。</p><p>还有一点要提一下，Get/ReleaseStringCritical 这对函数我没有用过，但是有了 Get/ReleaseStringChars  为啥还要这对玩意呢？而且这对函数使用起来条件比较苛刻，他们之间的本地代码不能调用会引起阻塞的方法以及创建新对象，否则虚拟机可能会引起死锁。</p><p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY1MjBiZDAxN2I4YzAwZjhlNGVmMDMwNWMzNmMwMzdfbWVpZFVVdGNMdEhYVnQ5QjJqM1J0Nmt3V2U0SkZiVTZfVG9rZW46Ym94Y25VTmZBWE1sdFhLNnZTNk55R0gzbTBnXzE2NDExMzYwODY6MTY0MTEzOTY4Nl9WNA" alt="img"></p><p>根据上面的文档，只能猜测他们的性能要稍微好点？？</p><h3 id="JNI-访问-java-字段与方法"><a href="#JNI-访问-java-字段与方法" class="headerlink" title="JNI 访问 java 字段与方法"></a>JNI 访问 java 字段与方法</h3><p>JNIEnv  提供了一个 FindClass 方法来寻找某一个类，这个里面的逻辑其实就是 ClassLoader 的逻辑。</p><p>这一套方法有点像 Java 里面的反射的使用方式。</p><p>上面拿到的是 jclass 对象，按照反射的逻辑，我们接下来就该获取对应的字段或者方法了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">jmethodID mid;<br>jclass runnableIntf =(*env)-&gt;FindClass(env, <span class="hljs-string">&quot;java/lang/Runnable&quot;</span>); <br>mid = (*env)-&gt;GetMethodID(env, runnableIntf, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <br></code></pre></td></tr></table></figure><p>GetMethodID 的第3个参数需要解释一下，看例子：</p><p>“(I)V”表明该方法有一个类型为int的参数并且返回类型为void。</p><p>“()D”表明该方法不需要参数并且返回一个double值。</p><p>调用静态方法，使用 GetStaticMethod ID。</p><p>访问字段/构造方法也是类似的，一看就懂。</p><p>那么这里就有一个问题，既然，能使用构造方法，来为啥不直接用 String 的构造方法来创建字符串，而是要为 String 创建专门的使用函数呢？</p><p>答案还是因为性能问题，字符串是编程语言中使用最频繁的了，必须得特别支持。</p><p>由于，FindClass/GetMethodID/GetFieldID 这些都会有性能问题，所以有一个小技巧就是将这些结果缓存起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">jmethodID MID_InstanceMethodCall_callback; <br><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_InstanceMethodCall_initIDs</span><span class="hljs-params">(JNIEnv *env, jclass cls)</span> </span>&#123;<br>    MID_InstanceMethodCall_callback = (*env)-&gt;GetMethodID(env, cls, <span class="hljs-string">&quot;callback&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>后面，直接使用缓存的字段就好了。</p><p>使用JNI访问字段和调用方法的性能特性如何？</p><p>一个典型的虚拟机实现执行Java/native调用比执行Java/Java调用大概慢两到三倍。</p><p>有了 method id 与 field id 就可以尝试访问方法与字段了，常用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">CallVoidMethod<br>CallVoidMethodV<br>CallVoidMethodA<br></code></pre></td></tr></table></figure><p>那这3个方法有啥区别呢？</p><p>从文档上看不出来什么东西，但是从源码里面可以看出来，前面两个内部调用的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">InvokeVirtualOrInterfaceWithVarArgs<br></code></pre></td></tr></table></figure><p>后面一个内部调用的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">InvokeVirtualOrInterfaceWithJValues<br></code></pre></td></tr></table></figure><p>那这两个内部又有啥区别呢？</p><p>这要说到两种类型，一种是 va_list，一种是 jvalue。va_list 就是可变长参数，我们使用 va_arg(变长参数, 类型)，就可以取出参数的值。jvalue 是一个联合类型，它里面储存的是真正的参数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">jvalue</span> &#123;</span><br>    jboolean    z;<br>    jbyte       b;<br>    jchar       c;<br>    jshort      s;<br>    jint        i;<br>    jlong       j;<br>    jfloat      f;<br>    jdouble     d;<br>    jobject     l;<br>&#125; jvalue;<br></code></pre></td></tr></table></figure><p>其实，<a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/reflection.h;drc=master;l=94">InvokeVirtualOrInterfaceWithVarArgs</a> 这个方法内部是将可变参数一个一个的取出来，然后转为 jvalue 类型，再处理，可以理解为上面的两个方法殊途同归。所以，最终的参数都是 jvalue 类型。但是使用起来还是 CallVoidMethod 最方便，它只需要我们传递 java 对应的类型就好了，比如需要一个 String，我们就传递一个 jstring。</p><h3 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h3><p>上面说到，将计算出来的 class/method/field 缓存起来可以提高运行性能，但是有一点需要注意。</p><p>FindClass 返回的是一个局部引用，而局部引用在函数返回后会被JVM自动回收。</p><p>查了一些资料以及经过自己的测试，发现 FindClass 返回的是局部引用，GetMethodID/GetFieldID 返回的是弱全局引用。</p><p>我写了这样的一个Demo：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jclass</span> cache_class;<br><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL<br><span class="hljs-attribute">Java_com_aprz_mytestdemo_jni_RefActivity_cache</span>(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">if</span> (cache_class == nullptr) &#123;<br>        <span class="hljs-attribute">cache_class</span> = env-&gt;FindClass(<span class="hljs-string">&quot;com/aprz/mytestdemo/jni/RefActivity&quot;</span>);<br>    &#125;<br>    <span class="hljs-attribute">LOGE</span>(<span class="hljs-string">&quot;cache_class = %p&quot;</span>, cache_class);<br>    <span class="hljs-attribute">jmethodID</span> just_print = env-&gt;GetMethodID(cache_class, <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-attribute">if</span> (just_print) &#123;<br>        <span class="hljs-attribute">env</span>-&gt;CallVoidMethodA(thiz, just_print, &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码想缓存一个 RefActivity 的引用以便后续使用，但是却有一个逻辑问题，cache_class 它是一个指针，第一次被赋值后，指向 RefActivity 的 class 的一个局部引用，这个引用在方法结束之后会被回收，但是 cache_class 的值仍然指向那个局部引用的地址（地址里面没有东西了），所以导致 cache_class 成了一个野指针。</p><p>该方法第一次执行时没有问题，第二次执行时就会报错：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">36.466</span> <span class="hljs-number">6683</span><span class="hljs-literal">-6683</span>/? A/DEBUG: signal <span class="hljs-number">6</span> (SIGABRT), code <span class="hljs-literal">-1</span> (SI_QUEUE), fault addr --------<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">36.466</span> <span class="hljs-number">6683</span><span class="hljs-literal">-6683</span>/? A/DEBUG: Abort message: <span class="hljs-string">&#x27;JNI DETECTED ERROR IN APPLICATION: use of deleted local reference 0x75</span><br><span class="hljs-string">        from void com.aprz.mytestdemo.jni.RefActivity.cache()&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的方式缓存 method id ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jmethodID</span> cache_method_id;<br><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL<br><span class="hljs-attribute">Java_com_aprz_mytestdemo_jni_RefActivity_cacheMethod</span>(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">if</span> (cache_method_id == nullptr) &#123;<br>        <span class="hljs-attribute">cache_method_id</span> = env-&gt;GetMethodID(env-&gt;GetObjectClass(thiz), <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    &#125;<br>    <span class="hljs-attribute">if</span> (cache_method_id) &#123;<br>        <span class="hljs-attribute">env</span>-&gt;CallVoidMethodA(thiz, cache_method_id, &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 GetMethodID 返回的是弱全局引用，那么只要有别的地方引用它，它就不会被回收，所以这样使用没有问题。多次运行是ok的。</p><p>还有一个问题，JNIEnv 提供了一个 DeleteLocalRef 方法用来删除局部引用，那么就有人要问了，既然局部引用在方法执行完之后会被回收，为啥还要提供这个方法，让它自己会被回收不香吗？</p><p>是基于两个原因，第一个是在某些版本的 android 里面，JNI的局部引用表是有限制的，比如 512。既然有限制，那么就有可能超过这个限制，比如，你方法里面有循环，又比如，你写了一个调用链巨长的方法。所以，我们应该在以下这些情况主动删除局部引用：</p><ol><li><p>本地代码遍历一个特别大的字符串数组，每遍历一个元素，都会创建一个局部引用，当对使用完这个元素的局部引用时，就应该马上手动释放它。</p></li><li><p>局部引用会阻止所引用的对象被 GC 回收。比如你写的一个本地函数中刚开始需要访问一个大对象，因此一开始就创建了一个对这个对象的引用，但在函数返回前会有一个大量的非常复杂的计算过程，而在这个计算过程当中是不需要前面创建的那个大对象的引用的。但是，在计算的过程当中，如果这个大对象的引用还没有被释放的话，会阻止 GC 回收这个对象，内存一直占用着，造成资源的浪费。所以这种情况下，在进行复杂计算之前就应该把引用给释放了，以免不必要的资源浪费。</p></li><li><p>编写工具函数时，要当心不要在函数的调用轨迹上遗漏任何的局部引用，因为工具函数被调用的场合和次数是不确定的，一量被大量调用，就很有可能造成内存溢出。</p></li></ol><p>反正，核心就是，能够删除的就立即删除。</p><p>比如，我写了一个工具方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tools</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>    jmethodID x = env-&gt;GetMethodID(env-&gt;GetObjectClass(thiz), <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>它泄漏了一个局部引用，当我在一个 while(true) 里面调用这个方法的时候，就会报错：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>] JNI ERROR (app bug): local reference table overflow (max=<span class="hljs-number">8388608</span>)<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>] local reference table dump:<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]   Last <span class="hljs-number">10</span> entries (of <span class="hljs-number">8388608</span>):<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388607</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388606</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388605</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br></code></pre></td></tr></table></figure><p>错误提示很明显，是局部引用表溢出了，800多万个，几秒就耗光了！！下面有表里面储存的对象的 dump，全是 RefActivity 的 class 对象，看我们上面的代码，是 env-&gt;GetObjectClass(thiz) 这行代码有问题，它返回了一个局部引用，每次调用这个方法，都会累加一次。所以造成溢出，应该将它删除。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">void</span> tools(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">jclass</span> tmp_class = env-&gt;GetObjectClass(thiz);<br>    <span class="hljs-attribute">jmethodID</span> tmp_method = env-&gt;GetMethodID(tmp_class, <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-attribute">env</span>-&gt;DeleteLocalRef(tmp_class);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写就没问题了，注意，tmp_method 不能 delete，会报错，突然发现好像也没有一个文档来说明那些应该删除，那些不能删除。</p><p>上面的这个例子有一点没能想通，就是 GetObjectClass 返回的是一个局部引用，循环体里面的方法执行完之后就释放了才对，为啥还会导致引用溢出，猜测与编译器优化，变量分配有关。</p><p>看了一下 android 11 的源码，local table 的大小为 512，上面测试的手机是我刷的android10的镜像，不知道为啥这么大。看注释可知，是故意设置这么小的，强制开发者注意随时释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Number of local references in the indirect reference table. </span><br><span class="hljs-comment">// The value is arbitrary but low enough that it forces sanity checks.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kLocalsInitial = <span class="hljs-number">512</span>;<br></code></pre></td></tr></table></figure><p>同样的，全局引用与弱全局引用也有对应的删除方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">env</span>-&gt;DeleteGlobalRef()<br><span class="hljs-attribute">env</span>-&gt;DeleteWeakGlobalRef()<br></code></pre></td></tr></table></figure><p>还有一个知识点是引用的比较：给定两个引用（不管是全局、局部还是弱全局引用），我们只需要调用 IsSameObject 来判断它们两个是否指向相同的对象。</p><p>例如：<code>（*``env``)-&gt;IsSameObject(env, obj1, obj2)</code></p><p>如果 obj1 和 obj2 指向相同的对象，则返回 JNI_TRUE（或者 1），否则返回 JNI_FALSE（或者 0）。这个方法还可以用于空指针的比较。如果 obj 是一个局部或全局引用，可以用来判断 obj 是否指向一个 null 对象。但需要注意的是，如果比较的是弱全局引用，那么true表示的是该引用被回收了。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当JNI调用 java 方法时，java 方法有可能会出现异常，那么我们需要做对应的处理，因为出了异常之后，不像在 java 里面，后面的流程会中断，而是会继续执行，看下面的一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_aprz_mytestdemo_jni_ExceptionActivity_toNative</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>    jclass exception_activity_class = env-&gt;GetObjectClass(thiz);<br>    jmethodID do_something_method_id = env-&gt;GetMethodID(exception_activity_class, <span class="hljs-string">&quot;doSomething&quot;</span>,<br>                                                        <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-keyword">if</span> (do_something_method_id) &#123;<br>        <span class="hljs-comment">// 这里出了异常</span><br>        env-&gt;CallVoidMethod(thiz, do_something_method_id);<br>    &#125;<br><br>    LOGE(<span class="hljs-string">&quot;i will print even exception occurred!!!!&quot;</span>);<br><br>    env-&gt;DeleteLocalRef(exception_activity_class);<br>&#125;<br></code></pre></td></tr></table></figure><p>doSomething 是一个 java 方法，它会抛出一个空指针异常。按照我们对 java 的理解，LOGE 这行代码应该执行不到才对，但是实际上它打印出来了。所以我们需要一种手段来检测异常是否出现，从而做对应的处理。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">exc</span> = (*env)-&gt;ExceptionOccurred(env); <br><span class="hljs-attribute">if</span> (exc) &#123;<br>    (*<span class="hljs-attribute">env</span>)-&gt;ExceptionDescribe(env); <br>    (*<span class="hljs-attribute">env</span>)-&gt;ExceptionClear(env); <br>&#125;<br></code></pre></td></tr></table></figure><p>ExceptionOccurred会检测到这个异常。</p><p>ExceptionDescribe会输出一个关于这个异常的描述性信息。</p><p>ExceptionClear方法清除这个异常。</p><p>还有一个 ExceptionCheck 方法，它的功能与 ExceptionOccurred 类似，但是它不会产生一个局部引用，所以使用起来比较方便。</p><p>异常检查的代码写起来很麻烦，但是确实是必要的，特别是你申请了资源的时候，出了异常必须要释放才行。</p><h3 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h3><p>当 Sytem.loadlibrary 加载一个 so 的时候，虚拟机会找到该 so 中的 JNI_OnLoad 方法，并调用它。</p><p>简单的追一下调用链：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">java.lang.System<span class="hljs-comment">#loadLibrary</span><br>java.lang.Runtime<span class="hljs-comment">#nativeLoad(java.lang.String, java.lang.ClassLoader, java.lang.Class&lt;?&gt;)</span><br>// 下面的是 android<span class="hljs-literal">-11</span>.<span class="hljs-number">0.0</span>—r3 代码<br>Runtime_nativeLoad  -&gt;<br>JVM_NativeLoad -&gt;<br>JavaVMExt::LoadNativeLibrary<br></code></pre></td></tr></table></figure><p>LoadNativeLibrary 这个方法里面做了两件非常重要的事情：</p><ol><li><p>void* <strong><a href="http://source.bytedance.net/android/s?refs=handle&project=android-11.0.0_r3">handle</a></strong> = <a href="http://source.bytedance.net/android/s?defs=android&project=android-11.0.0_r3">android</a>::<a href="http://source.bytedance.net/android/s?defs=OpenNativeLibrary&project=android-11.0.0_r3">OpenNativeLibrary</a></p><ol><li><p> 将 so 加载进来，使用的是 android_dlopen_ext 方法。</p></li><li><p> 创建一个 SharedLibrary 对象：new  SharedLibrary(…, handle, …)</p></li></ol></li><li><p>找到 JNI_OnLoad 函数的地址，执行这个函数</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">void</span>* sym = library-&gt;<span class="hljs-built_in">FindSymbol</span>(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>...<br><span class="hljs-keyword">using</span> JNI_OnLoadFn = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(JavaVM*, <span class="hljs-keyword">void</span>*);<br>JNI_OnLoadFn jni_on_load = <span class="hljs-keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);<br><span class="hljs-keyword">int</span> version = (*jni_on_load)(<span class="hljs-keyword">this</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><p>从这里，我们可以看出，该方法的第二个参数没什么卵用，是用来兼容以后的版本的。</p><p>JNI 提供了注册函数的两种方式，一种是静态注册，就是我们第一个例子使用的方式，第二种是动态注册（RegisterNatives），动态注册的时机通常就是在 JNI_OnLoad 中，动态注册相比较于静态注册的好处就是可以批量注册，而且还不会暴露出注册的函数。</p><p>看了一下源码流程，其实静态注册也是走的动态注册的流程。当一个类被加载的时候，会去设置</p><h3 id="C、C-使用-JNIEnv-的不同之处"><a href="#C、C-使用-JNIEnv-的不同之处" class="headerlink" title="C、C++ 使用 JNIEnv 的不同之处"></a>C、C++ 使用 JNIEnv 的不同之处</h3><p>c 中的 JNIEnv：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">typedef</span> const struct JNINativeInterface* JNIEnv;<br></code></pre></td></tr></table></figure><p>env 是一个 JNINativeInterface** c++ 中的 JNIEnv：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> _JNIEnv JNIEnv;<br></code></pre></td></tr></table></figure><p>_JNIEnv 又是 const struct JNINativeInterface* functions; 所以 env 是一个 JNINativeInterface** 类型都是一样的，但是使用方式不一样，是因为 JNINativeInterface 对C++做了封装。 看下面一段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">JNIEnv</span> &#123;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNINativeInterface</span>* <span class="hljs-title">functions</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__cplusplus)</span><br><br><span class="hljs-function">jint <span class="hljs-title">GetVersion</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> functions-&gt;<span class="hljs-built_in">GetVersion</span>(<span class="hljs-keyword">this</span>); &#125;<br></code></pre></td></tr></table></figure><p>_JNIEnv 除了直接引用了 JNINativeInterface* 之外，还将里面的接口重新定义了一遍，然后将 this 参数替我们传递了。</p><p>所以在cpp文件里面，使用 env 非常简单，而在 c 文件里面使用 env 比较麻烦。</p><h3 id="FindClass-GetMethodID-CallVoidMethod-内部逻辑"><a href="#FindClass-GetMethodID-CallVoidMethod-内部逻辑" class="headerlink" title="FindClass / GetMethodID / CallVoidMethod 内部逻辑"></a>FindClass / GetMethodID / CallVoidMethod 内部逻辑</h3><p>首先说 FindClass 的逻辑，这是看的 <a href="https://blog.csdn.net/luoshengyang/article/details/39533503">Android运行时ART加载类和方法的过程分析</a> 这篇文章，是分析的 4.4 的代码，很老了，但是大致逻辑应该差不过，理解了这个，可以再去看最新的代码。</p><p>上面提到过，FindClass 走的也是 classLoader 加载类的流程，我们知道，每个 classLoader 都会指定 path 用来加载 dex 文件，那么有了类的描述符之后，就会挨个的去找，从而获取对应的 DexFile 文件。如果 classLoader 为 null 的话，就会去系统启动路径去找。</p><p>找到 DexFile 之后，会创建一个 kclass 对象，就是 native 层的 Class。然后设置各种信息：类索引号，静态成员变量和实例成员变量，函数索引号等。</p><p>创建 class 的时候，会加载类的各个成员，比如类方法，这个时候，就会创建 ArtField 与 ArtMethod 等。对于 ArtMethod，会去 LinkCode，这个顾名思义，就是链接该方法对应的指令了。如果这个方法是一个 native 方法，就会去注册这个方法，就像动态注册一样，其实就是设置了  <a href="http://source.bytedance.net/android/s?defs=entry_point_from_jni_&project=android-5.0.1_r1">entry_point_from_jni_</a> 的值，只不过它设置的是一个 stub，等到真正调用的时候才会去 dlsym  查询 so 的函数地址，然后替换成真的，这种模式很常用。</p><p>所以，FindClass 其实就是加载了一个类，创建了对应 Class 对象，以及为每个类方法创建了 “Stub” 对象，方法真正被调用的时候才会创建真的。</p><p>那么 GetMethodID 的逻辑就更简单了，该方法需要一个 jclass 参数，而这个参数其实就是 Class 对象的一个指针，所以我们只需要拿到 Class 对象里面 ArtMethod 数组，一个一个对比就好了，不过有点麻烦的是，要考虑接口，父类等问题。</p><p>CallVoidMethod 的逻辑其实也不难，但是需要对 ArtMethod 的结构有一定的了解，我们看下面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">class</span> ArtMethod &#123;<br>…………<br><span class="hljs-attribute">protect</span>:<br><span class="hljs-attribute">HeapReference</span> declaring_class_;<br><span class="hljs-attribute">HeapReference</span>&gt; dex_cache_resolved_methods_;<br><span class="hljs-attribute">HeapReference</span>&gt; dex_cache_resolved_types_;<br><span class="hljs-attribute">uint32_t</span> access_flags_;<br><span class="hljs-attribute">uint32_t</span> dex_code_item_offset_;<br><span class="hljs-attribute">uint32_t</span> dex_method_index_;<br><span class="hljs-attribute">uint32_t</span> method_index_;<br><span class="hljs-attribute">struct</span> PACKED(<span class="hljs-number">4</span>) PtrSizedFields &#123;<br><span class="hljs-attribute">void</span>* entry_point_from_interpreter_;<br><span class="hljs-attribute">void</span>* entry_point_from_jni_;<br><span class="hljs-attribute">void</span>* entry_point_from_quick_compiled_code_;<br><span class="hljs-comment">#if defined(ART_USE_PORTABLE_COMPILER)</span><br><span class="hljs-attribute">void</span>* entry_point_from_portable_compiled_code_;<br><span class="hljs-comment">#endif</span><br>&#125; <span class="hljs-attribute">ptr_sized_fields_</span>;<br><span class="hljs-attribute">static</span> GcRoot java_lang_reflect_ArtMethod_;<br>｝<br>……<br></code></pre></td></tr></table></figure><p>这是 5.0 的代码，这个时候，还存在entry_point_from_jni_，entry_point_from_interpreter_ 这些字段，这些字段其实就是方法的指令入口地址：</p><p>entry_point_from_jni_ ：如果该方法是一个 native 方法，那么这个地址就是加载进来的 so 中的方法的地址。</p><p>entry_point_from_interpreter_：这个是使用解释器执行时，指令的地址。</p><p>entry_point_from_quick_compiled_code_：这个是非解释器执行时的指令地址（就是 aot 模式）。</p><p>还有一个 entry_point_from_portable_compiled_code_，这个似乎没有打开过。它与 entry_point_from_quick_compiled_code_ 类似，只不过是这两种模式生成的 oat 文件不一样，</p><p>通过Portable后端和Quick后端生成的OAT文件的本质区别在于，前者使用标准的动态链接器加载，而后者使用自定义的加载器加载。</p><p> 标准动态链接器在加载SO文件（这里是OAT文件）的时候，会自动处理重定位问题。也就是说，在生成的本地机器指令中，如果有依赖其它的SO导出的函数，那么标准动态链接器就会将被依赖的SO也加载进来，并且从里面找到被引用的函数的地址，用来重定位引用了该函数的符号。</p><p>自定义加载器的做法就不一样了。它在加载OAT文件时，并不需要做上述的重定位操作。因为Quick后端生成的本地机器指令需要调用一些外部库提供的函数时，是通过一个函数跳转表来实现的。由于在加载过程中不需要执行重定位，因此加载过程就会更快，Quick的名字就是这样得来的。</p><p>了解了上面的知识，我们再来看 CallVoidMethod，有了 method id，就相当于有了 ArtMethod，而 ArtMethod 里面又有方法对应的指令入口，直接跳转过去执行就好了，当然不像我说的这么简单，还要处理参数，栈帧等。</p><h3 id="hook-jni-调用"><a href="#hook-jni-调用" class="headerlink" title="hook jni 调用"></a>hook jni 调用</h3><p>上面说到，java 方法对应的 jni 函数的地址在 entry_point_from_jni_ 这个里面，那么我们只需要替换这个值为我们写的方法的地址，就可以监控方法的执行了。</p><p>实现这个功能的难点在于，如何找到 ArtMethod 里面的 entry_point_from_jni_ 这个字段。</p><p>因为每个版本，每个rom都可能不一样，所以有一种取巧的方式是写两个相邻的 native method：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">external fun <span class="hljs-title">x1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">external fun <span class="hljs-title">x2</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>然后，获取到他们的 jmethodid：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jclass</span> entry_point_activity = env-&gt;GetObjectClass(thiz);<br><br><span class="hljs-attribute">jmethodID</span> x<span class="hljs-number">1</span> = env-&gt;GetMethodID(entry_point_activity, <span class="hljs-string">&quot;x1&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br><span class="hljs-attribute">jmethodID</span> x<span class="hljs-number">2</span> = env-&gt;GetMethodID(entry_point_activity, <span class="hljs-string">&quot;x2&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br></code></pre></td></tr></table></figure><p>因为，jmethodID 实际上就是 ArtMethod 的指针，所以，我们就获取到了这两个对象的地址。</p><p>对象里面储存的是各个字段，我们只需要从对象的地址开始往后遍历，总能走到 entry_point_from_jni_ 这个字段，然后跟我们声明的 JNI 函数比较一下即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">intptr_t</span> offsetToFind =<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">intptr_t</span> &gt;(x1) - <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">intptr_t</span> &gt;(x2);<br><br><br><span class="hljs-keyword">if</span> (offsetToFind &lt; <span class="hljs-number">0</span>) &#123;<br>    offsetToFind = -offsetToFind;<br>&#125;<br><span class="hljs-keyword">if</span> (offsetToFind &gt; <span class="hljs-number">128</span>) &#123;<br>    offsetToFind = <span class="hljs-number">128</span>;<br>&#125;<br><br><br><span class="hljs-keyword">uintptr_t</span> jni_entry_point_offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uintptr_t</span> curOffset = <span class="hljs-number">0</span>; curOffset &lt; offsetToFind; curOffset += <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *)) &#123;<br>    <span class="hljs-keyword">uintptr_t</span> curAddr = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span> &gt;(x1) + curOffset;<br>    <span class="hljs-keyword">if</span> ((*<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> **&gt;(curAddr)) ==<br>        Java_com_aprz_mytestdemo_jni_EntryPointsActivity_x1) &#123;<br>        jni_entry_point_offset = curOffset;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是限制了最大往后遍历128位。其中有一点不太明白，就是为什么步长是  sizeof（void *），因为我们不确定rom会放什么字段。</p><p>经过测试发现，对象中的字段会对齐，按照字段占用最大值对齐，比如有一个 char，一个 void *，会将结构的占用的内存，扩展为最大值的倍数，于是char 扩展成 4/8 字节。</p><p>计算出了地址，hook 就只需要将你创建的替换函数的地址替换上去就好了，记得签名一致。</p><p>需要注意的是，这种ArtMethod计算方法只在11以下管用，11及以上ArtMethod的获取需要使用其他的方式，这个可以去翻翻源码来解决！</p><p>我看了5.x里面的逻辑，ArtMethod 的 entry_point_from_jni_ 字段，默认会设置为 Stub（<a href="http://source.bytedance.net/android/s?defs=art_jni_dlsym_lookup_stub&project=android-5.0.1_r1">art_jni_dlsym_lookup_stub</a>） 的地址，在 Stub 执行的时候，会在 so 里面找真实的方法地址，找到了之后 entry_point_from_jni_ 才会替换为真实的！！那如果这个方法之前没有被调用过不是找不到地址了吗？</p><p>所以想要找到entry_point_from_jni_的地址，必须要先调用一下这两个native方法，才能正确计算。计算完成之后，想要调用原来的方法，就需要去符号表里面寻找原函数并调用了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.android.com/training/articles/perf-jni#utf-8-and-utf-16-strings">JNI</a><a href="https://developer.android.com/training/articles/perf-jni#utf-8-and-utf-16-strings"> TIPS</a></p><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">JNI</a><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html"> SPEC</a></p><p><a href="https://zhuanlan.zhihu.com/p/54848337">ArtMethod结构与相关技术介绍</a></p><p><a href="https://blog4jimmy.com/category/the_java_native_interface_programmer_guide_and_specificationjni">JNI</a><a href="https://blog4jimmy.com/category/the_java_native_interface_programmer_guide_and_specificationjni">编程指南与规范</a></p><p><a href="https://www.jianshu.com/p/94ec55eb54fd">so 加载</a><a href="https://www.jianshu.com/p/94ec55eb54fd">https://www.jianshu.com/p/94ec55eb54fd</a>)</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>状态问题</title>
    <link href="/2021/08/22/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E7%8A%B6%E6%80%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/22/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E7%8A%B6%E6%80%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>4月份休假，5月份入职新公司，然后接近4个月没有更新博客了，一来确实是较之前忙了很多倍，二来也是自己懒，总觉得周末还不够自己休息的。</p><p>这个周末给自己定的目标就是把博客环境搭建起来，因为我之前一直使用移动硬盘来传博客，但是这个硬盘出了问题，所以就只能重新再搭建一个博客环境。本来是想用 ubuntu 的环境，但是不知道咋回事 ubuntu 也装不上了，想着再搞就要零点了，所以就在 windows 上搭建了一个环境，没想到还挺顺利的，半个小时不到就搞定了。</p><p>既然环境也搞定了，那就以后每个周末更新一篇文章吧。后面会研究一下 bytex 的源码，里面有些东西还是很有意思的，嗯，应该吧。</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>003-vscode环境搭建</title>
    <link href="/2021/06/13/blog_bak/Blog/C++/003-vscode%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/06/13/blog_bak/Blog/C++/003-vscode%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>距离上次写博客已经过了两个月了，第一个月在钓鱼，第二个月在适应新公司。</p><p>新公司确实比之前的要好，但是没有想象中的那么好，总之，还是朝着微软努力吧。</p><p>最近也升级了电脑的主板，由于操作的原因，导致了需要重装系统，所以各种环境还得再搭一遍。以前是按照别人的博客搭建的，现在自己按照官方文档搞了一下，发现超级简单。</p></blockquote><h3 id="下载-vscode"><a href="#下载-vscode" class="headerlink" title="下载 vscode"></a>下载 vscode</h3><p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><h3 id="安装c-插件"><a href="#安装c-插件" class="headerlink" title="安装c++插件"></a>安装c++插件</h3><ol><li>打开 vscode</li><li>点击左边的扩展按钮 （Ctrl+Shift+X）</li><li>搜索 c++</li><li>安装扩展</li></ol><p><img src="https://code.visualstudio.com/assets/docs/languages/cpp/search-cpp-extension.png"></p><p>这个插件安装之后，就可以支持 c/c++ 文件了。</p><h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>我选择的是  mingw64，但是很遗憾的是，我的在线安装下载不下来，所以选择的是离线安装。</p><ul><li><p>在线安装 [Mingw-w64 link](<a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains">https://sourceforge.net/projects/mingw-w64/files/Toolchains</a> targetting Win32/Personal Builds/mingw-builds/installer/mingw-w64-install.exe/download) </p></li><li><p>离线安装 </p><p>链接：<a href="https://links.jianshu.com/go?to=https://pan.baidu.com/s/13ukGn27JEseCpJ2PokzEPg">https://pan.baidu.com/s/13ukGn27JEseCpJ2PokzEPg</a><br>提取码：x2ms</p></li></ul><p>具体的一下选项，我是按照这个图(x86_64-8.1.0-posix-seh-rt_v6-rev0)：</p><p><img src="https://code.visualstudio.com/assets/docs/languages/cpp/choose-x86-64.png"></p><h3 id="编译器环境变量配置"><a href="#编译器环境变量配置" class="headerlink" title="编译器环境变量配置"></a>编译器环境变量配置</h3><p>这个没啥好说的，找到安装（解压）包的位置，在 path 里面添加一下就好了，添加完之后测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ --version<br>gdb --version<br></code></pre></td></tr></table></figure><h3 id="安装-code-runner-插件"><a href="#安装-code-runner-插件" class="headerlink" title="安装 code runner 插件"></a>安装 code runner 插件</h3><p>这个是为了在右上角有个点击运行的按钮，方便一些。安装完成之后，output 会是乱码，是因为我们的 cmd 是 gbk，而 coder runner 默认是 utf-8，所以改一下默认编码就好了，加一个配置项：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-fexec-charset</span>=GBK<br></code></pre></td></tr></table></figure><p>位置在下面的知乎链接里有。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://code.visualstudio.com/docs/languages/cpp">https://code.visualstudio.com/docs/languages/cpp</a></p><p><a href="https://zhuanlan.zhihu.com/p/153252108">https://zhuanlan.zhihu.com/p/153252108</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>002-Git的相对引用</title>
    <link href="/2021/04/05/blog_bak/Blog/Git/002-Git%E7%9A%84%E7%9B%B8%E5%AF%B9%E5%BC%95%E7%94%A8/"/>
    <url>/2021/04/05/blog_bak/Blog/Git/002-Git%E7%9A%84%E7%9B%B8%E5%AF%B9%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/head-1.png?raw=true" alt="head-1"></p><p>当我们执行如下命令后，会发生什么：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> checkout C<span class="hljs-number">1</span><br><span class="hljs-attribute">git</span> checkout main<br><span class="hljs-attribute">git</span> commit<br><span class="hljs-attribute">git</span> checkout C<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>刚开始看到 checkout 后面跟着一个 C1 的时候，可能会有些许不习惯，但是它确实可以工作。它会将 HEAD 指向 C1。</p><p>还有一个趣事，当我们本地与远程关联后，会有指针指向远端记录：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/head-2.png?raw=true" alt="head-2"></p><p>可以看到，o/bugFix 它表示的是远程仓库的 bugFix 分支的状态，如果我们执行 <code>git checkout o/bugFix</code> 会怎么样呢？HEAD 会指向 o/bugFix 吗？</p><p>答案是不会，因为 o/bugFix 表示的远程仓库的分支状态，它是无法被更改的，除非再次与远程仓库通信，所以 HEAD 也无法指向它，但是有趣的是，执行命令后，HEAD 指向了 C2，可以理解为退而求其次指向了 o/bugFix 指向的节点。</p><p>回到正题，执行那么多命令后的结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/head-3.png?raw=true" alt="head-3"></p><p>可以看到，HEAD 指向了 C2。我们可以继续 commit，但是由于 HEAD 没有指向任何分支，所以 commit 在所有分支上都看不到。想要在分支上生效，还需要进行处理，所以开发的时候需要搞清楚自己的 HEAD 在哪里。</p><h3 id="相对引用-与"><a href="#相对引用-与" class="headerlink" title="相对引用 ^ 与 ~"></a>相对引用 ^ 与 ~</h3><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如某个提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。舌头都快打结了吧…</p><p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p><p>但是，通过哈希值指定提交记录仍然很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p><p>相对引用非常给力，这里我介绍两个简单的用法：</p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li></ul><p>注意，只能向上移动，而且还要考虑有两个父节点的情况。</p><p>看下图，main 与 HEAD 都指向 C2：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-1.png?raw=true" alt="rel-ref-1"></p><p>执行 <code>git checkout main^</code> 会发生什么呢？</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-2.png?raw=true" alt="rel-ref-2"></p><p>HEAD 就指向了 C1，与直接 <code>checkout C1</code> 的效果是一样的。这种方式是不是比输入哈希值方便多了？！</p><p>再次执行 <code>git checkout main^</code> 会发生什么呢？HEAD 会指向 C0！</p><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。</p><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-3.png?raw=true" alt="rel-ref-3"></p><p>执行 <code>git checkout HEAD~4</code>后，结果是：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-4.png?raw=true" alt="rel-ref-4"></p><p>多么的简洁 —— 相对引用就是方便啊！</p><p>现在用它来做点实际事情，看一个例子：</p><p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> branch -f main HEAD~<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-5.png?raw=true" alt="rel-ref-5"></p><p>执行上面的命令后，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-6.png?raw=true" alt="rel-ref-5"></p><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p><p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p><p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-7.png?raw=true" alt="rel-ref-7"></p><p>我们执行 <code>git checkout HEAD^</code>，结果显然是 HEAD 指向了 C1（<em>在我们的图示中，第一个父提交记录是指合并提交记录正上方的那个提交记录。</em>）。</p><p>那么，我想让 HEAD 指向 C2 有什么办法呢？除了直接使用 C2，用相对引用可以做到吗？是可以的，我们执行 <code>git chekcout HEAD^2</code>，看结果：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/rel-ref-8.png?raw=true" alt="rel-ref-8"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>001-Git常用指令图解</title>
    <link href="/2021/04/05/blog_bak/Blog/Git/001-Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%9B%BE%E8%A7%A3/"/>
    <url>/2021/04/05/blog_bak/Blog/Git/001-Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>内容全部基于 Learn  Git Branching。</p><p>这是个网页版 Git 小游戏，很有意思的，希望大家可以花半天时间通关。</p><p>还有一个叫做 oh-my-git 的游戏也挺有意思。</p></blockquote><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>下图展示了一个（小型）Git 代码库（本地的）。当前有两个提交记录 —— 初始提交 <code>C0</code> 和其后可能包含某些有用修改的提交 <code>C1</code>。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-commit-1.png?raw=true" alt="git-commit-1"></p><p>然后，我们做一个 <code>git commit</code>操作，添加一个新提交，然后我们本地的仓库变为如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-commit-2.png?raw=true" alt="git-commit-2"></p><p>可以看到的是，<code>HEAD</code> 拽着 <code>main</code> 一起指向了最新的提交 C2。图中，<code>main</code> 后面的 <code>*</code> 号，就是 <code>HEAD</code>。</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><strong>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录。</strong>即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>只要记住使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p><p>我们来看一个示例：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-branch-1.png?raw=true" alt="git-branch-1"></p><p>接下来，我们执行 <code>git branch newImage</code>，创建一个 <code>newImage</code>分支：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-branch-2.png?raw=true" alt="git-branch-2"></p><p>可以看到的是，main 与 newImage 都指向了 C1。接下来，我们就可以先 <code>checkout newImage</code> ，然后在 newImage 上做提交了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">git checkout <span class="hljs-keyword">new</span><span class="hljs-type">Image</span><br>git commit<br></code></pre></td></tr></table></figure><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-branch-3.png?raw=true" alt="git-branch-3"></p><p>可以看到，main 还是指向的 C1，而 newImage 指向了 C2，而且由于 checkout 的原因，HEAD 指向了 newImage。</p><p>对了，有个更简洁的方式：如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 <code>git checkout -b &lt;your-branch-name&gt;</code> 来实现。</p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p><p>下面看一个例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-merge-1.png?raw=true" alt="git-merge-1"></p><p>上图中，HEAD 是指向了 main，我们想将 bugFix 分支的代码合并到 main 分支上来，那么执行 <code>git merge bugFix </code>即可：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-merge-2.png?raw=true" alt="git-merge-2"></p><p>看到了吗，合并之后多了一个 C4 节点，这个节点的父节点有两个，分别是 C2 与 C3。main 与 HEAD 也指向了合并后的最新节点。</p><p>如果，我们再切到 bugFix 分支，将 main 里面的代码合并过来，会发生什么呢？还会产生一个新的节点吗？</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-merge-3.png?raw=true" alt="git-merge-3"></p><p>答案是不会产生新的节点，因为此时的 main 是继承至 bugFix 的，所以此时合并啥都不用做，只需要 fast-forward 就好了。所以结果就是，bugFix 直接指向了 main 所指向的 C4 节点。</p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p>下面，会举一个例子，然后你可以将最终合并的结果与 merge 出来的结果相比较，就能明白什么叫做<strong>线性的提交历史</strong>了。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-rebase-1.png?raw=true" alt="git-rebase-1"></p><p>接下来，我们执行 rebase 操作：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git rebase <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><p>这个命令其实是省略了当前 HEAD 指向的分支，完整的因该是 <code>git rebase main bugFix</code>，就是将 bugFix 上的提交 rebase 到 main 上去。</p><p>rebase 的意思是<strong>重新以XX为父节点</strong>。上面的图中，C3 的父节点为 C1，rebase 之后的，C3 的父节点就“变成了” C2（一般情况下肯定会有冲突，但是这里就不讨论了），然后将 C3 copy 一份（解决冲突后），放到 C2 的下面，如图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-rebase-2.png?raw=true" alt="git-rebase-2"></p><p>可以看到，<strong>C3 节点仍然存在</strong>，不过创建了一个 C3’ 作为 C2 的子节点。bugFix 与 HEAD 也指向了“copy” 过来的节点。这样看起来，相比于 merge 是不是更加线性呢！不过有的人喜欢保留合并记录，当然这是属于个人爱好的事情，并无好坏之分。否则的话，也不会出现两种合并方案了。</p><p>一个小测验，如果，接下来，我们执行 <code>git rebase bugFix main</code> 会发生什么呢？</p><p>因为，bugFix 是继承至 main，所以只需要 fast-forward 就好了。可以将这情况下的 rebase，看成一种移动 HEAD 的方式。下面的图中，不仅 main 指向了 bugFix，而且 HEAD 还指向了 main。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-rebase-3.png?raw=true" alt="git-rebase-3"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><p>看一个例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-reset-1.png?raw=true" alt="git-reset-1"></p><p>执行 <code>git reset HEAD~1</code> 后，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-reset-2.png?raw=true" alt="git-reset-1"></p><p>Git 把 main 分支移回到 <code>C1</code>；现在我们的本地代码库根本就不知道有 <code>C2</code> 这个提交了。</p><blockquote><p>在reset后， <code>C2</code> 所做的变更还在，但是处于未加入暂存区状态。</p></blockquote><p>搞清楚什么是暂存区，工作区，请看这个链接：<a href="https://blog.csdn.net/qq_32452623/article/details/78417609">https://blog.csdn.net/qq_32452623/article/details/78417609</a></p><p>上面的解释感觉并不是特别准确，因为 C2 已经提交了，提交后是无法撤回的，历史是无法改变的。我们再执行 <code>git checkout C2</code>，HEAD 仍然会指向 C2，reset 后，C2 仍然存在，不过可以忽略。你仍然想用它，也可以用。虽然，<code>git log</code> 命令看不到了，但是这个历史确实是存在的。</p><p>reset 还有一个作用，就是将 add 到暂存区的文件，重新拿出来：</p><p><strong>撤消add：</strong>git reset 文件名</p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。来看演示：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-revert-1.png?raw=true" alt="git-revert-1"></p><p>当我们执行 <code>git revert HEAD</code> 后，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-revert-2.png?raw=true" alt="git-revert-1"></p><p>奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。<strong>也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code> 是相同的。</strong></p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><blockquote><p>记住，本地分支用 reset，远程分支用 revert</p></blockquote><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 <code>cherry-pick</code>，因为它特别简单。不仅简单，而且强大。看一个例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-cherry-pick-1.png?raw=true" alt="git-cherry-pick-1"></p><p>执行 <code>git cherry-pick C2 C4</code>，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-cherry-pick-2.png?raw=true" alt="git-cherry-pick-1"></p><p>注意，cherry-pick 后，main 与 HEAD 的位置。</p><p>这个功能就很强大了，比如说，你开了一个分支，正在做新特性，由于你自己的 commit 风格良好，每做一个逻辑就 commit 一下。在开发的过程中，还顺便优化了一下某个功能，它是一些单独的 commit。在你的新特性开发到一般的时候，有人告知你这个新特性暂时不做了，虽然你很蛋疼，但是作为一个敬业的开发者，你还是想将优化的 commit 合到 main 上去，这个时候就可以用 cherry-pick 了（虽然也有别的命令可以做到）。</p><h3 id="git-rebase-i"><a href="#git-rebase-i" class="headerlink" title="git rebase -i"></a>git rebase -i</h3><p>这个命令与 git rebase 一样，但是后面跟了一个参数 <code>-i</code>，意思是，它可以让用户来干涉（删掉，保留，编辑）每个 commit 被 rebase 的过程，所以，它可以做很多事。具体的还是自己体验一下游戏吧，这个用图说不清楚。</p><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>这个命令比较常用，而且比较实用，就是用来修改当前提交的。看下面的例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-commit-amend-1.png?raw=true" alt="git-commit-amend-1"></p><p>有时候会发生这样的事情，当我们提交完C2之后，发现提交错了，想修改一下C2重新提交，该怎么做呢？</p><p>使用 <code>git commit --amend</code>，看执行结果：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-commit-amend-2.png?raw=true" alt="git-commit-amend-2"></p><p>可以看出，这个使用 reset 也可以做到，不过会麻烦很多。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以<strong>永远</strong>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-tag-1.png?raw=true" alt="git-tag-1"></p><p>当我们执行 <code>git tag v1 C1</code>后，结果如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-tag-2.png?raw=true" alt="git-tag-2"></p><p>这里我们建立了一个标签，指向提交记录 <code>C1</code>，表示这是我们 1.0 版本。</p><p>我们将这个标签命名为 <code>v1</code>，并且明确地让它指向提交记录 <code>C1</code>，如果你不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p><p>以后我们想使用 v1 版本的代码，就直接 <code>checkout v1</code> 就好了。但是需要注意，checkout 后，HEAD 指向的是 C1，而不是 v1，因为 v1 不可变。</p><h3 id="git-describe"><a href="#git-describe" class="headerlink" title="git describe"></a>git describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；</p><p><code>git describe</code> 的语法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">describe</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">ref</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>_<span class="hljs-tag">&lt;<span class="hljs-name">numCommits</span>&gt;</span>_g<span class="hljs-tag">&lt;<span class="hljs-name">hash</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-describe-1.png?raw=true" alt="git-describe-1"></p><p>对于上面的这个例子，我们执行：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">describe</span> main 会输出：<br><br>v1_2_gC2<br><br>git <span class="hljs-built_in">describe</span> side 会输出：<br><br>v2_1_gC4<br></code></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>我们可以为 push 指定参数，语法是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git push <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">place</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先看看例子, 这个命令是:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p><p>看下面的图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-push-1.png?raw=true" alt="git-push-1"></p><p>执行下面的命令会发生什么：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout <span class="hljs-built_in">C0</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin main<br></code></pre></td></tr></table></figure><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-push-2.png?raw=true" alt="git-push-2"></p><p>可以看到，push 之后本地与远程的 mian 分支就同步了，而且 o/main 也改变了。</p><p>其实<code>git push origin main</code> 这个命令其实是省略了一部分，完整的应该是这样：<code>git push origin main:main</code>。我们看一个例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-push-3.png?raw=true" alt="git-push-3"></p><p>执行命令 <code>git push origin foo^:main</code> ，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-push-4.png?raw=true" alt="git-push-3"></p><p>使用这个命令，我们还可以将 foo 分支的代码推送到 main 分支里面，反正很强大就是了，但是一般不这么干。</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><strong>git fetch 做了些什么？</strong></p><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/main</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p>看下图，图中，虚线是远程分支。</p><p>左边是我们的本地仓库，右边是远程仓库。可以看到远程仓库与我们自己的本地仓库多了2个提交，说明有人往远程仓库push了代码，我们需要将这些提交同步到我们的本地仓库，然后再进行开发，看别人改动了什么。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-fetch-1.png?raw=true" alt="git-fetch-1"></p><p>那么如何进行同步呢？使用 <code>git fetch</code> 命令，看看执行命令后的效果：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-fetch-2.png?raw=true" alt="git-fetch-2"></p><p>可以看到，同步后，<code>o/main</code>已经与远程仓库完全一致了。<code>o/main</code>是远程仓库的指针，所以它一直指向上次与远程仓库通信时的位置。需要注意，我们本地的 <code>main</code>还是指向的原来的位置，有需要可自己移动。</p><p><strong>git fetch 不会做的事</strong></p><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>先看图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-pull-1.png?raw=true" alt="git-pull-1"></p><p>注意，上图中，远程的最新提交是 c3，本地的最新提交是 C2。如果，我们执行了 <code>git fetch</code> 命令，那么就会出现分叉。所以，还要进行 merge 操作：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">git fecth<br>git <span class="hljs-keyword">merge</span> o/main<br></code></pre></td></tr></table></figure><p>最终的到的图，如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/git-pull-2.png?raw=true" alt="git-pull-2"></p><p>嗯，这个图没画好，不过我也是用的别人做的图，将就着看吧。</p><p>现在，本地的 <code>o/main</code> 指向 c3，<code>main*</code>指向 c4，由于合并操作，c4 是合并产生的，它的父节点是 c2 与 c3。</p><p>其实呢，<code>git pull</code> 就是做了上面的操作，不过他将两个命令合成了一个。</p><h3 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h3><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p><ul><li><code>git push origin :side</code></li><li><code>git fetch origin :bugFix</code></li></ul><p>我们分别来看一下这两条命令的作用……</p><p><strong>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</strong></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/source-1.png?raw=true" alt="source-1"></p><p>执行 <code>git push origin :foo</code>，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/source-2.png?raw=true" alt="source-2"></p><p>可以看到，远程仓库的 foo 分支被删除了。</p><p><strong>如果 fetch 空 到本地，会在本地创建一个新分支。</strong>看下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/source-3.png?raw=true" alt="source-1"></p><p>执行 <code>git fetch origin :bar</code>，结果为：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Git/source-4.png?raw=true" alt="source-2"></p><p>可以看到，本地仓库创建了一个新的 bar 分支。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0004-真正执行监测的类</title>
    <link href="/2021/03/13/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0004-%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%9B%91%E6%B5%8B%E7%9A%84%E7%B1%BB/"/>
    <url>/2021/03/13/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0004-%E7%9C%9F%E6%AD%A3%E6%89%A7%E8%A1%8C%E7%9B%91%E6%B5%8B%E7%9A%84%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>上一篇</strong>我们分析了不少类，但是实际上它们做的<strong>工作主要是寻找监测点</strong>的工作，但是具体如何监测，都被委托给了 <code>ReachabilityWatcher</code> 这个接口。</p><p>这个接口只有一个实现了，就是 <code>ObjectWatcher</code>。</p><h3 id="ObjectWatcher"><a href="#ObjectWatcher" class="headerlink" title="ObjectWatcher"></a>ObjectWatcher</h3><p>我们先看 <code>expectWeaklyReachable</code> 这个方法，毕竟，委托的时候，就是调用的这个方法。</p><blockquote><p>leakcanary.ObjectWatcher#expectWeaklyReachable</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">expectWeaklyReachable</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  watchedObject: <span class="hljs-type">Any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  description: <span class="hljs-type">String</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (!isEnabled()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 移除已经被回收的监测对象（包装后的KeyedWeakReference）</span><br>  removeWeaklyReachableObjects()<br>  <span class="hljs-comment">// 生成 key，避免重复</span><br>  <span class="hljs-keyword">val</span> key = UUID.randomUUID()<br>    .toString()<br>  <span class="hljs-comment">// 记录开始监测的时间</span><br>  <span class="hljs-keyword">val</span> watchUptimeMillis = clock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> reference =<br>    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)<br>  SharkLog.d &#123;<br>    <span class="hljs-string">&quot;Watching &quot;</span> +<br>      (<span class="hljs-keyword">if</span> (watchedObject <span class="hljs-keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;instance of <span class="hljs-subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +<br>      (<span class="hljs-keyword">if</span> (description.isNotEmpty()) <span class="hljs-string">&quot; (<span class="hljs-variable">$description</span>)&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>) +<br>      <span class="hljs-string">&quot; with key <span class="hljs-variable">$key</span>&quot;</span><br>  &#125;<br><br>  <span class="hljs-comment">// 添加到监测集合中</span><br>  watchedObjects[key] = reference<br>  <span class="hljs-comment">// checkRetainedExecutor 在 AppWatcher 里面赋值</span><br>  <span class="hljs-comment">// 实际上它是利用了主线程的 handler，延迟 5s post 一个消息</span><br>  checkRetainedExecutor.execute &#123;<br>    moveToRetained(key)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段逻辑与 1.x 的版本似乎差不多，没啥好说的。不过这也是内存泄露监测的核心原理，弱引用 + 引用队列。</p><p>我们继续看：</p><blockquote><p>leakcanary.ObjectWatcher#moveToRetained</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// TODO 这里为啥要加上  Synchronized 关键字</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveToRetained</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> &#123;<br>  <span class="hljs-comment">// 真正开始确认是否发生了内存泄露，这里再次移除已经被gc回收的对象</span><br>  removeWeaklyReachableObjects()<br>  <span class="hljs-keyword">val</span> retainedRef = watchedObjects[key]<br>  <span class="hljs-comment">// 监测集合里面还存在，即有可能发生了泄露</span><br>  <span class="hljs-keyword">if</span> (retainedRef != <span class="hljs-literal">null</span>) &#123;<br>    retainedRef.retainedUptimeMillis = clock.uptimeMillis()<br>    <span class="hljs-comment">// onObjectRetainedListeners 里面的 listener 其实就是 InternalLeakCanary</span><br>    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 总的来说，ObjectWatcher 的作用其实就是做了一个过滤操作。从所有的监测对象里面，找出哪些是真正有可能泄露的，然后交给 InternalLeakCanary 去处理。</p><h3 id="InternalLeakCanary"><a href="#InternalLeakCanary" class="headerlink" title="InternalLeakCanary"></a>InternalLeakCanary</h3><p>我们从 <code>onObjectRetained</code> 方法，一直跟踪下去，忽略一些无关逻辑，调用链如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">leakcanary.<span class="hljs-keyword">internal</span>.InternalLeakCanary<span class="hljs-meta">#onObjectRetained</span><br>leakcanary.<span class="hljs-keyword">internal</span>.InternalLeakCanary<span class="hljs-meta">#scheduleRetainedObjectCheck</span><br>leakcanary.<span class="hljs-keyword">internal</span>.HeapDumpTrigger<span class="hljs-meta">#scheduleRetainedObjectCheck</span><br></code></pre></td></tr></table></figure><p>发现，它直接跑到了 HeapDumpTrigger 类的方法里面，从这个类的名字上来看，肯能需要开始 dump 内存映像然后做分析了。</p><h3 id="HeapDumpTrigger"><a href="#HeapDumpTrigger" class="headerlink" title="HeapDumpTrigger"></a>HeapDumpTrigger</h3><blockquote><p>leakcanary.internal.HeapDumpTrigger#scheduleRetainedObjectCheck</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scheduleRetainedObjectCheck</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  delayMillis: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  <span class="hljs-comment">// 第一次执行该方法，checkScheduledAt = 0</span><br>  <span class="hljs-comment">// 执行完后，checkScheduledAt &gt; 0</span><br>  <span class="hljs-comment">// 等 backgroundHandler post 的 runnable 执行后，重新赋值为 0</span><br>  <span class="hljs-comment">// 也就是说，这个方法即使调用的很频繁，它也会一次 post 一个 runnable，等这个 runnable 执行完后在 post 下一个</span><br>  <span class="hljs-keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt<br>  <span class="hljs-keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis<br>  <span class="hljs-comment">// backgroundHandler 是一个 HandlerThread 的 handler，在 InternalLeakCanary 的 invoke 方法中赋值</span><br>  backgroundHandler.postDelayed(&#123;<br>    checkScheduledAt = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// InternalLeakCanary 的 scheduleRetainedObjectCheck 调用过来时，delayMillis 是默认值 0</span><br>    checkRetainedObjects()<br>  &#125;, delayMillis)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是做了一个过滤的操作，防止频繁调用。</p><blockquote><p>leakcanary.internal.HeapDumpTrigger#checkRetainedObjects</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkRetainedObjects</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 从配置里面看是否可以 dump</span><br>  <span class="hljs-keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()<br><br>  <span class="hljs-keyword">val</span> config = configProvider()<br><br>  <span class="hljs-comment">// TODO 不能 dump，暂时先跳过这个逻辑</span><br>  ...<br><br>  <span class="hljs-comment">// 拿到监测集合中还存在的对象</span><br>  <span class="hljs-keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount<br><br>  <span class="hljs-comment">// 触发一次 gc，看看有没有误报的</span><br>  <span class="hljs-keyword">if</span> (retainedReferenceCount &gt; <span class="hljs-number">0</span>) &#123;<br>    gcTrigger.runGc()<br>    retainedReferenceCount = objectWatcher.retainedObjectCount<br>  &#125;<br><br>  <span class="hljs-comment">// checkRetainedCount 返回true,表示怀疑泄露的对象还没超过阈值,等下一次检测</span><br>  <span class="hljs-keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="hljs-keyword">return</span><br><br>  <span class="hljs-keyword">val</span> now = SystemClock.uptimeMillis()<br>  <span class="hljs-keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis<br>  <span class="hljs-comment">// 两次 dump 的时间小于 1 分钟</span><br>  <span class="hljs-keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;<br>    onRetainInstanceListener.onEvent(DumpHappenedRecently)<br>    <span class="hljs-comment">// 发一个通知</span><br>    showRetainedCountNotification(<br>      objectCount = retainedReferenceCount,<br>      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)<br>    )<br>    <span class="hljs-comment">// 延迟到下一次检测</span><br>    scheduleRetainedObjectCheck(<br>      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis<br>    )<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 准备 dump,取消通知</span><br>  dismissRetainedCountNotification()<br>  <span class="hljs-keyword">val</span> visibility = <span class="hljs-keyword">if</span> (applicationVisible) <span class="hljs-string">&quot;visible&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;not visible&quot;</span><br>  dumpHeap(<br>    retainedReferenceCount = retainedReferenceCount,<br>    retry = <span class="hljs-literal">true</span>,<br>    reason = <span class="hljs-string">&quot;<span class="hljs-variable">$retainedReferenceCount</span> retained objects, app is <span class="hljs-variable">$visibility</span>&quot;</span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法里面就是真正 dump 内存快照了。</p><p>那么，到了这里一个流程就分析完了。回想一下，这个版本的结构很分明：</p><ul><li>初始化是一块</li><li>watchers 是一块，专门用来寻找监测点</li><li>objectWatcher 是一块，它排除已经被回收的对象</li><li>dump 是一块，发通知， dump 内存</li><li>shark 是一块，分析 dump 出来的内存快照</li></ul><p>后面计划添加一下其他类的分析，然后搞 shark 源码分析。</p>]]></content>
    
    
    <categories>
      
      <category>LeakCanary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-LeakCanary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-自动初始化</title>
    <link href="/2021/03/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0002-%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2021/03/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0002-%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>源码版本 2.6 </p><p>AS 版本 4.1.1</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>新版的使用</strong>就非常的简单了：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>  <span class="hljs-comment">// debugImplementation because LeakCanary should only run in debug builds.</span><br>  debugImplementation <span class="hljs-string">&#x27;com.squareup.leakcanary:leakcanary-android:2.6&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只需要添加一个依赖就好了。旧版的话，还需要添加一个 release 的依赖，而且需要在 Application 里面手动初始化。因为需要在 Application 手动初始化，所以才必须添加 release 的依赖，只不过 release 里面的类都是空方法而已。</p><p>那么新版为何不需要做初始化呢？</p><h3 id="自动初始化"><a href="#自动初始化" class="headerlink" title="自动初始化"></a>自动初始化</h3><p>我们看下面的一段源码：</p><blockquote><p>android.app.ActivityThread#handleBindApplication</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleBindApplication</span><span class="hljs-params">(AppBindData data)</span> </span>&#123;<br>    ...<br>    <br>    Application app;<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();<br>    <span class="hljs-keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ① 创建 app 对象</span><br>        app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-keyword">null</span>);<br><br>        ...<br><br>        <span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>            <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<br>                <span class="hljs-comment">// ② 安装 contentProviders</span><br>                installContentProviders(app, data.providers);<br>            &#125;<br>        &#125;<br><br>        ...<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ③ 调用 app 的 onCreate 方法</span><br>            mInstrumentation.callApplicationOnCreate(app);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ...<br>        &#125;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 Application 的 onCreate 方法执行之前，调用了 <code>installContentProviders</code> 这个方法。</p><p>继续看这个方法：</p><blockquote><p>android.app.ActivityThread#installContentProviders</p></blockquote><p>它的调用链：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-selector-id">#installContentProviders</span><br>android<span class="hljs-selector-class">.app</span>.ActivityThread<span class="hljs-selector-id">#installProvider</span><br>android<span class="hljs-selector-class">.content</span>.ContentProvider<span class="hljs-selector-id">#attachInfo</span><br>android<span class="hljs-selector-class">.content</span>.ContentProvider<span class="hljs-selector-id">#attachInfo</span>(android<span class="hljs-selector-class">.content</span><span class="hljs-selector-class">.Context</span>, android<span class="hljs-selector-class">.content</span><span class="hljs-selector-class">.pm</span><span class="hljs-selector-class">.ProviderInfo</span>, boolean)<br>android<span class="hljs-selector-class">.content</span>.ContentProvider#onCreate<br></code></pre></td></tr></table></figure><p>所以，ContentProvider 的 onCreate 方法在 Application 的 onCreate 方法之前执行。</p><p>一般情况下，我们会将初始化代码写到 Application 的 onCreate 方法里面，是因为这个回调最先执行，那么我们将初始化代码移到 ContentProvider 的 onCreate 方法里面也是可以的。</p><blockquote><p>这里需要注意一个问题，如果所有的初始化都这样做，那么会拖慢启动速度，jetpack 有个库是为了解决这个问题的，同时也证明了 Google 对于在 ContentProvider 做初始化的做法是比较支持的。</p></blockquote><p>有了这个基础知识，我们再回头看 LeakCanary 的初始化。在工程的 External Libraries 里面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Gradle</span>:com.squareup.leakcanary:leakcanary-object-watcher-android:<span class="hljs-number">2</span>.<span class="hljs-number">6</span>@aar<br></code></pre></td></tr></table></figure><p>看它的 <code>AndroidManifest.xml</code> 文件里面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;leakcanary.internal.AppWatcherInstaller$MainProcess&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有一个 ContentProvider，看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Content providers are loaded before the application class is created. [AppWatcherInstaller] is</span><br><span class="hljs-comment"> * used to install [leakcanary.AppWatcher] on application start.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppWatcherInstaller</span> : <span class="hljs-type">ContentProvider</span></span>() &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>()<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span><br><span class="hljs-comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakCanaryProcess</span> : <span class="hljs-type">AppWatcherInstaller</span></span>()<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>    AppWatcher.manualInstall(application)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  。。。<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两个子类：</p><ul><li><p>MainProcess</p></li><li><p>LeakCanaryProcess</p></li></ul><p>指的是，LeakCanary 想要运行在哪个进程。如果我们依赖的时候，使用的是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;com.squareup.leakcanary:leakcanary-android:2.6</span>&#x27;<br></code></pre></td></tr></table></figure><p>则运行在主进程。如果我们依赖使用的是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;com.squareup.leakcanary:leakcanary-android-process:2.6</span>&#x27;<br></code></pre></td></tr></table></figure><p>那么就会单独开启一个进程来做内存泄露分析。</p><p>看<code>onCreate</code>里面的逻辑：</p><blockquote><p>leakcanary.internal.AppWatcherInstaller#onCreate</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>  <span class="hljs-keyword">val</span> application = context!!.applicationContext <span class="hljs-keyword">as</span> Application<br>  AppWatcher.manualInstall(application)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就一行代码，继续：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@JvmOverloads</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">manualInstall</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: <span class="hljs-type">Application</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  retainedDelayMillis: <span class="hljs-type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="hljs-number">5</span>)</span></span>,<br>  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)<br>) &#123;<br>  checkMainThread()<br>  check(!isInstalled) &#123;<br>    <span class="hljs-string">&quot;AppWatcher already installed&quot;</span><br>  &#125;<br>  check(retainedDelayMillis &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-string">&quot;retainedDelayMillis <span class="hljs-variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">this</span>.retainedDelayMillis = retainedDelayMillis<br>  <span class="hljs-keyword">if</span> (application.isDebuggableBuild) &#123;<br>    LogcatSharkLog.install()<br>  &#125;<br>  <span class="hljs-comment">// Requires AppWatcher.objectWatcher to be set</span><br>  LeakCanaryDelegate.loadLeakCanary(application)<br><br>  watchersToInstall.forEach &#123;<br>    it.install()<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个方法有很多注释，其中有一条说：</p><blockquote><p>如果你想自己调用这个 manualInstall 方法，那么需要先禁止 ContentProvider。</p><p>如何禁止，注释上有。</p><p>但是有一个疑问，如果自己调用这个方法的话，那 release 版本不是会报错？？？除非在 <code>src/debug/java</code> 里面做初始化。</p></blockquote><p>这个方法有3个参数，后面两个参数是默认的，第3个参数是重点，里面有各种各样的 watcher，用来检测内存泄露的。只需要调用 Watcher 的 install 方法即可。</p><p>Watcher 的分析下一篇再说。</p>]]></content>
    
    
    <categories>
      
      <category>LeakCanary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-LeakCanary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003-监测页面与View是否泄露的Watcher</title>
    <link href="/2021/03/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0003-%E7%9B%91%E6%B5%8B%E9%A1%B5%E9%9D%A2%E4%B8%8EView%E6%98%AF%E5%90%A6%E6%B3%84%E9%9C%B2%E7%9A%84Watcher/"/>
    <url>/2021/03/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0003-%E7%9B%91%E6%B5%8B%E9%A1%B5%E9%9D%A2%E4%B8%8EView%E6%98%AF%E5%90%A6%E6%B3%84%E9%9C%B2%E7%9A%84Watcher/</url>
    
    <content type="html"><![CDATA[<blockquote><p>想要监测一个对象是否泄露，需要知道的是这个对象什么时候应该被销毁，然后再做相应的处理，所以第一个难点是如何找准这个销毁的时机。</p><p>下面我们具体分析源码，看它是如何做的。</p></blockquote><p>所有的 Watcher 都在这个方法里面：</p><blockquote><p>leakcanary.AppWatcher#appDefaultWatchers</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">fun <span class="hljs-title">appDefaultWatchers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  application: Application,</span></span><br><span class="hljs-params"><span class="hljs-function">  reachabilityWatcher: ReachabilityWatcher = objectWatcher</span></span><br><span class="hljs-params"><span class="hljs-function">)</span>: List&lt;InstallableWatcher&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> listOf(<br>    ActivityWatcher(application, reachabilityWatcher),<br>    FragmentAndViewModelWatcher(application, reachabilityWatcher),<br>    RootViewWatcher(reachabilityWatcher),<br>    ServiceWatcher(reachabilityWatcher)<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先分析 <code>InstallableWatcher</code> 这个接口：</p><blockquote><p>leakcanary.InstallableWatcher</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InstallableWatcher</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span><br><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们说过，想要监测内存泄露，需要调用 Watcher 的 install 方法，对应的，要停止监测，就调用 uninstall 方法，我们下面看看它的子类。</p><h3 id="监测-activity-的泄露"><a href="#监测-activity-的泄露" class="headerlink" title="监测 activity 的泄露"></a>监测 activity 的泄露</h3><blockquote><p>leakcanary.ActivityWatcher</p><p>ActivityLifecycleCallbacks 的执行链：</p><ol><li>application 中注册回调</li><li>activity 的 onDestroy 方法执行</li><li>activity 利用 getApplication 获取 application 对象，调用它的 dispatch 方法</li><li>dispatch 方法调用回调的对应方法</li></ol></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityWatcher</span></span>(<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application,<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> reachabilityWatcher: ReachabilityWatcher<br>) : InstallableWatcher &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>    <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          activity, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span><br>        )<br>      &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">uninstall</span><span class="hljs-params">()</span></span> &#123;<br>    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑比较简单，就是在每个 activity 的 onDestroy 方法执行的时候去调用 <code>leakcanary.ReachabilityWatcher#expectWeaklyReachable</code> 这个方法。</p><p><code>ReachabilityWatcher</code>它的实现类是 <code>leakcanary.ObjectWatcher</code>，我们<strong>后面再具体分析它是如何监测某一个对象是否泄露了的</strong>！</p><h3 id="监测-fragment-的泄露"><a href="#监测-fragment-的泄露" class="headerlink" title="监测 fragment 的泄露"></a>监测 fragment 的泄露</h3><p>看 install 方法：</p><blockquote><p>leakcanary.FragmentAndViewModelWatcher#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>  application.registerActivityLifecycleCallbacks(lifecycleCallbacks)<br>&#125;<br></code></pre></td></tr></table></figure><p>欸，这里它也注册了一个 activity 的生命周期的回调。然后在这里回调里面做了这样的事情：</p><blockquote><p>leakcanary.FragmentAndViewModelWatcher#lifecycleCallbacks</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lifecycleCallbacks =<br>  <span class="hljs-keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="hljs-keyword">by</span> noOpDelegate() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      activity: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">for</span> (watcher <span class="hljs-keyword">in</span> fragmentDestroyWatchers) &#123;<br>        watcher(activity)<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的生命周期是 onActivityCreated</p></blockquote><p>嗯，这里有许多个 fragmentDestroyWatcher：</p><ul><li>AndroidOFragmentDestroyWatcher</li><li>AndroidXFragmentDestroyWatcher</li><li>AndroidSupportFragmentDestroyWatcher</li></ul><p>根据不同的库会有不同的实现，因为不同的库 fragment 的实现也不一样。这里我们只分析 androidx 的实现。</p><p>for 循环里面调用了 watcher 的 invoke 方法，我们看对应的代码：</p><blockquote><p>leakcanary.internal.AndroidXFragmentDestroyWatcher#invoke</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(activity: <span class="hljs-type">Activity</span>)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">is</span> FragmentActivity) &#123;<br>    <span class="hljs-keyword">val</span> supportFragmentManager = activity.supportFragmentManager<br>    supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="hljs-literal">true</span>)<br>    ViewModelClearedWatcher.install(activity, reachabilityWatcher)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是针对每一个 activity 都做了同样事情，在 activity 中注册了一个 FragmentLifecycleCallbacks，所以就能够监听到该 activity  中所有的 fragment 的生命周期。那么，如果监测 fragment 中的 fragment 的生命周期呢？看到上面的  <code>registerFragmentLifecycleCallbacks</code>这个方法中的第 2 个参数，它就是表示可以递归的注册的，所以，它可以监测 fragment 中的 fragment 的生命周期。</p><p>拿到 fragment 的生命周期之后，与 activity 一样，调用 ReachabilityWatcher 的方法：</p><blockquote><p>androidx.fragment.app.FragmentManager.FragmentLifecycleCallbacks#onFragmentDestroyed</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentDestroyed</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    fragment: <span class="hljs-type">Fragment</span></span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span> &#123;<br>    reachabilityWatcher.expectWeaklyReachable(<br>      fragment, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，fragment 与 activity 还不一样，它有两个 onDestroy 方法，一个是它自身的，一个是它的 view 的。当 fragment 的 onDestroyView 方法执行后，这个 View 应该被销毁，所以我们也要监测这个 view 是否泄露。因为很多情况下，fragment 的生命周期都只会走到 onDestroyView 这里，但是如果我们在内部类里面更新该 fragment 的界面的时候，就会出现内存泄露问题。</p><p>这样，fragment 的处理就差不多了，但是 invoke 方法里还有一行代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ViewModelClearedWatcher.install(activity, reachabilityWatcher)<br></code></pre></td></tr></table></figure><p>看起来是监测 ViewModel 的。</p><h3 id="监测-ViewModel-的泄露"><a href="#监测-ViewModel-的泄露" class="headerlink" title="监测 ViewModel 的泄露"></a>监测 ViewModel 的泄露</h3><p>看 install 方法：</p><blockquote><p>leakcanary.internal.ViewModelClearedWatcher.Companion#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">      storeOwner: <span class="hljs-type">ViewModelStoreOwner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">      reachabilityWatcher: <span class="hljs-type">ReachabilityWatcher</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>      <span class="hljs-keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="hljs-keyword">object</span> : Factory &#123;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel?&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T =<br>          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) <span class="hljs-keyword">as</span> T<br>      &#125;)<br>      provider.<span class="hljs-keyword">get</span>(ViewModelClearedWatcher::<span class="hljs-keyword">class</span>.java)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实就是调用了 ViewModelClearedWatcher 的构造方法。可以理解为在 activity 的 viewModelStore 里面添加了一个 <code>ViewModelClearedWatcher</code> 对象。</p><p>当 activity 执行 onDestroy 方法的时候，viewModel 的 onClear 方法会执行。所以，我们可以在 <code>ViewModelClearedWatcher</code>  这个对象的 onClear 方法里面去判断其他的 viewModel 是否内存泄露了。</p><p>首先，使用反射拿到 activity 的 viewModeStore 的 <code>mMap</code>字段：</p><blockquote><p>leakcanary/internal/ViewModelClearedWatcher.kt:24</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">init</span> &#123;<br>  <span class="hljs-comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span><br>  <span class="hljs-comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span><br>  <span class="hljs-comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span><br>  viewModelMap = <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">val</span> mMapField = ViewModelStore::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>    mMapField.isAccessible = <span class="hljs-literal">true</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    mMapField[storeOwner.viewModelStore] <span class="hljs-keyword">as</span> Map&lt;String, ViewModel&gt;<br>  &#125; <span class="hljs-keyword">catch</span> (ignored: Exception) &#123;<br>    <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 onClear 方法里面去遍历里面所有的对象，监测它们：</p><blockquote><p>leakcanary.internal.ViewModelClearedWatcher#onCleared</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCleared</span><span class="hljs-params">()</span></span> &#123;<br>  viewModelMap?.values?.forEach &#123; viewModel -&gt;<br>    reachabilityWatcher.expectWeaklyReachable(<br>      viewModel, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面只是说了监测 activity 中的 viewModel 的泄露，那么 fragment 中的 viewModel 没有监测吗？？</p><p>是有的，上面监测 activity 中的 viewModel 的泄露是在  onActivityCreated 的回调中处理的，而监测 fragment 中的 viewModel 的泄露是在下面的代码中做的：</p><blockquote><p>androidx.fragment.app.FragmentManager.FragmentLifecycleCallbacks#onFragmentCreated</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFragmentCreated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  fm: <span class="hljs-type">FragmentManager</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  fragment: <span class="hljs-type">Fragment</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  ViewModelClearedWatcher.install(fragment, reachabilityWatcher)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监测-rootView-的泄露"><a href="#监测-rootView-的泄露" class="headerlink" title="监测 rootView 的泄露"></a>监测 rootView 的泄露</h3><p>RootView 有多种：</p><ul><li><p>PHONE_WINDOW</p><ul><li>Activity（我们已经监测了 activity，所以这个没必要）</li><li>Dialog</li></ul></li><li><p>POPUP_WINDOW</p><p>由于 popup_window 通常会被缓存，所以没必要监测，当它 dismiss 后，还可能再显示出来</p></li><li><p>TOOLTIP</p><p>Tooltips可以实现类似pc端网页鼠标悬停时出现描述信息的功能，而到安卓中，如果给一个控件使用了Tooltips，那么当用户长按这个控件时，我们预设的描述信息就会悬浮出现在控件附件某个位置。</p></li><li><p>TOAST</p></li></ul><p>所以，最后，Dialog，TOOLTIP，TOAST 是需要监测的对象。当然，leakCanary 里面还做了 <code>else</code> 逻辑处理，略。</p><p>我们看它是在什么时候监测 rootView 的：</p><blockquote><p>curtains.internal.WindowManagerSpy#swapWindowManagerGlobalMViews</p></blockquote><p>在分析这个方法之前，我们看一下这个方法的名字，因为后面的许多逻辑都是这个套路，为了不重复，这里只分析一遍。</p><p><code>swapWindowManagerGlobalMViews</code> </p><p>swap  是交换</p><p>WindowManagerGlobal 是一个类，Framework 中的</p><p>mViews 是 WindowManagerGlobal 的一个字段。</p><p>很明显，这个方法的作用，是使用反射来替换掉 WindowManagerGlobal  的 mViews 字段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// You can discourage me all you want I&#x27;ll still do it.</span><br><span class="hljs-meta">@SuppressLint(<span class="hljs-meta-string">&quot;PrivateApi&quot;</span>, <span class="hljs-meta-string">&quot;ObsoleteSdkInt&quot;</span>, <span class="hljs-meta-string">&quot;DiscouragedPrivateApi&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">swapWindowManagerGlobalMViews</span><span class="hljs-params">(swap: (<span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">View</span>&gt;) -&gt; <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">View</span>&gt;)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (SDK_INT &lt; <span class="hljs-number">19</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    windowManagerInstance?.let &#123; windowManagerInstance -&gt;<br>      mViewsField?.let &#123; mViewsField -&gt;<br>        <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>        <span class="hljs-keyword">val</span> mViews = mViewsField[windowManagerInstance] <span class="hljs-keyword">as</span> ArrayList&lt;View&gt;<br>        mViewsField[windowManagerInstance] = swap(mViews)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>    Log.w(<span class="hljs-string">&quot;WindowManagerSpy&quot;</span>, ignored)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的注释也很有意思，你不让我搞，我还是要搞，我就是要出狂战斧！！！里面的逻辑就不细说了，就是反射。说个额外话题，就是为啥要 hook 这个字段呢？</p><p>因为，view想要显示出来，需要将自己添加到 window上，而 window 是由 WMS 管理的，app 与 WMS 是通过 Binder 通信，app 端的代理就是 WindowManagerGlobal 这个对象。所以，每个 activity，dialog，toast 显示的时候，都需要经过 WindowManagerGlobal 的 addView 方法，而所有的添加的 view 都存放在了 WindowManagerGlobal  的 mViews 字段里面。</p><p>这个方法的作用说清楚了，再说一下这个方法的构成，从它的名字，我们可以知道这个方法的作用，但是还需要注意的时，<strong>这个方法的参数是一个 lambda 表达式。这个 lambda 表达式的参数，是该方法要替换的那个字段。</strong></p><p>有点绕，但是好理解，因为有时候我们不仅仅是需要将字段替换一下，而是需要利用原来的字段值做一些处理之后再设置回去，这样，外部调用这个方法的时候，就可以直接使用 lambda 的参数即可。</p><p>我们看看使用这个方法的地方：</p><blockquote><p>curtains.internal.RootViewsSpy.Companion#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span>: RootViewsSpy &#123;<br>  <span class="hljs-keyword">return</span> RootViewsSpy().apply &#123;<br>    WindowManagerSpy.swapWindowManagerGlobalMViews &#123; mViews -&gt;<br>      delegatingViewList.apply &#123; addAll(mViews) &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是将 mViews 字段，替换为 delegatingViewList，delegatingViewList 将 mViews 里面的值 copy 过来了。这个方法里面的逻辑如此简单，相比奥妙必然在 delegatingViewList 里面。</p><blockquote><p>curtains/internal/RootViewsSpy.kt:23</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> val delegatingViewList = object : ArrayList&lt;View&gt;() &#123;<br>  <span class="hljs-function">override fun <span class="hljs-title">add</span><span class="hljs-params">(element: View)</span>: Boolean </span>&#123;<br>    listeners.forEach &#123; it.onRootViewsChanged(element, <span class="hljs-keyword">true</span>) &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.add(element)<br>  &#125;<br><br>  <span class="hljs-function">override fun <span class="hljs-title">removeAt</span><span class="hljs-params">(index: Int)</span>: View </span>&#123;<br>    val removedView = <span class="hljs-keyword">super</span>.removeAt(index)<br>    listeners.forEach &#123; it.onRootViewsChanged(removedView, <span class="hljs-keyword">false</span>) &#125;<br>    <span class="hljs-keyword">return</span> removedView<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它重写了 list 的 add 与 removeAt 方法，在这两个方法执行的时候，调用了 listener 的对应方法。这个  listener 是在下面的方法处添加的：</p><blockquote><p>leakcanary.RootViewWatcher#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">install</span><span class="hljs-params">()</span></span> &#123;<br>  Curtains.onRootViewsChangedListeners += listener<br>&#125;<br></code></pre></td></tr></table></figure><p>看这个 listener 的实现：</p><blockquote><p>leakcanary.RootViewWatcher#listener</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> listener = OnRootViewAddedListener &#123; rootView -&gt;<br>  <span class="hljs-keyword">val</span> trackDetached = <span class="hljs-keyword">when</span>(rootView.windowType) &#123;<br>    PHONE_WINDOW -&gt; &#123;<br>      <span class="hljs-keyword">when</span> (rootView.phoneWindow?.callback?.wrappedCallback) &#123;<br>        <span class="hljs-comment">// Activities are already tracked by ActivityWatcher</span><br>        <span class="hljs-keyword">is</span> Activity -&gt; <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">is</span> Dialog -&gt; rootView.resources.getBoolean(R.bool.leak_canary_watcher_watch_dismissed_dialogs)<br>        <span class="hljs-comment">// Probably a DreamService</span><br>        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// Android widgets keep detached popup window instances around.</span><br>    POPUP_WINDOW -&gt; <span class="hljs-literal">false</span><br>    TOOLTIP, TOAST, UNKNOWN -&gt; <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (trackDetached) &#123;<br>    rootView.addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : OnAttachStateChangeListener &#123;<br><br>      <span class="hljs-keyword">val</span> watchDetachedView = Runnable &#123;<br>        reachabilityWatcher.expectWeaklyReachable(<br>          rootView, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;rootView::class.java.name&#125;</span> received View#onDetachedFromWindow() callback&quot;</span><br>        )<br>      &#125;<br><br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>        mainHandler.removeCallbacks(watchDetachedView)<br>      &#125;<br><br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> &#123;<br>        mainHandler.post(watchDetachedView)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是，为每个 rootView 都添加了一个 addOnAttachStateChangeListener 监听。在 onViewDetachedFromWindow 的时候，去监听这个对象是否泄露。</p><h3 id="监测-Service-的泄露"><a href="#监测-Service-的泄露" class="headerlink" title="监测 Service 的泄露"></a>监测 Service 的泄露</h3><p>service 的泄露监测点要稍微复杂一点，涉及到两个方面：</p><ul><li>mH</li><li>ActivityManager</li></ul><blockquote><p>leakcanary.ServiceWatcher#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 替换 ActivityThread 里面 mH 的 callback 字段</span><br>swapActivityThreadHandlerCallback &#123; mCallback -&gt;<br>  <span class="hljs-comment">// uninstall 的时候，需要将替换的字段替换回来</span><br>  uninstallActivityThreadHandlerCallback = &#123;<br>    swapActivityThreadHandlerCallback &#123;<br>      mCallback<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 创建新的 callback 对象，替换原来的</span><br>  Handler.Callback &#123; msg -&gt;<br>    <span class="hljs-comment">// 针对 STOP_SERVICE 消息进行处理</span><br>    <span class="hljs-keyword">if</span> (msg.what == STOP_SERVICE) &#123;<br>      <span class="hljs-keyword">val</span> key = msg.obj <span class="hljs-keyword">as</span> IBinder<br>      <span class="hljs-comment">// 从 activityThread 的 mServices 字段里面，拿到 Service 对象</span><br>      activityThreadServices[key]?.let &#123;<br>        <span class="hljs-comment">// 将 service 用弱引用包装后放入 map</span><br>        onServicePreDestroy(key, it)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回 false，继续走 handler 的 handleMessage 逻辑</span><br>    mCallback?.handleMessage(msg) ?: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以  swap 方法开头的前面已经说过这个套路了，就不重复了，上面的代码就是 替换 ActivityThread 里面 mH 的 callback 字段。</p><p>由于，我们监测的是 Service，hook 它的作用就是可以拿到 service 对应的 binder 对象，通过这个 binder 对象，我们就可以获取到对应的 Service，然后在监测这个 Service。</p><p>上面的代码中，有个 <code>onServicePreDestroy</code> 方法，它就是将 binder 与 service 储存起来了。</p><blockquote><p>leakcanary.ServiceWatcher#onServicePreDestroy</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServicePreDestroy</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  token: <span class="hljs-type">IBinder</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  service: <span class="hljs-type">Service</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>  servicesToBeDestroyed[token] = WeakReference(service)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，找到真正 service 执行 onDestroy 的地方：</p><blockquote><p>leakcanary.ServiceWatcher#install</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>  <span class="hljs-comment">// 因为 handler 的 handleMessage 逻辑里面，会调用 ActivityManager.getService().serviceDoneExecuting() 方法</span><br>  <span class="hljs-comment">// 所以需要 hook ActivityManager，在这个方法里去监测 service 的泄露情况</span><br>  swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;<br>    <span class="hljs-comment">// 卸载函数，同上</span><br>    uninstallActivityManager = &#123;<br>      swapActivityManager &#123; _, _ -&gt;<br>        activityManagerInstance<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 动态代理，hook ActivityManager 的 serviceDoneExecuting 方法</span><br>    Proxy.newProxyInstance(<br>      activityManagerInterface.classLoader, arrayOf(activityManagerInterface)<br>    ) &#123; _, method, args -&gt;<br>      <span class="hljs-keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;<br>        <span class="hljs-keyword">val</span> token = args!![<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> IBinder<br>        <span class="hljs-keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;<br>          <span class="hljs-comment">// serviceDoneExecuting 方法的参数里面只有 token，所以在 onServicePreDestroy 里面保存了 token - service 的键值对（弱引用map）</span><br>          onServiceDestroyed(token)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 调用原来的逻辑</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span>) &#123;<br>          method.invoke(activityManagerInstance)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          method.invoke(activityManagerInstance, *args)<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (invocationException: InvocationTargetException) &#123;<br>        <span class="hljs-keyword">throw</span> invocationException.targetException<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span> (ignored: Throwable) &#123;<br>  SharkLog.d(ignored) &#123; <span class="hljs-string">&quot;Could not watch destroyed services&quot;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service 的 onDestroy 方法执行后，接下来就执行 ActivityManager 的 serviceDoneExecuting 方法，所以hook这个方法也没问题。</p><p><code>onServiceDestroyed</code>这个方法里面，就是监测代码了：</p><blockquote><p>leakcanary.ServiceWatcher#onServiceDestroyed</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDestroyed</span><span class="hljs-params">(token: <span class="hljs-type">IBinder</span>)</span></span> &#123;<br>  <span class="hljs-comment">// 从 map 中取出弱引用来</span><br>  servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;<br>    <span class="hljs-comment">// 拿到 service</span><br>    serviceWeakReference.<span class="hljs-keyword">get</span>()?.let &#123; service -&gt;<br>      <span class="hljs-comment">// 监测 service</span><br>      reachabilityWatcher.expectWeaklyReachable(<br>        service, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span><br>      )<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeakCanary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-LeakCanary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>镜像与代理问题</title>
    <link href="/2021/03/06/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E9%95%9C%E5%83%8F%E4%B8%8E%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/06/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E9%95%9C%E5%83%8F%E4%B8%8E%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Android-Stuido-设置SDK镜像地址"><a href="#Android-Stuido-设置SDK镜像地址" class="headerlink" title="Android Stuido 设置SDK镜像地址"></a>Android Stuido 设置SDK镜像地址</h3><ol><li>打开设置界面，搜索 proxy</li><li>找到 HTTP Proxy 选项</li><li>在 Auto-detect proxy settings 里面填入镜像地址</li></ol><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/pack/1.png?raw=true"></p><h3 id="Android-Studio-设置本地代理（clash等）"><a href="#Android-Studio-设置本地代理（clash等）" class="headerlink" title="Android Studio 设置本地代理（clash等）"></a>Android Studio 设置本地代理（clash等）</h3><p>打开工程的 <code>gradle.properties</code> 文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs groovy">systemProp.http.proxyHost=www.somehost.org<br>systemProp.http.proxyPort=<span class="hljs-number">8080</span><br>systemProp.http.proxyUser=user<br>systemProp.http.proxyPassword=password<br>systemProp.http.nonProxyHosts=localhost<br>systemProp.http.auth.ntlm.domain=domain<br><br>systemProp.https.proxyHost=www.somehost.org<br>systemProp.https.proxyPort=<span class="hljs-number">8080</span><br>systemProp.https.proxyUser=user<br>systemProp.https.proxyPassword=password<br>systemProp.https.nonProxyHosts=localhost<br>systemProp.https.auth.ntlm.domain=domain<br></code></pre></td></tr></table></figure><p>有时候，使用 Settings 里面的配置框，会改动 <code>.gradle</code> 文件里面的 <code>gradle.properties</code>，建议将它改成只读的。</p><h3 id="Git-设置代理"><a href="#Git-设置代理" class="headerlink" title="Git 设置代理"></a>Git 设置代理</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.proxy</span> &#x27;socks5:<span class="hljs-comment">//127.0.0.1:1080&#x27;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.proxy</span> &#x27;socks5:<span class="hljs-comment">//127.0.0.1:1080&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Provider的理解</title>
    <link href="/2021/03/04/blog_bak/Blog/flutter/010-Provider%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/03/04/blog_bak/Blog/flutter/010-Provider%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Provider 是官方推荐的状态管理框架。那么状态又是什么东西？在 Flutter 中，万物都是 Widget，Widget 又分为两种：</p><ul><li>StatelessWidget（无状态）</li><li>StatefulWidget  (有状态）</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">有些widgets是有状态的, 有些是无状态的<br>如果用户与widget交互，widget会发生变化，那么它就是有状态的.<br>widget的状态（<span class="hljs-keyword">state</span>）是一些可以更改的值, 如一个slider滑动条的当前值或checkbox是否被选中.<br>widget的状态保存在一个State对象中, 它和widget的布局显示分离。<br>当widget状态改变时, State 对象调用<span class="hljs-built_in">set</span>State(), 告诉框架去重绘widget.<br></code></pre></td></tr></table></figure><h3 id="管理状态"><a href="#管理状态" class="headerlink" title="管理状态"></a>管理状态</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">有多种方法可以管理状态.<br>如果不是很清楚时, 那就在父widget中管理状态吧.<br></code></pre></td></tr></table></figure><p>以下是管理状态的最常见的方法：</p><ul><li><a href="https://flutterchina.club/tutorials/interactive/#self-managed">widget管理自己的state</a></li><li><a href="https://flutterchina.club/tutorials/interactive/#parent-managed">父widget管理 widget状态</a></li><li><a href="https://flutterchina.club/tutorials/interactive/#mix-and-match">混搭管理（父widget和widget自身都管理状态））</a></li></ul><p>如何决定使用哪种管理方法？以下原则可以帮助您决定：</p><ul><li>如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父widget管理</li><li>如果所讨论的状态是有关界面外观效果的，例如动画，那么状态最好由widget本身来管理.</li></ul><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>通常，我们的一个页面会有许多控件，对应着许多状态。在看法Android的时候，每个页面对应着一个 ViewModel，这个 ViewModel 里面的数据是变化的，它的每个快照，就是页面该时刻的状态。</p><p>上面，我们说到，Widget 可以将状态的管理交给父类，实际上，通常使用 Provider 的时候，页面上所有的 widget 会将状态交给顶层 Widget 去管理，由于它是对 <a href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html">InheritedWidget</a> 进行了封装，所以页面上所有的子 Widget 可以进行数据共享与监听。</p><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>下面介绍一下，InheritedWidget 是如何做到子 Widget 可以获取父 Widget 的数据的，以及一些特殊的效果。</p><p>我们使用 InheritedWidget 时涉及到的工作量主要有 2 部分：</p><ul><li>创建一个继承自 InheritedWidget 的类，并将其插入 Widget 树</li><li>通过 BuildContext 对象提供的 <code>inheritFromWidgetOfExactType</code> 方法查找 Widget 树中最近的一个特定类型的 InheritedWidget 类的实例</li></ul><p>这里还暗含了一个逻辑，那就是当我们通过 <code>inheritFromWidgetOfExactType</code> 查找特定类型 InheritedWidget 的时候，这个 InheritedWidget 的信息是由父元素层层向子元素传递下来的呢？还是 <code>inheritFromWidgetOfExactType</code> 方法自己层层向上查找的呢？</p><h4 id="InheritedWidget-相关信息的传递机制"><a href="#InheritedWidget-相关信息的传递机制" class="headerlink" title="InheritedWidget 相关信息的传递机制"></a>InheritedWidget 相关信息的传递机制</h4><p>每个 Element 实例上都有一个 <code>_inheritedWidgets</code> 属性。该属性的类型为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;<br></code></pre></td></tr></table></figure><p>其中保存了祖先节点中出现的 InheritedWidget 与其对应 element 的映射关系。在 element 的 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L2754"><code>mount</code> 阶段</a>和 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L3019"><code>active</code> 阶段</a>，会执行 <code>_updateInheritance()</code> 方法更新这个映射关系。</p><p>对于普通 Element 实例，<code>_updateInheritance()</code> 只是<a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L3251-L3254">单纯把父 element 的 <code>_inheritedWidgets</code> 属性保存在自身 <code>_inheritedWidgets</code> 里</a>。从而实现映射关系的层层向下传递。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>  <span class="hljs-keyword">assert</span>(_active);<br>  _inheritedWidgets = _parent?._inheritedWidgets;<br>&#125;<br></code></pre></td></tr></table></figure><p>由 InheritedWidget 创建的 InheritedElement <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L4039-L4047">重写了该方法</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>  <span class="hljs-keyword">assert</span>(_active);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt; incomingWidgets = _parent?._inheritedWidgets;<br>  <span class="hljs-keyword">if</span> (incomingWidgets != <span class="hljs-keyword">null</span>)<br>    _inheritedWidgets = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);<br>  <span class="hljs-keyword">else</span><br>    _inheritedWidgets = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;();<br>  _inheritedWidgets[widget.runtimeType] = <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出 InheritedElement 实例会把自身的信息添加到 <code>_inheritedWidgets</code> 属性中，这样其子孙 element 就可以通过前面提到的 <code>_inheritedWidgets</code> 的传递机制获取到此 InheritedElement 的引用。</p><blockquote><p>总结一下：Widget 树中的依赖关系，是一层一层的往下传递的，如果遇到了 InheritedWidget ，还需要将这个 Widget 的依赖关系（这个 Widget 以及它向子Widget 提供的数据类型）添加进去。</p></blockquote><h4 id="InheritedWidget-的更新通知机制"><a href="#InheritedWidget-的更新通知机制" class="headerlink" title="InheritedWidget 的更新通知机制"></a>InheritedWidget 的更新通知机制</h4><p>首先，说一个小知识点。</p><p>前文提到 <code>_inheritedWidgets</code> 属性存在于 Element 实例上，而我们代码中调用的 <code>inheritFromWidgetOfExactType</code> 方法则存在于 BuildContext 实例之上。那么 BuildContext 是如何获取 Element 实例上的信息的呢？答案是<strong>不需要获取</strong>。因为<strong>每一个 Element 实例也都是一个 BuildContext 实例</strong>。</p><p>既然可以拿到 InheritedWidget 的信息了，那接下让我们通过源码看看更新通知机制的具体实现。</p><p>首先看一下 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L3230-L3242"><code>inheritFromWidgetOfExactType</code> 的实现</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart">InheritedWidget inheritFromWidgetOfExactType(<span class="hljs-built_in">Type</span> targetType) &#123;<br>  <span class="hljs-keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());<br>  <span class="hljs-keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : _inheritedWidgets[targetType];<br>  <span class="hljs-keyword">if</span> (ancestor != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">assert</span>(ancestor <span class="hljs-keyword">is</span> InheritedElement);<br>    _dependencies ??= <span class="hljs-keyword">new</span> HashSet&lt;InheritedElement&gt;();<br>    _dependencies.add(ancestor);<br>    ancestor._dependents.add(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> ancestor.widget;<br>  &#125;<br>  _hadUnsatisfiedDependencies = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先在 <code>_inheritedWidget</code> 映射中查找是否有特定类型 InheritedWidget 的实例。如果有则将该实例添加到自身的依赖列表中，同时将自身添加到对应的依赖项列表中。这样该 InheritedWidget 在更新后就可以通过其 <code>_dependents</code> 属性知道需要通知哪些依赖了它的 widget。</p><p>每当 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L3914-L3923">InheritedElement 实例更新</a>时，会执行实例上的 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L4070-L4086"><code>notifyClients</code> 方法</a>通知依赖了它的子 element 同步更新。<code>notifyClients</code> 实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;<br>  <span class="hljs-keyword">if</span> (!widget.updateShouldNotify(oldWidget))<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">assert</span>(_debugCheckOwnerBuildTargetExists(<span class="hljs-string">&#x27;notifyClients&#x27;</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Element</span> dependent <span class="hljs-keyword">in</span> _dependents) &#123;<br>    <span class="hljs-keyword">assert</span>(() &#123;<br>      <span class="hljs-comment">// check that it really is our descendant</span><br>      <span class="hljs-built_in">Element</span> ancestor = dependent._parent;<br>      <span class="hljs-keyword">while</span> (ancestor != <span class="hljs-keyword">this</span> &amp;&amp; ancestor != <span class="hljs-keyword">null</span>)<br>        ancestor = ancestor._parent;<br>      <span class="hljs-keyword">return</span> ancestor == <span class="hljs-keyword">this</span>;<br>    &#125;());<br>    <span class="hljs-comment">// check that it really depends on us</span><br>    <span class="hljs-keyword">assert</span>(dependent._dependencies.contains(<span class="hljs-keyword">this</span>));<br>    dependent.didChangeDependencies();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先执行相应 InheritedWidget 上的 <code>updateShouldNotify</code> 方法判断是否需要通知，如果该方法返回 <code>true</code> 则遍历 <code>_dependents</code> 列表中的 element 并执行他们的 <code>didChangeDependencies()</code> 方法。这样 InheritedWidget 中的更新就通知到依赖它的子 widget 中了。</p><blockquote><p>总结一下：inheritFromWidgetOfExactType 先根据 type 找到 InheritedElement，然后储存依赖 element ，当 <a href="https://github.com/flutter/flutter/blob/v0.5.7/packages/flutter/lib/src/widgets/framework.dart#L3914-L3923">InheritedElement 实例更新</a>时，通知储存的 element 去更新。</p></blockquote><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>看一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInheritedWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> accountId;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> scopeId;<br><br>  MyInheritedWidget(accountId, scopeId, child): <span class="hljs-keyword">super</span>(child);<br>  <br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(MyInheritedWidget old) =&gt;<br>    accountId != old.accountId || scopeId != old.scopeId;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> accountId;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> scopeId;<br>  <br>  MyPage(<span class="hljs-keyword">this</span>.accountId, <span class="hljs-keyword">this</span>.scopeId);<br>  <br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyInheritedWidget(<br>      accountId,<br>      scopeId,<br>      <span class="hljs-keyword">const</span> MyWidget(),<br>     );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">const</span> MyWidget();<br>  <br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// somewhere down the line</span><br>    <span class="hljs-keyword">const</span> MyOtherWidget();<br>    ...<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyOtherWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">const</span> MyOtherWidget();<br>  <br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> myInheritedWidget = MyInheritedWidget.of(context);<br>    <span class="hljs-built_in">print</span>(myInheritedWidget.scopeId);<br>    <span class="hljs-built_in">print</span>(myInheritedWidget.accountId);<br>    ...<br></code></pre></td></tr></table></figure><ol><li><code>accountId</code>或者<code>scopeId</code>值更新的时候，MyInheritedWidget会被重新创建，但是它的child不一定会被创建，取决于是否用到了<code>accountId</code>或者<code>scopeId</code>，上面的这个例子中<code>MyOtherWidget</code>会被rebuild，<strong>但是<code>MyWidget</code>不会被rebuild</strong></li><li>如果tree被其他事件触发rebuild，例如orientation changes，<code>InheritedWidget</code>会被rebuild，但是child同样不一定被rebuild，因为<code>accountId</code>和<code>scopeId</code>没变。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>了解一下Binder</title>
    <link href="/2021/02/22/blog_bak/Blog/Android/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BBinder/"/>
    <url>/2021/02/22/blog_bak/Blog/Android/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BBinder/</url>
    
    <content type="html"><![CDATA[<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>Binder用于线程之间的通信，我们看一个例子：</p><p><img src="https://img-blog.csdnimg.cn/20190307214553683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MDM3MDQ3,size_16,color_FFFFFF,t_70" alt="img"></p><p>这是点击桌面的图标，启动app的情景。我们可以看到这里面涉及到了4个进程，不算fork，有两个都使用了 Binder 通信，剩余一个却使用了 socket 通信，那么这是为什么呢？</p><h3 id="Zygote-进程与-SystemService-进程的-socket-通信"><a href="#Zygote-进程与-SystemService-进程的-socket-通信" class="headerlink" title="Zygote 进程与 SystemService 进程的 socket 通信"></a>Zygote 进程与 SystemService 进程的 socket 通信</h3><p>我查了一些文章，一般都认为是 Binder 线程池导致的问题。</p><p>下面介绍一下 Binder 线程池。</p><p>Binder 有 C/S 两端，对于 Service 端来说，它需要处理来自 Client 的请求，那么问题来了，Service 一个线程够用的吗？显然是不够的，不然的话，多个 client 同时发出请求，那就需要排队了，这个体验显然是不好的。所以，会有一个线程池来处理请求。而 Binder 的双方一般都是互为 C/S 端，所以两边各有一个线程池。那么我们写 Service 端的时候，需要注意同步问题。</p><p>再回来说，为什么线程池会导致 Zygote 进程与 SystemService 进程之间的通信无法使用 Binder 而是要使用 Socket 呢？</p><p>因为应用进程是从 Zygote 进程 fork 出来的，而 Unix 的进程 fork 有规定：</p><blockquote><p>fork只能拷贝当前线程，不支持多线程的fork。</p></blockquote><p>所以，如果 Zygote 采用 Binder 通信的话，fork 出来的应用进程就有问题，比如可能死锁（如果拷贝的当前线程还带等待别的线程的锁，但是别的线程没有拷贝过来）。</p><p>Zygote 在fork进程之前，会把多余的线程（包括Binder线程）都杀掉只保留一个线程。所以此时就无法把结果通过Binder把消息发送给system_server。fork()进程完成之后Zygote也会把其他线程重新启动，这时候即使有了Binder线程，也无法重新建立连接。</p><p>所以，就采用了 socket 通信，我觉得，这个解释还算比较合理。</p><h3 id="Binder-的优缺点"><a href="#Binder-的优缺点" class="headerlink" title="Binder 的优缺点"></a>Binder 的优缺点</h3><p>再看看 Binder 相比于 socket 通信的优缺点，毕竟是特意设计出来的，肯定要有两把刷子。</p><h4 id="Binder一次拷贝原理"><a href="#Binder一次拷贝原理" class="headerlink" title="Binder一次拷贝原理"></a>Binder一次拷贝原理</h4><p>我们先说内核空间与用户空间：</p><p>内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p><p><img src="http://p9.pstatp.com/large/pgc-image/26eb41d898ca4c6d9467a9789f400005" alt="腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程"></p><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助系统调用来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p><p>Binder的一次拷贝的核心就是：</p><p><strong>当数据从用户空间拷贝到内核空间的时候，是直从当前进程的用户空间接拷贝到目标进程的内核空间，这个过程是在请求端线程中处理的，操作对象是目标进程的内核空间</strong>。</p><p>然后，再通过内存映射，目标进程的用户空间就可以直接读取数据了。</p><p>内存映射可以简单的理解为，两个地址都指向物理内存的同一段区域。</p><p><img src="https://upload-images.jianshu.io/upload_images/1460468-1f61b4f411c35094.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h4 id="Binder传输数据的大小限制"><a href="#Binder传输数据的大小限制" class="headerlink" title="Binder传输数据的大小限制"></a>Binder传输数据的大小限制</h4><p>比如在Activity之间传输BitMap的时候，如果Bitmap过大，就会引起问题，比如崩溃等，这其实就跟Binder传输数据大小的限制有关系，在上面的一次拷贝中分析过，mmap函数会为Binder数据传递映射一块连续的虚拟地址，这块虚拟内存空间其实是有大小限制的，不同的进程可能还不一样。</p><p>普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 1<em>1024</em>1024) - (4096 *2) ：这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3次握手与4次挥手</title>
    <link href="/2021/02/22/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/TCP/3%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2021/02/22/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/TCP/3%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="3次握手"><a href="#3次握手" class="headerlink" title="3次握手"></a>3次握手</h3><p><strong>流程如下图所示（TCP的三次握手和四次挥手）：</strong></p><p><img src="http://www.52im.net/data/attachment/forum/201710/27/110528h9iiyaqrryaijdgi.jpg" alt="网络编程懒人入门(四)：快速理解TCP和UDP的差异_1915184-43e91a9185faa031.jpg"></p><p>上图就从客户端和服务端的角度，清楚的展示了 TCP 的三次握手和四次挥手。可以看到，当 TCP 试图建立连接时，三次握手指的是客户端主动触发了两次，服务端触发了一次。</p><p><strong>我们可以先明确一下 TCP 建立连接并且初始化的目标是什么呢？</strong></p><ul><li>1）初始化资源；</li><li>2）告诉对方我的序列号。</li></ul><p><strong>所以三次握手的次序是这样子的：</strong></p><ul><li>1）client端首先发送一个SYN包告诉Server端我的初始序列号是X；</li><li>2）Server端收到SYN包后回复给client一个ACK确认包，告诉client说我收到了；</li><li>3）接着Server端也需要告诉client端自己的初始序列号，于是Server也发送一个SYN包告诉client我的初始序列号是Y；</li><li>4）Client收到后，回复Server一个ACK确认包说我知道了。</li></ul><p>其中的 2 、3 步骤可以简化为一步，也就是说将 ACK 确认包和 SYN 序列化包一同发送给 Client 端。到此我们就比较简单的解释了 TCP 建立连接的“三次握手”。</p><h3 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h3><p>三次握手耳熟能详，四次挥手估计就少有人知道了。所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</p><p><img src="http://www.52im.net/data/attachment/forum/201604/26/142520px6qkzx886895jn8.png" alt="理论经典：TCP协议的3次握手与4次挥手过程详解_3.png"></p><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><ul><li>第一次挥手：<br>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：<br>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li><li>第三次挥手：<br>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li><li>第四次挥手：<br>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li></ul><p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，具体流程如下图：</p><p><img src="http://www.52im.net/data/attachment/forum/201604/26/142103g2950o52j929hni9.png" alt="理论经典：TCP协议的3次握手与4次挥手过程详解_4.png"></p><p>流程和状态在上图中已经很明了了，在此不再赘述，可以参考前面的四次挥手解析步骤。</p>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目组件化</title>
    <link href="/2021/02/01/blog_bak/Blog/Android/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <url>/2021/02/01/blog_bak/Blog/Android/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>断断续续花了3个月的时间在 Github 上开发了一个专门学习项目组件化的开源项目。项目里面的 WIKI 记录了各个功能的实现原理，这里就不展开了。</p><p>贴一个项目链接：</p><p><a href="https://github.com/aprz512/BRouter">BRouter</a></p><p>有啥问题，欢迎提 issue 与 pr。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一些好用的网址</title>
    <link href="/2021/01/04/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/"/>
    <url>/2021/01/04/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="VPN-相关"><a href="#VPN-相关" class="headerlink" title="VPN 相关"></a>VPN 相关</h2><blockquote><p><strong>If you want to keep a secret, you must also hide it from yourself.</strong></p></blockquote><table><thead><tr><th>工具</th><th>Android</th><th>Liunx</th><th>Windows</th></tr></thead><tbody><tr><td>Clash</td><td><a href="https://github.com/Kr328/ClashForAndroid">ClashForAndroid</a></td><td></td><td><a href="https://github.com/Fndroid/clash_for_windows_pkg">clash_for_windows_pkg</a></td></tr><tr><td>ShodowSocks</td><td><a href="https://github.com/shadowsocks/shadowsocks-android">shadowsocks-android</a></td><td><a href="https://github.com/shadowsocks/shadowsocks-qt5">shadowsocks-qt5</a></td><td><a href="https://github.com/shadowsocks/shadowsocks-windows">shadowsocks-windows</a></td></tr><tr><td>ShodowSocksR</td><td></td><td></td><td><a href="https://github.com/HMBSbige/ShadowsocksR-Windows">ShadowsocksR-Windows</a></td></tr></tbody></table><table><thead><tr><th>网站</th><th>邀请链接</th><th>稳定性</th><th>访问速度</th><th>是否使用过</th></tr></thead><tbody><tr><td><a href="https://caomei.jp/index">草莓</a></td><td><a href="http://www.fancl-co-jp.club/register?aff=LaRY">http://www.fancl-co-jp.club/register?aff=LaRY</a></td><td>敏感时期也可以用</td><td>大部分时候都很快，有很多节点，需要经常切换才行</td><td>曾经使用，已放弃</td></tr><tr><td><a href="https://www.monocloud.me/">monoCloud</a></td><td></td><td>几乎都能用</td><td>速度挺好，没卡过</td><td>正在使用</td></tr></tbody></table><h2 id="一些工具网址"><a href="#一些工具网址" class="headerlink" title="一些工具网址"></a>一些工具网址</h2><table><thead><tr><th>工具</th><th>介绍</th></tr></thead><tbody><tr><td><a href="https://jex.im/regulex/">Regulex</a></td><td>一个让正则表达式可视化的网址，把你的正则表达式贴上去你就知道是怎么回事了。</td></tr><tr><td><a href="https://msdn.itellyou.cn/">Windows 镜像</a></td><td>Windows 镜像下载</td></tr><tr><td><a href="https://topazlabs.com/">电影画质修复工具</a></td><td>使用AI来修复画质的工具（修复画质为4K），399美元，不过有 crack 的。</td></tr><tr><td><a href="https://mpv.io/">本地播放器 MPV</a></td><td>播放本地视频的播放器，非常好用（比 射手，VLC 等都好）</td></tr><tr><td><a href="https://typora.io/">markdown 编辑器</a></td><td>typora 编辑器，还支持 Linux，NB。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>依赖aar引起的问题</title>
    <link href="/2020/12/24/blog_bak/Blog/Android-Bugs/%E4%BE%9D%E8%B5%96aar%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/24/blog_bak/Blog/Android-Bugs/%E4%BE%9D%E8%B5%96aar%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="gradle-里面依赖-aar-的两种方式"><a href="#gradle-里面依赖-aar-的两种方式" class="headerlink" title="gradle 里面依赖  aar 的两种方式"></a>gradle 里面依赖  aar 的两种方式</h3><p>第一种是，将 aar 放入 libs 里面，然后添加下面的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&quot;libs&quot;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&quot;*.aar&quot;</span>])<br></code></pre></td></tr></table></figure><p>这样，libs 下所有的 aar 文件都会被依赖。</p><p>第二种是，将 aar 放入 libs，然后将 libs 作为仓库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br><br>    repositories &#123;<br>        flatDir &#123;<br>            dir <span class="hljs-string">&#x27;libs&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在依赖里面，指明要依赖的aar文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;mylibrary-debug&#x27;</span>, <span class="hljs-attr">ext:</span> <span class="hljs-string">&#x27;aar&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这两种方式，看起来似乎没啥区别，都是依赖了我们指定的aar，但是在打包的过程中，这两种不同的依赖方式，会产生不同的效果。</p><h3 id="引起的问题"><a href="#引起的问题" class="headerlink" title="引起的问题"></a>引起的问题</h3><p>首先看一下我们的打包环境：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:3.6.4&quot;</span><br>&#125;<br><br>distributionUrl=https\:<span class="hljs-comment">//services.gradle.org/distributions/gradle-5.6.4-all.zip</span><br></code></pre></td></tr></table></figure><p>再看一下工程结构，很简单：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">Project<br>-&gt; app<br>-&gt; mylibrary<br></code></pre></td></tr></table></figure><p>当我将 mylibrary 打成 aar 后，放入 app 的 libs 里面，这里我们使用的是上面的<strong>第二种aar依赖方式</strong>，执行 assembleDebug 命令时，报如下错误：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">desugaring</span> <span class="hljs-title">of</span> `<span class="hljs-title">com</span>.<span class="hljs-title">aprz</span>.<span class="hljs-title">mylibrary</span>.<span class="hljs-title">LibActivity</span>` <span class="hljs-title">failed</span> <span class="hljs-title">because</span> <span class="hljs-title">its</span> <span class="hljs-title">super</span> <span class="hljs-title">class</span> `<span class="hljs-title">androidx</span>.<span class="hljs-title">appcompat</span>.<span class="hljs-title">app</span>.<span class="hljs-title">AppCompatActivity</span>` <span class="hljs-title">is</span> <span class="hljs-title">missing</span></span><br></code></pre></td></tr></table></figure><p>我们加上 -s，看看详细信息，如果信息展示不全还可以输出到文件 log.txt：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">gradlew assembleDebug -s &gt;<span class="hljs-built_in">log</span>.txt <span class="hljs-number">2</span>&gt;<span class="hljs-meta">&amp;1</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt; Transform artifact mylibrary-debug<span class="hljs-selector-class">.aar</span> (:mylibrary-debug-d8:) with DexingWithClasspathTransform<br>D8: Default method desugaring of `com<span class="hljs-selector-class">.aprz</span><span class="hljs-selector-class">.mylibrary</span>.LibActivity` failed because its super class `androidx<span class="hljs-selector-class">.appcompat</span><span class="hljs-selector-class">.app</span>.AppCompatActivity` is missing<br><br>...<br><br>Caused by: com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.r8</span><span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.b</span>: Error: Default method desugaring of `com<span class="hljs-selector-class">.aprz</span><span class="hljs-selector-class">.mylibrary</span>.LibActivity` failed because its super class `androidx<span class="hljs-selector-class">.appcompat</span><span class="hljs-selector-class">.app</span>.AppCompatActivity` is missing<br>        at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.r8</span><span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.y0</span><span class="hljs-selector-class">.a</span>(:<span class="hljs-number">21</span>)<br>        at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.r8</span><span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.O</span><span class="hljs-selector-class">.a</span>(:<span class="hljs-number">51</span>)<br>        ... <span class="hljs-number">101</span> more<br></code></pre></td></tr></table></figure><p>我们可以看到，详细信息里面可以看到出错的地方与 r8 有关系。</p><p>这个错误是以前没有遇到过的，暂时不知道如何解决，所以<strong>我们使用了第一种aar依赖方式，居然就没有问题了，很神奇</strong>。</p><p>后来我去 Google 了，经过一番搜索之后，大概猜测出了使用第二种aar依赖方式引发出错的原因：</p><blockquote><p>我们的 AGP 版本太低，自带的 r8 版本低，有 bug。该版本的 r8 无法 desugar <strong>接口默认方法</strong></p></blockquote><p>因为，上面报错的 LibsActivity 实现了一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">R8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口里面有一个默认方法，当我<strong>去掉这个默认方法的时候，再次打包，果然就好了</strong>。</p><p>为了证实是该版本的 R8 有问题，可以做下面的验证：</p><ul><li><p>升级 AGP，我使用了新建工程的打包环境（4.0.2 + 6.1.1） 没有问题</p></li><li><p>指定 r8 为最新版本，也没有问题</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        maven &#123;<br>            url <span class="hljs-string">&#x27;http://storage.googleapis.com/r8-release/raw&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br>dependencies &#123;<br>    classpath <span class="hljs-string">&#x27;com.android.tools:r8:2.1.67&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="还有一个问题"><a href="#还有一个问题" class="headerlink" title="还有一个问题"></a>还有一个问题</h3><p>经过一系列的骚操作，我都快忘记了一个问题，那就是就算找出了使用第二种aar依赖方式报错的原因，但是还有一个问题没有解决，那就是，<strong>为啥使用第一种aar依赖方式的时候不会报错</strong>？？？</p><p>从出错的日志里面可以看到是<code>DexingWithClasspathTransform</code>这个 task 出错了。为了验证一个猜想，我们输出所有 transform 相关信息， 查看两种依赖方式的不同之处。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">在命令上加上 --<span class="hljs-builtin-name">info</span> 既可输入 transform 的详细信息<br></code></pre></td></tr></table></figure><p>搜索输出的日志（搜索 <code>&gt; Transform artifact mylibrary</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Line <span class="hljs-number">638</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with JetifyTransform<br>Line <span class="hljs-number">774</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarToClassTransform<br>Line <span class="hljs-number">1150</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with ExtractAarTransform<br>Line <span class="hljs-number">1293</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">1572</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">2223</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with LibrarySymbolTableTransform<br>Line <span class="hljs-number">2480</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarResourcesCompilerTransform<br>Line <span class="hljs-number">2782</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">3067</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">3792</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">4209</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">4873</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarToClassTransform<br>Line <span class="hljs-number">5188</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with AarTransform<br>Line <span class="hljs-number">5221</span>: &gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with DexingWithClasspathTransform<br></code></pre></td></tr></table></figure><p>在最后一个记录下，果然发现了错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; Transform artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with DexingWithClasspathTransform<br>Transforming artifact mylibrary-debug-d8.aar (:mylibrary-debug-d8:) with DexingWithClasspathTransform<br>Caching disabled <span class="hljs-keyword">for</span> DexingWithClasspathTransform: C:\Users\aprz512\.gradle\caches\transforms-<span class="hljs-number">2</span>\files-<span class="hljs-number">2.1</span>\fd035d5206d4a7a1458c993599791019\jetified-mylibrary-debug-d8-runtime.jar because:<br>  Build cache is disabled<br>DexingWithClasspathTransform: C:\Users\aprz512\.gradle\caches\transforms-<span class="hljs-number">2</span>\files-<span class="hljs-number">2.1</span>\fd035d5206d4a7a1458c993599791019\jetified-mylibrary-debug-d8-runtime.jar is not up-to-date because:<br>  Task has failed previously.<br>C:\Users\aprz512\.gradle\caches\transforms-<span class="hljs-number">2</span>\files-<span class="hljs-number">2.1</span>\fd035d5206d4a7a1458c993599791019\jetified-mylibrary-debug-d8-runtime.jar: D8: Type `androidx.appcompat.app.AppCompatActivity` was not found, it is required <span class="hljs-keyword">for</span> <span class="hljs-keyword">default</span> or <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">methods</span> <span class="hljs-title">desugaring</span> <span class="hljs-title">of</span> `<span class="hljs-title">void</span> <span class="hljs-title">com</span>.<span class="hljs-title">aprz</span>.<span class="hljs-title">mylibrary</span>.<span class="hljs-title">LibActivity</span>.<span class="hljs-title">onCreate</span>(<span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Bundle</span>)`</span><br><span class="hljs-class"><span class="hljs-title">D8</span>: <span class="hljs-title">Default</span> <span class="hljs-title">method</span> <span class="hljs-title">desugaring</span> <span class="hljs-title">of</span> `<span class="hljs-title">com</span>.<span class="hljs-title">aprz</span>.<span class="hljs-title">mylibrary</span>.<span class="hljs-title">LibActivity</span>` <span class="hljs-title">failed</span> <span class="hljs-title">because</span> <span class="hljs-title">its</span> <span class="hljs-title">super</span> <span class="hljs-title">class</span> `<span class="hljs-title">androidx</span>.<span class="hljs-title">appcompat</span>.<span class="hljs-title">app</span>.<span class="hljs-title">AppCompatActivity</span>` <span class="hljs-title">is</span> <span class="hljs-title">missing</span></span><br><span class="hljs-class"><span class="hljs-title">DexingWithClasspathTransform</span> (<span class="hljs-title">Thread</span>[<span class="hljs-title">Execution</span> <span class="hljs-title">worker</span> <span class="hljs-title">for</span> &#x27;:&#x27; <span class="hljs-title">Thread</span> 3,5,<span class="hljs-title">main</span>]) <span class="hljs-title">completed</span>. <span class="hljs-title">Took</span> 0.885 <span class="hljs-title">secs</span>.</span><br></code></pre></td></tr></table></figure><p>那么，我们再看看<strong>使用第一种aar依赖方式，打包的日志（搜索 <code>&gt; Transform artifact mylibrary</code>），没有发现任何记录</strong>！！！</p><p>这个结果还是符合我的猜想的，那就是使用第一种aar依赖方式的时候，libs 里面的 aar 包并不会经过 DexingWithClasspathTransform 的处理。</p><p>所以，这两种依赖 aar 的方式，还是有点区别的。</p><h3 id="最后得问题"><a href="#最后得问题" class="headerlink" title="最后得问题"></a>最后得问题</h3><p>使用第二种aar依赖方式，点击 run 三角按钮，却不会报错？？？ 这又是为啥？</p><p>看 console 里面，点击 run 按钮，也是执行的 assemble 命令，但是我们手动执行，却不行，这个暂时没搞清楚。</p>]]></content>
    
    
    <categories>
      
      <category>bugs</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View 的滑动处理（四）</title>
    <link href="/2020/12/21/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/12/21/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个例子可能举得不太恰当，应该用 NestedScrollView距离，因为在不同的版本上，下面的例子有不同的滑动效果。</p><p>例子基于 API 28</p></blockquote><p>看下面这个布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;120dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;btn_01&quot;</span> /&gt;</span><br><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">androidx.recyclerview.widget.RecyclerView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recycler_view&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/teal_200&quot;</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;120dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;btn_01&quot;</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;120dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;btn_01&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>忽略，其他无关的部分，其实就是一个 ScrollView 嵌套了一个 RecyclerView。</p><p>按照事件拦截机制来看，当 RecyclerView 滑动到底部的时候，应该就不能滑动了，而且 ScrollView 也无法滑动才对。</p><p>但是实际行为却不是这样的，实际上它们的滑动效果可以无缝链接，当 RecyclerView 滑动到底部的时候，继续滑动时，ScrollView 会滑动。惊了，决定看看源码，看看到底是怎么回事，这单纯用事件拦截机制是无法解释的。除非这两个控件强耦合。</p><p>那么，现在有几个问题是无法解释的：</p><ul><li>滑动 RecyclerView 的时候，为什么不是 ScrollView 拦截这个滑动事件？它是怎么做到的？</li><li>RecyclerView 滑动到底部的时候，ScrollView 是如何接着滑动的？</li></ul><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>我们看 ScrollView 的 <code>android.widget.ScrollView#onInterceptTouchEvent</code> 方法：</p><blockquote><p>android.widget.ScrollView#onInterceptTouchEvent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它决定是否拦截事件，主要取决于 <code>mIsBeingDragged</code> 这个变量。由于在这个滑动事件中，ScrollView 只会走 onInterceptTouchEvent 这个方法，所以我们只用看这个方法里面的逻辑，它里面 mIsBeingDragged 的赋值逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>) ev.getY(pointerIndex);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> yDiff = Math.abs(y - mLastMotionY);<br>    <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; (getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == <span class="hljs-number">0</span>) &#123;<br>        mIsBeingDragged = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>可以看到，mIsBeingDragged 的值取决于 getNestedScrollAxes() 这个方法的值。</p><p>那么，这个<code>getNestedScrollAxes() &amp; SCROLL_AXIS_VERTICAL) == 0</code> 条件啥时候为 true 呢？答案是当 ``getNestedScrollAxes()`不等于 SCROLL_AXIS_VERTICAL 的时候，也就是<strong>嵌套滑动方向不是竖直滑动的时候</strong>。</p><p>那么，我们看这个方法的逻辑：</p><blockquote><p>android.view.ViewGroup#getNestedScrollAxes</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNestedScrollAxes</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mNestedScrollAxes;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的返回了一个成员变量，看他在哪里赋值的：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">android.view.ViewGroup#onNestedScrollAccepted<br>-androidx.core.view.ViewParentCompat<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">onNestedScrollAccepted</span><span class="hljs-params">(<span class="hljs-variable">android</span>.<span class="hljs-variable">view</span>.<span class="hljs-variable">ViewParent</span>, <span class="hljs-variable">android</span>.<span class="hljs-variable">view</span>.<span class="hljs-variable">View</span>, <span class="hljs-variable">android</span>.<span class="hljs-variable">view</span>.<span class="hljs-variable">View</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>)</span></span><br>--androidx.core.view.NestedScrollingChildHelper<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">startNestedScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>)</span></span><br>---androidx.recyclerview.widget.RecyclerView<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">startNestedScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>)</span></span><br>----androidx.recyclerview.widget.RecyclerView#onInterceptTouchEvent<br><br>----androidx.recyclerview.widget.RecyclerView#onTouchEvent<br></code></pre></td></tr></table></figure><p>跟着这个调用链，可以知道，当 RecyclerView 的 onTouchEvent 方法执行的时候，就赋值为 <code>SCROLL_AXIS_VERTICAL</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;<br><span class="hljs-keyword">if</span> (canScrollHorizontally) &#123;<br>    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;<br>&#125;<br><span class="hljs-keyword">if</span> (canScrollVertically) &#123;<br>    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;<br>&#125;<br>startNestedScroll(nestedScrollAxis, TYPE_TOUCH);<br></code></pre></td></tr></table></figure><p>所以，ScrollView 的 mIsBeingDragged 一直为 false，它就不拦截事件。</p><p>整个流程就是：</p><ul><li>down 事件产生，传递到 recyclerView，recyclerView 的 child 没有能消费这个事件的，它自己处理了，调用到它自己的  onTouchEvent 方法</li><li>通过 NestedScrolling 的一些接口，通知父控件嵌套滑动方向为 SCROLL_AXIS_VERTICAL</li><li>move 事件到来时，由于嵌套滑动方向是竖直的，ScrollView 就不拦截</li></ul><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>在第一篇里面，我们是介绍了嵌套滑动的相关概念，这里就很像嵌套滑动。</p><p>然后看到了这样的调用链：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs leaf">androidx.recyclerview.widget.RecyclerView#onTouchEvent<br>-&gt;androidx.recyclerview.widget.RecyclerView<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>)</span></span><br>--&gt;androidx.core.view.NestedScrollingChildHelper<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>)</span></span><br></code></pre></td></tr></table></figure><p>这个方法里面，就有一个很有意思的东西：</p><blockquote><p>androidx.core.view.NestedScrollingChildHelper#dispatchNestedPreScroll(int, int, int[], int[], int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">int</span>[] consumed,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">int</span>[] offsetInWindow, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isNestedScrollingEnabled()) &#123;<br>        <span class="hljs-comment">// ① 这里获取了 parent，在上面的例子中，这个parent 就是 ScrollView</span><br>        <span class="hljs-keyword">final</span> ViewParent parent = getNestedScrollingParentForType(type);<br>        <span class="hljs-keyword">if</span> (parent == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dx != <span class="hljs-number">0</span> || dy != <span class="hljs-number">0</span>) &#123;<br>            ...<br>            <span class="hljs-comment">// ② 这里处理的嵌套滑动的逻辑    </span><br>            ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type);<br><br>            ...<br>            <span class="hljs-keyword">return</span> consumed[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span> || consumed[<span class="hljs-number">1</span>] != <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (offsetInWindow != <span class="hljs-keyword">null</span>) &#123;<br>            offsetInWindow[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            offsetInWindow[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先看注释①：</p><p>问题一：RecyclerView 是如何知道 ScrollView 是 parent 的？</p><blockquote><p>androidx.core.view.NestedScrollingChildHelper#getNestedScrollingParentForType</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ViewParent <span class="hljs-title">getNestedScrollingParentForType</span><span class="hljs-params">(<span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> TYPE_TOUCH:<br>            <span class="hljs-keyword">return</span> mNestedScrollingParentTouch;<br>        <span class="hljs-keyword">case</span> TYPE_NON_TOUCH:<br>            <span class="hljs-keyword">return</span> mNestedScrollingParentNonTouch;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>追踪链如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">androidx<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.view</span>.NestedScrollingChildHelper<span class="hljs-selector-id">#mNestedScrollingParentTouch</span><br>-&gt;androidx<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.view</span>.NestedScrollingChildHelper<span class="hljs-selector-id">#setNestedScrollingParentForType</span><br>--&gt;androidx<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.view</span>.NestedScrollingChildHelper<span class="hljs-selector-id">#startNestedScroll</span>(int, int)<br>---&gt;androidx<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.view</span>.NestedScrollingChildHelper#setNestedScrollingParentForType<br></code></pre></td></tr></table></figure><p>所以，parent 的赋值逻辑如下：</p><blockquote><p>androidx.core.view.NestedScrollingChildHelper#startNestedScroll(int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@ScrollAxis</span> <span class="hljs-keyword">int</span> axes, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hasNestedScrollingParent(type)) &#123;<br>        <span class="hljs-comment">// Already in progress</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isNestedScrollingEnabled()) &#123;<br>        ViewParent p = mView.getParent();<br>        View child = mView;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes, type)) &#123;<br>                setNestedScrollingParentForType(type, p);<br>                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes, type);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> View) &#123;<br>                child = (View) p;<br>            &#125;<br>            p = p.getParent();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑，就是不断的向上寻找 parent，直到 <code>androidx.core.view.ViewParentCompat#onStartNestedScroll(android.view.ViewParent, android.view.View, android.view.View, int, int)</code> 这个方法返回 true。看看这个方法的逻辑：</p><blockquote><p>androidx.core.view.ViewParentCompat#onStartNestedScroll(android.view.ViewParent, android.view.View, android.view.View, int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(ViewParent parent, View child, View target,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> nestedScrollAxes, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> NestedScrollingParent2) &#123;<br>        <span class="hljs-comment">// First try the NestedScrollingParent2 API</span><br>        <span class="hljs-keyword">return</span> ((NestedScrollingParent2) parent).onStartNestedScroll(child, target,<br>                nestedScrollAxes, type);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == ViewCompat.TYPE_TOUCH) &#123;<br>        <span class="hljs-comment">// Else if the type is the default (touch), try the NestedScrollingParent API</span><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">21</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 看这里，看这里</span><br>                <span class="hljs-keyword">return</span> parent.onStartNestedScroll(child, target, nestedScrollAxes);<br>            &#125; <span class="hljs-keyword">catch</span> (AbstractMethodError e) &#123;<br>                Log.e(TAG, <span class="hljs-string">&quot;ViewParent &quot;</span> + parent + <span class="hljs-string">&quot; does not implement interface &quot;</span><br>                        + <span class="hljs-string">&quot;method onStartNestedScroll&quot;</span>, e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> NestedScrollingParent) &#123;<br>            <span class="hljs-keyword">return</span> ((NestedScrollingParent) parent).onStartNestedScroll(child, target,<br>                    nestedScrollAxes);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为，ScrollView 是没有实现 NestedScrolling 相关接口的，所以，这里我们看 else if 中的逻辑，最后调用到了 ViewParent 的 onStartNestedScroll 方法。</p><p>看看这个方法有哪些类实现了，结果就有 ScrollView （ViewGroup 也实现了，只不过返回的是 false）。</p><blockquote><p>android.widget.ScrollView#onStartNestedScroll</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(View child, View target, <span class="hljs-keyword">int</span> nestedScrollAxes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (nestedScrollAxes &amp; SCROLL_AXIS_VERTICAL) != <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到了这里，答案就开始浮现出来了，虽然，ScollView 没有实现 NestedScrolling  相关接口，但是它的接口（ViewParent）里面也有相关的方法，所以，最终它也可以做到嵌套滑动。</p><p>我们回忆一下嵌套滑动的核心逻辑：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在一个move产生后：<br><br><span class="hljs-bullet">1.</span> child 先询问 parent，能够消耗多少，没有消耗完<br><span class="hljs-bullet">2.</span> child 自己消耗，没有消耗完<br><span class="hljs-bullet">3.</span> child 再次询问 parent，我这还有没消耗完的，你能消耗多少，如果 parent 还是没有消耗完<br><span class="hljs-bullet">4.</span> child 自己处理<br><br></code></pre></td></tr></table></figure><p>根据这个逻辑，我们追踪<code>androidx.core.view.ViewParentCompat#onNestedPreScroll(android.view.ViewParent, android.view.View, int, int, int[], int)</code>这个方法，调用链如下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs leaf">androidx.recyclerview.widget.RecyclerView#onTouchEvent<br>-&gt;androidx.recyclerview.widget.RecyclerView#scrollByInternal<br>--&gt;androidx.recyclerview.widget.RecyclerView<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">dispatchNestedScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>)</span></span><br>---&gt;androidx.core.view.NestedScrollingChildHelper<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">dispatchNestedScroll</span><span class="hljs-params">(<span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[], <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[])</span></span><br>----&gt;androidx.core.view.NestedScrollingChildHelper#dispatchNestedScrollInternal<br>-----&gt;androidx.core.view.ViewParentCompat<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">onNestedScroll</span><span class="hljs-params">(<span class="hljs-variable">android</span>.<span class="hljs-variable">view</span>.<span class="hljs-variable">ViewParent</span>, <span class="hljs-variable">android</span>.<span class="hljs-variable">view</span>.<span class="hljs-variable">View</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>, <span class="hljs-variable">int</span>[])</span></span><br>------&gt;android.view.ViewParent#onNestedScroll<br>-------&gt;android.widget.ScrollView#onNestedScroll<br></code></pre></td></tr></table></figure><p>这样，一个嵌套滑动的流程就完成了。</p><blockquote><p>android.widget.ScrollView#onNestedScroll</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(View target, <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldScrollY = mScrollY;<br>    <span class="hljs-comment">// 这里是让 ScrollView 滚动</span><br>    scrollBy(<span class="hljs-number">0</span>, dyUnconsumed);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> myConsumed = mScrollY - oldScrollY;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> myUnconsumed = dyUnconsumed - myConsumed;<br>    dispatchNestedScroll(<span class="hljs-number">0</span>, myConsumed, <span class="hljs-number">0</span>, myUnconsumed, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后总结一下：</p><p>首先是，事件拦截事件分发事件到 RecycleView，RecycleView先消耗move事件，拉到底部后，RecycleView无法消耗move事件了，然后通过 NestedScrolling 机制，将move距离往上分发到 ScrollView，ScrollView 即可滑动。</p><p>所以，如果我们想要实现一个支持嵌套滑动的控件，现在有两种方式了，一种是实现 NestedScrolling 接口，一种是直接复写 ViewGroup 里面的相关方法。不过这两种方式的接口都是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子线程更新UI的问题</title>
    <link href="/2020/12/21/blog_bak/Blog/Android-View/%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/21/blog_bak/Blog/Android-View/%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章，只能算是一个开头吧，后面准备研究一下，facebook 的那个  <a href="https://engineering.fb.com/android/components-for-android-a-declarative-framework-for-efficient-uis/">Components for Android</a> 里面提到的基于组件的细粒度回收复用机制。因为整体来说，这都属于 RecycleView 的优化，今天介绍的也是其中的一部分，或者说比较通用的一部分。</p><hr><p>了解了之后才发现，与 tangram-view 是一样的思想。但是我想的细粒度应该是复杂卡片拆解那样的，后来发现这应该属于自定义 LayoutManager 的内容，然后我就又想起了 vLayout 这个东西。绕来绕去，原来都是我以前都看过了的……</p></blockquote><p>通常情况下，页面卡顿，都是发生在较为复杂的页面。比如，一个非常大的 xml，它加载起来就会比较耗时，这样，打开该页面的时候，就会造成卡顿。</p><h3 id="异步加载-xml-引起的思考"><a href="#异步加载-xml-引起的思考" class="headerlink" title="异步加载 xml 引起的思考"></a>异步加载 xml 引起的思考</h3><p>一种解决的方式就是使用 <a href="https://developer.android.com/reference/androidx/asynclayoutinflater/view/AsyncLayoutInflater">AsyncLayoutInflater</a> 这个类来做布局的预加载（在子线程中）。</p><p>那么，有趣的问题来了：</p><blockquote><p>我们刚刚入门 Android 时，便知道「只能在主线程更新 UI」的规定。那为啥可以使用子线程来加载布局呢？</p></blockquote><p>要解答这个问题，我们探究一下，为啥说只能在主线程更新UI。其实是因为，我们在子线程更新 UI 的时候，会报一个异常：</p><blockquote><p>android.view.ViewRootImpl#checkThread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mThread != Thread.currentThread()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CalledFromWrongThreadException(<br>                <span class="hljs-string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先不考虑为啥这里它要检查一下，其实也是因为绝大部分 GUI 系统都是只允许「单个线程对某块区域做绘制操作的」，如果允许多个线程对同一块区域做绘制的话，很有可能导致同步问题。除非加锁，然而加锁极有可能导致死锁，性能等问题。</p><p>那么，我们能不能绕过或者是跳过这个检查逻辑呢？我们看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ImageView iv;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        iv = <span class="hljs-keyword">new</span> ImageView(<span class="hljs-keyword">this</span>);<br>        iv.setImageResource(R.drawable.ic_launcher_background);<br>        setContentView(iv);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; iv.setImageResource(R.drawable.ic_launcher_foreground)).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当我们，打开这个页面的时候，程序并不会出问题，完美运行。这是为什么呢？</p><p>这是因为我们的Thread执行的时候，ViewRootImpl还没有对view tree的根节点DecorView执行performTraversals，view tree里的所有View都没有被赋值mAttachInfo。</p><p>在onCreate完成时，Activity并没有完成初始化view tree。view tree的初始化是从ViewRootImpl执行performTraversals开始，这个过程会对view tree进行从根节点DecorView开始的遍历，对所有视图完成初始化，初始化包括视图的大小布局，以及AttachInfo，ViewParent等域的初始化。</p><p>执行ImageView.setImageResource，调用的过程是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ImageView.setImageResource <br>-&gt; View.invalidate <br>-&gt; View.invalidateInternal <br>-&gt; ViewGroup.invalidateChild<br>-&gt; ViewParent.invalidateChildInParent <span class="hljs-comment">//这里会不断Loop去取上一个结点的mParent</span><br>-&gt; ViewRootImpl.invalidateChildInParent <span class="hljs-comment">//DecorView的mParent是ViewRootImpl</span><br>-&gt; ViewRootImpl.checkThread <span class="hljs-comment">//在这里执行checkThread，如果非UI线程则抛出异常</span><br></code></pre></td></tr></table></figure><p>但是在Thread执行setImageResource时，此时Activity还在初始化，ViewRoot没有初始化整个view tree，ImageView的mAttachInfo是空的（mAttachInfo包含了Window的token等Binder）。而View.invalidateInternal调用ViewGroup.invalidateChild要判断是否存在ViewParent和AttachInfo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> AttachInfo ai = mAttachInfo;<br><span class="hljs-keyword">final</span> ViewParent p = mParent;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; ai != <span class="hljs-keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;<br>    <span class="hljs-comment">//....</span><br>    p.invalidateChild(<span class="hljs-keyword">this</span>, damage);<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，<strong>此时因为不存在ViewParent，invalidate的过程中止而没有完全执行，也即没有发生checkThread。</strong></p><p>所以说，在 View tree 初始化完成之前，我们可以在子线程里面做很多事，比如去加载布局。</p><p>说的更加直白一点，checkThread 是 ViewRootImpl 做的，到了它这里，布局早就已经被加载出来了，也就是说，它<strong>管不到布局是哪个线程加载出来</strong>的。</p><p>这个问题，我们搞定了，那么就再深入一点，我们看 checkThread 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里是不是有点奇怪</span><br>    <span class="hljs-keyword">if</span> (mThread != Thread.currentThread()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CalledFromWrongThreadException(<br>                <span class="hljs-string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看上面的 if 判断条件，它判断的居然不是主线程，而是当前线程，这说明了什么呢？这是不是意味着，如果我在子线程里面去创建布局，那么是不是就可以在子线程里面去更新布局了呢？</p><h3 id="子线程更新UI-Dialog"><a href="#子线程更新UI-Dialog" class="headerlink" title="子线程更新UI - Dialog"></a>子线程更新UI - Dialog</h3><p>试试吧！！！</p><p>我们先找到 ViewRootImpl 创建的位置：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">-&gt;android.app.ActivityThread#handleResumeActivity<br>--&gt;android.view.WindowManagerGlobal#addView<br></code></pre></td></tr></table></figure><p>在 addView 里面创建了 ViewRootImpl 对象，由于，handleResumeActivity 是工作在主线程，所以，addView 也是在主线程，那就暂时放弃测试 activity。</p><p>我们看看 dialog，它的 window 的 addView 方法是在 show 里面调用的，所以，我们可以拿它来测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> HandlerThread handlerThread = <span class="hljs-keyword">new</span> HandlerThread(<span class="hljs-string">&quot;ht&quot;</span>);<br>    <span class="hljs-keyword">private</span> Handler handler;<br>    <span class="hljs-keyword">private</span> EditText editText;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        handlerThread.start();<br>        handler = <span class="hljs-keyword">new</span> Handler(handlerThread.getLooper());<br><br>        <span class="hljs-comment">// 子线程去展示一个弹窗</span><br>        handler.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                Log.i(<span class="hljs-string">&quot;Thread&quot;</span>, Thread.currentThread().getName());<br>                AlertDialog.Builder customizeDialog =<br>                        <span class="hljs-keyword">new</span> AlertDialog.Builder(MainActivity.<span class="hljs-keyword">this</span>);<br>                <span class="hljs-keyword">final</span> View dialogView = LayoutInflater.from(MainActivity.<span class="hljs-keyword">this</span>)<br>                        .inflate(R.layout.dialog_customize, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-comment">// 获取EditView中的输入内容</span><br>                editText = (EditText) dialogView.findViewById(R.id.edit_text);<br>                customizeDialog.setTitle(<span class="hljs-string">&quot;我是一个自定义Dialog&quot;</span>);<br>                customizeDialog.setView(dialogView);<br>                customizeDialog.setPositiveButton(<span class="hljs-string">&quot;确定&quot;</span>,<br>                        <span class="hljs-keyword">new</span> DialogInterface.OnClickListener() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-keyword">int</span> which)</span> </span>&#123;<br>                                Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>,<br>                                        editText.getText().toString(),<br>                                        Toast.LENGTH_SHORT).show();<br>                            &#125;<br>                        &#125;);<br>                customizeDialog.show();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 在子线程里面去更新弹窗里面的内容</span><br>        handler.postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                Log.i(<span class="hljs-string">&quot;Thread&quot;</span>, Thread.currentThread().getName());<br>                editText.setText(<span class="hljs-string">&quot;hello from handler thread: &quot;</span> + SystemClock.currentThreadTimeMillis());<br>            &#125;<br>        &#125;, <span class="hljs-number">3000</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，完美运行！！！</p><h3 id="子线程更新UI-Activity"><a href="#子线程更新UI-Activity" class="headerlink" title="子线程更新UI - Activity"></a>子线程更新UI - Activity</h3><p>想要在子线程更新 UI，那么就需要搞定里面的 checkThread 这个方法。最粗暴的方式，就是使用反射替换掉里面的 mThread 值。</p><p>首先，需要找到界面对应的 ViewRootImpl，经过一番寻找之后，我是这样做的：</p><p>View 有个 getViewRootImpl 方法，但是该方法需要 mAttachInfo 这个值不为 null。那么什么时候这个值不为 null 呢？view attach 到 window上的时候。那么我们的思路就出来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hookViewRootImpl</span><span class="hljs-params">()</span> </span>&#123;<br>    getWindow().getDecorView().addOnAttachStateChangeListener(<span class="hljs-keyword">new</span> View.OnAttachStateChangeListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Method getViewRootImplMethod = v.getClass().getMethod(<span class="hljs-string">&quot;getViewRootImpl&quot;</span>);<br>                Object viewRootImplObject = getViewRootImplMethod.invoke(v);<br>                Class&lt;?&gt; viewRootImplClass = viewRootImplObject.getClass();<br>                Field thread = viewRootImplClass.getDeclaredField(<span class="hljs-string">&quot;mThread&quot;</span>);<br>                thread.setAccessible(<span class="hljs-keyword">true</span>);<br>                thread.set(viewRootImplObject, handlerThread);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们在 view 添加到 window 上的时候，将 ViewRootImpl 里面的 mThread 字段设置为子线程。</p><p>这样，我们就可以在子线程里面更新UI了。为了防止出啥意外，写一个 UiDispatcher，自动切换 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiDispatcher</span> </span>&#123;<br><br>    Handler target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UiDispatcher</span><span class="hljs-params">(<span class="hljs-keyword">final</span> View root, Handler main, <span class="hljs-keyword">final</span> Handler child)</span> </span>&#123;<br>        target = main;<br>        root.addOnAttachStateChangeListener(<span class="hljs-keyword">new</span> View.OnAttachStateChangeListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                root.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>);<br>                target = child;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(View v)</span> </span>&#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;<br>        target.post(runnable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们使用这个类，来更新UI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">md5.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        uiDispatcher.post(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                text.setText(<span class="hljs-string">&quot;msg from &quot;</span> + Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>正常运行！！！当然这个例子只是说明了，可以在子线程来更新UI，而且条件很苛刻。</p><p>需要注意的是：由于其他原因导致的界面更新依然是在主线程，所以很容易导致异常。替换了线程只是让我们可以在子线程更新View，但是View的绘制等操作还是在主线程中。</p><p>所以，最终测试的结果是：子线程也可以更新UI，但是还是有很多限制，比如 activity 就比较麻烦，因为 activityThread 已经限制了创建 ViewRootImpl 的线程在主线程。</p><p>总的来说，只有主线程可以更新UI这句话<strong>大体上还是对的</strong>，但是有两种例外：</p><ul><li>在 View tree 还没有创建出来的时候，是可以在子线程更新的，比如 setText 等操作，这是因为，ViewRootImpl 还没有创建出来，自然也就不会报错。而且它子所以可以更新成功，也是由于 setText 方法储存了 set 的值。</li><li>在子线程X里面创建了 ViewRootImpl ，自然可以在子线程X里面更新UI。</li></ul>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用虚拟器启动本地磁盘里面的系统</title>
    <link href="/2020/12/15/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%99%A8%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/12/15/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%99%A8%E5%90%AF%E5%8A%A8%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>我有一个移动硬盘，里面装了一个 centos 系统。</p><p>但是现在遇到一个麻烦事，就是有时候并不想重启电脑来切换系统。于是就想有没有一种办法，可以运行两个系统。</p><p>最先想到的是虚拟机，但是在虚拟机里面再装一个系统并不是我想要的，因为我硬盘里面有不少资料，copy过来很麻烦，而且搞一个虚拟磁盘，也不太通用。</p><p>所以，就想着有没有什么办法可以使用虚拟机直接启动这个移动硬盘里面的 centos 系统，这样的话，它即可以直接插USB启动，又可以从虚拟器启动，非常完美。</p><p>经过半天的折腾，成功了，记录一下过程以及遇到的问题。</p><h3 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h3><p>查看移动硬盘的序号：</p><p>在 计算机管理-&gt;储存-&gt;磁盘管理 中查看到移动硬盘为 <strong>磁盘3</strong>，3 是序号，需要记下来。</p><p>使用下面的命令来创建虚拟磁盘：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&quot;C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\O</span>racle<span class="hljs-symbol">\V</span>irtualBox<span class="hljs-symbol">\V</span>BoxManage.exe&quot; internalcommands createrawvmdk -filename G:<span class="hljs-symbol">\v</span>irtualbox<span class="hljs-symbol">\c</span>entos.vmdk -rawdisk <span class="hljs-symbol">\\</span>.<span class="hljs-symbol">\P</span>HYSICALDRIVE3<br></code></pre></td></tr></table></figure><p>-filename 后面是创建出来的虚拟磁盘的位置（路径需要存在，该命令无法创建文件夹，否则会出错），这里填自己的</p><p>-rawdisk 后面跟的是本地磁盘，3 就是磁盘序号，这里填自己的</p><p><strong>该命令需要以管理员方式运行，否则会出错。</strong> 正常输出：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">RAW host disk <span class="hljs-keyword">access</span> VMDK <span class="hljs-keyword">file</span> xxx.vmdk created successf..<br></code></pre></td></tr></table></figure><h3 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h3><p>这个按照正常操作创建就好了，只不过不要创建虚拟磁盘就行。</p><h3 id="添加虚拟磁盘"><a href="#添加虚拟磁盘" class="headerlink" title="添加虚拟磁盘"></a>添加虚拟磁盘</h3><p>打开上面创建的虚拟机的设置。</p><p>首先看<strong>系统</strong>设置，如果你的硬盘是 UEFI 分区，记得勾选这个选项，否则无法启动系统。</p><p>再看<strong>储存</strong>设置，添加磁盘</p><p><img src="https://i.stack.imgur.com/EW237.png"></p><p><strong>如果添加出错，记得以管理员身份重新启动 VirtualBox。</strong></p><h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><p>如果你启动，遇到了如下错误：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Press</span> <span class="hljs-variable">ESC</span> <span class="hljs-built_in">In</span> <span class="hljs-number">1</span> <span class="hljs-variable">Seconds</span> <span class="hljs-variable">To</span> <span class="hljs-built_in">Skip</span> <span class="hljs-variable">Startup</span><span class="hljs-operator">.</span><span class="hljs-variable">nsh</span> <span class="hljs-built_in">Or</span> <span class="hljs-variable">Any</span> <span class="hljs-variable">Other</span> <span class="hljs-built_in">Key</span> <span class="hljs-variable">To</span> <span class="hljs-built_in">Continue</span><br></code></pre></td></tr></table></figure><p>可以尝试两种方案。</p><p>第一种是网上的，就是在 shell 里面直接打开 grubx64.efi 这个文件，就可以看到启动画面了。但是对我不管用。具体过程如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">输入 fs0: 进入目录fs0<br>使用 <span class="hljs-keyword">ls</span> 命令列出文件目录<br>看到 EFI 目录，然后进入这个目录<br>使用 <span class="hljs-keyword">ls</span> 命令列出文件目录<br>看到 centos 这个目录，然后进入这个目录<br>使用 <span class="hljs-keyword">ls</span> 命令列出文件目录<br>看到了 grubx64.efi 文件，然后输入 grubx64.efi 即可<br><br>这是一种临时方案，一个永久方案就是编辑 startup.nsh 文件，将上面的步骤写进去，网上有相关文章<br></code></pre></td></tr></table></figure><p>第二种，就是升级 virtualBox 到最新版，升级完之后，重新开始走一遍流程，就可以了，我的是这样解决的。</p><h3 id="安装增强功能"><a href="#安装增强功能" class="headerlink" title="安装增强功能"></a>安装增强功能</h3><p>这个直接在虚拟机的 设备 选项里面点击一下就好了，但是我遇到了错误，查看输出日志之后，发现是缺少了依赖，运行如下命令即可：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> elfutils-libelf-devel<br></code></pre></td></tr></table></figure><p>然后重启虚拟机即可。</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建</title>
    <link href="/2020/12/15/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/12/15/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>主体仍然使用的是 Github pages + hexo。</p><p>现在我采用的主题是 Fluid。</p><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="1-安装-hexo"><a href="#1-安装-hexo" class="headerlink" title="1. 安装 hexo"></a>1. 安装 hexo</h4><p>按照<a href="https://hexo.io/zh-cn/docs/">文档</a>安装即可。</p><h4 id="2-安装主题"><a href="#2-安装主题" class="headerlink" title="2. 安装主题"></a>2. 安装主题</h4><p>参照 github 上的 <a href="https://github.com/fluid-dev/hexo-theme-fluid">readme</a> 步骤即可。</p><h4 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h4><p>参照 <a href="https://hexo.fluid-dev.com/docs/guide/">主题文档即可</a>。</p><h4 id="4-绑定域名"><a href="#4-绑定域名" class="headerlink" title="4. 绑定域名"></a>4. 绑定域名</h4><p>网上很多，搜索一下就好。</p>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fat-aar的踩坑之旅</title>
    <link href="/2020/12/08/blog_bak/Blog/Android/fat-aar%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/"/>
    <url>/2020/12/08/blog_bak/Blog/Android/fat-aar%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>因为某些原因（比如来自业务的不可抗力），要求将所有模块打包成一个sdk提供给别人使用，所以才有了这篇文章。虽然在实践的过程中学到了很多东西，但是我还是想吐槽一下这个需求。</p><p>我们使用的是 <a href="https://github.com/kezong/fat-aar-android">fat-aar-android</a> 这个开源插件。</p><p>在集成的过程中遇到了很多小问题，暂且不聊，说一些比较蛋疼的问题。</p><p>###主题问题</p><p>第一个是 activity 的主题问题，因为 activity 使用的是 application 的主题，现在打成 sdk 了，肯定不能让别人使用我们的 application。所以需要解决 activity 的主题设置问题。</p><p>给每个 activity 加上 theme，这是我们的目标。但是肯定不能手动加，几百个 activity，加上去就太累了，想到的方案是处理合并之后的 manifest 文件，这样可以利用 gradle 脚本来完成，具体如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs groovy">    <span class="hljs-comment">// 处理合并之后的 manifest 文件，给没有设置主题的 activity 加上主题</span><br>    project.afterEvaluate &#123;<br>        libraryVariants.all &#123; variant -&gt;<br>            String variantName = variant.name.capitalize()<br>            <span class="hljs-keyword">def</span> processManifestTask = project.tasks.getByName(<span class="hljs-string">&quot;process$&#123;variantName&#125;Manifest&quot;</span>)<br>            processManifestTask.doLast &#123; pmt -&gt;<br>                println(<span class="hljs-string">&quot;&gt;&gt;&gt; &quot;</span> + <span class="hljs-string">&quot;处理合并之后的 manifest 文件&quot;</span> + <span class="hljs-string">&quot; &lt;&lt;&lt;&quot;</span>)<br><span class="hljs-comment">//                String manifestPath = &quot;$pmt.manifestOutputDirectory/AndroidManifest.xml&quot;</span><br>                String manifestPath = <span class="hljs-string">&quot;$&#123;project.buildDir.path&#125;/intermediates/library_manifest/$&#123;variant.name&#125;/AndroidManifest.xml&quot;</span><br><br>                <span class="hljs-keyword">def</span> manifestFile = file(manifestPath)<br>                <span class="hljs-comment">// 忽略命名空间，否则语法比较蛋疼</span><br>                <span class="hljs-keyword">def</span> xml = <span class="hljs-keyword">new</span> XmlSlurper(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br>                        .parse(manifestFile)<br><br>                xml.<span class="hljs-string">&#x27;application&#x27;</span>.<span class="hljs-string">&#x27;activity&#x27;</span>.each &#123; activity -&gt;<br>                    <span class="hljs-keyword">def</span> themeExist = activity[<span class="hljs-string">&#x27;@android:theme&#x27;</span>].toString()<br>                    <span class="hljs-keyword">if</span> (!themeExist) &#123;<br>                        println(<span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span> + <span class="hljs-string">&quot;为$&#123;activity[&#x27;@android:name&#x27;]&#125;添加XXXTheme&quot;</span> + <span class="hljs-string">&quot;&lt;&lt;&lt;&quot;</span>)<br>                        activity[<span class="hljs-string">&#x27;@android:theme&#x27;</span>] = <span class="hljs-string">&#x27;@style/XXXTheme&#x27;</span><br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">def</span> outputBuilder = <span class="hljs-keyword">new</span> StreamingMarkupBuilder()<br>                String updatedXml = outputBuilder.bind &#123; mkp.yield xml &#125;<br>                file(manifestPath).write(updatedXml)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>其实，就是在 processXXXManifest 这个任务后面加上自己的一段逻辑。</p><p>不过，这里有个问题需要注意，因为 library 不像 app，它不会将依赖工程的 manifest 给合进来，所以 fat-aar 自己创建了一个 “task”（不算一个真正的task） 来做这件事，所以你需要先弄清楚 task 之间的先后顺序，再来看在这里处理 manifest 是否合适。</p><p>看它的代码，它创建的 合并task 也是在 processXXXManifest 之后，在我们的逻辑之前执行，所以没有问题。</p><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3><p>第二个问题是，R 文件导致的问题。</p><p>我们知道，aar 里面是不能有 R.java 这个东西的，因为 R.java 如果存在的话，它的字段值就被固定了，这样，app 集成 aar 的时候，就很容易导致字段值的冲突问题。所以，aar 里面是采用 R.txt 这个文件来代替 R.java，app集成的时候，会有task根据这个问题，重新计算所有资源的id，为每个module生成 R.java 文件。</p><p>那么，问题就来了，当我们将多个 aar 合并成一个的时候，app集成时，只会生成一个R.java 文件，就是主工程的。主工程的依赖工程就会报错，因为它写代码的时候，用的是自己的 R 文件，但是 app 集成的时候，却没有生成对应的 R 文件。</p><p>fat aar 提供的解决方案是这样的，它创建了一个 task，生成了依赖工程的 R 文件。但是 R 文件里面的值是无法确定的（它的值应该是 app 集成时确定），所以，fat-aar 是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">R</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-comment">// 将依赖工程的 R 字段，指向主工程对应的字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> res1 = com.main.library.R.string.res1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主工程的R.txt 合并所有依赖工程的 R.txt，这样就解决了R文件的问题。</p><p>但是，实际上，我们在集成的时候，遇到了这样的问题：</p><p><code>NoSuchFieldError</code></p><p>这是因为，假如模块使用的A版本的Support库中有资源文件res1，而接入方App使用了更高版本的Support库中没有res1这个资源，那么App构建生成的R文件中将没有res1这个资源索引，可是我们打入AAR中的R文件还保留着对res1的符号引用，结果就是在运行时类初始化失败。</p><p>那么，应该如何处理呢？</p><p>一种解决方案是：</p><p>将这种“桥接”的方式改成使用字节码修改的方式！<br>比如，某个依赖中是这样使用R 的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> com.lib.R.layout;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>        <span class="hljs-keyword">static</span> &#123;<br>            sKeys.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;layout/slbase_activity_camera_web_0&quot;</span>, layout.slbase_activity_camera_web);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过 transform 后，会变成下面的样子：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 这里包名变了</span><br><span class="hljs-keyword">import</span> com.aar.R.layout;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>        <span class="hljs-keyword">static</span> &#123;<br>            sKeys.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;layout/slbase_activity_camera_web_0&quot;</span>, layout.slbase_activity_camera_web);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是使用 transform 将所有依赖的 R 文件的包名改成 aar 的R包名。这样可以避免字段失效问题，就不用为每个依赖生成 R 文件，以及打对应的 jar 包了。</p><p>这个已经向 fat-aar-andorid 提了一个 pr。</p><p>还有一种更为简单的方式，就是将 gradle plugin 升级到 3.6.4（往上应该也可以）。这又是为啥呢?</p><p>在App的构建流程中，会根据最终的Support库版本（App依赖的Support库版本不可知）对各个R.txt里的内容做过滤，只保留App工程中确实存在的资源文件，生成最终的R文件。所以我们才遇到了上面的字段问题，那么如果打 aar 的时候也进行过滤呢？不就没有问题了吗！</p><p>事实上，在 3.6.4 里面，在打 aar 的时候，生成的 R.java 文件，确实进行了过滤。下面贴一段 fat-aar的代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">File getLocalSymbolFile() &#123;<br>    <span class="hljs-comment">// &gt; 3.6.0, R.txt contains remote resources, so we use R-def.txt</span><br>    <span class="hljs-keyword">if</span> (Utils.compareVersion(mGradlePluginVersion, <span class="hljs-string">&quot;3.6.0&quot;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> mProject.file(mProject.buildDir.path + <span class="hljs-string">&#x27;/intermediates/local_only_symbol_list/&#x27;</span> + mVariant.name + <span class="hljs-string">&quot;/R-def.txt&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Utils.compareVersion(mGradlePluginVersion, <span class="hljs-string">&quot;3.1.0&quot;</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> mProject.file(mProject.buildDir.path + <span class="hljs-string">&#x27;/intermediates/symbols/&#x27;</span> + mVariant.dirName + <span class="hljs-string">&quot;/R.txt&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> mProject.file(mProject.buildDir.path + <span class="hljs-string">&#x27;/intermediates/bundles/&#x27;</span> + mVariant.name + <span class="hljs-string">&quot;/R.txt&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里面过滤了远程依赖的资源(使用R-def.txt文件)，只保留了本地的资源。</p><h3 id="databinding问题"><a href="#databinding问题" class="headerlink" title="databinding问题"></a>databinding问题</h3><p>最后还有一个问题需要说一下，就是  databinding 是在 gradle 里面的，版本升级之后，databinding 生成的类的签名有些发生了改变，若你你的sdk采用的是 3.4.1 编译的，那么在 3.2.1 工程里面是无法使用的。请看：<a href="https://stackoverflow.com/questions/54221707/databinding-nosuchmethoderror-with-buildtools-3-4-0">https://stackoverflow.com/questions/54221707/databinding-nosuchmethoderror-with-buildtools-3-4-0</a></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分查找法中的坑</title>
    <link href="/2020/09/25/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
    <url>/2020/09/25/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>一个笑话：</p><p>有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。</p><p>从此，图书馆丢了 N - 1 本书。</p><p>二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：<strong>思路很简单，细节是魔鬼</strong>。</p><p>它的框架很简单，但是在细节的处理上，写起来总让人有点玄学编程的感觉。到底这里我应不应该加上等号，这里应不应该加一，这里要不要减一。</p><p>看下面的这个框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看第一个需要注意的地方：</p><p>这里我们搜索的区间是从 0 ~ length-1，它意味者区间值为 [left, right]。因为 nums.length - 1是有效索引，所以 while 的的判断条件是 left &lt;= right。我们从区间的角度理解一下，就是 [left, right]，此时 left == right，即 [right, right]，又因为区间里面的值都是有效的，所以 right 是存在的，即判断条件必须要带等号。</p><p>如果写成 right = nums.length 会发生什么？？？ [left, right) ，条件可以写成 left &lt; right。</p><p>再看下面两个需要注意的地方：</p><p>其实只要理解了上面的区间，这里就好理解了，因为区间是包含 left 与 right 的，所以表示 left 与 right 已经查找过了，折半的时候就 +/- 1 即可。</p><p>如果是半区间的话，就不能 +/- 1了。这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p><p>另外，还有一个坑：</p><p>计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p><p>还有一个拓展题目：<strong>寻找左侧边界的二分搜索</strong></p><p>同样的有多种写法，我们先看这种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length; <span class="hljs-comment">// 注意</span><br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，</span><br>            <span class="hljs-comment">// 在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</span><br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid; <span class="hljs-comment">// 注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码并不难，我觉得比较蛋疼的地方在于最后的返回值，为啥是 left 呢？能不能写 right？</p><p>其实都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p><p>再看另一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查出界情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就比上面的写法麻烦多了，是由于两个地方。</p><p>第一个：</p><p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6865c24b1317f1f65f02348fe622c829c71219c1.jpg?alt=media" alt="img"></p><p>所以，最后要检查边界！</p><p>第二个是这里可以返回 right 吗？</p><p>不可以，因为 right 是不可能指向要找的数字的（指向了会收缩右侧边界），所以只能是 left 指向。</p>]]></content>
    
    
    <categories>
      
      <category>算法思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于凑硬币问题的思考</title>
    <link href="/2020/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2020/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>关于 dp 的套路，<a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie#er-cou-ling-qian-wen-ti">这篇文章</a>已经写的非常清楚了，这里知识补充一下自己对里面 for 循环的一个理解。</p><p>给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">// coins 中是可选硬币面值，amount 是目标金额<br><span class="hljs-built_in">int</span> coinChange(<span class="hljs-built_in">int</span>[] coins, <span class="hljs-built_in">int</span> amount);<br></code></pre></td></tr></table></figure><p>我们先假设有你有一个超级电脑，它告诉你了一个函数 f，可以解决这个问题，那么就是 y = f(x)。y 是硬币的数量，x 是金额。</p><p>那么，我们推理一下，f(17) 与 f(10) + f(7)，它们有啥关系呢？</p><p>首先，f(17) 表示的是当金额为 17 的时候，硬币最少的数。 f(10) + f(7) 也是表示金额为 17，但是它的值是硬币最少的数量吗？可能是，也可能不是，但是我们可以肯定的是 f(17) &lt;= f(10) + f(7) .不然的话，f(17) 的意义的不存在了。</p><p>那么，我们再进一步，如何才能求出 f(17) 的值呢？显然可以使用遍历：</p><p>计算出 f(1) + 1，f(2) +1， … … ，f(15) + 1, f(16) + 1，f(17) 就是当中值最小的那个，为啥是 + 1呢，因为最好的情况就是，只需要加一个硬币，就刚好凑成金额是 17，如果都没有，那就是无解了。</p><p>当然这里我们是使用了整数，而题目中提供的是 c1, c2，我们转换一下：</p><p>f(c1) +1, f(c2) + 1…</p><p>这样的逻辑，用代码表示就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br><span class="hljs-built_in">min</span> = Math.<span class="hljs-built_in">min</span>(f(coin) + <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>);<br></code></pre></td></tr></table></figure><p>就是将所有组合遍历一下，记录最小值。</p><p>我们再看看正规的代码逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">coins: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], amount: <span class="hljs-built_in">int</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dp</span>(<span class="hljs-params">n</span>):</span><br>        <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-comment"># 求最小值，所以初始化为正无穷</span><br>        res = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>)<br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            subproblem = dp(n - coin)<br>            <span class="hljs-comment"># 子问题无解，跳过</span><br>            <span class="hljs-keyword">if</span> subproblem == -<span class="hljs-number">1</span>: <span class="hljs-keyword">continue</span><br>            res = <span class="hljs-built_in">min</span>(res, <span class="hljs-number">1</span> + subproblem)<br><br>        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">if</span> res != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;INF&#x27;</span>) <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> dp(amount)<br></code></pre></td></tr></table></figure><p>可以看到，它也是将大问题简化为小问题，里面也是有一个遍历，它的作用就是用来求出当前问题的最优解。这样不断的递归下去，就可能将问题化为基本问题，啥是基本问题，dp[0] = 0 , 就是基本问题，也就是我们所说的递归终止条件。</p><p>与上面的数学表达式不同的是，这里我们遍历的时候，因为不能按照自然数遍历，所以就采用了 n-coin 这种遍历方式。但是道理是一样的。</p><p>比如，我们的金额是 5，硬币有两种，1块与5块的，所以 dp[5] 最终为 dp[0] + 1。</p><p>当然，这个代码还是可以优化的，因为子问题有好多都重复了，借图一用：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F11389aca27fca8bf28578565fcd46e2c4b051e91.jpg?alt=media" alt="img"></p><p>所以，可以使用缓存将子问题的结果缓存起来。</p>]]></content>
    
    
    <categories>
      
      <category>算法思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向实战</title>
    <link href="/2020/09/16/blog_bak/Blog/%E9%80%86%E5%90%91/%E5%AE%9E%E6%88%98/"/>
    <url>/2020/09/16/blog_bak/Blog/%E9%80%86%E5%90%91/%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>因为我在Github上单独开了一个仓库，用来搞这个，所以这里就放一个链接好了。</p><p><a href="https://github.com/aprz512/Android-Crack">https://github.com/aprz512/Android-Crack</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fish-redux使用说明</title>
    <link href="/2020/09/11/blog_bak/Blog/flutter/fish_redux%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/09/11/blog_bak/Blog/flutter/fish_redux%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>一个页面大致可以分为这几个部分：</p><ul><li>控件</li><li>数据</li><li>交互逻辑</li></ul><p>fish-redux 针对这3个部分，抽象出了如下几个文件：</p><h3 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h3><p>view.dart    这个对应的页面上的控件，如同Android的layout.xml文件</p><p>还有一个 page.dart，这个就更简单了，它是一个脚手架，就是啥事也不干，只是把各个文件里面的函数组装起来。</p><h3 id="交互逻辑"><a href="#交互逻辑" class="headerlink" title="交互逻辑"></a>交互逻辑</h3><p>effect.dart 与 reducer.dart    这两个文件，对应的就是交互逻辑。</p><p>还有一个 action.dart ，描述的是每个交互的别称，就是给每个交互动作起个名字，好区分。</p><p>那交互逻辑为啥要分为两个文件呢？</p><p>这就涉及到数据的管理了。fish-redux是这样管理页面中的数据的。它认为页面中的数据始终是一个快照数据，每当数据变化的时候，就会生成一个新的数据对象出来。我们在进行多线程编程的时候，应该接触过这样的东西。</p><p>我们想一下 Flutter 的工作方式：在 Flutter 中，Widget 上展示的数据如果需要更新，那么就必须要调用 setState，将该 Widget 标记为 dirty。然后 widget 重新构建，构建的时候使用变化之后的数据。</p><p>那么有趣的地方就来了，为啥 fish-redux 一定要重新生成一份数据呢？其实这只是一种设计方式，当然也可以不用每次更新 state，每次更新 state，是因为里面的内部逻辑是判断前后两个 state 是否一样来决定是否更新 view 的。它也提供了自定义的更新逻辑：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> ShouldUpdate&lt;T&gt; = <span class="hljs-built_in">bool</span> <span class="hljs-built_in">Function</span>(T old, T now);<br></code></pre></td></tr></table></figure><p>比如，你可以使用 T 里面的属性来决定是否更新，但是这样属性很多的话，页面更新逻辑就非常的麻烦了。</p><p>好的，数据管理说了这么多，回到 effect.dart 与 reducer.dart 这两个文件上，根据上面的知识，要更新页面，就得创建出新的数据出来（默认逻辑）。那么，在哪里创建新的数据呢？答案是 reducer.dart 里面。而 effect.dart 是用来处理除了数据改变的其他逻辑的。</p><p>举个例子：</p><p>一个feed流页面，下拉刷新后，去请求网络，数据拿到后，需要更新页面。</p><p>根据fish-redux的分类，effect.dart 需要处理网络请求，reducer.dart 需要处理更新页面。</p><p>所以，大致逻辑如下：</p><blockquote><p>effect.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _init(Action action, Context&lt;ListState&gt; ctx) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> datas = <span class="hljs-keyword">await</span> fetchData();<br>  <span class="hljs-comment">// 拿到网络数据后，发送给 reducer.dart</span><br>  ctx.dispatch(ActionCreator.onFetchDataSuccessAction(datas));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>reducer.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">ListState _onFetchDataSuccess(ListState state, Action action) &#123;<br>  <span class="hljs-comment">// 这里clone了一份原来的数据，然后更改其属性，最后这个属性会传递到 view.dart 里面作为参数</span><br>  <span class="hljs-keyword">return</span> state.clone()..items = action.payload;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面出现了 action，我们说过，action 是交互动作的名字，它也可以携带参数。</p><p>effect.dart 拿到网络数据后，我们就可以更新页面了，但是不能直接更新，因为框架限制了我们需要改变数据，才能更新，而 effect 里面是访问不到数据的，想要改变数据，就需要到 reducer.dart  里面去，所以我们就发送了一个 action，而reducer.dart里面可以接受这个 action，从而做对应的处理。</p><p>effect 与  reducer 其实就是两个 map，key 是 action，value 就是收到 action 后应该如何处理。</p><blockquote><p>effect.dart</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Effect</span>&lt;<span class="hljs-type">ListState</span>&gt; buildEffect() &#123;<br>  <span class="hljs-keyword">return</span> combineEffects(<span class="hljs-operator">&lt;</span><span class="hljs-type">Object</span>, <span class="hljs-type">Effect</span>&lt;<span class="hljs-type">ListState</span>&gt;<span class="hljs-operator">&gt;</span>&#123;<br>    <span class="hljs-comment">///进入页面就执行的初始化操作</span><br>    <span class="hljs-type">Lifecycle</span>.initState: _init,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>combineEffects 是框架提供的方法，它的作用是从 map 里面取出对应 action 的 effect 方法。</p><blockquote><p>reducer.dart</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Reducer&lt;ListState&gt; buildReducer() &#123;<br>  <span class="hljs-keyword">return</span> asReducer(<br>    &lt;<span class="hljs-built_in">Object</span>, Reducer&lt;ListState&gt;&gt;&#123;<br>      FourthAction.fetchDataSuccess: _onFetchDataSuccess<br>    &#125;,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>asReducer 的作用与上面的 combineEffects  是一样的。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>state.dart 这里里面存放的是页面所有的数据。需要实现 Cloneable，因为方便创建新的数据对象。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Widget buildView(ListState state, Dispatch dispatch, ViewService viewService) &#123;&#125;<br></code></pre></td></tr></table></figure><p>当我们在 view 里面，调用 dispatch(action) 的时候，我们看看整个流程是什么样的。其实这里最好的自己打个断点，流程就很清楚了。</p><p>还有一个知识点需要注意，dispatch 是一个函数，这个框架里面很多地方都是传递的函数，如果不习惯函数编程的，会很绕。</p><p>dispatch 是 helper 类创建的。</p><blockquote><p>lib/src/redux_component/helper.dart:100</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Dispatch createDispatch&lt;T&gt;(Dispatch onEffect, Dispatch next, Context&lt;T&gt; ctx) =&gt; (Action action) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> result = onEffect?.call(action);<br>      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> || result == <span class="hljs-keyword">false</span>) &#123;<br>        next(action);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> result == _SUB_EFFECT_RETURN_NULL ? <span class="hljs-keyword">null</span> : result;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>从这里可以看到，这里先让 effect 处理了 action，如果没有设置effect，或者 effect 方法返回了 false，那么才执行 next 函数。也就是说，如果你的 action 想两个都走的话，就让 effect 返回 false 就好了。</p><p>官方文档也说了：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">当前<span class="hljs-keyword">effect</span>返回 true 的时候，就会停止后续的<span class="hljs-keyword">effect</span>和reducer的操作<br><br>当前<span class="hljs-keyword">effect</span>返回 false 的时候，后续<span class="hljs-keyword">effect</span>和reducer继续执行<br></code></pre></td></tr></table></figure><p>我们继续看看 next ：</p><blockquote><p>lib/src/redux_component/helper.dart:94</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">Dispatch createNextDispatch&lt;T&gt;(ContextSys&lt;T&gt; ctx) =&gt; (Action action) &#123;<br>      ctx.broadcastEffect(action);<br>      ctx.store.dispatch(action);<br>    &#125;;<br></code></pre></td></tr></table></figure><p>这里是兵分两路。bus先不管，看store。调用了 store 的 dispatch 方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">return</span> Store&lt;T&gt;()<br> ..getState = (() =&gt; _state)<br> ..dispatch = (Action action) &#123;<br>   ...<br><br>   <span class="hljs-keyword">try</span> &#123;<br>     _isDispatching = <span class="hljs-keyword">true</span>;<br>     _state = _reducer(_state, action);<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     _isDispatching = <span class="hljs-keyword">false</span>;<br>   &#125;<br><br>   ...<br> &#125;<br></code></pre></td></tr></table></figure><p>可以看到，它调用了 reducer 。</p><p>所以，流程图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xODgyMDg5MC0yMmJiNGRkZmMzNWJlMzM4?x-oss-process=image/format,png" alt="img"></p><p>需要注意的是，我们在 effect，reducer 里面 dispatch 的 action，也会重新走整个派发流程，所以不要发送自己可以接受的 action，<strong>避免造成死循环</strong>。</p><p>我们继续往后面跟踪代码，会发现调用到了：</p><blockquote><p>lib/src/redux_component/context.dart:236</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> onNotify() &#123;<br>  <span class="hljs-keyword">final</span> T now = state;<br>  <span class="hljs-keyword">if</span> (shouldUpdate(_latestState, now)) &#123;<br>    _widgetCache = <span class="hljs-keyword">null</span>;<br><br>    markNeedsBuild();<br><br>    _latestState = now;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 widget 标记为 dirty 的。我们在 view 里面创建的 widget 最终也会添加到一个内部的 widget 上。当这个内部的 widget 更新的时候，它会重新build，然后就会调用到 view 里面的 buildView 方法了。</p><blockquote><p>lib/src/redux_component/context.dart:216</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget buildWidget() &#123;<br>  Widget result = _widgetCache;<br>  <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 这里就是调用了 view 的  buildView 方法，因为 buildView 也是一个函数，所以这里是调用了一个函数</span><br>    result = _widgetCache = view(state, dispatch, <span class="hljs-keyword">this</span>);<br><br>    dispatch(LifecycleCreator.build(name));<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面做了缓存，那么，问题就来了，既然缓存起来了，那么怎么才能更新界面呢？很简单，将 _widgetCache 的值置为null就好了。上面的 onNotify 方法就做了这件事。所以 dispatch action 之后，如果 reducer 产生了新的数据对象，那么页面就会刷新。</p><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p>component 与 page 的用法差不多。因为 component 继承的 page，可以理解为 View 与 ViewGroup 的关系。component 创建出来后，可以在 page 里面使用。</p><p>如下，需要先在 page 里面的依赖申明一下，我有这个组件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">dependencies: Dependencies&lt;ThirdState&gt;(<br>    slots: &lt;<span class="hljs-built_in">String</span>, Dependent&lt;ThirdState&gt;&gt;&#123;<br>      <span class="hljs-comment">// 连接器理解为数据传递</span><br>      <span class="hljs-string">&quot;card1&quot;</span>: Card1Connector() + CardComponent(),<br>    &#125;),<br></code></pre></td></tr></table></figure><p>然后，在 view 里面使用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">viewService.buildComponent(<span class="hljs-string">&#x27;card1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>buildComponent 的返回值就是一个 widget。</p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>它表达了如何从一个大数据中读取小数据，同时对小数据的修改如何同步给大数据，这样的数据连接关系。</p><p>在fish-redux的页面设计中，数据全部都给 page 管理，component 的数据也在 page 里面，component虽然是有自己的数据，但是是从 page 里面传递过来的。我们使用 connector 将page中的数据传递给 component使用，同时也将 component更改的数据同步回page。</p><blockquote><p>page 里面的数据</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">ThirdState</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Cloneable</span>&lt;<span class="hljs-symbol">ThirdState</span>&gt; &#123;<br>  HeaderState headerState;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>component 里面的数据</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>&lt;<span class="hljs-title">HeaderState</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">int</span> count;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>connector</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 两个泛型 T -&gt; P，T 是大数据（页面），P是小数据（页面的组件）</span><br><span class="hljs-comment">// get 是用来从大数据中获取小数据，父类重写了 get 方法（里面做了缓存等），提供了一个 computed 方法</span><br><span class="hljs-comment">// set 是用来将小数据同步给大数据，保持数据同步</span><br><span class="hljs-comment">// 它支持 + 操作符号，可以看重写代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeaderConnector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConnOp</span>&lt;<span class="hljs-title">ThirdState</span>, <span class="hljs-title">HeaderState</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">ReselectMixin</span>&lt;<span class="hljs-title">ThirdState</span>, <span class="hljs-title">HeaderState</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  HeaderState computed(ThirdState state) &#123;<br>    <span class="hljs-keyword">return</span> state.headerState.clone();<br>  &#125;<br><br>  <span class="hljs-comment">// 这个方法会将 HeaderState 里面的数同步到 ThirdState 里面去</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span>(ThirdState state, HeaderState subState) &#123;<br>    state.headerState = subState;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>可以理解为 AOP。做切面编程了，比如，我先打印一个页面的生命周期：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Page</span>&lt;<span class="hljs-title">EntryState</span>, <span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">dynamic</span>&gt;&gt; </span>&#123;<br>  EntryPage()<br>      : <span class="hljs-keyword">super</span>(<br>          ...<br>          <span class="hljs-comment">// 这里还可以传一些 middleWare，用来做 AOP，比如打印生命周期</span><br>          effectMiddleware: &lt;EffectMiddleware&lt;EntryState&gt;&gt;[<br>            pageLifecycle(),<br>          ],<br>        );<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我给 effectMiddleware 传递了一个列表，里面有一个元素。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart">EffectMiddleware&lt;EntryState&gt; pageLifecycle() &#123;<br>  <span class="hljs-keyword">return</span> (AbstractLogic&lt;<span class="hljs-built_in">dynamic</span>&gt; logic, Store&lt;EntryState&gt; store,) &#123;<br>    <span class="hljs-keyword">return</span> (Effect&lt;<span class="hljs-built_in">dynamic</span>&gt; effect) &#123;<br>      <span class="hljs-keyword">return</span> (Action action, Context&lt;<span class="hljs-built_in">dynamic</span>&gt; ctx) &#123;<br>        <span class="hljs-keyword">if</span> (logic <span class="hljs-keyword">is</span> Page&lt;<span class="hljs-built_in">dynamic</span>, <span class="hljs-built_in">dynamic</span>&gt; &amp;&amp; action.type <span class="hljs-keyword">is</span> Lifecycle) &#123;<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;logic.runtimeType&#125;</span> <span class="hljs-subst">$&#123;action.type.toString()&#125;</span> &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> effect?.call(action, ctx);<br>      &#125;;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>EffectMiddleware 是一个函数，而这个函数的返回值也是函数，所以这里看起来相当蛋疼。它的作用就是打印了当前page的生命周期，当然也可以给所有page做切面，不过不再这里，在 PageRoutes 里面。</p><h4 id="全局状态"><a href="#全局状态" class="headerlink" title="全局状态"></a>全局状态</h4><p>之前流程分析源码那里有个兵分两路的，它是调用了 store 的dispatch，所以 page 内部也是使用的 store。</p><p>全局状态需要我们自己创建一个 store。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="markdown">建立一个全局数据区</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalStore</span> </span>&#123;<br>  <span class="hljs-comment">// Store 里面的泛型是储存的数据类型</span><br>  <span class="hljs-keyword">static</span> Store&lt;GlobalState&gt; _globalStore;<br><br>  <span class="hljs-keyword">static</span> Store&lt;GlobalState&gt; <span class="hljs-keyword">get</span> store =&gt;<br>      _globalStore ??= createStore&lt;GlobalState&gt;(GlobalState(), buildReducer());<br>&#125;<br></code></pre></td></tr></table></figure><p>store 里面储存全局数据。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalBaseState</span> </span>&#123;<br>  Color <span class="hljs-keyword">get</span> themeColor;<br>  <span class="hljs-keyword">set</span> themeColor(Color color);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GlobalBaseState</span>, <span class="hljs-title">Cloneable</span>&lt;<span class="hljs-title">GlobalState</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Color themeColor;<br><br>  <span class="hljs-meta">@override</span><br>  GlobalState clone() &#123;<br>    <span class="hljs-keyword">return</span> GlobalState();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 PageRoutes 建立全局数据与页面数据的关系：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart">visitor: (<span class="hljs-built_in">String</span> path, Page&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">dynamic</span>&gt; page) &#123;<br>  <span class="hljs-comment">/// <span class="markdown">只有特定的范围的 Page 才需要建立和 AppStore 的连接关系</span></span><br>  <span class="hljs-comment">/// <span class="markdown">满足 Page<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></span> ，T 是 GlobalBaseState 的子类</span></span><br>  <span class="hljs-keyword">if</span> (page.isTypeof&lt;GlobalBaseState&gt;()) &#123;<br>    <span class="hljs-comment">/// <span class="markdown">建立 AppStore 驱动 PageStore 的单向数据连接</span></span><br>    <span class="hljs-comment">/// <span class="markdown"><span class="hljs-bullet">1.</span> 参数1 AppStore</span></span><br>    <span class="hljs-comment">/// <span class="markdown"><span class="hljs-bullet">2.</span> 参数2 当 AppStore.state 变化时, PageStore.state 该如何变化</span></span><br>    page.connectExtraStore&lt;GlobalState&gt;(GlobalStore.store, (<span class="hljs-built_in">Object</span> pageState, GlobalState appState) &#123;<br>      <span class="hljs-keyword">final</span> GlobalBaseState p = pageState;<br>      <span class="hljs-keyword">if</span> (p.themeColor != appState.themeColor) &#123;<br>        <span class="hljs-keyword">if</span> (pageState <span class="hljs-keyword">is</span> Cloneable) &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> copy = pageState.clone();<br>          <span class="hljs-keyword">final</span> GlobalBaseState newState = copy;<br>          newState.themeColor = appState.themeColor;<br>          <span class="hljs-keyword">return</span> newState;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> pageState;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当全局数据被改变的时候，会调用 visitor 函数，所以 page 中的 state 也会改变。可以猜出来，它其实就是一个 reducer。</p><h3 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h3><p><a href="https://github.com/aprz512/first_flutter_demo">https://github.com/aprz512/first_flutter_demo</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Frida环境搭建</title>
    <link href="/2020/09/09/blog_bak/Blog/%E9%80%86%E5%90%91/Frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/09/09/blog_bak/Blog/%E9%80%86%E5%90%91/Frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>Anaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。</p><p>可以立即为它就是Python，但是它集成了很多东西，用起来很方便。</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p><p>根据自己的系统，下载完对应的安装包之后，安装就好了。</p><p>我的是 Windows，记得安装的时候<strong>勾上添加环境变量</strong>，不然还得自己加。</p><p>安装完毕输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda list</span><br></code></pre></td></tr></table></figure><p>查看安装结果。</p><h3 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h3><p>Anaconda 安装好了之后，再安装两个依赖包：</p><ul><li>frida</li><li>frida-tools</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pip install frida <span class="hljs-regexp">//</span> 这个贼慢<br>pip install frida-tools<br></code></pre></td></tr></table></figure><p>frida 默认安装的是最新的版本，你可以指定版本号。这里假设你的版本是 12.3.6，那么 python 必须要是 3.7 的。这是 Python 唯一蛋疼的地方，版本不兼容。</p><p>安装完成后输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">python</span><br></code></pre></td></tr></table></figure><p>进入python环境，导入个包试试：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> frida<br></code></pre></td></tr></table></figure><p>如果没报错，就ok了。</p><h3 id="frida-server"><a href="#frida-server" class="headerlink" title="frida-server"></a>frida-server</h3><p>下载地址：<a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><p>选择 frida-server 开头的，然后选择你自己的环境，我做 Android 逆向，就选 Android。然后选择手机版本，我的手机是 arm64 的。</p><p>查看自己手机CPU类型：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">adb shell getprop ro<span class="hljs-selector-class">.product</span><span class="hljs-selector-class">.cpu</span>.abi<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190424154339833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzE3NDQx,size_16,color_FFFFFF,t_70" alt="img"></p><p>我下载的是：<a href="https://github.com/frida/frida/releases/download/12.11.12/frida-server-12.11.12-android-arm64.xz">frida-server-12.11.12-android-arm64.xz</a></p><p>模拟器，一般选择 x86 的。</p><p>下载完server程序后，<strong>解压缩</strong>，然后推送到手机内部存储路径：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">adb <span class="hljs-keyword">push</span> frida-server-<span class="hljs-number">12.11</span>.<span class="hljs-number">12</span>-android-arm64 <span class="hljs-regexp">/data/</span>local<span class="hljs-regexp">/tmp/</span>fs<br></code></pre></td></tr></table></figure><p>这里顺便做了一个重命名，改成了 fs。</p><p>然后，修改文件执行权限：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> fs<br></code></pre></td></tr></table></figure><p>然后，运行文件，记得授予shell root 权限，否则可能会报权限拒绝错误：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">./<span class="hljs-built_in">fs</span><br></code></pre></td></tr></table></figure><p>然后，做一个端口转发，默认使用27042端口与frida-server通信：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> forward tcp:<span class="hljs-number">27042</span> tcp:<span class="hljs-number">27042</span><br></code></pre></td></tr></table></figure><p>上面命令的意思：即把PC电脑端TCP端口27042的数据转发到与电脑通过adb连接的Android设备的TCP端口27042上。</p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EdXposed框架使用</title>
    <link href="/2020/09/08/blog_bak/Blog/%E9%80%86%E5%90%91/EdXposed%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/08/blog_bak/Blog/%E9%80%86%E5%90%91/EdXposed%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h4><p>手机：Pixel</p><p>镜像：8.1.0 (OPM4.171019.021.P1, Jul 2018)，使用 10.0.0 失败了，EdXposed 不完善。</p><p>下载刷机包：<a href="https://dl.google.com/dl/android/aosp/sailfish-opm4.171019.021.p1-factory-0bcf4315.zip">Link</a></p><p>下载完成后，直接解压，运行 flash-all 即可（需要解锁 bootloader，并进入 bootloader 模式）。</p><p>进入 bootloader 模式，使用命令：</p><blockquote><p>adb reboot bootloader</p></blockquote><h4 id="twrp"><a href="#twrp" class="headerlink" title="twrp"></a>twrp</h4><p>刷机完成之后（如果之前root过的话，最好重新刷机一下，不然可能会无限重启…），再 root。</p><p>先安装 twrp，具体过程参考 <a href="https://twrp.me/google/googlepixel.html%EF%BC%8C**%E6%AF%8F%E4%B8%AA%E6%89%8B%E6%9C%BA%E9%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7**%E3%80%82">https://twrp.me/google/googlepixel.html，**每个手机都不一样**。</a></p><p><strong>实践</strong>：</p><p>下载 twrp，<a href="https://dl.twrp.me/sailfish/">https://dl.twrp.me/sailfish/</a></p><p>然后进入 bootloader：</p><blockquote><p><strong>adb reboot bootloader</strong></p></blockquote><p><img src="https://www.online-tech-tips.com/wp-content/uploads/2020/01/adb-reboot-bootloader.png.webp" alt="img"></p><p>然后，进入 twrp，<strong>将 twrp.img 改成你下载的文件的全路径，最好直接拖到cmd里面</strong></p><blockquote><p>fastboot boot twrp.img</p></blockquote><p><img src="https://www.online-tech-tips.com/wp-content/uploads/2020/01/boot-twrp.png.webp" alt="img"></p><p>然后，手机会出现如下画面，<strong>如果手机有密码，记得在弹出的窗口输入密码，不然文件乱码</strong>：</p><p><img src="https://www.online-tech-tips.com/wp-content/uploads/2020/01/install-zip-from-recovery-1.png.webp" alt="img"></p><h4 id="magisk"><a href="#magisk" class="headerlink" title="magisk"></a>magisk</h4><p>下载 magiskmanager，<a href="https://magiskmanager.com/downloading-magisk-manager">https://magiskmanager.com/downloading-magisk-manager</a></p><p>安装完成后，发现里面<strong>一直检查更新</strong>，点击<strong>菜单-&gt;设置-&gt;更新通道-&gt;自定义</strong>，输入：<a href="https://gitee.com/QingFeiDeiYi/Magisk/raw/master/stable.json">https://gitee.com/QingFeiDeiYi/Magisk/raw/master/stable.json</a> 这个地址，然后返回刷新界面，就好了。</p><p>下载 magisk，<a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a></p><p>然后将文件 push 到手机，进入 twrp，安装，重启，即可，手机就 root 了。</p><h4 id="EdXposed-安装"><a href="#EdXposed-安装" class="headerlink" title="EdXposed 安装"></a>EdXposed 安装</h4><p>下载3个文件：</p><ul><li>Riru-Core – <a href="https://github.com/RikkaApps/Riru/releases">Download</a></li><li>EDXposed Magisk Module – <a href="https://github.com/ElderDrivers/EdXposed/releases">Download</a> (YAHFA and SandHook are two variants available – try both and adopt stable variant which is best for your device)</li><li>EDXP Manager APK – <a href="https://github.com/ElderDrivers/EdXposedManager/releases">Download</a></li></ul><p>将前面两个压缩文件 push 到手机上，打开  magisk manager，点击 菜单 模块 ，将上面两个 zip 文件刷入就好了。</p><p>安装 EDXP Manager APK，重启，这样 EdXposed 框架就安装好了，打开 EdXposed Manager 会提示你是否安装好了。</p><h3 id="EdXposed-使用"><a href="#EdXposed-使用" class="headerlink" title="EdXposed 使用"></a>EdXposed 使用</h3><p>这个玩意的使用有点蛋疼，首先需要安装一个 app：<a href="https://github.com/PAGalaxyLab/VirtualHook">https://github.com/PAGalaxyLab/VirtualHook</a></p><p>安装好之后，编写 hook 代码，例子：<a href="https://github.com/PAGalaxyLab/YAHFA">https://github.com/PAGalaxyLab/YAHFA</a></p><p>编写好 hook 代码之后，打包成 apk，然后 push 到手机 sdcard 根目录。</p><p>打开安装的 VirtualHook app，里面有个 <strong>添加</strong> 按钮，点击它，出现一个页面，这个页面有<strong>两个 tab</strong>，切换到 <strong>APPS IN SDCARD</strong> 这个 tab（第二个）。</p><p>然后，选择 hook apk，即可。</p><p><strong>测试的 Android 10 ，会报错</strong>：<a href="https://github.com/PAGalaxyLab/YAHFA/issues/129">https://github.com/PAGalaxyLab/YAHFA/issues/129</a></p><p><strong>测试的 Android 8，会报错</strong>：<a href="https://github.com/PAGalaxyLab/VirtualHook/issues/100">https://github.com/PAGalaxyLab/VirtualHook/issues/100</a></p><p>暂时放弃，搞 Frida 去了…</p><h3 id="wifi-叉号问题"><a href="#wifi-叉号问题" class="headerlink" title="wifi 叉号问题"></a>wifi 叉号问题</h3><p><a href="https://support.google.com/pixelphone/forum/AAAAb4-OgUsK_o4E4r67dY">https://support.google.com/pixelphone/forum/AAAAb4-OgUsK_o4E4r67dY</a></p><p>直接运行</p><blockquote><p>adb shell “settings put global captive_portal_https_url <a href="https://developers.google.cn/generate_204&quot;">https://developers.google.cn/generate_204&quot;</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>右值引用</title>
    <link href="/2020/09/02/blog_bak/Blog/C++/002-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <url>/2020/09/02/blog_bak/Blog/C++/002-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>不严格的来说，左值对应变量的<strong>存储位置</strong>，而右值对应变量的<strong>值本身</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-comment">// a是左值，10是右值</span><br></code></pre></td></tr></table></figure><p>左值引用很好理解，就是我们常见的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>&amp; x = a;<span class="hljs-comment">// ok</span><br><span class="hljs-keyword">int</span>&amp; y = <span class="hljs-number">10</span>; <span class="hljs-comment">// error, 10 是右值</span><br></code></pre></td></tr></table></figure><p>右值引用也是引用，但是它<strong>只能且必须</strong>绑定在右值上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span>&amp;&amp; w = <span class="hljs-number">42</span>; <br><span class="hljs-keyword">int</span>&amp;&amp; z = a--;   <span class="hljs-comment">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span><br><span class="hljs-keyword">int</span>&amp;&amp; t = a * <span class="hljs-number">1</span>;  <span class="hljs-comment">// OK: a * 1 的结果是一个右值，将它绑定在右值引用上</span><br><span class="hljs-keyword">int</span>&amp;&amp; v = a;       <span class="hljs-comment">// Err: a 可以是左值，所以不能将它绑定在右值引用上</span><br></code></pre></td></tr></table></figure><h3 id="右值引用有啥用？"><a href="#右值引用有啥用？" class="headerlink" title="右值引用有啥用？"></a>右值引用有啥用？</h3><p>C++中右值可以被赋值给左值或者绑定到引用。</p><p>类的右值是一个临时对象，如果没有被绑定到引用，在<strong>表达式结束时就会被废弃</strong>。</p><p>于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。</p><p><strong>右值中的数据可以被安全移走</strong>。</p><h3 id="右值引用的使用"><a href="#右值引用的使用" class="headerlink" title="右值引用的使用"></a>右值引用的使用</h3><p>对于左值，如果我们明确放弃对其资源的所有权，则可以通过std::move()来将其转为右值引用。std::move()实际上是static_cast&lt;T&amp;&amp;&gt;()的简单封装。</p><p><a href="https://www.zhihu.com/question/22111546">https://www.zhihu.com/question/22111546</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>017-Matrix源码分析：监测SQL语句中的问题</title>
    <link href="/2020/09/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/017-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BSQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/09/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/017-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BSQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>该库可以在 APP 运行时对 sql 语句、执行序列、表信息等进行分析检测。其主要代码在 <code>matrix-sqlite-lint-android-sdk</code>下。虽然名带 “lint ” ，但并不是代码的静态检查。</p><p>这里主要介绍一下 SQLiteLint 的思路，因为需要检测出来哪些 SQL 是可以优化的，所以你就必须要了解 SQL 语句，而我对 SQL 语句的熟悉程度还达不到这一点，所以就很难看懂里面的一些算法。故算法部分就不深入分析了，有兴趣可以看源码以及官方文档。</p><h3 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsI9ibGiaIgT8sOFicBw5GHjWelfLAyI2F8NrWKo3Hp3tpAcMvSzONH3s4SNVxgiaUvNxJmob1H2gTiaWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>可以看到，基本流程与 IO 的检测是差不多的，实际上确实如此，源码部分也有很多类似的地方。</p><p>我们看下里面的几个流程：</p><ol><li><p>收集 APP 运行时的 sql 执行信息<br>  包括执行语句、创建的表信息等。其中表相关信息可以通过 pragma 命令得到。对于执行语句，有两种情况：<br>  a）DB 框架提供了回调接口。比如微信使用的是 WCDB ，很容易就可以通过MMDataBase.setSQLiteTrace 注册回调拿到这些信息。<br>  b） 若使用 Android 默认的 DB 框架，SQLiteLint 提供了一种无侵入的获取到执行的sql语句及耗时等信息的方式。通过hook的技巧，向 SQLite3 C 层的  api sqlite3_profile 方法注册回调，也能拿到分析所需的信息，从而无需开发者额外的打点统计代码。</p></li><li><p>预处理<br>包括生成对应的 sql 语法树，生成不带实参的 sql ，判断是否 select* 语句等，为后面的分析做准备。预处理和后面的算法调度都在一个单独的处理线程。</p></li><li><p>调度具体检测算法执行<br>checker 就是各种检测算法，也支持扩展。并且检测算法都是以 C++ 实现，方便支持多平台。而调度的时机包括：最近未分析 sql 语句调度，抽样调度，初始化调度，每条 sql 语句调度。</p></li><li><p>发布问题<br>上报问题或者弹框提示。</p></li></ol><p>可以看到重点在第 3 步，而这一步本文暂不分析。第2步也只简单的说一下。</p><h3 id="收集App运行时的-SQL-执行信息"><a href="#收集App运行时的-SQL-执行信息" class="headerlink" title="收集App运行时的 SQL 执行信息"></a>收集App运行时的 SQL 执行信息</h3><p>该库提供了两种方式，一种是 hook，一种是通过回调接口。至于使用哪种，需要我们执行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SQLiteLintConfig <span class="hljs-title">initSQLiteLintConfig</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HOOK模式下，SQLiteLint会自己去获取所有已执行的sql语句及其耗时(by hooking sqlite3_profile)</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@see</span> 而另一个模式：SQLiteLint.SqlExecutionCallbackMode.CUSTOM_NOTIFY , 则需要调用 &#123;<span class="hljs-doctag">@link</span> SQLiteLint#notifySqlExecution(String, String, int)&#125;来通知</span><br><span class="hljs-comment">         * SQLiteLint 需要分析的、已执行的sql语句及其耗时</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@see</span> TestSQLiteLintActivity#doTest()</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SQLiteLintConfig(SQLiteLint.SqlExecutionCallbackMode.HOOK);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SQLiteLintConfig(SQLiteLint.SqlExecutionCallbackMode.HOOK);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 hook 在高版本可能会有兼容问题，如果遇到后不要慌。</p><h4 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h4><p>我们看看 hook 实现的相关代码，可以回想一下 IO 的 hook，想必是差不多的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">xhook_register</span>(<span class="hljs-string">&quot;.*/libandroid_runtime\\.so$&quot;</span>, <span class="hljs-string">&quot;sqlite3_profile&quot;</span>, (<span class="hljs-keyword">void</span>*)hooked_sqlite3_profile, (<span class="hljs-keyword">void</span>**)&amp;original_sqlite3_profile);<br></code></pre></td></tr></table></figure><p>hook 的是 sqlite3_profile 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">hooked_sqlite3_profile</span><span class="hljs-params">(sqlite3* db, <span class="hljs-keyword">void</span>(*xProfile)(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, sqlite_uint64), <span class="hljs-keyword">void</span>* p)</span> </span>&#123;<br>    <span class="hljs-built_in">LOGI</span>(<span class="hljs-string">&quot;hooked_sqlite3_profile call&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">original_sqlite3_profile</span>(db, SQLiteLintSqlite3ProfileCallback, p);<br>&#125;<br></code></pre></td></tr></table></figure><p>hook 函数也没干啥，就是直接调用了原函数，不过传递了一个 callback 进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SQLiteLintSqlite3ProfileCallback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sql, sqlite_uint64 tm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (kStop) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    JNIEnv*env = <span class="hljs-built_in">getJNIEnv</span>();<br>    <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">nullptr</span>) &#123;<br>        SQLiteConnection* connection = <span class="hljs-keyword">static_cast</span>&lt;SQLiteConnection*&gt;(data);<br>        jstring extInfo = (jstring)env-&gt;<span class="hljs-built_in">CallStaticObjectMethod</span>(kUtilClass, kMethodIDGetThrowableStack);<br>        <span class="hljs-keyword">char</span> *ext_info = <span class="hljs-built_in">jstringToChars</span>(env, extInfo);<br><br>        <span class="hljs-built_in">NotifySqlExecution</span>(connection-&gt;label, sql, tm/<span class="hljs-number">1000000</span>, ext_info);<br><br>        <span class="hljs-built_in">free</span>(ext_info);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">LOGW</span>(<span class="hljs-string">&quot;SQLiteLintSqlite3ProfileCallback env null&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该回调会在 sql 执行后触发，这样我们就可以拿到该 sql 的相关信息。然后调用 NotifySqlExecution 通知 sql 执行了，实际上就是放入队列里面。</p><p>里面会有一个生产者-消费者模型，与 IO 是一样的，所以这里扮演的是生产者角色。</p><h4 id="手动通知"><a href="#手动通知" class="headerlink" title="手动通知"></a>手动通知</h4><p>当我们不使用 hook 的时候，就需要开发者自己在 sql 执行后手动调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifySqlExecution</span><span class="hljs-params">(String concernedDbPath, String sql, <span class="hljs-keyword">int</span> timeCost)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isPluginStarted()) &#123;<br>        SLog.i(TAG, <span class="hljs-string">&quot;notifySqlExecution isPluginStarted not&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    SQLiteLint.notifySqlExecution(concernedDbPath, sql, timeCost);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用这行代码之后，最终也会进入到 NotifySqlExecution 这行语句中，与 hook 方式是一样的，这样有点类似打点。</p><p>我们看看 NotifySqlExecution 最终会调用到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lint::NotifySqlExecution</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sql, <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> time_cost, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ext_info)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (sql == <span class="hljs-literal">nullptr</span>)&#123;<br>          <span class="hljs-built_in">sError</span>(<span class="hljs-string">&quot;Lint::NotifySqlExecution sql NULL&quot;</span>);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (env_.<span class="hljs-built_in">IsReserveSql</span>(sql)) &#123;<br>          <span class="hljs-built_in">sDebug</span>(<span class="hljs-string">&quot;Lint::NotifySqlExecution a reserved sql&quot;</span>);<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      SqlInfo *sql_info = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SqlInfo</span>();<br>      sql_info-&gt;sql_ = sql;<br>sql_info-&gt;execution_time_ = <span class="hljs-built_in">GetSysTimeMillisecond</span>();<br>      sql_info-&gt;ext_info_ = ext_info;<br>      sql_info-&gt;time_cost_ = time_cost;<br>      sql_info-&gt;is_in_main_thread_ = <span class="hljs-built_in">IsInMainThread</span>();<br><br>      <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex_)</span></span>;<br>      queue_.<span class="hljs-built_in">push_back</span>(std::unique_ptr&lt;SqlInfo&gt;(sql_info));<br>      queue_cv_.<span class="hljs-built_in">notify_one</span>();<br>      lock.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里给 sql_info 赋值了很多字段，就是收集相关信息了，然后就放到 queue_ 里面，然后通知消费者线程。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>sql 信心收集完成之后，需要进行处理，我们看源码，直接看消费者线程的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">         ...<br>             <br><span class="hljs-comment">// 从队列中取一个</span><br>         <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">TakeSqlInfo</span>(sql_info);<br><br>...<br>             <br>         <span class="hljs-comment">// 记录sql数量，用于抽样</span><br>         env_.<span class="hljs-built_in">IncSqlCnt</span>();<br>         <span class="hljs-comment">// 将 sql 语句进行预处理，去除前后空格，全转小写</span><br>         <span class="hljs-built_in">PreProcessSqlString</span>(sql_info-&gt;sql_);<br><br>...<br>             <br>         <span class="hljs-comment">// 真正的预处理逻辑</span><br>         <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">PreProcessSqlInfo</span>(sql_info.<span class="hljs-built_in">get</span>())) &#123;<br>             <span class="hljs-built_in">sWarn</span>(<span class="hljs-string">&quot;Lint::Check PreProcessSqlInfo failed&quot;</span>);<br>             env_.<span class="hljs-built_in">AddToSqlHistory</span>(*sql_info);<br>             sql_info = <span class="hljs-literal">nullptr</span>;<br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br><br>...<br><br>         <span class="hljs-comment">// 这里是抽样检测</span><br>         <span class="hljs-built_in">ScheduleCheckers</span>(CheckScene::kSample, *sql_info, published_issues);<br><br>...<br><br>         <span class="hljs-keyword">if</span> (!checked_sql_cache_.<span class="hljs-built_in">Get</span>(wildcard_sql, checked)) &#123;<br>             <span class="hljs-comment">// 这里是避免重复检测，与上面的抽象可能会重复</span><br>             <span class="hljs-built_in">ScheduleCheckers</span>(CheckScene::kUncheckedSql, *sql_info, published_issues);<br>             checked_sql_cache_.<span class="hljs-built_in">Put</span>(wildcard_sql, <span class="hljs-literal">true</span>);<br>         &#125; <br></code></pre></td></tr></table></figure><p>看看 ScheduleCheckers ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Lint::ScheduleCheckers</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CheckScene check_scene, <span class="hljs-keyword">const</span> SqlInfo&amp; sql_info, std::vector&lt;Issue&gt; *published_issues)</span> </span>&#123;<br>    <span class="hljs-comment">// 检测场景不符，就直接返回</span><br>    <span class="hljs-comment">// 每个 Checker 有自己的检测场景</span><br>    std::map&lt;CheckScene, std::vector&lt;Checker*&gt;&gt;::iterator it = checkers_.<span class="hljs-built_in">find</span>(check_scene);<br>    <span class="hljs-keyword">if</span> (it == checkers_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    std::vector&lt;Checker*&gt; scene_checkers = it-&gt;second;<br>    <span class="hljs-keyword">size_t</span> scene_checkers_cnt = scene_checkers.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>;i &lt; scene_checkers_cnt;i++) &#123;<br><br>        Checker* checker = scene_checkers[i];<br>        <span class="hljs-comment">// 如果是抽样检测（kSample），则需要满足隔 30 个取一个</span><br>        <span class="hljs-keyword">if</span> (check_scene != CheckScene::kSample<br>            || (env_.<span class="hljs-built_in">GetSqlCnt</span>() % checker-&gt;<span class="hljs-built_in">GetSqlCntToSample</span>() == <span class="hljs-number">0</span>)) &#123;<br>            checker-&gt;<span class="hljs-built_in">Check</span>(env_, sql_info, published_issues);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是调用了各个 Checker 的 Check 函数。Checker 有很多，里面具体做了啥，这里就不分析了，涉及到语法语义。</p><h3 id="上报"><a href="#上报" class="headerlink" title="上报"></a>上报</h3><p>上报的逻辑与IO差不多。具体逻辑在</p><blockquote><p>sqlitelint::OnIssuePublish</p></blockquote><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://mp.weixin.qq.com/s/laUgOmAcMiZIOfM2sWrQgw">https://mp.weixin.qq.com/s/laUgOmAcMiZIOfM2sWrQgw</a></p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>写入放大</title>
    <link href="/2020/09/01/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7/"/>
    <url>/2020/09/01/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p>闪存基本构成是由：页page（4K）→块block（通常64个page组成一个block，有的是128个）→面plane（多个blcok组成）→die（plane就是一个die）→闪存片（多个die组成）→SSD（多颗闪存片组成）</p><p><img src="https://pic4.zhimg.com/80/38d2501ae92f54a2d02edae6341a6b2b_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>一个块block是由128个页page组成，一个页page是大小是4KB</strong></p><p><img src="https://pic2.zhimg.com/80/391984c01d25ffcee3ab622b84831b5e_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>↑↑↑↑一个面Plane由1024个块block组成</strong></p><p>△▼△▼△▼△▼△▼分割线▼△▼▽▼△▼△▼△</p><p>其实写入放大很好理解，而造成写入的元凶是GC垃圾回收。</p><p>说之前先说下操作系统当删除一个数据时，他不会立马删除，而是把这个要删除的数据上标记一个“删”的标签，实际上没有真正删除，就是因为如此硬盘上数据纯在可恢复的原因。</p><p>而机械硬盘与固态硬盘工作原理不同，当机械硬盘要写入新数据时可以直接覆盖那些已经被标记“删”标签的数据，而固态硬盘不行，只能先擦除旧的数据才能写入新数据。</p><p>NAND闪存工作原理是以4K页（page）为一个单元写入的，但擦除只能以块block（64个page）为单位。</p><p>如果一个块block上有32个page有效数据和32个被标记“删”标签的无效数据，那要在这个块block上重新写入数据，那<strong>必须要擦除整个块block</strong>，那还有一半有效数据怎么办了？那只有把那32page的有效数据就要<strong>搬到另一个有空位置</strong>的块block中，这个这就是GC垃圾回收技术，那把那有效的数据搬到另一个块block中，原本就已经写入过一次了再加上这次搬迁不就又多了一次写入吗，这就是所谓的写入放大。</p>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>016-Matrix源码分析：监测IO情况</title>
    <link href="/2020/08/31/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/016-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BIO%E6%83%85%E5%86%B5/"/>
    <url>/2020/08/31/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/016-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BIO%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>经过一个星期的 C++ 基本语法的学习，终于可以继续分析了，好不容易写了 15 篇，被个 C++ 拦住了就笑死人了。</p></blockquote><p>IO的监测功能由以下3个库实现：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">matrix</span>-io-canary<br><span class="hljs-keyword">matrix</span>-android-<span class="hljs-keyword">lib</span><br><span class="hljs-keyword">matrix</span>-android-commons<br></code></pre></td></tr></table></figure><p>matrix-io-canary 里面的是核心代码。</p><p>这个库里面提供了一下几个功能：</p><ul><li>主线程IO，设定了一些阈值，超过就报警（最大读写时间超过 13ms，一次连续读写时间超过 500ms）</li><li>重复读IO（这个感觉有点鸡肋，可能是我没搞懂使用场景）</li><li>buffer太小的IO行为</li></ul><p>在分析这些功能是如何实现的之前，我们想一下，该如何监测应用中的的IO呢？</p><p>我们通常读取文件，都是通过 FileInputStream 等类来实现的，他们的内部是调用了 native 函数，最终会调用到 <code>libjavacore.so</code> 中的 <code>read/write</code> 方法，所以，我们只需要 hook 这俩个函数就好了。所以，最终的问题转化为如何hook 指定 .so 中的函数？？？</p><p>解决上面的问题需要用到 elf 文件格式的知识，以及 .so 的加载与链接知识。这些在《程序员的自我修养-链接、装载与库》中都有详细的描述，可以看看，我花了几天时间差不多看明白了。这里就简单的说一下这个过程。</p><h3 id="so相关"><a href="#so相关" class="headerlink" title=".so相关"></a>.so相关</h3><blockquote><p>没有阅读 《程序员的自我修养-链接、装载与库》 这本书的相关章节的话，这段内容几乎看不懂。</p></blockquote><p>.so 是一个 ELF 文件格式的文件。</p><p>.so 是共享库，也就是说它加载到内存后，是可以多个进程共享的。但是这个文件的加载比较特殊，并不是与普通文件一样，一股脑的全部放到内存就行了。</p><p>简单的来说，它里面有多个段，指令（就是存放函数代码，它是只读的）放在一个段，这个是可以共享的。而有些段不是共享的，它是每个进程各自一份，比如全局偏移表（.got），这个里面存放的就是变量函数的地址，因为每个进程都有自己的虚拟内存，所以共享库函数的地址也是不一样的。</p><p>与 .got 相关的还有一个 .plt，它是用来懒绑定的，就是说函数到真正使用的时候，才会绑定地址，因为有的函数根本就不会被调用。</p><h3 id="hook-函数"><a href="#hook-函数" class="headerlink" title="hook 函数"></a>hook 函数</h3><p>这里的 hook 有两种选择，一种是 java 层，一种是 native 层。</p><p>但是 java 层有些缺点：</p><ul><li>兼容性差。Java Hook 需要每个 Android 版本去兼容，特别是 Android P 增加对非公开 API 限制。</li><li>无法监控 Native 代码。</li><li>I/O 操作调用非常频繁，因为使用动态代理和 Java 的大量字符串操作，导致性能比较差，无法达到线上使用的标准。</li></ul><p>所以，采用的是 native 的方式。最终是从 libc.so 中的这几个函数中选定 Hook 的目标函数（当然，遍历所有已经加载的 library，全部替换更好）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> size)</span></span>; <span class="hljs-function">write_cuk</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>不同版本的 Android 系统实现有所不同，在 Android 7.0 之后，我们还需要替换下面这三个方法。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">open64<br><span class="hljs-variable">__read_chk</span><br><span class="hljs-variable">__write_chk</span><br></code></pre></td></tr></table></figure><p>爱奇艺开源的 xhook 可以 hook .so 中的函数，Github 上有相关信息，有兴趣的可以去看源码。</p><p>先上一张图，再看一下使用方式：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true" alt="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true"></p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><blockquote><p>iocanary::Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">JNIEXPORT jboolean JNICALL</span><br><span class="hljs-function">    <span class="hljs-title">Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook</span><span class="hljs-params">(JNIEnv *env, jclass type)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TARGET_MODULE_COUNT; ++i) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* so_name = TARGET_MODULES[i];<br><br>        <span class="hljs-keyword">void</span>* soinfo = <span class="hljs-built_in">xhook_elf_open</span>(so_name);<br><br>        <span class="hljs-comment">// 从 .so 里面 找到 open 函数，将open函数的地址指向 ProxyOpen，原来的函数地址保存到 original_open</span><br>        <span class="hljs-comment">// void** 相当于一个泛型</span><br>        <span class="hljs-built_in">xhook_hook_symbol</span>(soinfo, <span class="hljs-string">&quot;open&quot;</span>, (<span class="hljs-keyword">void</span>*)ProxyOpen, (<span class="hljs-keyword">void</span>**)&amp;original_open);<br>        ...<br><br>        <span class="hljs-built_in">xhook_elf_close</span>(soinfo);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> JNI_TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，使用还是挺简单的，先打开 .so 文件，然后传递需要hook的函数名，以及俩个函数指针就好了，我们看看 ProxyOpen 函数：</p><blockquote><p>iocanary::ProxyOpen</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ProxyOpen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">mode_t</span> mode)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">IsMainThread</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">original_open</span>(pathname, flags, mode);<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">original_open</span>(pathname, flags, mode);<br><br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">DoProxyOpenLogic</span>(pathname, flags, mode, ret);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，它只监测了<strong>主线程的IO</strong>（其他的代理方法都有这个逻辑，可能是其他线程有bug还是什么）。然后调用原来的 open 函数打开文件，拿到返回的文件描述符后，执行插入的代理逻辑：</p><blockquote><p>iocanary::DoProxyOpenLogic</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoProxyOpenLogic</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">mode_t</span> mode, <span class="hljs-keyword">int</span> ret)</span> </span>&#123;<br>    JNIEnv* env = <span class="hljs-literal">NULL</span>;<br>    kJvm-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-keyword">void</span>**)&amp;env, JNI_VERSION_1_6);<br>    <span class="hljs-keyword">if</span> (env == <span class="hljs-literal">NULL</span> || !kInitSuc) &#123;<br>        __android_log_print(ANDROID_LOG_ERROR, kTag, <span class="hljs-string">&quot;ProxyOpen env null or kInitSuc:%d&quot;</span>, kInitSuc);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取 java 层的 JavaContext 对象</span><br>        jobject java_context_obj = env-&gt;<span class="hljs-built_in">CallStaticObjectMethod</span>(kJavaBridgeClass, kMethodIDGetJavaContext);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == java_context_obj) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取java层堆栈信息</span><br>        jstring j_stack = (jstring) env-&gt;<span class="hljs-built_in">GetObjectField</span>(java_context_obj, kFieldIDStack);<br>        <span class="hljs-comment">// 线程名</span><br>        jstring j_thread_name = (jstring) env-&gt;<span class="hljs-built_in">GetObjectField</span>(java_context_obj, kFieldIDThreadName);<br><br>        <span class="hljs-keyword">char</span>* thread_name = <span class="hljs-built_in">jstringToChars</span>(env, j_thread_name);<br>        <span class="hljs-keyword">char</span>* stack = <span class="hljs-built_in">jstringToChars</span>(env, j_stack);<br>        <span class="hljs-comment">// 创建 C++ 层的 JavaContex 对象</span><br>        <span class="hljs-function">JavaContext <span class="hljs-title">java_context</span><span class="hljs-params">(GetCurrentThreadId(), thread_name == <span class="hljs-literal">NULL</span> ? <span class="hljs-string">&quot;&quot;</span> : thread_name, stack == <span class="hljs-literal">NULL</span> ? <span class="hljs-string">&quot;&quot;</span> : stack)</span></span>;<br>        <span class="hljs-built_in">free</span>(stack);<br>        <span class="hljs-built_in">free</span>(thread_name);<br><br>        iocanary::IOCanary::<span class="hljs-built_in">Get</span>().<span class="hljs-built_in">OnOpen</span>(pathname, flags, mode, ret, java_context);<br><br>        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(java_context_obj);<br>        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(j_stack);<br>        env-&gt;<span class="hljs-built_in">DeleteLocalRef</span>(j_thread_name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>kJavaBridgeClass 等变量在 JNI_OnLoad 的时候就已经初始化好了。这些都是用来创建 java 层的对象的。</p><p>该函数就是创建出了一些必要的参数，然后调用了 OnOpen 方法，最终调用到</p><blockquote><p>IOInfoCollector::OnOpen</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IOInfoCollector::OnOpen</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">mode_t</span> mode, <span class="hljs-keyword">int</span> open_ret,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">const</span> JavaContext &amp;java_context)</span> </span>&#123;<br>    <span class="hljs-comment">//__android_log_print(ANDROID_LOG_DEBUG, kTag, &quot;OnOpen fd:%d; path:%s&quot;, open_ret, pathname);</span><br><br>    <span class="hljs-comment">// 文件打开失败返回 -1，成功返回文件描述符，太奇葩了</span><br>    <span class="hljs-keyword">if</span> (open_ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里刚开始会觉得很奇怪啊，为啥要使用 返回值作为key？？？因为 open_ret 是文件的描述符</span><br>    <span class="hljs-comment">// 文件已经被记录了</span><br>    <span class="hljs-keyword">if</span> (info_map_.<span class="hljs-built_in">find</span>(open_ret) != info_map_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">//__android_log_print(ANDROID_LOG_WARN, kTag, &quot;OnOpen fd:%d already in info_map_&quot;, open_ret);</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// make_shared 会在堆上创建对象，返回一个智能指针</span><br>    std::shared_ptr&lt;IOInfo&gt; info = std::make_shared&lt;IOInfo&gt;(pathname, java_context);<br>    <span class="hljs-comment">// 记录</span><br>    info_map_.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(open_ret, info));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，每次打开一个文件的时候，都会将其记录到 map 中，key 是文件的路径，value 是一个IOInfo类型的指针。</p><h4 id="read-write"><a href="#read-write" class="headerlink" title="read/write"></a>read/write</h4><p>我们使用同样的方式，可以追踪到 read/write 的相关hook逻辑：</p><blockquote><p>IOInfoCollector::CountRWInfo</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span></span><br><span class="hljs-function"><span class="hljs-title">IOInfoCollector::CountRWInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> FileOpType &amp;fileOpType, <span class="hljs-keyword">long</span> op_size, <span class="hljs-keyword">long</span> rw_cost)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (info_map_.<span class="hljs-built_in">find</span>(fd) == info_map_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int64_t</span> now = <span class="hljs-built_in">GetSysTimeMicros</span>();<br><br>    info_map_[fd]-&gt;op_cnt_++;<br>    info_map_[fd]-&gt;op_size_ += op_size;<br>    info_map_[fd]-&gt;rw_cost_us_ += rw_cost;<br><br>    <span class="hljs-comment">// 记录单次最大的读写时间</span><br>    <span class="hljs-keyword">if</span> (rw_cost &gt; info_map_[fd]-&gt;max_once_rw_cost_time_μs_) &#123;<br>        info_map_[fd]-&gt;max_once_rw_cost_time_μs_ = rw_cost;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果连续读写间隔小于   kContinualThreshold（8ms）</span><br>    <span class="hljs-keyword">if</span> (info_map_[fd]-&gt;last_rw_time_μs_ &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (now - info_map_[fd]-&gt;last_rw_time_μs_) &lt; kContinualThreshold) &#123;<br>        <span class="hljs-comment">// 本次连续读写时间</span><br>        info_map_[fd]-&gt;current_continual_rw_time_μs_ += rw_cost;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        info_map_[fd]-&gt;current_continual_rw_time_μs_ = rw_cost;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (info_map_[fd]-&gt;current_continual_rw_time_μs_ &gt;<br>        info_map_[fd]-&gt;max_continual_rw_cost_time_μs_) &#123;<br>        info_map_[fd]-&gt;max_continual_rw_cost_time_μs_ = info_map_[fd]-&gt;current_continual_rw_time_μs_;<br>    &#125;<br>    <span class="hljs-comment">// 记录读写时刻</span><br>    info_map_[fd]-&gt;last_rw_time_μs_ = now;<br><br>    <span class="hljs-comment">// 记录操作的 buffer 大小，这里是记录的最大值</span><br>    <span class="hljs-keyword">if</span> (info_map_[fd]-&gt;buffer_size_ &lt; op_size) &#123;<br>        info_map_[fd]-&gt;buffer_size_ = op_size;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果对一个文件又读又写，记录第一次的读写类型？？？</span><br>    <span class="hljs-keyword">if</span> (info_map_[fd]-&gt;op_type_ == FileOpType::kInit) &#123;<br>        info_map_[fd]-&gt;op_type_ = fileOpType;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面是记录了一些读写的数据。</p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><blockquote><p>IOInfoCollector::OnClose</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回 fd 对应的文件信息，在 info_map_ 中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">std::shared_ptr&lt;IOInfo&gt; <span class="hljs-title">IOInfoCollector::OnClose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> close_ret)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (info_map_.<span class="hljs-built_in">find</span>(fd) == info_map_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-comment">//__android_log_print(ANDROID_LOG_DEBUG, kTag, &quot;OnClose fd:%d not in info_map_&quot;, fd);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从打开到关闭的耗时</span><br>    info_map_[fd]-&gt;total_cost_μs_ = <span class="hljs-built_in">GetSysTimeMicros</span>() - info_map_[fd]-&gt;start_time_μs_;<br>    <span class="hljs-comment">// 文件大小</span><br>    info_map_[fd]-&gt;file_size_ = <span class="hljs-built_in">GetFileSize</span>(info_map_[fd]-&gt;path_.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 其他信息在读写时记录了</span><br>    std::shared_ptr&lt;IOInfo&gt; info = info_map_[fd];<br>    info_map_.<span class="hljs-built_in">erase</span>(fd);<br><br>    <span class="hljs-keyword">return</span> info;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里也记录了一些信息，注意，这里返回了指针，然后 map 里面的键值对被擦除了。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>经过上面对几个函数的hook，我们可以获取到读写文件时的详细信息。拿到这些信息之后，我们就可以进行相应的处理，判断该IO行为是否正常。</p><p>我们从 plugin 的 start 开始分析整个流程。</p><blockquote><p>com.tencent.matrix.iocanary.core.IOCanaryCore#initDetectorsAndHookers</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initDetectorsAndHookers</span><span class="hljs-params">(IOConfig ioConfig)</span> </span>&#123;<br>    <span class="hljs-keyword">assert</span> ioConfig != <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (ioConfig.isDetectFileIOInMainThread()<br>        || ioConfig.isDetectFileIOBufferTooSmall()<br>        || ioConfig.isDetectFileIORepeatReadSameFile()) &#123;<br>        IOCanaryJniBridge.install(ioConfig, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 监测 io 是否关闭了</span><br>    <span class="hljs-comment">//if only detect io closeable leak use CloseGuardHooker is Better</span><br>    <span class="hljs-keyword">if</span> (ioConfig.isDetectIOClosableLeak()) &#123;<br>        mCloseGuardHooker = <span class="hljs-keyword">new</span> CloseGuardHooker(<span class="hljs-keyword">this</span>);<br>        mCloseGuardHooker.hook();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里只分析第一个 if 里面的东西，第二个 if 里面的东西最后分析。</p><p>在第一个 if 里面，就是判断了是否开启某些监测，开启了才调用相应代码。</p><p>install 函数里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">install</span><span class="hljs-params">(IOConfig config, OnJniIssuePublishListener listener)</span> </span>&#123;<br>    MatrixLog.v(TAG, <span class="hljs-string">&quot;install sIsTryInstall:%b&quot;</span>, sIsTryInstall);<br>    <span class="hljs-keyword">if</span> (sIsTryInstall) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 加载 .so 文件</span><br>    <span class="hljs-comment">//load lib</span><br>    <span class="hljs-keyword">if</span> (!loadJni()) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;install loadJni failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//set listener</span><br>    sOnIssuePublishListener = listener;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//set config</span><br>        <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (config.isDetectFileIOInMainThread()) &#123;<br>                <span class="hljs-comment">// 调用 native 方法</span><br>                enableDetector(DetectorType.MAIN_THREAD_IO);<br>                <span class="hljs-comment">// ms to μs</span><br>                setConfig(ConfigKey.MAIN_THREAD_THRESHOLD, config.getFileMainThreadTriggerThreshold() * <span class="hljs-number">1000L</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (config.isDetectFileIOBufferTooSmall()) &#123;<br>                enableDetector(DetectorType.SMALL_BUFFER);<br>                setConfig(ConfigKey.SMALL_BUFFER_THRESHOLD, config.getFileBufferSmallThreshold());<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (config.isDetectFileIORepeatReadSameFile()) &#123;<br>                enableDetector(DetectorType.REPEAT_READ);<br>                setConfig(ConfigKey.REPEAT_READ_THRESHOLD, config.getFileRepeatReadThreshold());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//hook</span><br>        doHook();<br><br>        sIsTryInstall = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Error e) &#123;<br>        MatrixLog.printErrStackTrace(TAG, e, <span class="hljs-string">&quot;call jni method error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数做了这些事：</p><ul><li><p>先加载对应的 .so 库</p></li><li><p>根据 config 设置对应的监听，enableDetector 是一个native 代码，最终会调用到</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IOCanary::RegisterDetector</span><span class="hljs-params">(DetectorType type)</span> </span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (type) &#123;<br>        <span class="hljs-keyword">case</span> DetectorType::kDetectorMainThreadIO:<br>            <span class="hljs-comment">// 添加到detector容器集合</span><br>            detectors_.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileIOMainThreadDetector</span>());<br>            <span class="hljs-keyword">break</span>;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>进行 hook，这里的 hook 就是上面说的 hook 函数部分了。</li></ul><p>这里，我们知道，监听设置了，但是监听什么时候被调用呢？我们看 IOCanary 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">IOCanary::<span class="hljs-built_in">IOCanary</span>() &#123;<br>    exit_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 创建一个线程，detect 是被调用的函数，其参数是 this（隐式参数）</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">detect_thread</span><span class="hljs-params">(&amp;IOCanary::Detect, <span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// 分离线程，线程单独运行</span><br>    detect_thread.<span class="hljs-built_in">detach</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，它开启了一个线程，该线程运行的是 Detect 函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IOCanary::Detect</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Issue&gt; published_issues;<br>    <span class="hljs-comment">// 只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”，</span><br>    <span class="hljs-comment">// 就不必担心在哪里写delete p语句——实际上根本不需要编写这条语句，</span><br>    <span class="hljs-comment">// 托管 p 的 shared_ptr 对象在消亡时会自动执行delete p。</span><br>    <span class="hljs-comment">// 有点 java 的味道了</span><br>    std::shared_ptr&lt;IOInfo&gt; file_io_info;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        published_issues.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">TakeFileIOInfo</span>(file_io_info);<br><br>        <span class="hljs-comment">// exit_ 为0， 就跳出了</span><br>        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// detectors_ 是监听集合</span><br>        <span class="hljs-comment">// 具体可见 IOCanary::RegisterDetector 方法</span><br>        <span class="hljs-comment">// 在对一个文件操作完毕之后，open -&gt; read/write -&gt; close，才会回调</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> detector : detectors_) &#123;<br>            detector-&gt;<span class="hljs-built_in">Detect</span>(env_, *file_io_info, published_issues);<br>        &#125;<br><br>        <span class="hljs-comment">// 调用回调方法</span><br>        <span class="hljs-comment">// 该监听是在 iocanary::JNI_OnLoad 里面设置的</span><br>        <span class="hljs-keyword">if</span> (issued_callback_ &amp;&amp; !published_issues.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">issued_callback_</span>(published_issues);<br>        &#125;<br><br>        <span class="hljs-comment">// 释放指针</span><br>        file_io_info = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面是一个生产者-消费者模式，Detect 扮演的是消费者的角色，它调用 TakeFileIOInfo 函数获取一个 IOInfo 的指针，然后对它进行处理，我们可以看到，在 for 里面，它将这个指针传递到了我们之前设置的监听函数的回调参数里面。这样，在监听的回调函数里面，我们就可以拿到本次IO的各种信息了。</p><p>这里是生产者-消费者模式，所以我们还要搞清楚，谁是生产者。搜索，queue_cv_ 变量，我们可以发现如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IOCanary::OnClose</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> close_ret)</span> </span>&#123;<br>    std::shared_ptr&lt;IOInfo&gt; info = collector_.<span class="hljs-built_in">OnClose</span>(fd, close_ret);<br>    <span class="hljs-keyword">if</span> (info == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">OfferFileIOInfo</span>(info);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IOCanary::OfferFileIOInfo</span><span class="hljs-params">(std::shared_ptr&lt;IOInfo&gt; file_io_info)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex_)</span></span>;<br>    queue_.<span class="hljs-built_in">push_back</span>(file_io_info);<br>    <span class="hljs-comment">// 通知等待线程，添加进去了一个元素</span><br>    queue_cv_.<span class="hljs-built_in">notify_one</span>();<br>    lock.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从 queue_ 里面获取队头的 file_io_info 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IOCanary::TakeFileIOInfo</span><span class="hljs-params">(std::shared_ptr&lt;IOInfo&gt; &amp;file_io_info)</span> </span>&#123;<br>    <span class="hljs-comment">// std::unique_lock对象以独占所有权的方式(unique owership)管理mutex对象的上锁和解锁操作，</span><br>    <span class="hljs-comment">// 即在unique_lock对象的声明周期内，它所管理的锁对象会一直保持上锁状态；</span><br>    <span class="hljs-comment">// 而unique_lock的生命周期结束之后，它所管理的锁对象会被解锁。</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queue_mutex_)</span></span>;<br><br>    <span class="hljs-comment">// 如果队列为空，那就一直等待，开起来像是一个生产者-消费者模式</span><br>    <span class="hljs-keyword">while</span> (queue_.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-comment">// wait 会释放锁</span><br>        queue_cv_.<span class="hljs-built_in">wait</span>(lock);<br>        <span class="hljs-keyword">if</span> (exit_) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为参数是引用，所以这里会改变传递进来的实参值</span><br>    file_io_info = queue_.<span class="hljs-built_in">front</span>();<br>    <span class="hljs-comment">// pop 居然没有返回 pop 出来的值，难怪要多加一句</span><br>    queue_.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>OnClose 是我们的 hook 函数的代码，它在文件关闭的时候会被调用，所以结论就是文件关闭的时候，会返回（上面提到过）一个 IOInfo 的指针，然后将它放到队列中，通知等待线程开始执行，最后就回调到了我们的监听代码中。</p><h3 id="主线程IO"><a href="#主线程IO" class="headerlink" title="主线程IO"></a>主线程IO</h3><p>我们看看主线程IO的监听代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileIOMainThreadDetector::Detect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> IOCanaryEnv &amp;env, <span class="hljs-keyword">const</span> IOInfo &amp;file_io_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      std::vector&lt;Issue&gt;&amp; issues)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetMainThreadId</span>() == file_io_info.java_context_.thread_id_) &#123;<br>        <span class="hljs-keyword">int</span> type = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 最大读写时间超过 13ms</span><br>        <span class="hljs-keyword">if</span> (file_io_info.max_once_rw_cost_time_μs_ &gt; IOCanaryEnv::kPossibleNegativeThreshold) &#123;<br>            type = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 一次连续读写时间超过 500ms</span><br>        <span class="hljs-keyword">if</span>(file_io_info.max_continual_rw_cost_time_μs_ &gt; env.<span class="hljs-built_in">GetMainThreadThreshold</span>()) &#123;<br>            type |= <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-function">Issue <span class="hljs-title">issue</span><span class="hljs-params">(kType, file_io_info)</span></span>;<br>            issue.repeat_read_cnt_ = type;  <span class="hljs-comment">//use repeat to record type</span><br>            <span class="hljs-built_in">PublishIssue</span>(issue, issues);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没啥好说的，就是判断一些阈值而已。如果你想监测别的数据，可以自己设置一些监听。</p><h3 id="重复读"><a href="#重复读" class="headerlink" title="重复读"></a>重复读</h3><p>这个监听我就不贴代码了，感觉它现在有点鸡肋，我的 note 分支里面有详细注释，有兴趣可以查看。</p><p>其实，我觉得可以统计一下App在一次运行过程中，每个文件被读取的次数。反正你可以获取到每次IO的所有信息，想做什么就做什么。</p><h3 id="小-Buffer-的io"><a href="#小-Buffer-的io" class="headerlink" title="小 Buffer 的io"></a>小 Buffer 的io</h3><p>我们知道，对于文件系统是以block为单位读写，对于磁盘是以page 为单位读写，看起来即使我们在应用程序上面使用很小的Buffer，在底层应该差别不大，那是不是这样呢？</p><p>实际上不是的，因为如果 buffer 过小，会导致多次无用的系统调用，write与read的次数变多，这样性能就下降了，那么应该如何选择 buffer的大小呢？可以参考文件系统的 block size 的大小来决定。一般是 4K。</p><p>那么又来了一个问题？buffer搞很大会咋样呢？实际上如果你自己测试一下的话，会发现4K往上的话，收益就开始变小了，甚至会降低。所以一般推荐 4K 以上，也不要搞太大。</p><p>看一下监测小buffer的代码，很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileIOSmallBufferDetector::Detect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> IOCanaryEnv &amp;env, <span class="hljs-keyword">const</span> IOInfo &amp;file_io_info,</span></span><br><span class="hljs-params"><span class="hljs-function">                                       std::vector&lt;Issue&gt; &amp;issues)</span> </span>&#123;<br>    <span class="hljs-comment">//__android_log_print(ANDROID_LOG_ERROR, &quot;FileIOSmallBufferDetector&quot;, &quot;Detect buffer_size:%d threshold:%d op_cnt:%d rw_cost:%d&quot;,</span><br>    <span class="hljs-comment">//                  file_io_info.buffer_size_, env.GetSmallBufferThreshold(), file_io_info.op_cnt_, file_io_info.max_continual_rw_cost_time_μs_);</span><br><br>    <span class="hljs-comment">// 读写次数 &gt; 20</span><br>    <span class="hljs-comment">// 读写总数量 / 读写次数 &lt; 4096</span><br>    <span class="hljs-comment">// 最大连续读写耗时 &gt;= 13ms</span><br>    <span class="hljs-keyword">if</span> (file_io_info.op_cnt_ &gt; env.kSmallBufferOpTimesThreshold<br>        &amp;&amp; (file_io_info.op_size_ / file_io_info.op_cnt_) &lt; env.<span class="hljs-built_in">GetSmallBufferThreshold</span>()<br>        &amp;&amp; file_io_info.max_continual_rw_cost_time_μs_ &gt;= env.kPossibleNegativeThreshold) &#123;<br><br>        <span class="hljs-built_in">PublishIssue</span>(<span class="hljs-built_in">Issue</span>(kType, file_io_info), issues);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="未关闭的文件"><a href="#未关闭的文件" class="headerlink" title="未关闭的文件"></a>未关闭的文件</h3><p>除了上面监测主线程的各种问题之外，该库还提供了一个特殊的功能，监测未关闭的文件操作。</p><p>其大致原理是使用了 CloseGuard 类，这个类的用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CloseGuard mCloseGuard = CloseGuard.get();<br><br>...<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputQueue</span><span class="hljs-params">()</span> </span>&#123;<br>       mPtr = nativeInit(<span class="hljs-keyword">new</span> WeakReference&lt;InputQueue&gt;(<span class="hljs-keyword">this</span>), Looper.myQueue());<br><br>       mCloseGuard.open(<span class="hljs-string">&quot;dispose&quot;</span>);<br>   &#125;<br><br>...<br>       <br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           dispose(<span class="hljs-keyword">true</span>);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">super</span>.finalize();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;<br>       dispose(<span class="hljs-keyword">false</span>);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> finalized)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (mCloseGuard != <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">if</span> (finalized) &#123;<br>               mCloseGuard.warnIfOpen();<br>           &#125;<br>           mCloseGuard.close();<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (mPtr != <span class="hljs-number">0</span>) &#123;<br>           nativeDispose(mPtr);<br>           mPtr = <span class="hljs-number">0</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>用法还是挺简单的，就是利用了 finalize 方法。</p><p>它先在构造方法里面，调用了 CloseGuard 的 open 方法，open方法里面记录了一个标识。假设，我们使用完该类后，没有调用该类的 dispose 方法，那么 CloseGuard  里面的标识就还存在，那么当该类被回收的时候，会触发 finalize 方法，然后执行到 CloseGuard.warnIfOpen 方法，这样就会弹出警告。</p><p>所以它的原理，其实就是利用了 finalize 来监测我们是否成对的调用了某些方法。</p><p>我们可以利用这个类，因为系统的很多类都使用了 CloseGuard ，我们开启严格模式后能监测一些问题，就是利用的这个原理。</p><p>所以，我们需要 hook 这个类，监测到未关闭的文件，就提出警告。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryHook</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// hook 系统的 CloseGuard 类，该类是用于监测某些类是否正常关闭的，比如 cursor</span><br>        <span class="hljs-comment">// 具体是先看一下 android.view.InputQueue 的源码就好了，几十行</span><br>        <span class="hljs-comment">// 大致原理就是依赖 finalize 方法来监测是否有调用对应的  close 方法</span><br>        <span class="hljs-comment">// 所以，我们使用反射开启这个类的功能，然后 hook 它，在里面做我们的逻辑</span><br>        Class&lt;?&gt; closeGuardCls = Class.forName(<span class="hljs-string">&quot;dalvik.system.CloseGuard&quot;</span>);<br>        Class&lt;?&gt; closeGuardReporterCls = Class.forName(<span class="hljs-string">&quot;dalvik.system.CloseGuard$Reporter&quot;</span>);<br>        Method methodGetReporter = closeGuardCls.getDeclaredMethod(<span class="hljs-string">&quot;getReporter&quot;</span>);<br>        Method methodSetReporter = closeGuardCls.getDeclaredMethod(<span class="hljs-string">&quot;setReporter&quot;</span>, closeGuardReporterCls);<br>        Method methodSetEnabled = closeGuardCls.getDeclaredMethod(<span class="hljs-string">&quot;setEnabled&quot;</span>, <span class="hljs-keyword">boolean</span>.class);<br><br>        sOriginalReporter = methodGetReporter.invoke(<span class="hljs-keyword">null</span>);<br><br>        methodSetEnabled.invoke(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">// open matrix close guard also</span><br>        MatrixCloseGuard.setEnabled(<span class="hljs-keyword">true</span>);<br><br>        ClassLoader classLoader = closeGuardReporterCls.getClassLoader();<br>        <span class="hljs-keyword">if</span> (classLoader == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        methodSetReporter.invoke(<span class="hljs-keyword">null</span>, Proxy.newProxyInstance(classLoader,<br>            <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;closeGuardReporterCls&#125;,<br>                <span class="hljs-comment">// hook 类</span><br>            <span class="hljs-keyword">new</span> IOCloseLeakDetector(issueListener, sOriginalReporter)));<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;tryHook exp=%s&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们在 IOCloseLeakDetector 里面，就可以处理问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;invoke method: %s&quot;</span>, method.getName());<br>        <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;report&quot;</span>)) &#123;<br>            ...<br><br>            <span class="hljs-keyword">if</span> (isPublished(stackKey)) &#123;<br>                ...<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 这里处理 issue</span><br>                Issue ioIssue = <span class="hljs-keyword">new</span> Issue(SharePluginInfo.IssueType.ISSUE_IO_CLOSABLE_LEAK);<br>                ioIssue.setKey(stackKey);<br>                JSONObject content = <span class="hljs-keyword">new</span> JSONObject();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    content.put(SharePluginInfo.ISSUE_FILE_STACK, stackKey);<br>                &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br><span class="hljs-comment">//                e.printStackTrace();</span><br>                    MatrixLog.e(TAG, <span class="hljs-string">&quot;json content error: %s&quot;</span>, e);<br>                &#125;<br>                ioIssue.setContent(content);<br>                publishIssue(ioIssue);<br>                MatrixLog.i(TAG, <span class="hljs-string">&quot;close leak issue publish, key:%s&quot;</span>, stackKey);<br>                markPublished(stackKey);<br>            &#125;<br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(originalReporter, args);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里，就触发了 publishIssue 方法。</p><p>有一点需要注意，这里是开启了 CloseGuard，所以使用了 CloseGuard 的类都可以监测到，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;android.view.InputQueue&quot;</span>);<br>    Object o = aClass.newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br><br><span class="hljs-comment">//need to trigger gc to detect leak</span><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Runtime.getRuntime().gc();<br>        Runtime.getRuntime().runFinalization();<br>        Runtime.getRuntime().gc();<br>    &#125;<br>&#125;).start();<br><br></code></pre></td></tr></table></figure><p>这里我们使用了，InputQueue，它里面使用了 CloseGuard，而我们没有调用其 dispose 方法，所以这个函数会被检测出来使用有问题。</p><h3 id="处理issue"><a href="#处理issue" class="headerlink" title="处理issue"></a>处理issue</h3><p>上面检测出来的问题，最终都会汇总到 com.tencent.matrix.plugin.Plugin#onDetectIssue 这个方法里面，然后对 Issue 进行处理，其实就是转为json，用于可视化展示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDetectIssue</span><span class="hljs-params">(Issue issue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (issue.getTag() == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// set default tag</span><br>        issue.setTag(getTag());<br>    &#125;<br>    issue.setPlugin(<span class="hljs-keyword">this</span>);<br>    JSONObject content = issue.getContent();<br>    <span class="hljs-comment">// add tag and type for default</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (issue.getTag() != <span class="hljs-keyword">null</span>) &#123;<br>            content.put(Issue.ISSUE_REPORT_TAG, issue.getTag());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (issue.getType() != <span class="hljs-number">0</span>) &#123;<br>            content.put(Issue.ISSUE_REPORT_TYPE, issue.getType());<br>        &#125;<br>        content.put(Issue.ISSUE_REPORT_PROCESS, MatrixUtil.getProcessName(application));<br>        content.put(Issue.ISSUE_REPORT_TIME, System.currentTimeMillis());<br><br>    &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;json error&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-comment">// 这里的回调是整个 matrix 的一个回调，我们可以在这个回调里面进行个性化处理，比如上报后台之类的</span><br>    <span class="hljs-comment">//MatrixLog.e(TAG, &quot;detect issue:%s&quot;, issue);</span><br>    pluginListener.onReportIssue(issue);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zhuanlan.zhihu.com/p/36426206">https://zhuanlan.zhihu.com/p/36426206</a></p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>番外篇：重定位</title>
    <link href="/2020/08/27/blog_bak/Blog/C++/%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <url>/2020/08/27/blog_bak/Blog/C++/%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>很久很久以前，在一个非常遥远的银河系……</p><p>在最开始的时候，程序员需要先将程序写在纸上。当程序要被运行的时候，程序员人工的将它写的程序写到储存设备上，最原始的储存设备是纸带，即在纸上打孔。</p><p>假设有一种计算机，它的每条指令是1个字节，也就是8位。我们假设有一种跳转指令，它的高4位是 0001，表示这是一种跳转指令。低4位存放的是跳转目的的绝对地址。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0001</span> <span class="hljs-number">0100</span><br><span class="hljs-symbol">1 </span>...<br><span class="hljs-symbol">2 </span>...<br><span class="hljs-symbol">3 </span>...<br><span class="hljs-symbol">4 </span><span class="hljs-number">1000</span> <span class="hljs-number">0111</span><br><span class="hljs-symbol">5 </span>...<br></code></pre></td></tr></table></figure><p>看上面的例子，这个程序的第一条指令是一个跳转指令，它的目的地址是第 5 跳指令（<strong>注意，第 5 条指令的绝对地址是 4</strong>）。</p><p>现在问题来了，程序写好了之后，并不是永远不变的。比如，我们想在第1条指令之后，第5条指令之前加入某些指令，那么第5条指令及后面的指令需要相应的往后移动，且第1条指令的目的地址也需要调整。在这个过程中程序员需要人工的重新计算每个子程序或跳转的目标地址。当程序修改的时候，这些位置都要重新计算，非常容易出错，而且又耗时。<strong>这样重新计算各个目标的地址的过程就叫做重定位</strong>。</p><p>如果，某个程序需要多个纸带储存，那么就会出现跨纸带跳转的情况，那么重定位就更加复杂了。</p><p>这个时候，汇编语言就出现了。汇编语言使用符号与标记来解决这些问题。举个例子，在前面的程序中，我们将第5条指令开始的子程序叫做 foo，那么第1条汇编就可以写成：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">jmp</span> foo<br></code></pre></td></tr></table></figure><p>使用了符号命令的子程序之后，不管 foo 之前插入或删除了多少指令，汇编器在每次汇编程序的时候，都会重新计算 foo 子程序的地址。然后将所有引用 foo 的指令修改位这个正确的地址。</p><p><strong>符号</strong>，表示一个地址，这个地址可能是一段子程序的地址地址，也可能是一个变量的起始地址。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机捡漏</title>
    <link href="/2020/08/25/blog_bak/Blog/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8D%A1%E6%BC%8F/"/>
    <url>/2020/08/25/blog_bak/Blog/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8D%A1%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>之前在看《深入理解虚拟机》的时候，有点东西一直没懂，这里主要是做一些补充，避免后面自己又忘记了。</p><h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p><p>这个是啥意思呢？看下面：</p><p>在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p><p>比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。</p><p>然后等 Class 加载到内存中之后，会将符号引用替换为具体的 Class 地址。</p><h3 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h3><p>直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。<strong>如果有了直接引用，那引用的目标必定已经被加载入内存中了</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>000-序言</title>
    <link href="/2020/08/19/blog_bak/Blog/C++/000-%E5%BA%8F%E8%A8%80/"/>
    <url>/2020/08/19/blog_bak/Blog/C++/000-%E5%BA%8F%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>学习C++纯粹就是因为想看懂Matrix里面的所有东西，而且对我之后的逆向学习计划有很大帮助。</p><p>以前我学东西一般都是撸书，虽然确实可以学的很全，但是真的是太慢了，直到学 Flutter 的时候，同事推荐了一个视频，发现很不错，讲的是源码，体验下来的感觉真的是有人讲与自己琢磨的效率是天差地别。所以，以后学东西，尽量先撸视频，然后查漏补缺再去撸书。</p><p>而且，我看书有个最大的问题就是会一开始就找一些特别经典的书籍开始看。但是实际上，我自认为已经精通java了，但是看一些经典的书籍（核心技术一二册），还是会学到很多东西。这样导致的问题就是，作为一个初学者，看这些书很慢很慢，抓不到重点，容易半途而废。</p><p>如果没有其他事情中断的话，预计耗时1-2周。</p><p>学习视频地址：</p><p><a href="https://www.bilibili.com/video/av41559729/">https://www.bilibili.com/video/av41559729/</a></p><p>讲义：</p><p><a href="https://github.com/AnkerLeng/Cpp-0-1-Resource">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>001-语法捡漏</title>
    <link href="/2020/08/19/blog_bak/Blog/C++/001-%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F/"/>
    <url>/2020/08/19/blog_bak/Blog/C++/001-%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="指针常量与常量指针"><a href="#指针常量与常量指针" class="headerlink" title="指针常量与常量指针"></a>指针常量与常量指针</h3><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><blockquote><p>C++ primer 中的就近原则：const 里 * 近，就是指针不可变，离 int 近，就是值不可变。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * p1 = &amp;a; <br>p1 = &amp;b; <span class="hljs-comment">//正确</span><br><span class="hljs-comment">//*p1 = 100;  报错</span><br><br><br><span class="hljs-comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span><br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p2 = &amp;a;<br><span class="hljs-comment">//p2 = &amp;b; //错误</span><br>*p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span><br><br>    <span class="hljs-comment">//const既修饰指针又修饰常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p3 = &amp;a;<br><span class="hljs-comment">//p3 = &amp;b; //错误</span><br><span class="hljs-comment">//*p3 = 100; //错误</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>常量指针的用处之一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">/* data */</span><br>    <span class="hljs-keyword">int</span> age;<br>    string name;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 这里的参数是值传递，不是 java 的引用传递，相当于是将 student 拷贝了一份</span><br><span class="hljs-comment"> * 所以，如果结构体很重，那么我们一般传递地址</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStudentBad</span><span class="hljs-params">(Student s)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; s.age &lt;&lt; s.name;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  这里虽然使用了指针，但是对结构体的控制就减弱了，因为可以随便修改，而且会影响到原结构体变量</span><br><span class="hljs-comment"> *  解决办法是使用 const 修饰</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStudentGood</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student *s)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">// Student const *s;</span><br>    <span class="hljs-comment">// const Student *s;</span><br><br>    cout &lt;&lt; s-&gt;age &lt;&lt; s-&gt;name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a>new 关键字</h3><p>C++ 中有4个区，其中局部变量在栈区：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    Student stu;<br>    stu.age = <span class="hljs-number">10</span>;<br>    stu.name = <span class="hljs-string">&quot;xiao li&quot;</span>;<br><br>    <span class="hljs-keyword">int</span> b = <span class="hljs-number">100</span>;<br>    cout &lt;&lt; &amp;stu &lt;&lt; endl;<br>    cout &lt;&lt; &amp;b &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果会发现，stu 与 b 的地址端很近，说明他们都在栈区，注意与java的区别。想要让对象分配在堆区，需要使用 new 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Student * stu2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;xiao mao&quot;</span>&#125;);<br>cout &lt;&lt; stu2 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这样，stu2 就分配到了堆区，打印发现地址段离栈区很远。</p><p>使用 new 关键字，还有一个需要注意的地方，看如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//A()&#123;a=1;&#125;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *a1 = <span class="hljs-keyword">new</span> A;<br>    A *a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br><br>    cout &lt;&lt; a1-&gt;a &lt;&lt; endl; <span class="hljs-comment">//输出:-842150451</span><br><br>    cout &lt;&lt; a2-&gt;a &lt;&lt; endl; <span class="hljs-comment">//输出0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因看下面链接：</p><p><a href="https://www.zhihu.com/question/35843839">https://www.zhihu.com/question/35843839</a></p><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p><strong>引用的本质在c++内部实现是一个指针常量.</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nim">//发现是引用，转换为 <span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> = &amp;a;<br><span class="hljs-built_in">void</span> <span class="hljs-keyword">func</span>(<span class="hljs-built_in">int</span>&amp; <span class="hljs-keyword">ref</span>)&#123;<br><span class="hljs-keyword">ref</span> = <span class="hljs-number">100</span>; // <span class="hljs-keyword">ref</span>是引用，转换为*<span class="hljs-keyword">ref</span> = <span class="hljs-number">100</span><br>&#125;<br><span class="hljs-built_in">int</span> main()&#123;<br><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>    <br>    //自动转换为 <span class="hljs-built_in">int</span>* <span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改<br><span class="hljs-built_in">int</span>&amp; <span class="hljs-keyword">ref</span> = a; <br><span class="hljs-keyword">ref</span> = <span class="hljs-number">20</span>; //内部发现<span class="hljs-keyword">ref</span>是引用，自动帮我们转换为: *<span class="hljs-keyword">ref</span> = <span class="hljs-number">20</span>;<br>    <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; <span class="hljs-keyword">ref</span> &lt;&lt; endl;<br>    <br><span class="hljs-keyword">func</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><p>一个奇怪的问题：</p><blockquote><p>error: cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> &amp;r = <span class="hljs-number">10</span>; <span class="hljs-comment">// 这行代码会报错</span><br><span class="hljs-comment">// 不過，加上 const 的話倒是可以：</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>这是因为：10是一个常量，常量是記憶體中臨時的資料，無法對常量取址。而加上 const 之后，編譯器會將以上轉換為像是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> _n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = _n;<br></code></pre></td></tr></table></figure><p>類似地，以下會編譯失敗：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">int</span> &amp;r = a + b; // error: cannot <span class="hljs-keyword">bind</span> non-<span class="hljs-keyword">const</span> lvalue reference <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> &#x27;<span class="hljs-built_in">int</span>&amp;&#x27; to an rvalue <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> &#x27;<span class="hljs-built_in">int</span>&#x27;<br></code></pre></td></tr></table></figure><p>這是因為 <code>a + b</code> 運算出的結果，會是在臨時的記憶體空間中，無法取址；類似地，若想通過編譯，必須加上 <code>const</code>。</p><h3 id="struct-与-class-的区别"><a href="#struct-与-class-的区别" class="headerlink" title="struct 与 class 的区别"></a>struct 与 class 的区别</h3><p>struct 中的成员默认是公共的，class中的成员默认是私有的。</p><h3 id="pragma-once"><a href="#pragma-once" class="headerlink" title="pragma once"></a>pragma once</h3><p>防止文头件重复包含。</p><p>将头文件与实现拆开后，类的实现方法需要指定所属类，比如：</p><blockquote><p>头文件中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">()</span></span>;  <br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>实现中：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P::setX</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 加上 :: </span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2.1  括号法，常用</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="hljs-comment">//Person p2();</span><br><br><span class="hljs-comment">//2.2 显式法</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <br>Person p3 = <span class="hljs-built_in">Person</span>(p2);<br><span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br><span class="hljs-comment">//2.3 隐式转换法</span><br>Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br>    <br>    <span class="hljs-comment">// 这相当于 Person p6;</span><br>    <span class="hljs-built_in">Person</span> (p6);<br>&#125;<br></code></pre></td></tr></table></figure><p>拷贝构造函数的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Person</span>(<span class="hljs-keyword">const</span> Person&amp; p) &#123; <span class="hljs-comment">// const + &amp;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = p.mAge;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员变量</p><ul><li> 所有对象共享同一份数据</li><li> 在编译阶段分配内存</li><li> <strong>类内声明，类外初始化</strong></li></ul><h3 id="常函数与常对象"><a href="#常函数与常对象" class="headerlink" title="常函数与常对象"></a>常函数与常对象</h3><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>m_A = <span class="hljs-number">0</span>;<br>m_B = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-comment">//const Type* const pointer;</span><br><span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span><br><span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br><span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-comment">//mA = 10000;</span><br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在类的最上面加上 friend 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><br><span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">goodGay</span>;</span><br><br><span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数名改为 operator+ 即可</span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Person&amp; p) &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//后置++，注意这里使用了占位符</span><br>MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) &#123;<br><span class="hljs-comment">//先返回</span><br>MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br>m_Num++;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个匿名对象的使用案例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdd</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重载了函数调用符</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 + v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyAdd add;<br><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-comment">//匿名对象调用  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承有三种方式：</p><p>private</p><p>protected</p><p>public</p><p>这3个其实很好理解，就是子类对父类继承的东西的一种限制方式。拿 private 继承来说，父类的 public 属性，到了子类也变成 private 了。</p><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p><h3 id="访问父类同名-静态-成员"><a href="#访问父类同名-静态-成员" class="headerlink" title="访问父类同名(静态)成员"></a>访问父类同名(静态)成员</h3><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，<strong>子类会隐藏父类中所有同名成员函数（包括重载）</strong>，<strong>加作用域</strong>可以访问到父类中同名函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">s.Base::<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>可以使用开发人员工具查看一下对象模型，了解一下虚基类指针与虚基类表。</p><p>用来解决菱形继承数据重复的问题。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Speak函数就是虚函数</span><br><span class="hljs-comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>子类继承 Animal 之后，如果重写了 speak 方法，那么可以正常多态行为，如果 Animal 的 speak 方法没有 virtual 修饰，那么多态行为就不正常，这点需要与 Java 区分开来。</p><p>其原理是虚方法表，java的多态也是类似的，子类有自己的方法表，父类有自己的方法表，在调用方法的时候，会判断 this 的指向，然后调用对应的方法表的方法。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//纯虚函数</span><br><span class="hljs-comment">//类中只要有一个纯虚函数就称为抽象类</span><br><span class="hljs-comment">//抽象类无法实例化对象</span><br><span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> :</span><span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="虚析构与纯虚析构"><a href="#虚析构与纯虚析构" class="headerlink" title="虚析构与纯虚析构"></a>虚析构与纯虚析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br><span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span><br><span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span><br>    <span class="hljs-comment">// 这里是只调用了父类的析构函数，没有调用子类的</span><br><span class="hljs-keyword">delete</span> animal;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要给父类析构函数加上 virtual：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Animal虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>模板的通用性并不是万能的</p><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123; <br>   a = b;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了。</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//普通函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a == b)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="hljs-comment">//具体化优先于常规模板</span><br><span class="hljs-comment">// 对上面的一个补充</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">myCompare</span><span class="hljs-params">(Person &amp;p1, Person &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类模板中成员函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T2</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//成员函数类内声明</span><br><span class="hljs-built_in">Person</span>(T1 name, T2 age);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>T1 m_Name;<br>T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">// 与普通实现相比：需要声明模板，需要写尖括号</span><br><span class="hljs-comment">//构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T2</span>&gt;</span><br>Person&lt;T1, T2&gt;::<span class="hljs-built_in">Person</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T2</span>&gt;</span><br><span class="hljs-keyword">void</span> Person&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到（这个不是很明白，为啥直接包含了cpp文件，就能链接到？？？）</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>015-Matrix源码分析：检测内存中重复的Bitmap</title>
    <link href="/2020/08/19/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/015-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84Bitmap/"/>
    <url>/2020/08/19/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/015-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84Bitmap/</url>
    
    <content type="html"><![CDATA[<p>在分析activity的引用链的时候，我们还可以顺便分析一下，内存中有没有重复的Bitmap，如果有的话，就可以看看是什么原因导致的，这样对优化内存有帮助。</p><p>分析该任务的类是 <code>DuplicatedBitmapAnalyzer</code>。用过 as 的都知道它有一个 profiler功能，里面可以对CPU/网络/内存做分析。而内存分析的话，它也提供了 dump 与分析 hprof 文件的功能。</p><p>所以，我们查看这个模块的相关源码的话，就可以找到这个类：</p><blockquote><p><a href="https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib/heap/memoryanalyzer/DuplicatedBitmapAnalyzerTask.java">https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib/heap/memoryanalyzer/DuplicatedBitmapAnalyzerTask.java</a></p></blockquote><p>里面是使用了一个算法来分析内存中的相同的bitmap。</p><p>先看看上面链接的这个类，然后再看 matrix 的这个类，会更好一点，因为 matrix 的这个类加了不少东西，导致方法很长，看起来就不好懂。</p><p>那我们就先分析 google 的那个类，它的逻辑很纯粹，好理解这个算法。</p><p>先说一下这个算法是如何做的：</p><p>首先，要判断两个 Bitmap 是否是一样的，只需要判断它的 mBuffer 字段是不是一样的，所以就归结为<strong>比较两个 byte 数组是否一样</strong>。</p><p>内存中的 Bitmap 对象那么多，怎么才能列举出所有相等的 mBuffer 呢？</p><p>第一步，将 mBuffer 按照 mBuffer[0] 的值进行分组。假设，得到了 8 组。</p><p>第二部，遍历上面得到的 8 组内容，对每组按照 mBuffer[1] 的值再进行分组。</p><p>重复上面的过程。一直到有 mBuffer 已经被遍历完了，就检查一下被遍历完成的集合大小，是否大于1。如果大于1，则说明这个集合里面的 mBuffer 是一样的。所以就找到了所有的相同的 mBuffer。下面是具体的实现代码：</p><blockquote><p>DuplicatedBitmapAnalyzerTask#analyze</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> columnIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!commonPrefixSets.isEmpty()) &#123;<br>    <span class="hljs-keyword">for</span> (Set&lt;ArrayInstance&gt; commonPrefixArrays : commonPrefixSets) &#123;<br>        Map&lt;Object, Set&lt;ArrayInstance&gt;&gt; entryClassifier = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<br>                commonPrefixArrays.size());<br>        <span class="hljs-keyword">for</span> (ArrayInstance arrayInstance : commonPrefixArrays) &#123;<br>            Object element = cachedValues.get(arrayInstance)[columnIndex];<br>            <span class="hljs-keyword">if</span> (entryClassifier.containsKey(element)) &#123;<br>                entryClassifier.get(element).add(arrayInstance);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Set&lt;ArrayInstance&gt; instanceSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>                instanceSet.add(arrayInstance);<br>                entryClassifier.put(element, instanceSet);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Set&lt;ArrayInstance&gt; branch : entryClassifier.values()) &#123;<br>            <span class="hljs-keyword">if</span> (branch.size() &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// Unique branch, ignore it and it won&#x27;t be counted towards duplication.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            Set&lt;ArrayInstance&gt; terminatedArrays = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>            <span class="hljs-comment">// Move all ArrayInstance that we have hit the end of to the candidate result list.</span><br>            <span class="hljs-keyword">for</span> (ArrayInstance instance : branch) &#123;<br>                <span class="hljs-keyword">if</span> (instance.getLength() == columnIndex + <span class="hljs-number">1</span>) &#123;<br>                    terminatedArrays.add(instance);<br>                &#125;<br>            &#125;<br>            branch.removeAll(terminatedArrays);<br>            <span class="hljs-comment">// Exact duplicated arrays found.</span><br>            <span class="hljs-keyword">if</span> (terminatedArrays.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">int</span> byteArraySize = -<span class="hljs-number">1</span>;<br>                ArrayList&lt;Instance&gt; duplicateBitmaps = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (ArrayInstance terminatedArray : terminatedArrays) &#123;<br>                    duplicateBitmaps.add(byteArrayToBitmapMap.get(terminatedArray));<br>                    byteArraySize = terminatedArray.getLength();<br>                &#125;<br>                results.add(<br>                        <span class="hljs-keyword">new</span> DuplicatedBitmapEntry(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(duplicateBitmaps),<br>                                byteArraySize));<br>            &#125;<br>            <span class="hljs-comment">// If there are ArrayInstances that have identical prefixes and haven&#x27;t hit the</span><br>            <span class="hljs-comment">// end, add it back for the next iteration.</span><br>            <span class="hljs-keyword">if</span> (branch.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                reducedPrefixSets.add(branch);<br>            &#125;<br>        &#125;<br>    &#125;<br>    commonPrefixSets.clear();<br>    commonPrefixSets.addAll(reducedPrefixSets);<br>    reducedPrefixSets.clear();<br>    columnIndex++;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实还有一种找出重复 mBuffer  的方式，比较简单，就是对 mBuffer 进行 md5或者hash。比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理 heap，找出有相同 buffer 的 bitmap 的 instance，存放在 map 中。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> objMap 存放相同 buffer 的 instance 的map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> heap 待处理的 heap</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> classObj 这里是  bitmap 的封装对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">analyzeHeapForSameBuffer</span><span class="hljs-params">(Map&lt;String, ArrayList&lt;ObjNode&gt;&gt; objMap,</span></span><br><span class="hljs-params"><span class="hljs-function">                                Heap heap, ClassObj classObj)</span></span>&#123;<br>    List&lt;Instance&gt; instances = classObj.getHeapInstances(heap.getId());<br>    <span class="hljs-keyword">for</span> (Instance instance : instances)&#123;<br>        ArrayInstance buffer = HahaHelper.fieldValue(HahaHelper.classInstanceValues(instance), <span class="hljs-string">&quot;mBuffer&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = HahaHelper.getByteArray(buffer);<br>        <span class="hljs-keyword">try</span> &#123;<br>            String md5String = Md5Helper.getMd5(bytes);<br>            <span class="hljs-keyword">if</span>(objMap.containsKey(md5String))&#123;<br>                objMap.get(md5String).add(getObjNode(instance));<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                ArrayList&lt;ObjNode&gt; objNodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                objNodes.add(getObjNode(instance));<br>                objMap.put(md5String, objNodes);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>重复的图片找到之后，再找到引用链（与分析 activity 的引用链一样），然后将这些信息保存起来。这里还保存了 mBuffer，用于还原图片，便于开发者寻找问题。</p><blockquote><p>com.tencent.matrix.resource.analyzer.CLIMain#analyzeAndStoreResult</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 bitmap 的 buffer 还原成图片</span><br><span class="hljs-comment">// Store bitmap buffer.</span><br><span class="hljs-keyword">final</span> List&lt;DuplicatedBitmapEntry&gt; duplicatedBmpEntries = duplicatedBmpResult.getDuplicatedBitmapEntries();<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> duplicatedBmpEntryCount = duplicatedBmpEntries.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; duplicatedBmpEntryCount; ++i) &#123;<br>    <span class="hljs-keyword">final</span> DuplicatedBitmapEntry entry = duplicatedBmpEntries.get(i);<br>    <span class="hljs-keyword">final</span> BufferedImage img = BitmapDecoder.getBitmap(<br>            <span class="hljs-keyword">new</span> HprofBitmapProvider(entry.getBuffer(), entry.getWidth(), entry.getHeight()));<br>    <span class="hljs-comment">// Since bmp format is not compatible with alpha channel, we export buffer as png instead.</span><br>    <span class="hljs-keyword">final</span> String pngName = bufferContentsRootDirName + <span class="hljs-string">&quot;/&quot;</span> + entry.getBufferHash() + <span class="hljs-string">&quot;.png&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        zos.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(pngName));<br>        ImageIO.write(img, <span class="hljs-string">&quot;png&quot;</span>, zos);<br>        zos.flush();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zos.closeEntry();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// Ignored.</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就是输出 json 信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> JSONObject duplicatedBmpResultJson = <span class="hljs-keyword">new</span> JSONObject();<br>duplicatedBmpResult.encodeToJSON(duplicatedBmpResultJson);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>014-Matrix源码分析：使用haha库找出泄漏的引用链</title>
    <link href="/2020/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/014-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8haha%E5%BA%93%E6%89%BE%E5%87%BA%E6%B3%84%E6%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE/"/>
    <url>/2020/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/014-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8haha%E5%BA%93%E6%89%BE%E5%87%BA%E6%B3%84%E6%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>听说现在 LeakCanary 改用 shark 这个库来分析 hprof 了。</p><p>前面讲到，当检测到 Activity 泄漏之后，会将裁剪之后的 hprof 文件打包，然后储存到某个位置（这个过程自行实现），这里假设我们储存到了app的目录中，然后我们导出这个文件，使用 matrix-resource-canary-analyzer 来分析这个压缩文件。</p><p>matrix-resource-canary-analyzer 是一个命令行工具，我们从 main 方法入手，这里同样省略到命令参数的处理过程。</p><p>首先，肯定是要将压缩文件里面的 hprof 文件释放出来：</p><blockquote><p>com.tencent.matrix.resource.analyzer.CLIMain#doAnalyze</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将裁剪后的 hprof copy 到一个临时文件</span><br><span class="hljs-comment">// We would extract hprof entry into a temporary file.</span><br>tempHprofFile = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;&quot;</span>).getAbsoluteFile(), <span class="hljs-string">&quot;temp_&quot;</span> + System.currentTimeMillis() + <span class="hljs-string">&quot;.hprof&quot;</span>);<br>StreamUtil.extractZipEntry(zf, hprofEntry, tempHprofFile);<br></code></pre></td></tr></table></figure><p>接下来，就需要使用 haha 来分析这个文件了。在开始之前，我们先说一个预备知识，如果你看过 LeakCanary 的部分源码，那么你应该知道这个类<code>AndroidExcludedRefs</code>，它的作用就是用来排除一些由  Android Sdk  自身（或者制造商）引起的一些泄漏。</p><p>我们看一个例子：</p><blockquote><p>com.tencent.matrix.resource.analyzer.model.AndroidExcludedRefs</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ACTIVITY_CLIENT_RECORD__NEXT_IDLE() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sdkVersion, String manufacturer)</span> </span>&#123;<br>        <span class="hljs-comment">// 需要满足的条件</span><br>        <span class="hljs-keyword">return</span> sdkVersion &gt;= VersionCodes.KITKAT &amp;&amp; sdkVersion &lt;= VersionCodes.LOLLIPOP;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ExcludedRefs.Builder excluded)</span> </span>&#123;<br>        excluded.instanceField(<span class="hljs-string">&quot;android.app.ActivityThread$ActivityClientRecord&quot;</span>, <span class="hljs-string">&quot;nextIdle&quot;</span>)<br>                .reason(<span class="hljs-string">&quot;Android AOSP sometimes keeps a reference to a destroyed activity as a&quot;</span><br>                     + <span class="hljs-string">&quot; nextIdle client record in the android.app.ActivityThread.mActivities map.&quot;</span><br>                     + <span class="hljs-string">&quot; Not sure what&#x27;s going on there, input welcome.&quot;</span>);<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>可以看到，<code>ActivityThread$ActivityClientRecord</code> 这个字段有可能会导致误报，reason 里面是原因。还有些其他的，可以自行查看，对后面分析源码有较大帮助。</p><p>我们现在开始分析 hprof 文件：</p><blockquote><p>com.tencent.matrix.resource.analyzer.CLIMain#analyzeAndStoreResult</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> HeapSnapshot heapSnapshot = <span class="hljs-keyword">new</span> HeapSnapshot(hprofFile);<br><span class="hljs-comment">// 添加需要排除的引用，主要是由Android的SDK引起的，在AndroidExcludedRefs这个类中</span><br><span class="hljs-keyword">final</span> ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults(sdkVersion, manufacturer).build();<br><span class="hljs-comment">// 拿到泄漏的分析结果，根据 leakedActivityKey 找到了对象，就说明泄漏了，则返回引用链</span><br><span class="hljs-comment">// 没有找到对象（或者排除了），则返回 com.tencent.matrix.resource.analyzer.model.ActivityLeakResult.noLeak</span><br><span class="hljs-keyword">final</span> ActivityLeakResult activityLeakResult<br>        = <span class="hljs-keyword">new</span> ActivityLeakAnalyzer(leakedActivityKey, excludedRefs).analyze(heapSnapshot);<br></code></pre></td></tr></table></figure><p>就这几行代码，我们就拿到了 activity 的引用链（如果真的泄漏了，会在 hprof 里面找到该实例对象）。所有的分析代码，都是在 ActivityLeakAnalyzer 的 analyze 方法中，我们追踪下去，会发现下面这个方法：</p><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#findPath(com.squareup.haha.perflib.Snapshot, java.util.Collection&lt;com.squareup.haha.perflib.Instance&gt;)</p></blockquote><p>ShortestPathFinder 就是专门用来分析引用链的，对象的引用关系与图是一样的，所以里面用到的分析方法就是广度遍历。</p><h3 id="广度优先遍历-入队-gc-roots"><a href="#广度优先遍历-入队-gc-roots" class="headerlink" title="广度优先遍历-入队 gc roots"></a>广度优先遍历-入队 gc roots</h3><p>我们看一下大致的逻辑，由于是遍历，肯定需要先入队一些元素，这里肯定就是 gcRoots 了：</p><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#enqueueGcRoots</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueGcRoots</span><span class="hljs-params">(Snapshot snapshot)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (RootObj rootObj : snapshot.getGCRoots()) &#123;<br>        <span class="hljs-keyword">switch</span> (rootObj.getRootType()) &#123;<br>            <span class="hljs-keyword">case</span> JAVA_LOCAL:<br>                <span class="hljs-comment">// Java棧幀中的局部變量</span><br>                Instance thread = HahaSpy.allocatingThread(rootObj);<br>                <span class="hljs-comment">// 拿到线程名字</span><br>                String threadName = threadName(thread);<br>                <span class="hljs-comment">// 如果线程在排除范围内，那么就不考虑</span><br>                <span class="hljs-comment">// 比如 main 线程，主线程堆栈一直在变化，所以局部变量不太可能长时间保存引用。</span><br>                <span class="hljs-comment">// 如果是真的泄漏，一定会有另外一条路径</span><br>                Exclusion params = excludedRefs.threadNames.get(threadName);<br>                <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span> || !params.alwaysExclude) &#123;<br>                    enqueue(params, <span class="hljs-keyword">null</span>, rootObj, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> INTERNED_STRING:<br>            <span class="hljs-keyword">case</span> DEBUGGER:<br>            <span class="hljs-keyword">case</span> INVALID_TYPE:<br>                <span class="hljs-comment">// An object that is unreachable from any other root, but not a root itself.</span><br>            <span class="hljs-keyword">case</span> UNREACHABLE:<br>            <span class="hljs-keyword">case</span> UNKNOWN:<br>                <span class="hljs-comment">// An object that is in a queue, waiting for a finalizer to run.</span><br>            <span class="hljs-keyword">case</span> FINALIZING:<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> SYSTEM_CLASS:<br>            <span class="hljs-keyword">case</span> VM_INTERNAL:<br>                <span class="hljs-comment">// A local variable in native code.</span><br>            <span class="hljs-keyword">case</span> NATIVE_LOCAL:<br>                <span class="hljs-comment">// A global variable in native code.</span><br>            <span class="hljs-keyword">case</span> NATIVE_STATIC:<br>                <span class="hljs-comment">// An object that was referenced from an active thread block.</span><br>            <span class="hljs-keyword">case</span> THREAD_BLOCK:<br>                <span class="hljs-comment">// Everything that called the wait() or notify() methods, or that is synchronized.</span><br>            <span class="hljs-keyword">case</span> BUSY_MONITOR:<br>            <span class="hljs-keyword">case</span> NATIVE_MONITOR:<br>            <span class="hljs-keyword">case</span> REFERENCE_CLEANUP:<br>                <span class="hljs-comment">// Input or output parameters in native code.</span><br>            <span class="hljs-keyword">case</span> NATIVE_STACK:<br>            <span class="hljs-keyword">case</span> JAVA_STATIC:<br>                <span class="hljs-comment">// 其他情况，直接入队列</span><br>                enqueue(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, rootObj, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;Unknown root type:&quot;</span> + rootObj.getRootType());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法虽然有点长，但是还是挺简单的，就是将 gc roots 分为两部分了，对于 java_local 来说，有些字段是需要排除（参见AndroidExcludedRefs，只有 gc root 才这样处理），所以 Exclusion 可能会有值。其他的 gc roots ，Exclusion  都没有值，即不会排除，即使 AndroidExcludedRefs 设置了。</p><h3 id="广度优先遍历-处理队列中的元素"><a href="#广度优先遍历-处理队列中的元素" class="headerlink" title="广度优先遍历-处理队列中的元素"></a>广度优先遍历-处理队列中的元素</h3><p>入队之后，就需要对这个引用对象做处理了，处理这个元素的时候，还会往队列继续添加元素：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">如果是 RootObj，那么将它引用的对象入队<br>如果是 ClassInstance，遍历该对象字段以及父类字段，然后入队<br>如果是 ClassObj，那么需要将它的静态字段入队<br>如果是 ArrayInstance，就将元素入队<br></code></pre></td></tr></table></figure><p>具体的逻辑可以看代码，这里就贴一个 visitClassObj 的逻辑：</p><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#visitClassObj</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitClassObj</span><span class="hljs-params">(ReferenceNode node)</span> </span>&#123;<br>    ClassObj classObj = (ClassObj) node.instance;<br>    Map&lt;String, Exclusion&gt; ignoredStaticFields =<br>            excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());<br>    <span class="hljs-comment">// 遍历静态字段</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Field, Object&gt; entry : classObj.getStaticFieldValues().entrySet()) &#123;<br>        Field field = entry.getKey();<br>        <span class="hljs-comment">// 不是 object（ref），就忽略</span><br>        <span class="hljs-keyword">if</span> (field.getType() != Type.OBJECT) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        一个Instance的field大致有这些：</span><br><span class="hljs-comment">        $staticOverhead 不知道是啥，猜测是静态类的大小？？？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        参考：https://android.googlesource.com/platform/dalvik.git/+/android-4.2.2_r1/vm/hprof/HprofHeap.cpp</span><br><span class="hljs-comment">        The static field-name for the synthetic object generated to account for class Static overhead.</span><br><span class="hljs-comment">        #define STATIC_OVERHEAD_NAME    &quot;$staticOverhead&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        04-25 10:20:46.793 D/LeakCanary: * Class com.xiao.memoryleakexample.app.App</span><br><span class="hljs-comment">        04-25 10:20:46.793 D/LeakCanary: |   static $staticOverhead = byte[24]@314667009 (0x12c17001)</span><br><span class="hljs-comment">        04-25 10:20:46.793 D/LeakCanary: |   static sActivities = java.util.ArrayList@315492800 (0x12ce09c0)</span><br><span class="hljs-comment">        04-25 10:20:46.793 D/LeakCanary: |   static serialVersionUID = -920324649544707127</span><br><span class="hljs-comment">        04-25 10:20:46.793 D/LeakCanary: |   static $change = null</span><br><span class="hljs-comment">         */</span><br>        String fieldName = field.getName();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;$staticOverhead&quot;</span>.equals(fieldName)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        Instance child = (Instance) entry.getValue();<br>        <span class="hljs-keyword">boolean</span> visit = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 排除某些静态字段</span><br>        <span class="hljs-keyword">if</span> (ignoredStaticFields != <span class="hljs-keyword">null</span>) &#123;<br>            Exclusion params = ignoredStaticFields.get(fieldName);<br>            <span class="hljs-keyword">if</span> (params != <span class="hljs-keyword">null</span>) &#123;<br>                visit = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">// 看了下AndroidExcludedRefs，现在的静态字段里面都没有设置alwaysExclude</span><br>                <span class="hljs-keyword">if</span> (!params.alwaysExclude) &#123;<br>                    enqueue(params, node, child, fieldName, STATIC_FIELD);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (visit) &#123;<br>            enqueue(<span class="hljs-keyword">null</span>, node, child, fieldName, STATIC_FIELD);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里也是让我有点疑惑的位置，为啥要遍历 Class 对象的静态字段，是因为我们写的静态字段是属于 Class 的吗？</p><p>按照上面的规则，遍历完之后，如果有泄漏了，是肯定可以找到泄漏的对象的。当然不要忘记记录已经遍历过的对象。</p><h3 id="广度优先遍历-防止重复遍历"><a href="#广度优先遍历-防止重复遍历" class="headerlink" title="广度优先遍历-防止重复遍历"></a>广度优先遍历-防止重复遍历</h3><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#findPath(com.squareup.haha.perflib.Snapshot, java.util.Collection&lt;com.squareup.haha.perflib.Instance&gt;)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到了，跳出循环</span><br><span class="hljs-comment">// Termination</span><br><span class="hljs-keyword">if</span> (targetRefSet.contains(node.instance)) &#123;<br>    results.put(node.instance, <span class="hljs-keyword">new</span> Result(node, node.exclusion != <span class="hljs-keyword">null</span>));<br>    targetRefSet.remove(node.instance);<br>    <span class="hljs-keyword">if</span> (targetRefSet.isEmpty()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 该节点被 visit 过了，跳过，像图的广度遍历</span><br><span class="hljs-keyword">if</span> (checkSeen(node)) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到泄漏的对象之后，还需要找到引用链，这个就比较简单了，由于在入队的过程中，我们给每个对象都封装了一下：</p><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#enqueue</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReferenceNode childNode = <span class="hljs-keyword">new</span> ReferenceNode(exclusion, child, parent, referenceName, referenceType);<br></code></pre></td></tr></table></figure><p>里面记录了，child 与 parent。所以我们向上遍历 parent 直到 gc root 既可获取引用链。</p><blockquote><p>com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder.Result#buildReferenceChain</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ReferenceChain <span class="hljs-title">buildReferenceChain</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;ReferenceTraceElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// We iterate from the leak to the GC root</span><br>    ReferenceNode node = <span class="hljs-keyword">new</span> ReferenceNode(<span class="hljs-keyword">null</span>,<br>            <span class="hljs-keyword">null</span>, referenceChainHead, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 不断的从 泄漏的对象 向上遍历，直到 gcRoots</span><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;<br>        ReferenceTraceElement element = buildReferenceTraceElement(node);<br>        <span class="hljs-keyword">if</span> (element != <span class="hljs-keyword">null</span>) &#123;<br>            elements.add(<span class="hljs-number">0</span>, element);<br>        &#125;<br>        node = node.parent;<br>    &#125;<br>    <span class="hljs-comment">// 就生成了一个引用链</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ReferenceChain(elements);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，泄漏对象的引用链就找到了。</p><p>假设有两条泄漏路径的话，这里找到的是最短的那一条，因为是广度优先，所以最短的肯定先找完，然后就结束寻找了。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>013-Matrix源码分析：检测Activity内存泄漏</title>
    <link href="/2020/08/17/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/013-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8BActivity%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2020/08/17/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/013-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8BActivity%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Matrix的框架抽象了一个 Plugin 类。我们可以继承这个类来实现我们想做的功能。使用的时候只需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TracePlugin tracePlugin = (<span class="hljs-keyword">new</span> TracePlugin(traceConfig));<br>builder.plugin(tracePlugin);<br></code></pre></td></tr></table></figure><p>matrix-resource-canary-android这个module里面就提供了一个 ResourcePlugin。其主要作用就是检测 APP 中的 activity 泄漏，然后 dump 出 hprof 文件，再裁剪 hprof 文件，最后上传。</p><p>检测 activity 泄漏，通常会想到 leakcanary，这个module 也是在 leakcanary 的基础上进行了二次开发，我们看看源码。</p><p>核心代码在 ActivityRefWatcher 里面。</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>plugin 里面分别调用了 watcher 的 start stop等方法，这些方法属于 plugin 的生命周期，从这里入手逻辑会更清晰。</p><p>首先既然要检测泄漏，那么必然要监听 activity 的 destroy 方法，老一套，使用了 ActivityLifecycleCallbacks：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityDestroyed</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>     <span class="hljs-comment">// 该方法里面的逻辑也很简单，就是将activity的信息添加到一个集合中</span><br>     <span class="hljs-comment">// 后面会开启扫描任务扫描这个集合</span><br>     pushDestroyedActivityInfo(activity);<br><span class="hljs-comment">/*     synchronized (mDestroyedActivityInfos) &#123;</span><br><span class="hljs-comment">         mDestroyedActivityInfos.notifyAll();</span><br><span class="hljs-comment">     &#125;*/</span><br> &#125;<br></code></pre></td></tr></table></figure><p>在 LeakCanary 里面，我们判断是否泄漏是延迟了 5S，而且还加上了 gc，再去判断对象是否还存在。</p><p>Matrix的判断方式有点不一样，往下看。</p><h3 id="RetryableTask"><a href="#RetryableTask" class="headerlink" title="RetryableTask"></a>RetryableTask</h3><p>在start的时候，也开启了一个task，这个task是运行在 HandlerThread 中，也就是一个线程了。</p><p>我们分析看这个 task 做了啥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 weak 引用，触发 gc，看有没有被回收，触发 gc，系统不一定会叼你</span><br><span class="hljs-keyword">final</span> WeakReference&lt;Object&gt; sentinelRef = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(<span class="hljs-keyword">new</span> Object());<br>triggerGc();<br><span class="hljs-keyword">if</span> (sentinelRef.get() != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// System ignored our gc request, we will retry later.</span><br>    MatrixLog.d(TAG, <span class="hljs-string">&quot;system ignore our gc request, wait for next detection.&quot;</span>);<br>    <span class="hljs-keyword">return</span> Status.RETRY;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 task 做了很多处理，减少泄漏误判情况，比如，这里它创建了一个弱引用，用来判断 gc 是否真的执行了。需要注意一下，这个 task 是有返回值的，Status.RETRY 表示这个 task 会再次执行。</p><p>接下来就是扫描上面说的那个集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// activity 已经被回收了</span><br><span class="hljs-keyword">if</span> (destroyedActivityInfo.mActivityRef.get() == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// The activity was recycled by a gc triggered outside.</span><br>    MatrixLog.v(TAG, <span class="hljs-string">&quot;activity with key [%s] was already recycled.&quot;</span>, destroyedActivityInfo.mKey);<br>    infoIt.remove();<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br>++destroyedActivityInfo.mDetectedCount;<br><br><span class="hljs-comment">// 泄露检测测试超过一定次数才认为是真的泄露了</span><br><span class="hljs-keyword">if</span> (destroyedActivityInfo.mDetectedCount &lt; mMaxRedetectTimes<br>        || !mResourcePlugin.getConfig().getDetectDebugger()) &#123;<br>    <span class="hljs-comment">// Although the sentinel tell us the activity should have been recycled,</span><br>    <span class="hljs-comment">// system may still ignore it, so try again until we reach max retry times.</span><br>    MatrixLog.i(TAG, <span class="hljs-string">&quot;activity with key [%s] should be recycled but actually still \n&quot;</span><br>                    + <span class="hljs-string">&quot;exists in %s times, wait for next detection to confirm.&quot;</span>,<br>            destroyedActivityInfo.mKey, destroyedActivityInfo.mDetectedCount);<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里也是减少误判，只有当一个 activity 泄漏到了一定次数后，才会认为它是真的泄漏了。</p><p>后面的逻辑，就是根据不同的模式来进行不同的逻辑处理，这个插件支持的模式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DumpMode</span> </span>&#123;<br>    NO_DUMP, AUTO_DUMP, MANUAL_DUMP, SILENCE_DUMP<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只介绍 AUTO_DUMP 模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果是 AUTO_DUMP 模式，那么就去自动分析 heap 文件了，与 LeakCanary 类似</span><br><span class="hljs-keyword">final</span> File hprofFile = mHeapDumper.dumpHeap();<br><span class="hljs-keyword">if</span> (hprofFile != <span class="hljs-keyword">null</span>) &#123;<br>    markPublished(destroyedActivityInfo.mActivityName);<br>    <span class="hljs-comment">// dump hprof 文件</span><br>    <span class="hljs-keyword">final</span> HeapDump heapDump = <span class="hljs-keyword">new</span> HeapDump(hprofFile, destroyedActivityInfo.mKey, destroyedActivityInfo.mActivityName);<br>    <span class="hljs-comment">// 处理 dump 出来的 hprof 文件</span><br>    mHeapDumpHandler.process(heapDump);<br>    infoIt.remove();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    MatrixLog.i(TAG, <span class="hljs-string">&quot;heap dump for further analyzing activity with key [%s] was failed, just ignore.&quot;</span>,<br>                destroyedActivityInfo.mKey);<br>    infoIt.remove();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看它是怎么处理 hprof 文件的，我之前以为这个模式会与 LeakCanary一样会使用 haha 库来分析泄漏引用链，但是看了源码后，发现没有，这里只是做了 hprof 文件的裁剪。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shrinkHprofAndReport</span><span class="hljs-params">(Context context, HeapDump heapDump)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Intent intent = <span class="hljs-keyword">new</span> Intent(context, CanaryWorkerService.class);<br>    intent.setAction(ACTION_SHRINK_HPROF);<br>    intent.putExtra(EXTRA_PARAM_HEAPDUMP, heapDump);<br>    enqueueWork(context, CanaryWorkerService.class, JOB_ID, intent);<br>&#125;<br></code></pre></td></tr></table></figure><p>将裁剪任务交给了 JobIntentService。虽然里面有个 MatrixJobIntentService，但是基本上是拷贝的 JobIntentService，在里面做了一些 try catch 操作。</p><p>接下来，分析它具体的裁剪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">is = <span class="hljs-keyword">new</span> FileInputStream(hprofIn);<br>os = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(hprofOut));<br><span class="hljs-keyword">final</span> HprofReader reader = <span class="hljs-keyword">new</span> HprofReader(<span class="hljs-keyword">new</span> BufferedInputStream(is));<br><span class="hljs-comment">// 这里是做了一个访问者模式，所以，核心代码都在 visitor 里面</span><br><span class="hljs-comment">// 不了解 hprof 的结构。里面的代码没法看</span><br>reader.accept(<span class="hljs-keyword">new</span> HprofInfoCollectVisitor());<br><span class="hljs-comment">// Reset.</span><br>is.getChannel().position(<span class="hljs-number">0</span>);<br>reader.accept(<span class="hljs-keyword">new</span> HprofKeptBufferCollectVisitor());<br><span class="hljs-comment">// Reset.</span><br>is.getChannel().position(<span class="hljs-number">0</span>);<br>reader.accept(<span class="hljs-keyword">new</span> HprofBufferShrinkVisitor(<span class="hljs-keyword">new</span> HprofWriter(os)));<br></code></pre></td></tr></table></figure><p>由于我对 hprof 结构也不熟悉，查了些文档也收获不大，所以就不细说了。</p><p>里面的逻辑大致分为几步：</p><ul><li><p>收集 hprof 文件的 bitmap 与 string 对象（索引id）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitStringRecord</span><span class="hljs-params">(ID id, String text, <span class="hljs-keyword">int</span> timestamp, <span class="hljs-keyword">long</span> length)</span> </span>&#123;<br>    <span class="hljs-comment">// 主要是处理了 Bitmap 与 String 这两个类</span><br><br>    <span class="hljs-comment">// Bitmap 有个 mBuffer 字段与 mRecycled 字段</span><br>    <span class="hljs-comment">// Bitmap在android sdk &lt; 26之前（&gt; 2.3），存儲像素的byte數組是放在Java層的，26之後是放在native層的。</span><br><br>    <span class="hljs-comment">// String 有个 value 字段</span><br>    <span class="hljs-comment">// String在android sdk &lt; 23之前，存儲字符的byte數組是放在Java層的，23之後是放在native層的。</span><br><br>    <span class="hljs-keyword">if</span> (mBitmapClassNameStringId == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">&quot;android.graphics.Bitmap&quot;</span>.equals(text)) &#123;<br>        mBitmapClassNameStringId = id;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mMBufferFieldNameStringId == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">&quot;mBuffer&quot;</span>.equals(text)) &#123;<br>        mMBufferFieldNameStringId = id;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mMRecycledFieldNameStringId == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">&quot;mRecycled&quot;</span>.equals(text)) &#123;<br>        mMRecycledFieldNameStringId = id;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mStringClassNameStringId == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">&quot;java.lang.String&quot;</span>.equals(text)) &#123;<br>        mStringClassNameStringId = id;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mValueFieldNameStringId == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">&quot;value&quot;</span>.equals(text)) &#123;<br>        mValueFieldNameStringId = id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>收集 string 与 bitmap 的字段（索引id），重要的是 bitmap 的 mBuffer 的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到Bitmap實例</span><br><span class="hljs-keyword">if</span> (mBmpClassId != <span class="hljs-keyword">null</span> &amp;&amp; mBmpClassId.equals(typeId)) &#123;<br>    ID bufferId = <span class="hljs-keyword">null</span>;<br>    Boolean isRecycled = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">final</span> ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(instanceData);<br>    <span class="hljs-keyword">for</span> (Field field : mBmpClassInstanceFields) &#123;<br>        <span class="hljs-keyword">final</span> ID fieldNameStringId = field.nameId;<br>        <span class="hljs-keyword">final</span> Type fieldType = Type.getType(field.typeId);<br>        <span class="hljs-keyword">if</span> (fieldType == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;visit bmp instance failed, lost type def of typeId: &quot;</span> + field.typeId);<br>        &#125;<br>        <span class="hljs-comment">// 找到這個實例mBuffer字段的索引id</span><br>        <span class="hljs-keyword">if</span> (mMBufferFieldNameStringId.equals(fieldNameStringId)) &#123;<br>            bufferId = (ID) IOUtil.readValue(bais, fieldType, mIdSize);<br>        &#125;<br>        <span class="hljs-comment">// 找到這個實例mRecycled的boolean值(基礎數據類型，沒有引用關係)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mMRecycledFieldNameStringId.equals(fieldNameStringId)) &#123;<br>            isRecycled = (Boolean) IOUtil.readValue(bais, fieldType, mIdSize);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bufferId == <span class="hljs-keyword">null</span> || isRecycled == <span class="hljs-keyword">null</span>) &#123;<br>            IOUtil.skipValue(bais, fieldType, mIdSize);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    bais.close();<br>    <span class="hljs-comment">// 確認Bitmap沒有被回收</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> reguardAsNotRecycledBmp = (isRecycled == <span class="hljs-keyword">null</span> || !isRecycled);<br>    <span class="hljs-keyword">if</span> (bufferId != <span class="hljs-keyword">null</span> &amp;&amp; reguardAsNotRecycledBmp &amp;&amp; !bufferId.equals(mNullBufferId)) &#123;<br>        <span class="hljs-comment">// 將mBuffer對應的byte數組索引id加入集合</span><br>        mBmpBufferIds.add(bufferId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>去除<strong>非 bitmap 的 buffer</strong>与<strong>重复的bitmap的buffer</strong>（String 的除外）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (deduplicatedId != <span class="hljs-keyword">null</span> &amp;&amp; !bufferId.equals(deduplicatedId) &amp;&amp; !bufferId.equals(mNullBufferId)) &#123;<br>    <span class="hljs-comment">// 让重复的 buf 指向同一个</span><br>    modifyIdInBuffer(instanceData, bufferIdPos, deduplicatedId);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重複的byte數組索引 重定向之後的 索引id</span><br><span class="hljs-keyword">final</span> ID deduplicatedID = mBmpBufferIdToDeduplicatedIdMap.get(id);<br><span class="hljs-comment">// Discard non-bitmap or duplicated bitmap buffer but keep reference key.</span><br><span class="hljs-comment">// 将非 bitmap 数组也给裁了</span><br><span class="hljs-keyword">if</span> (deduplicatedID == <span class="hljs-keyword">null</span> || !id.equals(deduplicatedID)) &#123;<br>    <span class="hljs-comment">// 这里判断了 string</span><br>    <span class="hljs-comment">// 也就是说，Hprof文件裁剪的過程主要是裁剪了重複Bitmap的byte[]數據，String 是用来判断的</span><br>    <span class="hljs-keyword">if</span> (!mStringValueIds.contains(id)) &#123;<br>        <span class="hljs-comment">// 这里直接 return，没有调用 super 方法，</span><br>        <span class="hljs-comment">// 即没有调用 `com.tencent.matrix.resource.hproflib.HprofWriter.HprofHeapDumpWriter.visitHeapDumpPrimitiveArray` 的方法，</span><br>        <span class="hljs-comment">// 所以不会写入数组信息</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">super</span>.visitHeapDumpPrimitiveArray(tag, id, stackId, numElements, typeId, elements);<br></code></pre></td></tr></table></figure><p>经过这些步骤之后，hprof 文件就裁剪完成了。</p></li></ul><p>裁剪完成之后，会执行 CanaryResultService，回调到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReportHprofResult</span><span class="hljs-params">(String resultPath, String activityName)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> JSONObject resultJson = <span class="hljs-keyword">new</span> JSONObject();<br><span class="hljs-comment">//            resultJson = DeviceUtil.getDeviceInfo(resultJson, getApplication());</span><br><span class="hljs-comment">// resultPath 裁剪后的hprof压缩文件路径</span><br>            resultJson.put(SharePluginInfo.ISSUE_RESULT_PATH, resultPath);<br>            resultJson.put(SharePluginInfo.ISSUE_ACTIVITY_NAME, activityName);<br>            Plugin plugin =  Matrix.with().getPluginByClass(ResourcePlugin.class);<br><br>            <span class="hljs-keyword">if</span> (plugin != <span class="hljs-keyword">null</span>) &#123;<br>                plugin.onDetectIssue(<span class="hljs-keyword">new</span> Issue(resultJson));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable thr) &#123;<br>            MatrixLog.printErrStackTrace(TAG, thr, <span class="hljs-string">&quot;unexpected exception, skip reporting.&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>最终会调用，plugin 的 onDetectIssue 方法，这里我们可以进行对应的处理。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>012-Matrix源码分析：使用插件来删除ApkChecker查出的无用资源</title>
    <link href="/2020/08/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/012-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9D%A5%E5%88%A0%E9%99%A4ApkChecker%E6%9F%A5%E5%87%BA%E7%9A%84%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90/"/>
    <url>/2020/08/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/012-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9D%A5%E5%88%A0%E9%99%A4ApkChecker%E6%9F%A5%E5%87%BA%E7%9A%84%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>在第 010 篇文章中，我们说过了 ApkChecker 是如何查找 apk 中的无用资源的，那么找到之后，如果你不想手动删除资源，然后重新打包的话，该怎么办？</p><p>Matrix 也提供了一个插件来做这个事情，也是在 matrix-gradle-plugin 中，我们介绍方法插桩的时候分析过其中一个插件，还有一个没有介绍，就留到现在说，串起来舒服些。</p><p>里面有个 RemoveUnusedResourcesTask，它就是用来删除无用资源的。</p><p>直接上源码部分：</p><blockquote><p>com.tencent.matrix.plugin.task.RemoveUnusedResourcesTask#removeResources</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取未签名的 apk 路径，这些都是 gradle 的 api，就不介绍了，需要自己看文档</span><br>String unsignedApkPath = output.outputFile.getAbsolutePath();<br>Log.i(RemoveUnusedResourcesTask.TAG, <span class="hljs-string">&quot;original apk file %s&quot;</span>, unsignedApkPath);<br><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br><span class="hljs-comment">// 获取 R.txt 文件路径，已经签名信息</span><br>removeUnusedResources(unsignedApkPath, project.getBuildDir().getAbsolutePath() + <span class="hljs-string">&quot;/intermediates/symbols/$&#123;variant.name&#125;/R.txt&quot;</span>, variant.variantData.variantConfiguration.signingConfig);<br></code></pre></td></tr></table></figure><p>上面就是获取必要的信息。</p><blockquote><p>com.tencent.matrix.plugin.task.RemoveUnusedResourcesTask#removeUnusedResources</p></blockquote><p>removeUnusedResources 还是比较长的，只截取部分代码，主要流程有就行，其他的可以自行拉我 fork 库的 note 分支查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">File inputFile = <span class="hljs-keyword">new</span> File(originalApk);<br>Set&lt;String&gt; ignoreRes = project.extensions.matrix.removeUnusedResources.ignoreResources;<br><span class="hljs-comment">// 加载配置的应该忽略的资源</span><br><span class="hljs-keyword">for</span> (String res : ignoreRes) &#123;<br>    <span class="hljs-comment">// 通配符转转正则表达式</span><br>    <span class="hljs-comment">// 配置的语法应该支持 * 啥的吧</span><br>    ignoreResources.add(Util.globToRegexp(res));<br>&#125;<br><span class="hljs-comment">// 加载配置的 未使用的资源，这个就是 ApkChecker 分析出来的资源</span><br>Set&lt;String&gt; unusedResources = project.extensions.matrix.removeUnusedResources.unusedResources;<br></code></pre></td></tr></table></figure><p>这里是从我们的 build.gradle 文件中，读取配置信息，配置信息长这样：</p><blockquote><p>build.gradle</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.tencent.matrix-plugin&#x27;</span><br>matrix &#123;<br>    trace &#123;<br>        enable = <span class="hljs-literal">true</span><br>        baseMethodMapFile = <span class="hljs-string">&quot;$&#123;project.projectDir&#125;/matrixTrace/methodMapping.txt&quot;</span><br>        blackListFile = <span class="hljs-string">&quot;$&#123;project.projectDir&#125;/matrixTrace/blackMethodList.txt&quot;</span><br>    &#125;<br>    removeUnusedResources &#123;<br>        enable <span class="hljs-literal">true</span><br>        variant = <span class="hljs-string">&quot;debug&quot;</span><br>        needSign <span class="hljs-literal">true</span><br>        shrinkArsc <span class="hljs-literal">true</span><br>        <span class="hljs-comment">//Notice: You need to modify the  value of $apksignerPath on different platform. the value below only suitable for Mac Platform,</span><br>        <span class="hljs-comment">//if on Windows, you may have to  replace apksigner with apksigner.bat.</span><br>        apksignerPath = <span class="hljs-string">&quot;$&#123;android.getSdkDirectory().getAbsolutePath()&#125;/build-tools/$&#123;android.getBuildToolsVersion()&#125;/apksigner.bat&quot;</span><br>        unusedResources = project.ext.unusedResourcesSet<br>        ignoreResources = [<span class="hljs-string">&quot;R.id.*&quot;</span>, <span class="hljs-string">&quot;R.bool.*&quot;</span>]<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看上面的removeUnusedResources部分，里面有个 unusedResources，这里就应该填上 ApkChecker 分析出来的资源，我们直到 ApkChecker 分析出来的结果是一个 json 文件，那么应该怎么与它关联起来呢？</p><p>官方的 Sample 里面，有一个用法是这样的。</p><p>首先，我们定义一个 ext 属性：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext.unusedResourcesSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br></code></pre></td></tr></table></figure><p>然后，在打包的时候，插入如下动作：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs groovy">applicationVariants.all &#123; variant -&gt;<br>    <span class="hljs-comment">// 只对 debug 包做处理</span><br>    <span class="hljs-keyword">if</span> (variant.name.equalsIgnoreCase(<span class="hljs-string">&quot;debug&quot;</span>)) &#123;<br>        <span class="hljs-comment">// packageDebug 是一个内置属性</span><br>        packageDebug.doLast &#123;<br>            <span class="hljs-comment">// 打包完成之后，使用 apkchecker 分析这个包</span><br>            ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder();<br>            println configurations.apkCheckerDependency.getAt(<span class="hljs-number">0</span>).getAbsolutePath()<br>            processBuilder.command(<span class="hljs-string">&quot;java&quot;</span>,<br>                                   <span class="hljs-string">&quot;-jar&quot;</span>, configurations.apkCheckerDependency.getAt(<span class="hljs-number">0</span>).getAbsolutePath(),<br>                                   <span class="hljs-string">&quot;--apk&quot;</span>, variant.outputs.first().outputFile.getAbsolutePath(),<br>                                   <span class="hljs-string">&quot;--output&quot;</span>, project.getProjectDir().getAbsolutePath() + <span class="hljs-string">&quot;/unused_resources&quot;</span>,<br>                                   <span class="hljs-string">&quot;--format&quot;</span>, <span class="hljs-string">&quot;json&quot;</span>,<br>                                   <span class="hljs-string">&quot;-unusedResources&quot;</span>, <span class="hljs-string">&quot;--rTxt&quot;</span>, project.getBuildDir().getAbsolutePath() + <span class="hljs-string">&quot;/intermediates/symbols/$&#123;variant.name&#125;/R.txt&quot;</span>);<br>            Process process = processBuilder.start();<br>            <span class="hljs-comment">// 等待程序执行完成</span><br>            process.waitFor();<br>            File outputFile = <span class="hljs-keyword">new</span> File(project.getProjectDir().getAbsolutePath() + <span class="hljs-string">&quot;/unused_resources.json&quot;</span>);<br>            <span class="hljs-comment">// 读取 json 文件到 unusedResourcesSet 里面</span><br>            <span class="hljs-keyword">if</span> (outputFile.exists()) &#123;<br>                Gson gson = <span class="hljs-keyword">new</span> Gson();<br>                JsonArray jsonArray = gson.fromJson(outputFile.text, JsonArray.<span class="hljs-keyword">class</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jsonArray.size(); i++) &#123;<br>                    <span class="hljs-keyword">if</span> (jsonArray.get(i).asJsonObject.get(<span class="hljs-string">&quot;taskType&quot;</span>).asInt == <span class="hljs-number">12</span>) &#123;<br>                        JsonArray resList = jsonArray.get(i).asJsonObject.get(<span class="hljs-string">&quot;unused-resources&quot;</span>).asJsonArray;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; resList.size(); j++) &#123;<br>                            project.ext.unusedResourcesSet.add(resList.get(j).asString);<br>                        &#125;<br>                        println <span class="hljs-string">&quot;find unused resources:\n&quot;</span> + unusedResourcesSet<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                outputFile.delete();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就拿到了 ApkChecker 里面分析出来的结果，而且还是一步到位。回到源码部分，接着是读取 rTxt 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">readResourceTxtFile(resTxtFile, resourceMap, styleableMap);<br></code></pre></td></tr></table></figure><p>就是将 R.txt 中的符号表内存读到map里面。</p><p>比如：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> attr layout_editor_absoluteY <span class="hljs-number">0x7f0200c5</span> <br>就会变成 &#123;<span class="hljs-string">&quot;R.attr.layout_editor_absoluteY&quot;</span>:<span class="hljs-number">0x7f0200c5</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span>[] styleable ViewStubCompat &#123; <span class="hljs-number">0x010100d0</span>, <span class="hljs-number">0x010100f2</span>, <span class="hljs-number">0x010100f3</span> &#125; <br>会变成 &#123;<span class="hljs-string">&quot;R.styleable.ViewStubCompat&quot;</span> : [Pair(<span class="hljs-string">&quot;R.styleable.ViewStubCompat&quot;</span>, <span class="hljs-number">0x010100d0</span>)]&#125;<br></code></pre></td></tr></table></figure><p>接下来是，拷贝apk里面的文件，针对 res 文件做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (zipEntry.name.startsWith(<span class="hljs-string">&quot;res/&quot;</span>)) &#123;<br>    <span class="hljs-comment">// zipEntry.name --&gt; res/mipmap-hdpi-v4/ic_launcher_round.png</span><br>    <span class="hljs-comment">// resourceName --&gt; R.mipmap.ic_launcher_round.png</span><br>    String resourceName = entryToResouceName(zipEntry.name);<br>    <span class="hljs-keyword">if</span> (!Util.isNullOrNil(resourceName)) &#123;<br>        <span class="hljs-comment">// 如果有配置了 unusedResources，这里就不拷贝这个资源到新的 apk 里面了</span><br>        <span class="hljs-keyword">if</span> (removeResources.containsKey(resourceName)) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;remove unused resource %s&quot;</span>, resourceName);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            addZipEntry(zipOutputStream, zipEntry, zipInputFile);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addZipEntry(zipOutputStream, zipEntry, zipInputFile);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 unusedResources 里面的资源是需要移除的，所以这里只拷贝不在该集合中的资源。</p><p>拷贝文件，针对非 res 文件做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为啥 META-INF/ 下的文件也不拷贝</span><br><span class="hljs-comment">// 里面的几个签名文件可以不用管，因为后面会重新签名，但是还有别的文件呢</span><br><span class="hljs-keyword">if</span> (needSign &amp;&amp; zipEntry.name.startsWith(<span class="hljs-string">&quot;META-INF/&quot;</span>)) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// shrinkArsc 需要精简 arsc 文件，这是大头</span><br>    <span class="hljs-keyword">if</span> (shrinkArsc &amp;&amp; zipEntry.name.equalsIgnoreCase(<span class="hljs-string">&quot;resources.arsc&quot;</span>) &amp;&amp; unusedResources.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        File srcArscFile = <span class="hljs-keyword">new</span> File(inputFile.getParentFile().getAbsolutePath() + <span class="hljs-string">&quot;/resources.arsc&quot;</span>);<br>        File destArscFile = <span class="hljs-keyword">new</span> File(inputFile.getParentFile().getAbsolutePath() + <span class="hljs-string">&quot;/resources_shrinked.arsc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (srcArscFile.exists()) &#123;<br>            srcArscFile.delete();<br>            srcArscFile.createNewFile();<br>        &#125;<br>        <span class="hljs-comment">// 将 zip 文件中的 .asrs 文件解压出来</span><br>        unzipEntry(zipInputFile, zipEntry, srcArscFile);<br><br>        <span class="hljs-comment">// 分析 .arsc 文件，需要一张图配合看</span><br>        <span class="hljs-comment">// https://user-gold-cdn.xitu.io/2019/5/24/16ae9b85b2f4e918?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</span><br>        <span class="hljs-comment">// 或者使用 010 打开看看（推荐）</span><br>        ArscReader reader = <span class="hljs-keyword">new</span> ArscReader(srcArscFile.getAbsolutePath());<br>        ResTable resTable = reader.readResourceTable();<br>        <span class="hljs-keyword">for</span> (String resName : removeResources.keySet()) &#123;<br>            ArscUtil.removeResource(resTable, removeResources.get(resName), resName);<br>        &#125;<br>        <span class="hljs-comment">// 重新生成 .arsc 文件</span><br>        ArscWriter writer = <span class="hljs-keyword">new</span> ArscWriter(destArscFile.getAbsolutePath());<br>        writer.writeResTable(resTable);<br>        Log.i(TAG, <span class="hljs-string">&quot;shrink resources.arsc size %f KB&quot;</span>, (srcArscFile.length() - destArscFile.length()) / <span class="hljs-number">1024.0</span>);<br>        addZipEntry(zipOutputStream, zipEntry, destArscFile);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addZipEntry(zipOutputStream, zipEntry, zipInputFile);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面主要是针对 arsc 文件做了处理，其他的文件原封不动的拷贝就好了。对于 arsc 文件结构，番外篇已经介绍了一部分，这里就只说说它处理了什么吧。</p><p>使用 010 Editor 打开 arsc 文件，会发现如下结构：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">TablePackageType<br><span class="hljs-string">...</span><br><span class="hljs-params">--ResTable_typeSpec</span><br><span class="hljs-params">--ResTable_type</span><br><span class="hljs-params">--ResTable_entry</span><br><span class="hljs-params">--Res_value</span><br></code></pre></td></tr></table></figure><p>当我们从apk中删除了一些资源后，比如，我们删除了一个 drawable 资源（因为 values 下面的资源都在一个文件中，比如 string.xml 等，所以拷贝时无法删除其中的某一项），那么它的 ResTable_type 这个结构就需要改一下，需要将这个资源对应的 ResTable_entry 与 Res_value 删除才行。这里还要考虑文件的格式，删除还是挺麻烦的，具体可以看代码。</p><p>需要注意的时，删除的时候，需要保证原来的索引不变。比如，有两个 String，A 与 B，假设他们生成的 id 为 （A）0x01 与 （B）0x02，A是个无用资源，当你删除之后，仍然要保证 arsc 文件中，B的id是0X02，而 id 是与该 entry 在数组中的index有关。</p><p>文件都拷贝完成之后，就需要进行签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用 apksigner 程序，进行签名</span><br>Log.i(TAG, <span class="hljs-string">&quot;resign apk...&quot;</span>);<br>ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder();<br>processBuilder.command(apksigner, <span class="hljs-string">&quot;sign&quot;</span>, <span class="hljs-string">&quot;-v&quot;</span>,<br>                       <span class="hljs-string">&quot;--ks&quot;</span>, signingConfig.storeFile.getAbsolutePath(),<br>                       <span class="hljs-string">&quot;--ks-pass&quot;</span>, <span class="hljs-string">&quot;pass:&quot;</span> + signingConfig.storePassword,<br>                       <span class="hljs-string">&quot;--key-pass&quot;</span>, <span class="hljs-string">&quot;pass:&quot;</span> + signingConfig.keyPassword,<br>                       <span class="hljs-string">&quot;--ks-key-alias&quot;</span>, signingConfig.keyAlias,<br>                       outputFile.getAbsolutePath());<br><span class="hljs-comment">//Log.i(TAG, &quot;%s&quot;, processBuilder.command());</span><br>Process process = processBuilder.start();<br>process.waitFor();<br></code></pre></td></tr></table></figure><p>直接调用了 apksigner 来做这件事。</p><p>然后是移除 styleable，上面的逻辑只处理了非 styleable 资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; styleableItera =  styleableMap.keySet().iterator();<br><span class="hljs-keyword">while</span> (styleableItera.hasNext()) &#123;<br>    String styleable = styleableItera.next();<br>    Pair&lt;String, Integer&gt;[] attrs = styleableMap.get(styleable);<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; attrs.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!removeResources.containsValue(attrs[i].right)) &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (attrs.length &gt; <span class="hljs-number">0</span> &amp;&amp; i == attrs.length) &#123;<br>        Log.i(TAG, <span class="hljs-string">&quot;removed styleable &quot;</span> + styleable);<br>        styleableItera.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，压缩 R.txt，因为删除了些资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">shrinkResourceTxtFile(newResTxtFile, resourceMap, styleableMap);<br></code></pre></td></tr></table></figure><p>这样，整个流程就完毕了。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matrix源码分析番外篇：Dex文件结构</title>
    <link href="/2020/08/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9ADex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2020/08/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9ADex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="构造DEX文件"><a href="#构造DEX文件" class="headerlink" title="构造DEX文件"></a>构造DEX文件</h3><p>首先，我们编写一个简单的程序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">static</span> String b = <span class="hljs-string">&quot;HelloDalvik&quot;</span>;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span> e = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">return</span> e + i + j;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">int</span> d = <span class="hljs-number">2</span>;  <br>        HelloWorld helloWorld = <span class="hljs-keyword">new</span> HelloWorld();  <br>        String sayNumber = String.valueOf(helloWorld.getNumber(c, d));  <br>        System.out.println(<span class="hljs-string">&quot;HelloDex!&quot;</span> + sayNumber);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>使用命令行编译成 dex 文件。不想使用命令的直接拖到 Android studio 里面，打个apk也行，不过后面的 dex 文件内容分析就对不上了。</p><p>拿到 dex 文件后，我们使用 010 editor 打开它，可以看到如下内容：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex1.png?raw=true" alt="image"></p><p>下面的表格就是 dex 的大致结构。点开各个entry，里面又有很多东西，我们慢慢道来，其实这个与 class 文件结构很像，如果你读过 《深入理解Java虚拟机》就很容易上手。</p><h3 id="dex-header"><a href="#dex-header" class="headerlink" title="dex_header"></a>dex_header</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex2.png?raw=true" alt="image"></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex3.png?raw=true" alt="image"></p><ol><li><p> **magic[8]**；它代表dex中的文件标识，一般被称为魔数。是用来识别dex这种文件的，它可以判断当前的dex文件是否有效，可以看到它用了8个1字节的无符号数来表示，我们在010Editor中可以看到也就是“64 65 78 0A 30 33 35 00 ”这8个字节，这些字节都是用16进制表示的，用16进制表示的话，两个数代表一个字节（一个字节等于8位，一个16进制的数能表示4位）。这8个字节用ASCII码表转化一下可以转化为：dex 035。</p></li><li><p><strong>checksum</strong>;  它是dex文件的校验和，通过它可以判断dex文件是否被损坏或者被篡改。它占用4个字节，也就是“5D 9D F9 59”。这里提醒一下，在010Editor中，其实可以分别识别我们在DexHeader中看到的这些字段的，你可以点一下这里：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex4.png?raw=true" alt="image"></p><p>你可以看到这个header列表展开了，其实我们分析下来就和它这个结构是一样的，你可以先看下，我们现在分析到了checksum中了，你可以看到后面对应的值是“59 F9 9D 5D”。咦？这好像和上面的字节不是一一对应的啊。对的，你可以发现它是反着写的。这是由于dex文件中采用的是<strong>小字节序的编码方式</strong>，也就是低位上存储的就是低字节内容，所以它们应该要反一下。</p></li><li><p>**signature[kSHA1DigestLen]**，signature字段用于检验dex文件，其实就是把整个dex文件用SHA-1签名得到的一个值。这里占用20个字节，你可以自己点010Editor看一看。</p></li><li><p><strong>fileSize</strong>;表示整个文件的大小，占用4个字节。</p></li><li><p><strong>headerSize</strong>;表示DexHeader头结构的大小，占用4个字节。这里可以看到它一共占用了112个字节，112对应的16进制数为70h，你可以选中头文件看看010Editor是不是真的占用了这么多：</p></li></ol><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex5.png?raw=true" alt="image"></p><ol start="6"><li><p><strong>endianTag</strong>;代表 字节序标记，用于指定dex运行环境的cpu，预设值为0x12345678，对应在101Editor中为“78 56 34 12”（小字节序）。</p></li><li><p>接下来两个分别是<strong>linkSize</strong>;和u4  <strong>linkOff</strong>;这两个字段，它们分别指定了链接段的大小和文件偏移，通常情况下它们都为0。linkSize为0的话表示静态链接。</p></li><li><p>再下来就是<strong>mapOff</strong>字段了，它指定了DexMapList的文件偏移，这里我们先不过多介绍它，你可以看一下它的值为“14 04 00 00”，它其实对应的16进制数就是414h（别忘了小字节序），我们可以在414h的位置看一下它在哪里：</p></li></ol><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex6.png?raw=true" alt="image"></p><p>​        其实就是dex文件最后一部分内容。关于这部分内容里面是什么，我们先不说，继续往下看。</p><ol start="9"><li><strong>stringIdsSize</strong> 和 <strong>stringIdsOff</strong>字段：这两个字段指定了dex文件中所有用到的字符串的个数和位置偏移，我们先看stringIdsSize，它的值为：“1C 00 00 00”，16进制的1C也就是十进制的28，也就是说我们这个dex文件中一共有28个字符串，然后stringIdsOff为：“70 00 00 00”，代表字符串的偏移位置为70h。</li><li><strong>typeIdsSize</strong>和<strong>typeIdsOff</strong>。它们代表什么呢？它们代表的是类的类型的数量和位置偏移，也是都占4个字节。</li><li>这下到了<strong>protoIdsSize</strong>和<strong>protoIdsOff</strong>了，它们代表的是dex文件中方法原型的个数和位置偏移。</li><li><strong>fieldIdsSize</strong>和<strong>fieldIdsOff</strong>字段。这两个字段指向的是dex文件中字段名的信息。</li><li><strong>methodIdsSize</strong>和<strong>methodIdsOff</strong>字段。这俩字段指明了方法所在的类、方法的声明以及方法名。</li><li><strong>classDefsSize</strong>和<strong>classDefsOff</strong>字段。这两个字段指明的是dex文件中类的定义的相关信息。</li></ol><p>下面，详细的解释一下上面 9-14的内容。</p><h3 id="dex-string-ids"><a href="#dex-string-ids" class="headerlink" title="dex_string_ids"></a>dex_string_ids</h3><p>这个里面描述的是字符串。</p><p>我们就先介绍一下DexStringId这个结构，图中从70h开始，</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex7.png?raw=true" alt="image"></p><p>所有被选中的都是DexStringId这种数据结构的内容，DexStringId代表的是字符串的位置偏移，每个DexStringId占用4个字节，也就是说<strong>它里面存的还不是真正的字符串，它们只是存储了真正字符串的偏移位置</strong>（偏移位置从0开始算起）。</p><p>下面我们先分析几个看看：</p><p>取第一个“<strong>B2 02 00 00</strong>”，它代表的位置偏移是2B2h，我们先找到这个位置：   </p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex8.png?raw=true" alt="image"></p><p>可以发现我一共选中了10个字节，这10个字节就表示了一个字符串。下面我们看一下dex文件中的字符串是如何表示的。dex中的字符串采用了一种叫做<strong>MUTF-8这样的编码</strong>，它是经过传统的UTF-8编码修改的。在MTUF-8中，它的头部存放的是由uleb128编码的字符的个数。</p><p>也就是说在“08 3C 63 6C 69 6E 69 74 3E 00”这些字节中，<strong>第一个08指定的是后面需要用到的编码的个数，也就是8个</strong>，即“ 3C 63 6C 69 6E 69 74 3E”这8个，但是我们为什么一共选中了10个字节呢，<strong>因为最后一个空字符“0”表示的是字符串的结尾</strong>，字符个数没有把它算进去。下面我们来看看“ 3C 63 6C 69 6E 69 74 3E”这8个字符代表了什么字符串：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex9.png?raw=true" alt="image"></p><p>（要说明的一点是，这里凑巧这几个uleb128编码的字符都用了1个字节，所以我们可以这样进行查询，uleb128编码标准用的是1~5个字节， 这里只是恰好都是一个字节）。也就是说上面的70h开始的第一个DexStringId指向的其实是字符串“<clinit>”（但是貌似我们的代码中没有用到这个字符串啊，先不用管，我们接着分析）。再看到这里：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex10.png?raw=true" alt="image"></p><p>刚刚我们分析到“B2 02 00 00”所指向的真实字符串了，下面我们接着再分析一个，我们直接分析第三个，不分析第二个了。第三个为“<strong>C4 02 00 00</strong>”，对应的位置也就是2C4h，我们找到它：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex11.png?raw=true" alt="image"></p><p>看这里，这就是2C4h的位置了。我们首先看第一个字符，它的值为0Bh，也就是十进制的11，也就是说接下来的11个字符代表了它的字符串，我们依旧是查看接下来11个字符代表的是什么，经过查询整理：  </p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex12.png?raw=true" alt="image"></p><p>上面就是“HelloDalvik”这个字符串，可以看看我们的代码，我们确实用了一个这样的字符串，bingo。</p><p>下面剩下的字符串就不分析了。其实直接使用 010 editor 会更直观一些。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex13.png?raw=true" alt="image"></p><p>我们这半天分析的stringIdsSize 和 stringIdsOff字段指向的位置就是上面那个箭头指向的位置，它们里面存储的是真实字符串的位置偏移，它们都存储在data区域。（先透露一下，后面我们要分析的几个也和stringIdsSize 与stringIdsOff字段类似，它们里面存储的基本都是位置偏移，并不是真正的数据，真正的数据都在data区域）</p><h3 id="dex-type-ids"><a href="#dex-type-ids" class="headerlink" title="dex_type_ids"></a>dex_type_ids</h3><p>这个里面描述的是类型（基本类型，类类型）。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex14.png?raw=true" alt="image"></p><p>typeIdsSize的值为9h，也就是我们dex文件中用到的类的类型一共有9个，位置偏移在E0h位置，下面我们找到这个位置</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex15.png?raw=true" alt="image"></p><p>这里我们又得介绍一种数据结构了，因为这里的数据也是一种数据结构的数据组成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexTypeId</span>&#123;</span><br>u4 descriptorIdx;<span class="hljs-comment">/*指向DexStringId列表的索引*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它里面只有一个数据descriptorIdx，它的值的内容是DexStringId列表的索引。</p><p>我们直接去 010 中的  dex_string_ids 中展开这个索引，就可以知道这个字符串是啥了。</p><p>先看第一个“05 00 00 00”，也就是05h，即十进位的5。然后我们在上面所有整理出的字符串看看5索引的是什么？翻上去可以看到是“I”。</p><h3 id="dex-proto-ids"><a href="#dex-proto-ids" class="headerlink" title="dex_proto_ids"></a>dex_proto_ids</h3><p>这个里面描述的是方法签名。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex16.png?raw=true" alt="image"></p><p>protoIdsSize的值为十进制的7，说明有7个方法原型，然后位置偏移为104h，我们找到这个位置</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex17.png?raw=true" alt="image"></p><p>下面又有新的数据结构了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexProtoId</span>&#123;</span><br>u4 shortyIdx;<span class="hljs-comment">/*指向DexStringId列表的索引*/</span><br>u4 returnTypeIdx;<span class="hljs-comment">/*指向DexTypeId列表的索引*/</span><br>u4 parametersOff;<span class="hljs-comment">/*指向DexTypeList的位置偏移*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个数据结构由三个变量组成。</p><p>第一个shortyIdx它指向的是我们上面分析的DexStringId列表的索引，代表的是方法声明<strong>字符串</strong>。</p><p>第二个returnTypeIdx它指向的是 我们上边分析的DexTypeId列表的索引，代表的是方法返回类型<strong>字符串</strong>。</p><p>第三个parametersOff指向的是DexTypeList的位置索引，<strong>这又是一个新的数据结构了</strong>，先说一下这里面 存储的是方法的参数列表。可以看到这三个参数，有方法声明字符串，有返回类型，有方法的参数列表，这基本上就确定了我们一个方法的大体内容。</p><p>我们接着看看DexTypeList这个数据结构，看看参数列表是如何存储的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexTypeList</span>&#123;</span><br>u4 size;<span class="hljs-comment">/*DexTypeItem的个数*/</span><br>DexTypeItem list[<span class="hljs-number">1</span>];<span class="hljs-comment">/*DexTypeItem结构*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它有两个参数，其中第一个size说的是DexTypeItem的个数，那DexTypeItem又是啥咧？它又是一种数据结构。我们继续看看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexTypeItem</span>&#123;</span><br>u2 typeIdx;<span class="hljs-comment">/*指向DexTypeId列表的索引*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个指向DexTypeId列表的索引，也就是代表参数列表中某一个具体的参数的位置。</p><p>下面我们具体地分析一个类吧。</p><p>一个DexProtoId一共占用12个字节。所以，我们取前12个字节进行分析。“06 00 00 00，00 00 00 00，94 02 00 00”，这就是那12个字节了。</p><p>首先“06 00 00 00”代表的是shortyIdx，它的值是指向DexStringId列表的索引，我们找到DexStringId列表中第6个对应的值，也就是III，说明这个方法中声明字符串为三个int。</p><p>接着，“00 00 00 00”代表的是returnTypeIdx，它的值指向的是DexTypeId列表的索引，我们找到对应的值，也就是I，说明这个方法的返回值是int类型的。</p><p>最后，我们看“94 02 00 00”，它代表的是DexTypeList的位置偏移，它的值为294h，我们找到这个位置：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex18.png?raw=true" alt="image"></p><p>这里是DexTypeList结构，首先看前4个字节，代表的是DexTypeItem的个数，“02 00 00 00 ”也就是2，说明接下来有2个DexTypeItem的数据，每个DexTypeItem占用2个字节，也就是两个都是“00 00”，它们的值是DexTypeId列表的索引，我们去找一下，发现0对应的是I，也就是说它的两个参数都是int型的。因此这个方法的声明我们也就确定了，也就是int(int,int)。</p><h3 id="dex-field-ids"><a href="#dex-field-ids" class="headerlink" title="dex_field_ids"></a>dex_field_ids</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex19.png?raw=true" alt="image"></p><p>fieldIdsSize为3h，说明共有3个字段。fieldIdsOff为158h，说明偏移为158h，我们继续看到158h这里：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex20.png?raw=true" alt="image"></p><p>接下来的数据结构是DexFieldId，我们看下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexFieldId</span>&#123;</span><br>u2 classIdx;<span class="hljs-comment">/*类的类型，指向DexTypeId列表的索引*/</span><br>u2 typeIdx;<span class="hljs-comment">/*字段类型，指向DexTypeId列表的索引*/</span><br>u4 nameIdx;<span class="hljs-comment">/*字段名，指向DexStringId列表的索引*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们依旧是分析一下第一个字段，“01 00 ，00 00，13 00 00 00”，类的类型为DexTypeId列表的索引1，也就是HelloWorld。</p><p>字段的类型为DexTypeId列表中的索引0，也就是int。</p><p>字段名为DexStringId列表中的索引13h，即十进制的19，找一下，是a，也就是说我们这个字段就确认了，即int HelloWorld.a。这不就是我们在HelloWorld.java文件里定义的变量a嘛。</p><h3 id="dex-method-ids"><a href="#dex-method-ids" class="headerlink" title="dex_method_ids"></a>dex_method_ids</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex21.png?raw=true" alt="image"></p><p>methodIdsSize，为Ah，即十进制的10，说明共有10个方法。methodIdsOff，为170h，说明它们的位置偏移在170h。我们看到这里</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex22.png?raw=true" alt="image"></p><p>请看DexMethodId</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexMethodId</span>&#123;</span><br>u2 classIdx;<span class="hljs-comment">/*类的类型，指向DexTypeId列表的索引*/</span><br>u2 protoIdx;<span class="hljs-comment">/*声明类型，指向DexProtoId列表的索引*/</span><br>u4 nameIdx;<span class="hljs-comment">/*方法名，指向DexStringId列表的索引*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们直接分析一下第一个数据，“01 00, 04 00， 00 00 00 00”，</p><p>首先，classIdx，为1，对应DexTypeId列表的索引1，也就是HelloWorld；</p><p>其次，protoIdx，为4，对应DexProtoId列表中的索引4，也就是void()；</p><p>最后，nameIdx，为0，对应DexStringId列表中的索引0，也就是<clinit>。</p><p>因此，第一个数据就出来了，即void HelloWorld.&lt;clinit&gt;() 。</p><h3 id="dex-class-defs"><a href="#dex-class-defs" class="headerlink" title="dex_class_defs"></a>dex_class_defs</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex23.png?raw=true" alt="image"></p><p>classDefsSize字段，为1，也就是只有一个类定义，classDefsOff，为1C0h，我们找到它的偏移位置。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex24.png?raw=true" alt="image"></p><p>接下来的数据结构是DexClassDef，请看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexClassDef</span>&#123;</span><br>u4 classIdx;<span class="hljs-comment">/*类的类型，指向DexTypeId列表的索引*/</span><br>u4 accessFlags;<span class="hljs-comment">/*访问标志*/</span><br>u4 superclassIdx;<span class="hljs-comment">/*父类类型，指向DexTypeId列表的索引*/</span><br>u4 interfacesOff;<span class="hljs-comment">/*接口，指向DexTypeList的偏移*/</span><br>u4 sourceFileIdx;<span class="hljs-comment">/*源文件名，指向DexStringId列表的索引*/</span><br>u4 annotationsOff;<span class="hljs-comment">/*注解，指向DexAnnotationsDirectoryItem结构*/</span><br>u4 classDataOff;<span class="hljs-comment">/*指向DexClassData结构的偏移*/</span><br>u4 staticValuesOff;<span class="hljs-comment">/*指向DexEncodedArray结构的偏移*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们直接根据结构开始分析吧。</p><p>classIdx为1，对应DexTypeId列表的索引1，找到是HelloWorld，确实是我们源程序中的类的类型。</p><p>accessFlags为1，它是类的访问标志，对应的值是一个以ACC_开头的枚举值，1对应的是 ACC_PUBLIC，你可以在010Editor中看一下，说明我们的类是public的。</p><p>superclassIdx的值为3，找到DexTypeId列表中的索引3，对应的是java.lang.object，说明我们的类的父类类型是Object的。</p><p>interfaceOff指向的是DexTypeList结构，我们这里是0说明没有接口。如果有接口的话直接对应到DexTypeList，就和之前我们分析的一样了，这里不多解释，有兴趣的可以写一个有接口的类验证下。</p><p>再下来sourceFileIdx指向的是DexStringId列表的索引，代表源文件名，我们这里位4，找一下对应到了字符串”HelloWorld.java”，说明我们类程序的源文件名为HelloWorld.java。</p><p>annotationsOff字段指向注解目录接口，根据类型不同会有注解类、注解方法、注解字段与注解参数，我们这里的值为0，说明没有注解，这里也不过多解释，有兴趣可以自己试试。</p><p>接下来是classDataOff了，它指向的是DexClassData结构的位置偏移，DexClassData中存储的是类的数据部分，我们开始详细分析一下它，首先，还是先找到偏移位置3F8h：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/dex25.png?raw=true" alt="image"></p><p>我们看看DexClassData数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexClassData</span>&#123;</span><br>DexClassDataHeader        header;<span class="hljs-comment">/*指定字段与方法的个数*/</span><br>DexField* staticFields;<span class="hljs-comment">/*静态字段，DexField结构*/</span><br>DexField*instanceFields；<span class="hljs-comment">/*实例字段，DexField结构*/</span><br>DexMethod*directMethods;<span class="hljs-comment">/*直接方法，DexMethod结构*/</span><br>DexMethod*virtualMethods;<span class="hljs-comment">/*虚方法，DexMethod结构*/</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexClassDataHeader</span>&#123;</span><br>u4 staticFieldsSize;<span class="hljs-comment">/*静态字段个数*/</span><br>u4 instanceFieldsSize;<span class="hljs-comment">/*实例字段个数*/</span><br>u4 directMethodsSize;<span class="hljs-comment">/*直接方法个数*/</span><br>u4 virtualMethodsSize;  <span class="hljs-comment">/*虚方法个数*/</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexField</span>&#123;</span><br>u4 fieldIdx;<span class="hljs-comment">/*指向DexFieldId的索引*/</span><br>u4 accessFlags;<span class="hljs-comment">/*访问标志*/</span><br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DexMethod</span>&#123;</span><br>u4 methodIdx;<span class="hljs-comment">/*指向DexMethodId的索引*/</span><br>u4 accessFlags;<span class="hljs-comment">/*访问标志*/</span><br>u4 codeOff;<span class="hljs-comment">/*指向DexCode结构的偏移*/</span><br><br></code></pre></td></tr></table></figure><p>注意，在这些结构中的u4不是指的占用4个字节，而是指它们是uleb128类型（占用1~5个字节）的数据。</p><p>这里面就不具体分析了，可以自己打开 010 就知道里面的字段是什么意思了。就是描述这个类的静态字段，实例字段，各种方法。字段的访问表示等等。在方法的描述中，有个 dexCode，里面描述的方法的指令集。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/sinat_18268881/article/details/55832757">一篇文章带你搞懂DEX文件的结构</a></p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>004-Flutter的Widget渲染</title>
    <link href="/2020/08/11/blog_bak/Blog/flutter/004-Flutter%E7%9A%84Widget%E6%B8%B2%E6%9F%93/"/>
    <url>/2020/08/11/blog_bak/Blog/flutter/004-Flutter%E7%9A%84Widget%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<p>事情要从<a href="https://lizhaoxuan.github.io/2019/01/02/Flutter-%E4%BD%A0%E8%BF%98%E5%9C%A8%E6%BB%A5%E7%94%A8StatefulWidget%E5%90%97/">Flutter-你还在滥用StatefulWidget吗</a> 说起。看了这篇文章之后，我还是以为很有道理的，直到我看了 fish-redux 的大致结构，发现根本就没必要。而且这样做会带来很多麻烦，比如：组件的抽取，又要考虑不能多次 build，又要考虑复用，这两者几乎是冲突的，写出来的代码很难看。但是话说回来，能减少 build 的控件当然最好了，这样创建销毁的对象也少些。</p><p>fish-redux 里面将 page 作为一个整体来 build，每次 state 发生变化的时候，重新 build 一次就好了。即使只有一个 text 发生了变化，也要重新 build 一次。虽然看起来，build 了很多无用的东西，实际上渲染的时候，只渲染了变化的 text 部分。</p><p>为啥呢？这就要从 3 棵树说起。</p><h4 id="Widget-tree"><a href="#Widget-tree" class="headerlink" title="Widget tree"></a>Widget tree</h4><p>第一个是 Widget 树，它的里面没有渲染相关的的东西，只负责<strong>描述</strong> Widget 的大小与位置。我们把它当作普通类理解就好了。</p><h4 id="Element-tree"><a href="#Element-tree" class="headerlink" title="Element  tree"></a>Element  tree</h4><p>第二个是 Element 树，Element 是啥呢？每个 Widget 都有 build 方法（之类会在这个基础上再改变一下）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 这个是 StatefulWidget 的 build 方法</span><br>Widget build(BuildContext context);<br></code></pre></td></tr></table></figure><p>这个 context 实际上就是一个 Element。</p><p>Element 可以理解为一个中间人，每个 Widget 都有一个对应的 Element 对象。我们对 Widget 树的更改会反应到 Element 树上。但是 Element 有一个 diff 机制，就是说它会复用之前的 Element 对象。</p><h5 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h5><p>比如，屏幕上有3个 widget：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@override</span><br><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (map.containsKey(widget.name)) &#123;<br>    print(<span class="hljs-string">&#x27;isSame = $&#123;context == map[widget.name]&#125;, time = $&#123;DateTime.now()&#125;&#x27;</span>);<br>    print(<span class="hljs-string">&#x27;old context = $&#123;map[widget.name].toString()&#125;, time = $&#123;DateTime.now()&#125;&#x27;</span>);<br>    print(<span class="hljs-string">&#x27;context = $&#123;context.toString()&#125;, time = $&#123;DateTime.now()&#125;&#x27;</span>);<br>  &#125;<br><br>  map[widget.name] = context;<br><br>  <span class="hljs-keyword">return</span> Container(<br>    child: Text(<br>      widget.name,<br>      style: TextStyle(color: Colors.white, fontSize: <span class="hljs-number">30</span>),<br>    ),<br>    height: <span class="hljs-number">80</span>,<br>    color: randColor,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>我们，每次 build 的时候，会生成新的 widget 对象，是肯定的，但是 context 却是复用的。打印下 log：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = true, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">033290</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;&#x27;aaaa&#x27;&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">58614</span>), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">033968</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;&#x27;aaaa&#x27;&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">58614</span>), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">034196</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = true, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">035217</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;&#x27;bbbb&#x27;&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">7</span>d<span class="hljs-number">32</span>b), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">035636</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;&#x27;bbbb&#x27;&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">7</span>d<span class="hljs-number">32</span>b), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">035891</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = true, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">037472</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;&#x27;cccc&#x27;&gt;](dirty, state: _ListItemFulState#cd<span class="hljs-number">85</span>b), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">037819</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;&#x27;cccc&#x27;&gt;](dirty, state: _ListItemFulState#cd<span class="hljs-number">85</span>b), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">08</span>:<span class="hljs-number">50</span>.<span class="hljs-number">038083</span><br></code></pre></td></tr></table></figure><p>无论，每次 build 多少次，发现都是复用的同一个 element 对象。这是因为它满足了复用规则：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;<br>  <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType<br>      &amp;&amp; oldWidget.key == newWidget.key;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><p>我们接下来，改一下这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">final</span> List&lt;String&gt; names = [<span class="hljs-string">&quot;aaaa&quot;</span>, <span class="hljs-string">&quot;bbbb&quot;</span>, <span class="hljs-string">&quot;cccc&quot;</span>]; <br><br>  <span class="hljs-function">Widget <span class="hljs-title">buildPage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;列表测试&quot;</span>),<br>      ),<br>      body: ListView(<br>        children: names.map((item) &#123;<br>          <span class="hljs-keyword">return</span> ListItemFul(<br>            item,<br><span class="hljs-comment">//            key: ValueKey(item),</span><br>          );<br>        &#125;).toList(),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        child: Icon(Icons.delete),<br>        onPressed: () &#123;<br>          setState(() &#123;<br>            names.removeAt(<span class="hljs-number">0</span>);<br>            names.add(<span class="hljs-string">&#x27;aaaa&#x27;</span>);<br>          &#125;);<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure><p>我们加了一个 button，点击这个 button，将第一个与第3个 widget 换个位置。看看打印的是什么信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = false, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">885164</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul(state: _ListItemFulState#<span class="hljs-number">93</span>a<span class="hljs-number">82</span>), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">886470</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul(dirty, state: _ListItemFulState#<span class="hljs-number">65</span>e<span class="hljs-number">5</span>d), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">886706</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = false, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">888019</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul(state: _ListItemFulState#<span class="hljs-number">5</span>f<span class="hljs-number">8</span>fd), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">888226</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul(dirty, state: _ListItemFulState#<span class="hljs-number">93</span>a<span class="hljs-number">82</span>), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">888521</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): isSame = false, time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">889172</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul(state: _ListItemFulState#<span class="hljs-number">65</span>e<span class="hljs-number">5</span>d), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">889322</span><br><span class="hljs-attribute">I</span>/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul(dirty, state: _ListItemFulState#<span class="hljs-number">5</span>f<span class="hljs-number">8</span>fd), time = <span class="hljs-number">2020</span>-<span class="hljs-number">08</span>-<span class="hljs-number">06</span> <span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">17</span>.<span class="hljs-number">889634</span><br></code></pre></td></tr></table></figure><p>我们发现，element 不一样了，但是仔细看一下，会发现其实是，widget 1 复用了 widget 3 的 element，widget 2 复用了 widget 1 的 element，widget 3 复用了 widget 2 的 element。</p><p>这是因为，我们没传递 key，所以只要 runtimeType 一样，就可以复用。大致过程如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">build</span> 执行，<br>需要先 <span class="hljs-keyword">build</span> <span class="hljs-string">&#x27;bbbb&#x27;</span> 控件<br>发现位置上有一个 <span class="hljs-string">&#x27;aaaa&#x27;</span> 的 <span class="hljs-keyword">element</span><br>判断该 <span class="hljs-keyword">element</span> 是否可用，发现可用，则直接使用。<br>重复上面的过程<br></code></pre></td></tr></table></figure><h5 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h5><p>再对该例子做点改动，将 <code>key: ValueKey(item),</code> 这行代码的注释去掉，再点击 button，打印结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">I/flutter ( <span class="hljs-number">8694</span>): isSame = <span class="hljs-keyword">true</span>, time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.103764</span><br>I/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;<span class="hljs-string">&#x27;aaaa&#x27;</span>&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">28e81</span>), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.104217</span><br>I/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;<span class="hljs-string">&#x27;aaaa&#x27;</span>&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">28e81</span>), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.104387</span><br>I/flutter ( <span class="hljs-number">8694</span>): isSame = <span class="hljs-keyword">true</span>, time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.104683</span><br>I/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;<span class="hljs-string">&#x27;bbbb&#x27;</span>&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">6e7</span>c6), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.104839</span><br>I/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;<span class="hljs-string">&#x27;bbbb&#x27;</span>&gt;](dirty, state: _ListItemFulState#<span class="hljs-number">6e7</span>c6), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.105229</span><br>I/flutter ( <span class="hljs-number">8694</span>): isSame = <span class="hljs-keyword">true</span>, time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.106242</span><br>I/flutter ( <span class="hljs-number">8694</span>): old context = ListItemFul-[&lt;<span class="hljs-string">&#x27;cccc&#x27;</span>&gt;](dirty, state: _ListItemFulState#ab41f), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.106712</span><br>I/flutter ( <span class="hljs-number">8694</span>): context = ListItemFul-[&lt;<span class="hljs-string">&#x27;cccc&#x27;</span>&gt;](dirty, state: _ListItemFulState#ab41f), time = <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-number">-07</span> <span class="hljs-number">01</span>:<span class="hljs-number">53</span>:<span class="hljs-number">35.106977</span><br></code></pre></td></tr></table></figure><p>发现，每个 widget 都复用了自己原来的 element。这是为什么呢？是因为 ValueKey 是一个 LocalKey。它在源码里面有这样的一个注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">Keys must be unique amongst the [<span class="hljs-built_in">Element</span>]s <span class="hljs-keyword">with</span> the same parent.<br></code></pre></td></tr></table></figure><p>这句话就是说一个 parent 的所有 child 的 element 的 key 应该是唯一的，这样的话，方便复用。它会在 <code>RenderObjectElement.updateChildren</code> 里进行 diff 算法，计算 old 与 new 的可复用关系。因为，我们只是交换位置，所以 element 完全可以复用，设置一个 LocalKey就可以做到 parent 级别的复用。</p><h4 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h4><p>它才是真正负责 widget 渲染的树。每当 Widget 重新 build 后，element 会计算出哪些可复用的，拿到可复用的之后，就会开始更新 renderObject：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> updateRenderObject(BuildContext context, <span class="hljs-keyword">covariant</span> RenderObject renderObject) &#123; &#125;<br></code></pre></td></tr></table></figure><p>我们拿 RichText 举例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> updateRenderObject(BuildContext context, RenderParagraph renderObject) &#123;<br>  <span class="hljs-keyword">assert</span>(textDirection != <span class="hljs-keyword">null</span> || debugCheckHasDirectionality(context));<br>  renderObject<br>    ..text = text<br>    ..textAlign = textAlign<br>    ..textDirection = textDirection ?? Directionality.of(context)<br>    ..softWrap = softWrap<br>    ..overflow = overflow<br>    ..textScaleFactor = textScaleFactor<br>    ..maxLines = maxLines<br>    ..strutStyle = strutStyle<br>    ..textWidthBasis = textWidthBasis<br>    ..textHeightBehavior = textHeightBehavior<br>    ..locale = locale ?? Localizations.localeOf(context, nullOk: <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它就是重新设置了一下属性值而已。但是 RenderObject  在下一帧绘制的时候，就绘制的是改变之后的值。需要注意的是 RenderObject 数也正是重新渲染了变化的节点。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://www.youtube.com/watch?v=996ZgFRENMs">https://www.youtube.com/watch?v=996ZgFRENMs</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>005-Flutter的动画</title>
    <link href="/2020/08/10/blog_bak/Blog/flutter/005-Flutter%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <url>/2020/08/10/blog_bak/Blog/flutter/005-Flutter%E7%9A%84%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><ul><li><p>addListener方法</p><p>每当动画的状态值发生变化时，动画都会通知所有通过 <code>addListener</code> 添加的监听器。（我们可以调用 setState 来更新动画效果）</p></li><li><p>addStatusListener</p><p>当动画的状态发生变化时，会通知所有通过 <code>addStatusListener</code> 添加的监听器。（我们可以在这里做些逻辑处理，比如：反转，重新开始等 ）</p></li></ul><h3 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h3><p>Animation是一个抽象类，并不能用来直接创建对象实现动画的使用。</p><p>AnimationController是Animation的一个子类，实现动画通常我们需要创建AnimationController对象。</p><ul><li>AnimationController会生成一系列的值，<strong>默认情况下值是0.0到1.0区间的值</strong></li></ul><p>AnimationController有一个必传的参数vsync（开发中比较常见的是将SingleTickerProviderStateMixin混入到State的定义中）。</p><h3 id="CurvedAnimation"><a href="#CurvedAnimation" class="headerlink" title="CurvedAnimation"></a>CurvedAnimation</h3><p>它的目的是为了给AnimationController增加动画曲线。</p><h3 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h3><p>默认情况下，AnimationController动画生成的值所在区间是0.0到1.0，如果希望使用这个以外的值，或者其他的数据类型，就需要使用Tween。一个 AnimationController 可以使用多个 Tween，类似 Android的动画集合，一个动画集合可以包含透明度变化、大小变化、颜色变化、旋转动画等；</p><h3 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h3><p>我们必须监听动画值的改变，并且改变后需要调用setState，这会带来两个问题：</p><ul><li>执行动画必须包含这部分代码，代码比较冗余</li><li>调用setState意味着整个State类中的build方法就会被重新build</li></ul><p>AnimatedWidget可以优化上面的操作。</p><h3 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h3><p>AnimatedWidget 是不是最佳的解决方案呢？</p><ul><li>我们每次都要新建一个类来继承自AnimatedWidget</li><li>如果我们的动画Widget有子Widget，那么意味着它的子Widget也会重新build</li></ul><p>AnimatedBuilder可以优化上面的操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimationDemo01State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AnimationDemo01</span>&gt; <span class="hljs-title">with</span> <span class="hljs-title">SingleTickerProviderStateMixin</span> </span>&#123;<br>  AnimationController controller;<br>  Animation&lt;<span class="hljs-built_in">double</span>&gt; animation;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    <span class="hljs-comment">// 1.创建AnimationController</span><br>    controller = AnimationController(duration: <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>), vsync: <span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 2.动画添加Curve效果</span><br>    animation = CurvedAnimation(parent: controller, curve: Curves.elasticInOut, reverseCurve: Curves.easeOut);<br>    <span class="hljs-comment">// 3.监听动画</span><br>    <span class="hljs-comment">// 4.控制动画的翻转</span><br>    animation.addStatusListener((status) &#123;<br>      <span class="hljs-keyword">if</span> (status == AnimationStatus.completed) &#123;<br>        controller.reverse();<br>      &#125; elseif (status == AnimationStatus.dismissed) &#123;<br>        controller.forward();<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 5.设置值的范围</span><br>    animation = Tween(begin: <span class="hljs-number">50.0</span>, end: <span class="hljs-number">120.0</span>).animate(controller);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Center(<br>      child: AnimatedBuilder(<br>        animation: animation,<br>        builder: (ctx, child) &#123;<br>          <span class="hljs-keyword">return</span> Icon(Icons.favorite, color: Colors.red, size: animation.value,);<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    controller.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="享元动画"><a href="#享元动画" class="headerlink" title="享元动画"></a>享元动画</h3><p>在Flutter中，有一个专门的Widget可以来实现这种动画效果：Hero</p><p>实现Hero动画，需要如下步骤：</p><ul><li>1.在第一个Page1中，定义一个起始的Hero Widget，被称之为source hero，并且绑定一个tag；</li><li>2.在第二个Page2中，定义一个终点的Hero Widget，被称之为 destination hero，并且绑定相同的tag；</li><li>3.可以通过Navigator来实现第一个页面Page1到第二个页面Page2的跳转过程；</li></ul><p>Flutter会设置Tween来界定Hero从起点到终端的大小和位置，并且在图层上执行动画效果。</p><p>首页Page代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span><span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">import</span><span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span><span class="hljs-string">&#x27;package:testflutter001/animation/image_detail.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>          primarySwatch: Colors.blue, splashColor: Colors.transparent),<br>      home: HYHomePage(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;Hero动画&quot;</span>),<br>      ),<br>      body: HYHomeContent(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYHomeContent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> GridView(<br>      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(<br>        crossAxisCount: <span class="hljs-number">2</span>,<br>        crossAxisSpacing: <span class="hljs-number">8</span>,<br>        mainAxisSpacing: <span class="hljs-number">8</span>,<br>        childAspectRatio: <span class="hljs-number">2</span><br>      ),<br>      children: <span class="hljs-built_in">List</span>.generate(<span class="hljs-number">20</span>, (index) &#123;<br>        <span class="hljs-built_in">String</span> imageURL = <span class="hljs-string">&quot;https://picsum.photos/id/<span class="hljs-subst">$index</span>/400/200&quot;</span>;<br>        <span class="hljs-keyword">return</span> GestureDetector(<br>          onTap: () &#123;<br>            Navigator.of(context).push(PageRouteBuilder(<br>              pageBuilder: (ctx, animation, animation2) &#123;<br>                <span class="hljs-keyword">return</span> FadeTransition(<br>                  opacity: animation,<br>                  child: HYImageDetail(imageURL),<br>                );<br>              &#125;<br>            ));<br>          &#125;,<br>          child: Hero(<br>            tag: imageURL,<br>            child: Image.network(imageURL)<br>          ),<br>        );<br>      &#125;),<br>    );<br>  &#125;<br>&#125;<br><br>-------------------------------------------------<br>    <br><span class="hljs-keyword">import</span><span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYImageDetail</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  finalString imageURL;<br><br>  HYImageDetail(<span class="hljs-keyword">this</span>.imageURL);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      backgroundColor: Colors.black,<br>      body: Center(<br>        child: GestureDetector(<br>          onTap: () &#123;<br>            Navigator.of(context).pop();<br>          &#125;,<br>          child: Hero(<br>            tag: imageURL,<br>            child: Image.network(<br>              <span class="hljs-keyword">this</span>.imageURL,<br>              width: <span class="hljs-built_in">double</span>.infinity,<br>              fit: BoxFit.cover,<br>            ),<br>          )),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>006-Flutter的状态管理</title>
    <link href="/2020/08/10/blog_bak/Blog/flutter/006-Flutter%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <url>/2020/08/10/blog_bak/Blog/flutter/006-Flutter%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>可以实现跨组件数据的传递。需要 Widget 之间有同一个 Parent。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYDataWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  finalint counter;<br><br>  HYDataWidget(&#123;<span class="hljs-keyword">this</span>.counter, Widget child&#125;): <span class="hljs-keyword">super</span>(child: child);<br><br>  <span class="hljs-comment">// 该方法通过context开始去查找祖先的HYDataWidget</span><br>  <span class="hljs-keyword">static</span> HYDataWidget of(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> context.dependOnInheritedWidgetOfExactType();<br>  &#125;<br><br>  <span class="hljs-comment">// 对比新旧HYDataWidget，是否需要对更新相关依赖的Widget</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(HYDataWidget oldWidget) &#123;<br>    returnthis.counter != oldWidget.counter;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider是目前官方推荐的全局状态管理工具。</p><p>在使用Provider的时候，我们主要关心三个概念：</p><ul><li>ChangeNotifier：真正数据（状态）存放的地方</li><li>ChangeNotifierProvider：Widget树中提供数据（状态）的地方，会在其中创建对应的ChangeNotifier</li><li>Consumer：Widget树中需要使用数据（状态）的地方</li></ul><p><strong>第一步：创建自己的ChangeNotifier</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">100</span>;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> counter &#123;<br>    <span class="hljs-keyword">return</span> _counter;<br>  &#125;<br>  <span class="hljs-keyword">set</span> counter(<span class="hljs-built_in">int</span> value) &#123;<br>    _counter = value;<br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：在Widget Tree中插入ChangeNotifierProvider</strong></p><p>我们需要在Widget Tree中插入ChangeNotifierProvider，以便Consumer可以获取到数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>  runApp(ChangeNotifierProvider(<br>    create: <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> CounterProvider(),<br>    <span class="hljs-attr">child</span>: MyApp(),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三步：在接收处处理事件</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">body: Center(<br>  child: Consumer&lt;CounterProvider&gt;(<br>    builder: (ctx, counterPro, child) &#123;<br>      <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;当前计数:<span class="hljs-subst">$&#123;counterPro.counter&#125;</span>&quot;</span>, style: TextStyle(fontSize: <span class="hljs-number">20</span>, color: Colors.red),);<br>    &#125;<br>  ),<br>),<br></code></pre></td></tr></table></figure><p><strong>第四步：在按钮处，发送事件</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">floatingActionButton: Selector&lt;CounterProvider, CounterProvider&gt;(<br>  selector: (ctx, provider) =&gt; provider.count,<br>  shouldRebuild: (pre, next) =&gt; <span class="hljs-keyword">false</span>,<br>  builder: (ctx, counterPro, child) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;floatingActionButton展示的位置builder被调用&quot;</span>);<br>    <span class="hljs-keyword">return</span> FloatingActionButton(<br>      child: child,<br>      onPressed: () &#123;<br>        <span class="hljs-comment">// 调用 set counter 方法，发送通知</span><br>        counterPro.counter += <span class="hljs-number">1</span>;<br>      &#125;,<br>    );<br>  &#125;,<br>  child: Icon(Icons.add),<br>),<br></code></pre></td></tr></table></figure><h3 id="MultiProvider"><a href="#MultiProvider" class="headerlink" title="MultiProvider"></a>MultiProvider</h3><p>在开发中，我们需要共享的数据肯定不止一个，并且数据之间我们需要组织到一起，所以一个Provider必然是不够的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">runApp(MultiProvider(<br>  providers: [<br>    ChangeNotifierProvider(create: (ctx) =&gt; CounterProvider()),<br>    ChangeNotifierProvider(create: (ctx) =&gt; UserProvider()),<br>  ],<br>  child: MyApp(),<br>));<br></code></pre></td></tr></table></figure><h3 id="Selector-与-Consumer"><a href="#Selector-与-Consumer" class="headerlink" title="Selector 与 Consumer"></a>Selector 与 Consumer</h3><p><strong>Selector控制的粒度比Consumer更细，Consumer是监听一个Provider中所有数据的变化，Selector则是监听某一个/多个值的变化</strong>。</p><ul><li><p>Selector相当于Cosumer，但是可以在某些值不变的情况下，防止rebuild。</p></li><li><p>selector方法：Selector使用 Provider.of获取共享的数据。数据作为selector方法的入参A，执行selector方法，返回build需要的数据S，返回的数据要尽可能少，能满足build就好。</p></li><li><p>shouldRebuild：默认判断前后两次S相等性，来决定是否rebuild。并且也提供了自定义的shouldRebuild方法来判断,参数是前后两次S。</p></li><li><p>S：selector的数据，必须是immutable(不可变)的.因此 selector通常返回集合或覆盖了”==”的类。</p></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/u013894711/article/details/102785532">https://blog.csdn.net/u013894711/article/details/102785532</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>007-Flutter的主题</title>
    <link href="/2020/08/10/blog_bak/Blog/flutter/007-Flutter%E7%9A%84%E4%B8%BB%E9%A2%98/"/>
    <url>/2020/08/10/blog_bak/Blog/flutter/007-Flutter%E7%9A%84%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Theme分为：全局Theme和局部Theme</p><p>主题有两个作用：</p><ul><li>设置了主题之后，某些Widget会自动使用主题的样式（比如AppBar的颜色）</li><li>将某些样式放到主题中统一管理，在应用程序的其它地方直接引用</li></ul><h3 id="全局Theme"><a href="#全局Theme" class="headerlink" title="全局Theme"></a>全局Theme</h3><p>全局Theme会影响整个app的颜色和字体样式。</p><p>使用起来非常简单，只需要向MaterialApp构造器传入 <code>ThemeData</code> 即可。</p><ul><li>如果没有设置Theme，Flutter将会使用预设的样式。</li><li>当然，我们可以对它进行定制。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MyApp</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">StatelessWidget</span> &#123;<br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-variable">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">MaterialApp</span>(<br>      <span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      <span class="hljs-attribute">theme</span>: ThemeData(<br>        <span class="hljs-comment">// 1.亮度: light-dark</span><br>        <span class="hljs-attribute">brightness</span>: Brightness.light,<br>        <span class="hljs-comment">// 2.primarySwatch: primaryColor/accentColor的结合体</span><br>        <span class="hljs-attribute">primarySwatch</span>: Colors.red,<br>        <span class="hljs-comment">// 3.主要颜色: 导航/底部TabBar</span><br>        <span class="hljs-attribute">primaryColor</span>: Colors.pink,<br>        <span class="hljs-comment">// 4.次要颜色: FloatingActionButton/按钮颜色</span><br>        <span class="hljs-attribute">accentColor</span>: Colors.orange,<br>        <span class="hljs-comment">// 5.卡片主题</span><br>        <span class="hljs-attribute">cardTheme</span>: CardTheme(<br>          <span class="hljs-attribute">color</span>: Colors.greenAccent,<br>          <span class="hljs-attribute">elevation</span>: <span class="hljs-number">10</span>,<br>          <span class="hljs-attribute">shape</span>: Border.all(<span class="hljs-attribute">width</span>: <span class="hljs-number">3</span>, <span class="hljs-attribute">color</span>: Colors.red),<br>          <span class="hljs-attribute">margin</span>: EdgeInsets.all(<span class="hljs-number">10</span>)<br>        ),<br>        <span class="hljs-comment">// 6.按钮主题</span><br>        <span class="hljs-attribute">buttonTheme</span>: ButtonThemeData(<br>          <span class="hljs-attribute">minWidth</span>: <span class="hljs-number">0</span>,<br>          <span class="hljs-attribute">height</span>: <span class="hljs-number">25</span><br>        ),<br>        <span class="hljs-comment">// 7.文本主题</span><br>        <span class="hljs-attribute">textTheme</span>: TextTheme(<br>          <span class="hljs-attribute">title</span>: TextStyle(<span class="hljs-attribute">fontSize</span>: <span class="hljs-number">30</span>, <span class="hljs-attribute">color</span>: Colors.blue),<br>          <span class="hljs-attribute">display1</span>: TextStyle(<span class="hljs-attribute">fontSize</span>: <span class="hljs-number">10</span>),<br>        )<br>      ),<br>      <span class="hljs-attribute">home</span>: HYHomePage(),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部Theme"><a href="#局部Theme" class="headerlink" title="局部Theme"></a>局部Theme</h3><p>如果某个具体的Widget不希望直接使用全局的Theme，而希望自己来定义，应该如何做呢？</p><ul><li>非常简单，只需要在Widget的父节点包裹一下Theme即可</li></ul><p>创建另外一个新的页面，页面中使用新的主题：</p><ul><li>在新的页面的Scaffold外，包裹了一个Theme，并且设置data为一个新的ThemeData</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYSecondPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Theme</span>(<br>      data: <span class="hljs-type">ThemeData</span>(),<br>      child: <span class="hljs-type">Scaffold</span>(<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，我们很多时候并不是想完全使用一个新的主题，而且在之前的主题基础之上进行修改：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HYSecondPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Theme</span>(<br>      data: <span class="hljs-type">Theme</span>.of(context).copyWith(<br>        primaryColor: <span class="hljs-type">Colors</span>.greenAccent<br>      ),<br>      child: <span class="hljs-type">Scaffold</span>(<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="darkTheme"><a href="#darkTheme" class="headerlink" title="darkTheme"></a>darkTheme</h3><p>目前很多应用程序都需要适配暗黑模式，Flutter中如何做到暗黑模式的适配呢？</p><p>事实上，MaterialApp中有theme和dartTheme两个参数：</p><ul><li>按照下面的写法，我们已经默认适配了暗黑主题</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">MaterialApp</span>(<br>      title: <span class="hljs-symbol">&#x27;Flutter</span> <span class="hljs-type">Demo</span>&#x27;,<br>      theme: <span class="hljs-type">ThemeData</span>.light(),<br>      darkTheme: <span class="hljs-type">ThemeData</span>.dark(),<br>      home: <span class="hljs-type">HYHomePage</span>(),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>008-Flutter的适配</title>
    <link href="/2020/08/10/blog_bak/Blog/flutter/008-Flutter%E7%9A%84%E9%80%82%E9%85%8D/"/>
    <url>/2020/08/10/blog_bak/Blog/flutter/008-Flutter%E7%9A%84%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>这里只说一个适配，rpx 适配。rpx可以理解为自适应的 px。啥意思呢？就是我们以 UI 给出的图为基准，将屏幕宽度分成固定的份数。</p><p>假如，UI是按照 500*800 出的设计图，那么我们将屏幕的宽度分为 500 份，那么每一份的宽度就是一个 rpx。</p><p>这样适配的话，就相当于是按照比例在适配，比如，界面上有一个 250 * 300 的正方形，那么它在 400 * 600 的屏幕上，应该显示的宽度是 ：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">250 </span>/ <span class="hljs-number">500</span> = x / <span class="hljs-number">400</span><br></code></pre></td></tr></table></figure><p>所以说，rpx 是自适应的，它在不同的屏幕上会有不同的大小。</p><p>其实，在Android中，这样的适配方式还是很常见的，我们拿一个举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">float</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> unit, <span class="hljs-keyword">float</span> value, DisplayMetrics metrics)</span></span>&#123;<br>    <span class="hljs-keyword">switch</span> (unit) &#123;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_PX:<br>            <span class="hljs-keyword">return</span> value;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_DIP:<br>            <span class="hljs-keyword">return</span> value * metrics.density;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_SP:<br>            <span class="hljs-keyword">return</span> value * metrics.scaledDensity;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_PT:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi * (<span class="hljs-number">1.0f</span>/<span class="hljs-number">72</span>);<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_IN:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_MM:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi * (<span class="hljs-number">1.0f</span>/<span class="hljs-number">25.4f</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Android中的控件都是使用的 dp，dp 会让所有设备的表现尽量一致，但是显然这就会引出很多问题，一个400dp的控件，在小屏手机就显示不下，所以使用比例适配是一种更加好的方案。</p><p>但是如果控件全部改成使用 px，那改动太大，然而我们分析系统源码，就可以发现使用dp也可以做到按照比例适配，其原因就是dp最终仍然被转成了px，所以我们需要做的就是干涉 dp 转 px 的这个过程。</p><p>上面的代码，已经将 dp 转 px 的过程贴出来了，我们只需要将 density 的值改一下就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> density;<br></code></pre></td></tr></table></figure><p>是 public 的，还不是 final 的，太好了！！！</p><p>比如，UI 出的图是按照 320 * 480 的，一个 32 * 32 的控件，那么在 1080 * 1920 的屏幕上就是 108 * 108，那么我们需要将 density 的值改成：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">32 </span>* density = <span class="hljs-number">32</span> / <span class="hljs-number">320</span> * <span class="hljs-number">1080</span>  =&gt; density = <span class="hljs-number">1080</span> / <span class="hljs-number">320</span><br></code></pre></td></tr></table></figure><p>可以看出，其实就是让 density 维持了这个比例。</p><p>下面，给出一些常用的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ui&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeFit</span> </span>&#123;<br>  <span class="hljs-comment">// 1.基本信息</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> physicalWidth;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> physicalHeight;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> screenWidth;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> screenHeight;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> dpr;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> statusHeight;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> rpx;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> px;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> initialize(&#123;<span class="hljs-built_in">double</span> standardSize = <span class="hljs-number">750</span>&#125;) &#123;<br>    <span class="hljs-comment">// 1.手机的物理分辨率</span><br>    physicalWidth = <span class="hljs-built_in">window</span>.physicalSize.width;<br>    physicalHeight = <span class="hljs-built_in">window</span>.physicalSize.height;<br><br>    <span class="hljs-comment">// 2.获取dpr</span><br>    dpr = <span class="hljs-built_in">window</span>.devicePixelRatio;<br><br>    <span class="hljs-comment">// 3.宽度和高度</span><br>    screenWidth = physicalWidth / dpr;<br>    screenHeight = physicalHeight / dpr;<br><br>    <span class="hljs-comment">// 4.状态栏高度</span><br>    statusHeight = <span class="hljs-built_in">window</span>.padding.top / dpr;<br><br>    <span class="hljs-comment">// 5.计算rpx的大小</span><br>    rpx = screenWidth / standardSize;<br>    px = screenWidth / standardSize * <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> setRpx(<span class="hljs-built_in">double</span> size) &#123;<br>    <span class="hljs-keyword">return</span> rpx * size;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> setPx(<span class="hljs-built_in">double</span> size) &#123;<br>    <span class="hljs-keyword">return</span> px * size;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做适配的时候，可以使用 setPx 方法。setRpx用于 web 端。</p><p>当然，这样写很麻烦，可以使用新出的扩展函数语法，与 kotlin 的扩展函数一样。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>009-Flutter的路由</title>
    <link href="/2020/08/10/blog_bak/Blog/flutter/009-Flutter%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/08/10/blog_bak/Blog/flutter/009-Flutter%E7%9A%84%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>Route：一个页面要想被路由统一管理，必须包装为一个Route</p><h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>Navigator：管理所有的Route的Widget，通过一个Stack来进行管理的</p><p>基本的跳转还是比较简单的，看如下例子。</p><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p>点击按钮跳转到详情页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">_onPushTap(BuildContext context) &#123;<br>  Navigator.of(context).push(MaterialPageRoute(<br>    builder: (ctx) &#123;<br>      <span class="hljs-keyword">return</span> DetailPage();<br>    &#125;<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h4><p>详情页返回</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">_onBackTap(BuildContext context) &#123;<br>  Navigator.of(context).pop(<span class="hljs-string">&quot;a detail message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h4><p>跳跳详细页，传递一个参数，参数在 page 的构造函数中接收。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">_onPushTap(BuildContext context) &#123;<br>  <span class="hljs-comment">// 1.跳转代码</span><br>  <span class="hljs-keyword">final</span> future = Navigator.of(context).push(MaterialPageRoute(<br>    builder: (ctx) &#123;<br>      <span class="hljs-keyword">return</span> DetailPage(<span class="hljs-string">&quot;a home message&quot;</span>);<br>    &#125;<br>  ));<br><br>  <span class="hljs-comment">// 2.获取结果</span><br>  future.then((res) &#123;<br>    setState(() &#123;<br>      _message = res;<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回细节"><a href="#返回细节" class="headerlink" title="返回细节"></a>返回细节</h3><p>监听返回按钮的点击（给Scaffold包裹一个WillPopScope）</p><ul><li><p>WillPopScope有一个onWillPop的回调函数，当我们点击返回按钮时会执行</p></li><li><p>这个函数要求有一个Future的返回值：</p></li><li><ul><li>true：那么系统会自动帮我们执行pop操作</li><li>false：系统不再执行pop操作，需要我们自己来执行</li></ul></li></ul><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><ul><li>命名路由是将名字和路由的映射关系，在一个地方进行统一的管理</li><li>有了命名路由，我们可以通过<code>Navigator.pushNamed()</code> 方法来跳转到新的页面</li><li>命名路由在哪里管理呢？可以放在MaterialApp的 <code>initialRoute</code> 和 <code>routes</code> 中<ul><li><code>initialRoute</code>：设置应用程序从哪一个路由开始启动，设置了该属性，就不需要再设置<code>home</code>属性了</li><li><code>routes</code>：定义名称和路由之间的映射关系，类型为Map&lt;String, WidgetBuilder&gt;</li></ul></li></ul><p>看如下例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">return</span> MaterialApp(<br>  title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>  theme: ThemeData(<br>    primarySwatch: Colors.blue, splashColor: Colors.transparent<br>  ),<br>  initialRoute: <span class="hljs-string">&quot;/&quot;</span>,<br>  routes: &#123;<br>    <span class="hljs-string">&quot;/home&quot;</span>: (ctx) =&gt; HYHomePage(),<br>    <span class="hljs-string">&quot;/detail&quot;</span>: (ctx) =&gt; HYDetailPage()<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><p>现在跳转可以使用如下方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">_onPushTap(BuildContext context) &#123;<br>  Navigator.of(context).pushNamed(<span class="hljs-string">&quot;/detail&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="命名路由参数传递"><a href="#命名路由参数传递" class="headerlink" title="命名路由参数传递"></a>命名路由参数传递</h3><p>pushNamed时，如何传递参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">_onPushTap(BuildContext context) &#123;<br>  Navigator.of(context).pushNamed(HYDetailPage.routeName, arguments: <span class="hljs-string">&quot;a home message of naned route&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在HYDetailPage中，如何获取到参数呢？在<strong>build</strong>方法中ModalRoute.of(context)可以获取到传递的参数，由于只能在 build 方法中获取参数，所以<strong>一般不这样传递参数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Wid<span class="hljs-keyword">get</span> <span class="hljs-title">build</span>(<span class="hljs-params">BuildContext context</span>) &#123;<br>  <span class="hljs-comment">// 1.获取数据</span><br>  final message = ModalRoute.of(context).settings.arguments;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="onGenerateRoute"><a href="#onGenerateRoute" class="headerlink" title="onGenerateRoute"></a>onGenerateRoute</h4><p>onGenerateRoute的钩子函数：</p><ul><li><p>当我们通过pushNamed进行跳转，但是对应的name没有在routes中有映射关系，那么就会执行onGenerateRoute钩子函数；</p></li><li><p>我们可以在该函数中，手动创建对应的Route进行返回；</p></li><li><p>该函数有一个参数RouteSettings，该类有两个常用的属性：</p></li><li><ul><li>name: 跳转的路径名称</li><li>arguments：跳转时携带的参数</li></ul></li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">onGenerateRoute: (settings) &#123;<br>  <span class="hljs-keyword">if</span> (settings.name == <span class="hljs-string">&quot;/about&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> MaterialPageRoute(<br>      builder: (ctx) &#123;<br>        <span class="hljs-keyword">return</span> HYAboutPage(settings.arguments);<br>      &#125;<br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="onUnknownRoute"><a href="#onUnknownRoute" class="headerlink" title="onUnknownRoute"></a>onUnknownRoute</h4><p>如果我们打开的一个路由名称是根本不存在，这个时候我们希望跳转到一个统一的错误页面。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">onUnknownRoute: (settings) &#123;<br>  <span class="hljs-keyword">return</span> MaterialPageRoute(<br>    builder: (ctx) &#123;<br>      <span class="hljs-keyword">return</span> UnknownPage();<br>    &#125;<br>  );<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>002-Flutter控件捡漏</title>
    <link href="/2020/08/05/blog_bak/Blog/flutter/002-Flutter%E6%8E%A7%E4%BB%B6%E6%8D%A1%E6%BC%8F/"/>
    <url>/2020/08/05/blog_bak/Blog/flutter/002-Flutter%E6%8E%A7%E4%BB%B6%E6%8D%A1%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="Text-rich"><a href="#Text-rich" class="headerlink" title="Text.rich"></a>Text.rich</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Text.rich(<br>      TextSpan(<br><span class="hljs-comment">//        text: &quot;Hello World&quot;,</span><br><span class="hljs-comment">//        style: TextStyle(color: Colors.red, fontSize: 20)</span><br>          children: [<br>            TextSpan(text: <span class="hljs-string">&quot;Hello World&quot;</span>, style: TextStyle(color: Colors.red)),<br>            TextSpan(text: <span class="hljs-string">&quot;Hello flutter&quot;</span>, style: TextStyle(color: Colors.green)),<br>            WidgetSpan(child: Icon(Icons.favorite, color: Colors.red,)),<br>            TextSpan(text: <span class="hljs-string">&quot;Hello dart&quot;</span>, style: TextStyle(color: Colors.blue)),<br>          ]<br>      )<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure><p>富文本，可以进行图文混排，以 span 为单位。</p><h4 id="FadeInImage"><a href="#FadeInImage" class="headerlink" title="FadeInImage"></a>FadeInImage</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> title = <span class="hljs-string">&#x27;Fade in images&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MaterialApp(<br>      title: title,<br>      home: <span class="hljs-keyword">new</span> Scaffold(<br>        appBar: <span class="hljs-keyword">new</span> AppBar(<br>          title: <span class="hljs-keyword">new</span> Text(title),<br>        ),<br>        body: <span class="hljs-keyword">new</span> Stack(<br>          children: &lt;Widget&gt;[<br>            <span class="hljs-keyword">new</span> Center(child: <span class="hljs-keyword">new</span> CircularProgressIndicator()),<br>            <span class="hljs-keyword">new</span> Center(<br>              child: <span class="hljs-keyword">new</span> FadeInImage.memoryNetwork(<br>                placeholder: kTransparentImage,<br>                image:<br>                    <span class="hljs-string">&#x27;https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true&#x27;</span>,<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显示一个占位符，然后在图像加载完显示时淡入。</p><h4 id="Align"><a href="#Align" class="headerlink" title="Align"></a>Align</h4><p>组件可以调整子组件的位置，并且可以根据子组件的宽高来确定自身的的宽高。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Container(<br>  height: <span class="hljs-number">120.0</span>,<br>  width: <span class="hljs-number">120.0</span>,<br>  color: Colors.blue[<span class="hljs-number">50</span>],<br>  child: Align(<br>    alignment: Alignment.topRight,<br>    child: FlutterLogo(<br>      size: <span class="hljs-number">60</span>,<br>    ),<br>  ),<br>)<br></code></pre></td></tr></table></figure><p>Alignment 会以<strong>矩形的中心点作为坐标原点</strong>。上面的例子，就是以 Container 的中心为坐标原点 （0, 0），左上角是 （-1，-1），右下角是（1，1）。</p><p>Align 还有两个参数：<code>widthFactor</code>和<code>heightFactor</code>是用于确定<code>Align</code> 组件本身宽高的属性；它们是两个缩放因子，会分别<strong>乘以子元素</strong>的宽、高。比如，child 的高是 100，heightFactor 设置为 2，则 Align 的高度是 200。</p><p><strong>Center 继承自 Align</strong>。</p><h4 id="Container-BoxShadow"><a href="#Container-BoxShadow" class="headerlink" title="Container - BoxShadow"></a>Container - BoxShadow</h4><p>Container 有个 BoxDecoration 参数，可以用于实现一些背景装饰。</p><p>BoxDecoration 里面有个 boxShadow 参数，它可以用于实现阴影效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">decoration: <span class="hljs-keyword">new</span> BoxDecoration(<br>    border: <span class="hljs-keyword">new</span> Border.all(color: Color(<span class="hljs-number">0xFFFF0000</span>), width: <span class="hljs-number">0.5</span>), <span class="hljs-comment">// 边色与边宽度</span><br><span class="hljs-comment">// 生成俩层阴影，一层绿，一层黄， 阴影位置由offset决定,阴影模糊层度由blurRadius大小决定（大就更透明更扩散），阴影模糊大小由spreadRadius决定</span><br>    boxShadow: [<br>        BoxShadow(color: Color(<span class="hljs-number">0x99FFFF00</span>), offset: Offset(<span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span>), blurRadius: <span class="hljs-number">10.0</span>, spreadRadius: <span class="hljs-number">2.0</span>), <br>        BoxShadow(color: Color(<span class="hljs-number">0x9900FF00</span>), offset: Offset(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)), BoxShadow(color: Color(<span class="hljs-number">0xFF0000FF</span>))<br>    ],<br><br></code></pre></td></tr></table></figure><h4 id="Widget的大小是如何约束的"><a href="#Widget的大小是如何约束的" class="headerlink" title="Widget的大小是如何约束的"></a>Widget的大小是如何约束的</h4><p>熟记这些规则：</p><ul><li><strong>首先，上层 widget 向下层 widget 传递约束条件。</strong></li><li><strong>然后，下层 widget 向上层 widget 传递大小信息。</strong></li><li><strong>最后，上层 widget 决定下层 widget 的位置。</strong></li></ul><p><strong>更多细节：</strong></p><ul><li>Widget 会通过它的 <strong>父级</strong> 获得自身的约束。 约束实际上就是 4 个浮点类型的集合： 最大/最小宽度，以及最大/最小高度。</li><li>然后，这个 widget 将会逐个遍历它的 <strong>children</strong> 列表。向子级传递 <strong>约束</strong>（子级之间的约束可能会有所不同），然后询问它的每一个子级需要用于布局的大小。</li><li>然后，这个 widget 就会对它子级的 <strong>children</strong> 逐个进行布局。 （水平方向是 <code>x</code> 轴，竖直是 <code>y</code> 轴）</li><li>最后，widget 将会把它的大小信息向上传递至父 widget（包括其原始约束条件）。</li></ul><p>看链接：<a href="https://juejin.im/post/6846687593745088526">https://juejin.im/post/6846687593745088526</a></p><h4 id="Container-Text-为何没居中？"><a href="#Container-Text-为何没居中？" class="headerlink" title="Container - Text 为何没居中？"></a>Container - Text 为何没居中？</h4><p>我们在 Container 里面套一个 Text，你会发现，Text 的文字不是居中的。这是因为，Text 的布局被强制为与 Container 的大小一样大了，也就是说，上层 widget 向下层 widget 传递约束条件，其中 最大/最小宽度，以及最大/最小高度都是最大值。</p><p>而，我们设置了 alignment 之后，发现，Text 居中了，这是因为 alignment 内部创建了一个 Align 控件，将 Text 包裹起来了，而 Align 不会强制 Text 的大小与自己一样，Container 强制 Align 大小与自己一样，所以就有了 Text 居中的效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">ConstrainedBox(<br>   constraints: BoxConstraints(<br>      minWidth: <span class="hljs-number">70</span>, <br>      minHeight: <span class="hljs-number">70</span>,<br>      maxWidth: <span class="hljs-number">150</span>, <br>      maxHeight: <span class="hljs-number">150</span>,<br>   ),<br>   child: Container(color: Colors.red, width: <span class="hljs-number">10</span>, height: <span class="hljs-number">10</span>),<br>)<br></code></pre></td></tr></table></figure><p>但我们在 homePage 里面传递这个参数的时候，发现，结果如下：</p><p><img src="https://flutter.dev/assets/ui/layout/layout-9-0fdac80cd5d63906e0af3dc1574fb79f22577cf69cfc0a17b3823f5b2bfa999c.png" alt="Example 9 layout"></p><p>这个我还没搞懂，官方文档说参数被忽略了，但是我没搞清楚为啥被忽略。</p><p>看了下源码，是因为这里的约束时附加约束，它还是要结合父布局传过来的约束进行处理。</p><p>比如，我们传递的 minWidth 是 70，那么它需要进行计算，这里假设父布局的高度约束是 [400, 400]。</p><p>那么，新计算出来的约束实际上是将 70 clamp 到 [400, 400] 这个范围，得出结果是 400，所以相当于忽略了。</p><p>如果 父布局的高度约束是 [0, 400]，那么 clamp 出来的结果就是 70，则使用了约束的高度。</p><h4 id="Expand-的空间分配问题"><a href="#Expand-的空间分配问题" class="headerlink" title="Expand 的空间分配问题"></a>Expand 的空间分配问题</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart">children: &lt;Widget&gt;[<br>  <span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">   <span class="hljs-emphasis">* Flexible中的属性:</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">   *</span> - flex</span></span></span><br><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">   <span class="hljs-emphasis">* Expanded(更多) -&gt; Flexible(fit: FlexFit.tight)</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">   *</span> 空间分配问题</span></span></span><br><span class="hljs-strong"><span class="markdown"><span class="hljs-comment">   <span class="hljs-emphasis">*/</span></span></span></span><br>  Expanded(flex: <span class="hljs-number">1</span>, child: Container(height: <span class="hljs-number">60</span>, color: Colors.red)),<br>  Expanded(<br>      flex: <span class="hljs-number">2</span>,<br>      child: Container(width: <span class="hljs-number">1000</span>, height: <span class="hljs-number">100</span>, color: Colors.green)),<br>  Container(width: <span class="hljs-number">90</span>, height: <span class="hljs-number">80</span>, color: Colors.blue),<br>  Container(width: <span class="hljs-number">50</span>, height: <span class="hljs-number">120</span>, color: Colors.orange),<br>],<br></code></pre></td></tr></table></figure><p>两个 expand 的宽度比例为 1：2，就是 flex 的比例。</p><p>还有一个 Flexible，它的空间分配可以参考：严格约束或宽松约束。</p><p>一个宽松约束换句话来说就是设置了最大宽度/高度， 但是让允许其子 widget 获得比它更小的任意大小。 换句话来说，宽松约束的最小宽度/高度为 <strong>0</strong>。</p><p>严格约束给你了一种获得确切大小的选择。 换句话来说就是，它的最大/最小宽度是一致的，高度也一样。</p><h4 id="SafeArea-与-SliverSafeArea"><a href="#SafeArea-与-SliverSafeArea" class="headerlink" title="SafeArea 与 SliverSafeArea"></a>SafeArea 与 SliverSafeArea</h4><p>现在的手机出现了刘海屏，当你的界面没有 appbar 的时候，那么刘海的位置可能会导致界面的部分内容不可见。使用安全区域可以避免这个问题。</p><p>SafeArea 就是说只让界面在刘海屏下面的位置展示，不使用刘海的位置。</p><p>而 SliverSafeArea 有点不一样，它是刚开始显示的时候，不使用刘海的位置，但是如果你的布局可以滚动，它还是会滚动到刘海位置。这样的话体验会稍微好点。</p><h4 id="SliverPadding"><a href="#SliverPadding" class="headerlink" title="SliverPadding"></a>SliverPadding</h4><p>SliverPadding 与 SliverSafeArea 的行为有点类似。</p><p>通常我们会遇到这样的ui：在GridView 的顶部需要与 AppBar 有一定距离，我们通常会给 GridView 设置一个 Padding，但是这样会导致 GridView 滑动起来，始终与 AppBar 都有一段距离，而 SliverPadding 就可以解决这个问题，它刚开始的时候，与 AppBar 都有一段距离，但是滑动后，与 AppBar 没有距离。</p><h4 id="NotificationListener"><a href="#NotificationListener" class="headerlink" title="NotificationListener"></a>NotificationListener</h4><p>这个是一个 Widget，可以监听可控件的一些通知，比如：可以监听可滚动 Widget 什么时候开始滚动，什么时候结束滚动等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyHomePage</span>&gt; </span>&#123;<br><br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: NotificationListener&lt;ScrollNotification&gt;(<br>        onNotification: (ScrollNotification notification)&#123;<br>          ScrollMetrics metrics = notification.metrics;<br>          <span class="hljs-built_in">print</span>(metrics.pixels);<span class="hljs-comment">// 当前位置</span><br>          <span class="hljs-built_in">print</span>(metrics.atEdge);<span class="hljs-comment">//是否在顶部或底部</span><br>          <span class="hljs-built_in">print</span>(metrics.axis);<span class="hljs-comment">//垂直或水平滚动</span><br>          <span class="hljs-built_in">print</span>(metrics.axisDirection);<span class="hljs-comment">// 滚动方向是down还是up</span><br>          <span class="hljs-built_in">print</span>(metrics.extentAfter);<span class="hljs-comment">//视口底部距离列表底部有多大</span><br>          <span class="hljs-built_in">print</span>(metrics.extentBefore);<span class="hljs-comment">//视口顶部距离列表顶部有多大</span><br>          <span class="hljs-built_in">print</span>(metrics.extentInside);<span class="hljs-comment">//视口范围内的列表长度</span><br>          <span class="hljs-built_in">print</span>(metrics.maxScrollExtent);<span class="hljs-comment">//最大滚动距离，列表长度-视口长度</span><br>          <span class="hljs-built_in">print</span>(metrics.minScrollExtent);<span class="hljs-comment">//最小滚动距离</span><br>          <span class="hljs-built_in">print</span>(metrics.viewportDimension);<span class="hljs-comment">//视口长度</span><br>          <span class="hljs-built_in">print</span>(metrics.outOfRange);<span class="hljs-comment">//是否越过边界</span><br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------------------------&#x27;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;,<br>          child: ListView.builder(<br>            itemExtent: <span class="hljs-number">50</span>,<br>              itemCount: <span class="hljs-number">50</span>,<br>              itemBuilder: (BuildContext context,<span class="hljs-built_in">int</span> index)&#123;<br>              <span class="hljs-keyword">return</span> ListTile(title: Text(index.toString()),);<br>              &#125;,<br>          ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ScrollNotification 有很多子类，我们可以在里面判断：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (notification <span class="hljs-keyword">is</span> ScrollUpdateNotification)<br><br><span class="hljs-keyword">if</span> (notification <span class="hljs-keyword">is</span> ScrollStartNotification)<br><br><span class="hljs-keyword">if</span> (notification <span class="hljs-keyword">is</span> ScrollEndNotification)<br></code></pre></td></tr></table></figure><h4 id="CustomClipper"><a href="#CustomClipper" class="headerlink" title="CustomClipper"></a>CustomClipper</h4><p>可以裁剪区域。比如，要做一个评分控件，有时候需要显示半颗星，那么需要对星星裁剪。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StarPath</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CustomClipper</span>&lt;<span class="hljs-title">Path</span>&gt; </span>&#123;<br>  StarPath(&#123;<span class="hljs-keyword">this</span>.scale = <span class="hljs-number">2.5</span>&#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> scale;<br><br>  <span class="hljs-keyword">double</span> perDegree = <span class="hljs-number">36</span>;<br><br>  <span class="hljs-comment">/// 角度转弧度公式</span><br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">degree2Radian</span><span class="hljs-params">(<span class="hljs-keyword">double</span> degree)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (pi * degree / <span class="hljs-number">180</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-function">Path <span class="hljs-title">getClip</span><span class="hljs-params">(Size size)</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-function">bool <span class="hljs-title">shouldReclip</span><span class="hljs-params">(StarPath oldClipper)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> oldClipper.scale != <span class="hljs-keyword">this</span>.scale;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getClip 是生成我们想要的裁剪的区域的 path。</p><p>shouldReclip 表示是否需要重新裁剪。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>003-Flutter的异步操作</title>
    <link href="/2020/08/05/blog_bak/Blog/flutter/003-Flutter%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/05/blog_bak/Blog/flutter/003-Flutter%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="如何catch-error？"><a href="#如何catch-error？" class="headerlink" title="如何catch error？"></a>如何catch error？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testFuture</span><span class="hljs-params">()</span></span>&#123;<br>  Future future = <span class="hljs-keyword">new</span> Future(() =&gt; <span class="hljs-keyword">null</span>);<br>  future.then((_)&#123;<br>    print(<span class="hljs-string">&quot;then&quot;</span>);<br>  &#125;).catchError((_)&#123;<br>    print(<span class="hljs-string">&quot;catchError&quot;</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是比较常见的一种捕获异常的方式，但是 then 里面也有一个 onError 参数，是可选命名参数。</p><p>那么 它 与 catchError 有啥区别呢？</p><p>then 里面的 onError 只会捕获当前 future.then 创建的新的 Future 里面的异常。</p><p>catchError 会捕获所有异常，除非你设置的 test 条件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 代码捕获了异常</span><br>Future future = <span class="hljs-keyword">new</span> Future(() =&gt; <span class="hljs-keyword">null</span>);<br>future.then((_)&#123;<br>    <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;).then((e)&#123;<br>    <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;).catchError((_)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catchError&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 代码未完全捕获异常</span><br>Future future = <span class="hljs-keyword">new</span> Future(() =&gt; <span class="hljs-keyword">null</span>);<br>future.then((_)&#123;<br>    <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;, onError: (e) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catchError&quot;</span>);<br>&#125;).then((e)&#123;<br>    <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="error-指定参数会出错"><a href="#error-指定参数会出错" class="headerlink" title="error 指定参数会出错"></a>error 指定参数会出错</h4><p>在 catchError 里面需要参入一个参数，是一个函数，函数也有一个参数。</p><p>一般的我们都这样写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">catchError((e)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catchError&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果，我们确定了 e 的类型是 Exception，那么可能想这样写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">catchError((Exception e)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catchError&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>但是运行会报错，是因为 catchError 指定了函数的参数必须要是 dynamic 的，所以我们不能强制指定类型，只能判断后处理。</p><h4 id="奇怪的阻塞行为"><a href="#奇怪的阻塞行为" class="headerlink" title="奇怪的阻塞行为"></a>奇怪的阻塞行为</h4><p>看如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">Futurn&lt;<span class="hljs-built_in">String</span>&gt; network() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> sleep(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main 里面直接调用这个函数，发现 main 还是阻塞了，是为什么呢？</p><p>是因为该函数的 return 语句没有立刻执行，它调用了 sleep，没有立刻返回一个 future，所以 main 就阻塞了。</p><h4 id="async-sync"><a href="#async-sync" class="headerlink" title="async * / sync *"></a>async * / sync *</h4><p>先看一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">foo1 ()&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo1 start&#x27;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-built_in">print</span>(i);<br>  &#125;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo1 stop&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这个函数，输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">foo1</span> start<br><br><span class="hljs-attribute">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><br><span class="hljs-attribute">foo1</span> stop<br></code></pre></td></tr></table></figure><p>我们对上面的例子使用 <code>sync *</code>，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-built_in">Iterable</span>&lt;<span class="hljs-built_in">int</span>&gt; foo2() <span class="hljs-keyword">sync</span>*&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo2 start&#x27;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;运行了foo2，当前index：<span class="hljs-subst">$&#123;i&#125;</span>&#x27;</span>);<br>    <span class="hljs-keyword">yield</span> i;<br>  &#125;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo2 stop&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这回我们在 <code>main</code> 函数里运行 <code>foo2()</code>，会出现什么效果？</p><p>答案是<strong>什么也不会发生</strong>，print也没有打印。这是为什么呢？！！</p><p>当我们调用 <code>foo2()</code>的时候，这里会<strong>马上返回</strong>一个 <code>Iterable</code>，就像网络请求会马上返回一个 <code>Future</code>一样。在我们没有调用 <code>Iterable</code> 的 <code>moveNext</code> 的时候，当前函数体是不会执行的。而当我们调用了 <code>moveNext</code> 方法后，代码会执行到 <code>yield</code> 关键字的位置，并且在这里停住。当我们再一次调用 <code>moveNext</code> 后，会再恢复执行，然后再次停到 <code>yield</code> 关键字的位置，依次循环，当没有下一个值得时候，函数会隐式的调用 return方法来终止函数。</p><p>看看运行输出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> b = foo2().iterator;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;还没开始调用 moveNext&#x27;</span>);<br>b.moveNext();<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第<span class="hljs-subst">$&#123;b.current&#125;</span>次moveNext&#x27;</span>);<br>b.moveNext();<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第<span class="hljs-subst">$&#123;b.current&#125;</span>次moveNext&#x27;</span>);<br>b.moveNext();<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第<span class="hljs-subst">$&#123;b.current&#125;</span>次moveNext&#x27;</span>);<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">还没开始调用 moveNext<br>foo2 start<br>运行了foo2，当前index：<span class="hljs-number">0</span><br>第<span class="hljs-number">0</span>次moveNext<br>运行了foo2，当前index：<span class="hljs-number">1</span><br>第<span class="hljs-number">1</span>次moveNext<br>运行了foo2，当前index：<span class="hljs-number">2</span><br>第<span class="hljs-number">2</span>次moveNext<br></code></pre></td></tr></table></figure><p>说异步生成器之前，先来说一下普通的异步调用。</p><p>现在有一个这样的需求，我想每隔一秒钟请求一下数据，一共请求10次，看看有没有人关注我等等，</p><p>如果使用原始的 async，该怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getData() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-keyword">await</span> Future.delayed(Duration(seconds: <span class="hljs-number">1</span>), ()<span class="hljs-keyword">async</span> &#123;<br>        Data data = <span class="hljs-keyword">await</span> getXXX();<br>      <span class="hljs-function"><span class="hljs-title">setState</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>      &#125;;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用循环，然后每一秒钟请求依次接口，返回数据后 setState();</p><p>这样肯定不行，因为你不可能一两秒钟就 setState()一次，</p><p>这个时候 async* 就派上用场了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Stream&lt;Data&gt; getData() <span class="hljs-keyword">async</span>* &#123;<br>  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    <span class="hljs-keyword">await</span> Future.delayed(Duration(seconds: <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">await</span> getXXX();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在页面上，我们可以用 <code>StreamBuilder</code> 来包住，这样每次返回数据就不用 setState() 了。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>001-数组中重复的数字</title>
    <link href="/2020/08/05/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84/001-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/08/05/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/%E6%95%B0%E7%BB%84/001-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字。"><a href="#找出数组中重复的数字。" class="headerlink" title="找出数组中重复的数字。"></a>找出数组中重复的数字。</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs excel">在一个长度为 <span class="hljs-built_in">n</span> 的数组 nums 里的所有数字都在 <span class="hljs-number">0</span>～<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br><br><br>限制：<br><br><span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">100000</span><br></code></pre></td></tr></table></figure><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>在排序的算法中，有一个桶排序，我们采用同样的思路。</p><p>分配一个空数组 arr，大小为 n（ n &lt;= 100000，所以是可以接受的），由于所有的数组在 0～n-1 的范围内，所以我们可以这样：</p><p>将 nums 里面的每个元素“放到” arr 的下标位置，即，如果元素为 5，则储存到 arr[5] 里面，但是这里并不需要真的储存，只需要储存的时候，判断一下是否已经有值，如果有值，则说明有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length;i++) &#123;<br>            temp[nums[i]]++;<br>            <span class="hljs-keyword">if</span> (temp[nums[i]] &gt;=<span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的解法，空间为 O(n)。</p><p>提交结果一般：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">2</span> ms, 在所有 Java 提交中击败了<span class="hljs-number">69.93</span><span class="hljs-comment">% 的用户</span><br>内存消耗：<span class="hljs-number">47.6</span> MB, 在所有 Java 提交中击败了<span class="hljs-number">74.99</span><span class="hljs-comment">% 的用户</span><br></code></pre></td></tr></table></figure><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>大佬的解法：原地置换。这个思路是对题目真的理解透了。</p><p>我们假设 nums 中没有重复的数字，那么会怎么样呢？nums 就是由 0 ~ n-1 这 n 个数字组成。</p><p>我们可以利用这个特性，将元素值与角标对应起来，啥意思呢？</p><p>就是说从第 0 个位置开始，假如它的值是 3，那么就将 0 位置与 3 位置的元素互换，则位置 3 就搞定了，那么位置 0 的元素又变成了别的数字，假如是 9，则再将位置 0 与 9 互换，这样一直重复下去。</p><p>如果说 nums 中没有重复的数字，我们是不会遇到相等的数字的，遇到了，则说明有重复的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">while</span> (nums[i]!=i)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])&#123;<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                &#125;<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的解法，空间为 O(1)。</p><p>提交结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">执行用时：<span class="hljs-number">1</span> ms, 在所有 Java 提交中击败了<span class="hljs-number">91.42</span><span class="hljs-comment">%的用户</span><br>内存消耗：<span class="hljs-number">47.2</span> MB, 在所有 Java 提交中击败了<span class="hljs-number">97.58</span><span class="hljs-comment">%的用户</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>001-Dart语法捡漏</title>
    <link href="/2020/08/04/blog_bak/Blog/flutter/001-Dart%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F/"/>
    <url>/2020/08/04/blog_bak/Blog/flutter/001-Dart%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="Object-与-dynamic"><a href="#Object-与-dynamic" class="headerlink" title="Object 与 dynamic"></a>Object 与 dynamic</h4><p>Dart 中所有的类都继承于 Object，所以我们可以这样写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Object</span> x = <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>dynamic 是动态类型，会自己做类型推断，所以也可以这样写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">dynamic</span> x = <span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></td></tr></table></figure><p>他们之间的区别是：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>    <span class="hljs-built_in">dynamic</span> x = <span class="hljs-string">&#x27;123&#x27;</span>;<br>    <span class="hljs-built_in">print</span>(x.substring(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，由于 x 被推断为 String 类型，所以可以调用 String 的方法，但是换成 Object 就不行了。</p><h4 id="final-与-const"><a href="#final-与-const" class="headerlink" title="final 与 const"></a>final 与 const</h4><p>final和const都是用于定义常量的, 也就是定义之后值都不可以修改</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">final <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;coderwhy&#x27;</span>;<br><span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;kobe&#x27;</span>; <span class="hljs-comment">// 错误做法</span><br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;age = <span class="hljs-number">20</span>; <span class="hljs-comment">// 错误做法</span><br></code></pre></td></tr></table></figure><p>final和const有什么区别呢?</p><ul><li>const在赋值时, 赋值的内容必须是在编译期间就确定下来的</li><li>final在赋值时, 可以动态获取, 比如赋值一个函数</li></ul> <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> getName() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;coderwhy&#x27;</span>;<br>&#125;<br><br>main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  <span class="hljs-keyword">const</span> name = getName(); <span class="hljs-comment">// 错误的做法, 因为要执行函数才能获取到值</span><br>  <span class="hljs-keyword">final</span> name = getName(); <span class="hljs-comment">// 正确的做法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，const 还可以修饰构造函数。可以让同样字段值的构造函数返回同样的对象。</p><h4 id="命名可选参数-和-位置可选参数"><a href="#命名可选参数-和-位置可选参数" class="headerlink" title="命名可选参数 和 位置可选参数"></a><strong>命名可选参数</strong> 和 <strong>位置可选参数</strong></h4><p>定义方式:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">命名可选参数: &#123;para<span class="hljs-name">m1</span>, para<span class="hljs-name">m2</span>, ...&#125;<br>位置可选参数: [para<span class="hljs-name">m1</span>, para<span class="hljs-name">m2</span>, ...]<br></code></pre></td></tr></table></figure><p>位置可选参数是有顺序的，命名可选参数没有。</p><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="??=赋值操作"></a>??=赋值操作</h4><ul><li>当变量为null时，使用后面的内容进行赋值。</li><li>当变量有值时，使用自己原来的值。</li></ul><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">num</span> x;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">num</span> y;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">num</span> distance;<br><br>  <span class="hljs-comment">// 错误写法</span><br>  <span class="hljs-comment">// Point(this.x, this.y) &#123;</span><br>  <span class="hljs-comment">//   distance = sqrt(x * x + y * y);</span><br>  <span class="hljs-comment">// &#125;</span><br><br>  <span class="hljs-comment">// 正确的写法</span><br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y) : distance = sqrt(x * x + y * y);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化列表相对于命令可选参数来说，它更灵活，可以使用表达式，而可选参数的值需要是 const。</p><h4 id="const-构造方法"><a href="#const-构造方法" class="headerlink" title="const 构造方法"></a>const 构造方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">const</span> Person(<span class="hljs-string">&#x27;why&#x27;</span>);<br>  <span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">const</span> Person(<span class="hljs-string">&#x27;why&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(identical(p1, p2)); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;<br><br>  <span class="hljs-keyword">const</span> Person(<span class="hljs-keyword">this</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>将构造方法前加<code>const进行修饰</code>，那么可以保证同一个参数，创建出来的对象是相同的。</p><ul><li><strong>注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的</strong>.</li><li><strong>注意二:</strong> 为了可以通过常量构造方法，创建出相同的对象，不再使用 <strong>new</strong>关键字，而是使用const关键字</li></ul><h4 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart">main(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; args) &#123;<br>  <span class="hljs-keyword">var</span> p1 = Person(<span class="hljs-string">&#x27;why&#x27;</span>);<br>  <span class="hljs-keyword">var</span> p2 = Person(<span class="hljs-string">&#x27;why&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(identical(p1, p2)); <span class="hljs-comment">// true</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> name;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Person&gt; _cache = &lt;<span class="hljs-built_in">String</span>, Person&gt;&#123;&#125;;<br><br>  <span class="hljs-keyword">factory</span> Person(<span class="hljs-built_in">String</span> name) &#123;<br>    <span class="hljs-keyword">if</span> (_cache.containsKey(name)) &#123;<br>      <span class="hljs-keyword">return</span> _cache[name];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">final</span> p = Person._internal(name);<br>      _cache[name] = p;<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br>  &#125;<br><br>  Person._internal(<span class="hljs-keyword">this</span>.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂构造函数就是需要自己手动的返回一个对象。</p><h4 id="Mixin混入"><a href="#Mixin混入" class="headerlink" title="Mixin混入"></a>Mixin混入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">main(List&lt;String&gt; args) &#123;<br>  <span class="hljs-keyword">var</span> superMan = SuperMain();<br>  superMan.run();<br>  superMan.fly();<br>&#125;<br><br>mixin Runner &#123;<br>  run() &#123;<br>    print(<span class="hljs-string">&#x27;在奔跑&#x27;</span>);<br>  &#125;<br>&#125;<br><br>mixin Flyer &#123;<br>  fly() &#123;<br>    print(<span class="hljs-string">&#x27;在飞翔&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// implements的方式要求必须对其中的方法进行重新实现</span><br><span class="hljs-comment">// class SuperMan implements Runner, Flyer &#123;&#125;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperMain</span> <span class="hljs-title">with</span> <span class="hljs-title">Runner</span>, <span class="hljs-title">Flyer</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法有点像是对接口的使用简化。用接口来实现一些行为，然后可以直接被使用。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>011-Matrix源码分析：ApkChecker的其他小工具</title>
    <link href="/2020/08/03/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/011-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E7%9A%84%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/08/03/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/011-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E7%9A%84%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍一下 ApkChecker 里面的一些其他小工具，因为都比较简单，所以就合成一篇算了。</p><h3 id="CountClassTask"><a href="#CountClassTask" class="headerlink" title="CountClassTask"></a>CountClassTask</h3><p>用于计算 apk 里面所有 dex 文件包含的的 class 的数量。</p><h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskInitException </span>&#123;<br>    <span class="hljs-keyword">super</span>.init();<br>    String inputPath = config.getUnzipPath();<br><br>    ...<br><br>    inputFile = <span class="hljs-keyword">new</span> File(inputPath);<br>    ...<br><br>    File[] files = inputFile.listFiles();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (files != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (File file : files) &#123;<br>                <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.DEX_FILE_SUFFIX)) &#123;<br>                    dexFileNameList.add(file.getName());<br>                    RandomAccessFile randomAccessFile = <span class="hljs-keyword">new</span> RandomAccessFile(file, <span class="hljs-string">&quot;rw&quot;</span>);<br>                    dexFileList.add(randomAccessFile);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TaskInitException(e.getMessage(), e);<br>    &#125;<br><br>    <span class="hljs-comment">// 命令支持 GROUP-BY 参数，将结果分组</span><br>    <span class="hljs-keyword">if</span> (params.containsKey(JobConstants.PARAM_GROUP)) &#123;<br>        <span class="hljs-keyword">if</span> (JobConstants.GROUP_PACKAGE.equals(params.get(JobConstants.PARAM_GROUP))) &#123;<br>            group = JobConstants.GROUP_PACKAGE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;GROUP-BY &#x27;&quot;</span> + params.get(JobConstants.PARAM_GROUP) + <span class="hljs-string">&quot;&#x27; is not correct!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>init 方法里面，就是获取了所有 .dex 文件。注意，它使用了 RandomAccessFile。为啥呢？因为它读取的是 .dex 文件，它是有一定的结构的，所以读取的时候肯定需要跳来跳去。贴一张 dex 结构图，番外篇专门介绍，其实它与 class 文件的结构很像。</p><p><img src="https://img-blog.csdn.net/20170220085323266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMTgyNjg4ODE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>上图比较简单，有详细点的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/18/16acab9179e7b6a2?imageslim" alt="img"></p><p>还有更详细点的，就不贴了，贴了也看不懂。</p><h4 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读取dex文件，</span><br><span class="hljs-comment"> * 获取dex文件中的所有类</span><br><span class="hljs-comment"> * 进行分组</span><br><span class="hljs-comment"> * 然后输出</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TaskResult <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskExecuteException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dexFileList.size(); i++) &#123;<br>            RandomAccessFile dexFile = dexFileList.get(i);<br>            DexData dexData = <span class="hljs-keyword">new</span> DexData(dexFile);<br>            dexData.load();<br>            dexFile.close();<br>            <span class="hljs-comment">// 获取 dex 中定义的 class</span><br>            <span class="hljs-comment">// 注意 dex 中可能会有其他 dex 中的 class 的引用，这里是不包含的</span><br>            ClassRef[] defClassRefs = dexData.getInternalReferences();<br>            Set&lt;String&gt; classNameSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (ClassRef classRef : defClassRefs) &#123;<br>                <span class="hljs-comment">// 将 &quot;Ljava/lang/String;&quot; 变成 &quot;java.lang.String&quot;,</span><br>                String className = ApkUtil.getNormalClassName(classRef.getName());<br>                <span class="hljs-keyword">if</span> (classProguardMap.containsKey(className)) &#123;<br>                    <span class="hljs-comment">// 获取混淆前的类名</span><br>                    <span class="hljs-comment">// classProguardMap 是解压 task 中生成的 map</span><br>                    className = classProguardMap.get(className);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (className.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                classNameSet.add(className);<br>            &#125;<br>            ...<br>        <span class="hljs-keyword">return</span> taskResult;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TaskExecuteException(e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环里面的 DexData 是核心类，但是需要了解 dex 文件结构才能将解，会专门起一篇留到番外。</p><p>直接看输出的json，然后理解代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">15</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Count classes in dex file, output results group by package name.&quot;</span>,<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 21:34:37:539&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 21:34:39:381&quot;</span>,<br>  <span class="hljs-attr">&quot;total-classes&quot;</span>: <span class="hljs-number">1423</span>,<br>  <span class="hljs-attr">&quot;groups&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;android.support.v7.widget&quot;</span>,<br>      <span class="hljs-attr">&quot;class-count&quot;</span>: <span class="hljs-number">187</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;android.support.v4.app&quot;</span>,<br>      <span class="hljs-attr">&quot;class-count&quot;</span>: <span class="hljs-number">175</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;android.support.v4.view&quot;</span>,<br>      <span class="hljs-attr">&quot;class-count&quot;</span>: <span class="hljs-number">92</span><br>    &#125;,<br>    ...<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是将所有 dex 中的 class 按照包名分组，然后统计其数量。</p><p>那么，这个有什么用处呢？我个人的想法，其实是可以生成一个历史记录，看看每个版本各个包下的类的数量变化。</p><h3 id="CountRTask"><a href="#CountRTask" class="headerlink" title="CountRTask"></a>CountRTask</h3><p>这个 task 是用于计算所有 R 文件的字段数量。</p><p>如果没有特意的 keep R文件的话，由于 proguard 会将 R 文件的字段内联到代码里面，所以 release 版就不会有 R 文件。当然某些情况下需要keep R 文件，那么 最好的处理是只 keep 住需要的字段。</p><h4 id="call-方法-1"><a href="#call-方法-1" class="headerlink" title="call 方法"></a>call 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (RandomAccessFile dexFile : dexFileList) &#123;<br>    DexData dexData = <span class="hljs-keyword">new</span> DexData(dexFile);<br>    dexData.load();<br>    dexFile.close();<br>    ClassRef[] defClassRefs = dexData.getInternalReferences();<br>    <span class="hljs-comment">// 遍历dex中的类</span><br>    <span class="hljs-keyword">for</span> (ClassRef classRef : defClassRefs) &#123;<br>        <span class="hljs-comment">// 获取类名</span><br>        String className = ApkUtil.getNormalClassName(classRef.getName());<br>        <span class="hljs-keyword">if</span> (classProguardMap.containsKey(className)) &#123;<br>            <span class="hljs-comment">// 根据混淆文件，获取未混淆类名</span><br>            className = classProguardMap.get(className);<br>        &#125;<br>        <span class="hljs-comment">// 去除内部类的后半部分</span><br>        <span class="hljs-comment">// com.example.sample.R$styleable -&gt; com.example.sample.R</span><br>        String pureClassName = getOuterClassName(className);<br>        <span class="hljs-comment">// 一个光 R 是个什么鬼？？？</span><br>        <span class="hljs-comment">// 连包名都没有，java可以运行吗？</span><br>        <span class="hljs-keyword">if</span> (pureClassName.endsWith(<span class="hljs-string">&quot;.R&quot;</span>) || <span class="hljs-string">&quot;R&quot;</span>.equals(pureClassName)) &#123;<br>            <span class="hljs-comment">// 获取该类的字段长度</span><br>            <span class="hljs-keyword">if</span> (!classesMap.containsKey(pureClassName)) &#123;<br>                classesMap.put(pureClassName, classRef.getFieldArray().length);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 累加内部类</span><br>                <span class="hljs-comment">// com.example.sample.R$string</span><br>                <span class="hljs-comment">// com.example.sample.R$layout</span><br>                classesMap.put(pureClassName, classesMap.get(pureClassName) + classRef.getFieldArray().length);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算 R 文件的字段数量与计算 dex 中 class 数量是差不多的。主要是如何找到 R 文件。</p><p>输出结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">9</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Count the R class.&quot;</span>,<br>  <span class="hljs-attr">&quot;R-count&quot;</span>: <span class="hljs-number">27</span>,<br>  <span class="hljs-attr">&quot;Field-counts&quot;</span>: <span class="hljs-number">5449</span>,<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:16:14:524&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:16:16:318&quot;</span>,<br>  <span class="hljs-attr">&quot;R-classes&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;com.example.resapk.R&quot;</span>,<br>      <span class="hljs-attr">&quot;field-count&quot;</span>: <span class="hljs-number">1839</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;android.support.v7.appcompat.R&quot;</span>,<br>      <span class="hljs-attr">&quot;field-count&quot;</span>: <span class="hljs-number">1577</span><br>    &#125;,<br>    ...<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DuplicateFileTask"><a href="#DuplicateFileTask" class="headerlink" title="DuplicateFileTask"></a>DuplicateFileTask</h3><p>找出重复的文件。这个 task 还是很有用的，特别是对于一些资源文件。apk 解压后文件并不多，所以重复文件都是针对的 res 下的图片之类的。</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TaskResult <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskExecuteException </span>&#123;<br>    TaskResult taskResult = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>        computeMD5(inputFile);<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TaskExecuteException(e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> taskResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>为文件生成 md5 值，然后比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算出文件的 md5</span><br><span class="hljs-keyword">final</span> String md5 = Util.byteArrayToHex(msgDigest.digest());<br>String filename = file.getAbsolutePath().substring(inputFile.getAbsolutePath().length() + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 获取混淆之前的名字</span><br><span class="hljs-keyword">if</span> (entryNameMap.containsKey(filename)) &#123;<br>    filename = entryNameMap.get(filename);<br>&#125;<br><span class="hljs-keyword">if</span> (!md5Map.containsKey(md5)) &#123;<br>    md5Map.put(md5, <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>    <span class="hljs-comment">// 统计文件大小</span><br>    <span class="hljs-keyword">if</span> (entrySizeMap.containsKey(filename)) &#123;<br>        <span class="hljs-comment">// 文件重复就使用之前的数据</span><br>        fileSizeList.add(Pair.of(md5, entrySizeMap.get(filename).getFirst()));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fileSizeList.add(Pair.of(md5, totalRead));<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 统计所有文件的 md5</span><br><span class="hljs-comment">// 一个 md5 对应一个 list</span><br>md5Map.get(md5).add(filename);<br></code></pre></td></tr></table></figure><p>就是使用一个map记录所有文件的 md5，发现有重复的则添加到 list 里面。</p><p>看看输出格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Find out the duplicated files.&quot;</span>,<br>  <span class="hljs-attr">&quot;files&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;md5&quot;</span>: <span class="hljs-string">&quot;02aca4b1e0a80c3cf29ebefc103a506a&quot;</span>,<br>      <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">340</span>,<br>      <span class="hljs-attr">&quot;files&quot;</span>: [<br>        <span class="hljs-string">&quot;res\\drawable-xxhdpi-v4\\bg_shadow_top.png&quot;</span>,<br>        <span class="hljs-string">&quot;res\\drawable-xxhdpi-v4\\bg_shadow_top_copy.png&quot;</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;md5&quot;</span>: <span class="hljs-string">&quot;c9e47dbb0e1927076ed7b2e1ec157be7&quot;</span>,<br>      <span class="hljs-attr">&quot;size&quot;</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">&quot;files&quot;</span>: [<br>        <span class="hljs-string">&quot;META-INF\\androidx.appcompat_appcompat.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.asynclayoutinflater_asynclayoutinflater.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.coordinatorlayout_coordinatorlayout.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.core_core.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.cursoradapter_cursoradapter.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.customview_customview.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.documentfile_documentfile.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.drawerlayout_drawerlayout.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.fragment_fragment.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.interpolator_interpolator.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.legacy_legacy-support-core-ui.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.legacy_legacy-support-core-utils.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.loader_loader.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.localbroadcastmanager_localbroadcastmanager.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.print_print.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.slidingpanelayout_slidingpanelayout.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.swiperefreshlayout_swiperefreshlayout.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.vectordrawable_vectordrawable-animated.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.vectordrawable_vectordrawable.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.versionedparcelable_versionedparcelable.version&quot;</span>,<br>        <span class="hljs-string">&quot;META-INF\\androidx.viewpager_viewpager.version&quot;</span><br>      ]<br>    &#125;<br>    ...<br>  ],<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:29:58:809&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:29:58:910&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FindNonAlphaPngTask"><a href="#FindNonAlphaPngTask" class="headerlink" title="FindNonAlphaPngTask"></a>FindNonAlphaPngTask</h3><p>找出不带透明通道的 png 图片，因为没有透明通道，png 就是浪费，可以使用 jpg 等别的格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findNonAlphaPng</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (file != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br>            File[] files = file.listFiles();<br>            <span class="hljs-keyword">for</span> (File tempFile : files) &#123;<br>                findNonAlphaPng(tempFile);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.PNG_FILE_SUFFIX) &amp;&amp; !file.getName().endsWith(ApkConstants.NINE_PNG)) &#123;<br>            <span class="hljs-comment">// png 文件，但是不是 .9</span><br>            <span class="hljs-comment">// .9 图片需要透明度，所以直接跳过</span><br>            BufferedImage bufferedImage = ImageIO.read(file);<br>            <span class="hljs-comment">// 如果 没有 alpha 通道</span><br>            <span class="hljs-keyword">if</span> (bufferedImage != <span class="hljs-keyword">null</span> &amp;&amp; bufferedImage.getColorModel() != <span class="hljs-keyword">null</span> &amp;&amp; !bufferedImage.getColorModel().hasAlpha()) &#123;<br>                <span class="hljs-comment">// 获取文件名</span><br>                String filename = file.getAbsolutePath().substring(inputFile.getAbsolutePath().length() + <span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 获取混淆前的文件名</span><br>                <span class="hljs-keyword">if</span> (entryNameMap.containsKey(filename)) &#123;<br>                    filename = entryNameMap.get(filename);<br>                &#125;<br>                <span class="hljs-keyword">long</span> size = file.length();<br>                <span class="hljs-keyword">if</span> (entrySizeMap.containsKey(filename)) &#123;<br>                    <span class="hljs-comment">// 获取文件大小</span><br>                    size = entrySizeMap.get(filename).getFirst();<br>                &#125;<br>                <span class="hljs-comment">// 大于阈值，记录下来</span><br>                <span class="hljs-keyword">if</span> (size &gt;= downLimitSize * ApkConstants.K1024) &#123;<br>                    nonAlphaPngList.add(Pair.of(filename, file.length()));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是一个递归函数，直接看 else if 的逻辑就好了。</p><p>我还是第一个次见到 BufferedImage 这个 API，学到了。</p><h3 id="ManifestAnalyzeTask"><a href="#ManifestAnalyzeTask" class="headerlink" title="ManifestAnalyzeTask"></a>ManifestAnalyzeTask</h3><p>分析 manifest 文件。这里有个有意思的东西，在 eclipse 年代，我们的版本号都是写在  manifest 中的，现在写在了 gradle 中，那么问题来了，当编译之后，可以从 manifest  获取到版本号吗？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionCode</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionName</span>=<span class="hljs-string">&quot;1.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:compileSdkVersion</span>=<span class="hljs-string">&quot;29&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:compileSdkVersionCodename</span>=<span class="hljs-string">&quot;10&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.resapk&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">platformBuildVersionCode</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">platformBuildVersionName</span>=<span class="hljs-string">&quot;1065353216.000000&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-sdk</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:minSdkVersion</span>=<span class="hljs-string">&quot;19&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:targetSdkVersion</span>=<span class="hljs-string">&quot;29&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>上面的 xml 是我从 apk 里面解压出来，拖到 as 里面展示的信息，里面是可以获取到版本号的。</p><p>而且，我们也可以在 intermediates 中看最终的 manifest 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.resapk&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionCode</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:versionName</span>=<span class="hljs-string">&quot;1.0&quot;</span> &gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-sdk</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:minSdkVersion</span>=<span class="hljs-string">&quot;19&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:targetSdkVersion</span>=<span class="hljs-string">&quot;29&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>解析代码其实就是一个 xml 解析器，就不贴代码了，不过有一个疑问，就是这个解析器还使用到了 arsc 文件，很奇怪，肯能与 api 的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ManifestParser</span><span class="hljs-params">(File manifestFile, File arscFile)</span> <span class="hljs-keyword">throws</span> IOException, AndrolibException </span>&#123;<br>    <span class="hljs-keyword">if</span> (manifestFile != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.manifestFile = manifestFile;<br>    &#125;<br>    resourceParser = ApkResourceDecoder.createAXmlParser(arscFile);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Read package info from the AndroidManifest.xml.&quot;</span>,<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:29:55:208&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 22:29:55:217&quot;</span>,<br>  <span class="hljs-attr">&quot;manifest&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;package&quot;</span>: <span class="hljs-string">&quot;com.example.resapk&quot;</span>,<br>    <span class="hljs-attr">&quot;android:minSdkVersion&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,<br>    <span class="hljs-attr">&quot;android:targetSdkVersion&quot;</span>: <span class="hljs-string">&quot;29&quot;</span>,<br>    <span class="hljs-attr">&quot;android:versionCode&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>    <span class="hljs-attr">&quot;android:versionName&quot;</span>: <span class="hljs-string">&quot;1.0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MethodCountTask"><a href="#MethodCountTask" class="headerlink" title="MethodCountTask"></a>MethodCountTask</h3><p>统计 apk 中的方法数量，可以分组。这个task的逻辑与 CountClassTask 很像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDex</span><span class="hljs-params">(RandomAccessFile dexFile)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    classInternalMethod.clear();<br>    classExternalMethod.clear();<br>    pkgInternalRefMethod.clear();<br>    pkgExternalMethod.clear();<br>    DexData dexData = <span class="hljs-keyword">new</span> DexData(dexFile);<br>    dexData.load();<br>    <span class="hljs-comment">// 获取 dex 中的方法，在 struct method_id_list dex_method_ids 中储存</span><br>    MethodRef[] methodRefs = dexData.getMethodRefs();<br>    <span class="hljs-comment">// 获取不属于该 dex 的类</span><br>    ClassRef[] externalClassRefs = dexData.getExternalReferences();<br>    Map&lt;String, String&gt; proguardClassMap = config.getProguardClassMap();<br>    String className = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">for</span> (ClassRef classRef : externalClassRefs) &#123;<br>        className = ApkUtil.getNormalClassName(classRef.getName());<br>        <span class="hljs-keyword">if</span> (proguardClassMap.containsKey(className)) &#123;<br>            className = proguardClassMap.get(className);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (className.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将外部类的方法数置为0</span><br>        classExternalMethod.put(className, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (MethodRef methodRef : methodRefs) &#123;<br>        <span class="hljs-comment">// 该方法所属的类</span><br>        className = ApkUtil.getNormalClassName(methodRef.getDeclClassName());<br>        <span class="hljs-keyword">if</span> (proguardClassMap.containsKey(className)) &#123;<br>            className = proguardClassMap.get(className);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!Util.isNullOrNil(className)) &#123;<br>            <span class="hljs-keyword">if</span> (className.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 将dex内部方法放到 classInternalMethod</span><br>            <span class="hljs-comment">// 将dex外部方法方法 classExternalMethod</span><br>            <span class="hljs-keyword">if</span> (classExternalMethod.containsKey(className)) &#123;<br>                classExternalMethod.put(className, classExternalMethod.get(className) + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (classInternalMethod.containsKey(className)) &#123;<br>                classInternalMethod.put(className, classInternalMethod.get(className) + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                classInternalMethod.put(className, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 移除外部类（引用的方法为0的）</span><br>    <span class="hljs-comment">//remove 0-method referenced class</span><br>    Iterator&lt;String&gt; iterator = classExternalMethod.keySet().iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (classExternalMethod.get(iterator.next()) == <span class="hljs-number">0</span>) &#123;<br>            iterator.remove();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>统计 dex 中的方法数量，这里由于 class 分为两种，一种是 dex 中定义的，一种是引用的别的 dex 的。所以这里区分了一下，这个指标可以作为分包的一个指标，因为如果一个dex里面引用的别的 dex 的 class 非常多的话，说明分包没分好，会导致 dex 体积变大，从而导致 apk 变大。</p><p>看看输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>    &#123;<br>        <span class="hljs-attr">&quot;dex-file&quot;</span>:<span class="hljs-string">&quot;classes.dex&quot;</span>,<br>        <span class="hljs-attr">&quot;internal-packages&quot;</span>:[<br>            &#123;<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;android.support.v7.widget&quot;</span>,<br>                <span class="hljs-attr">&quot;methods&quot;</span>:<span class="hljs-number">2390</span><br>            &#125;,<br>            ...<br>            &#123;<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;com.example.resapk&quot;</span>,<br>                <span class="hljs-attr">&quot;methods&quot;</span>:<span class="hljs-number">24</span><br>            &#125;,<br>            ...<br>        ],<br>        <span class="hljs-attr">&quot;total-internal-classes&quot;</span>:<span class="hljs-number">1316</span>,<br>        <span class="hljs-attr">&quot;total-internal-methods&quot;</span>:<span class="hljs-number">12459</span>,<br>        <span class="hljs-attr">&quot;external-packages&quot;</span>:[<br>            &#123;<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;android.view&quot;</span>,<br>                <span class="hljs-attr">&quot;methods&quot;</span>:<span class="hljs-number">692</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;android.widget&quot;</span>,<br>                <span class="hljs-attr">&quot;methods&quot;</span>:<span class="hljs-number">563</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;android.app&quot;</span>,<br>                <span class="hljs-attr">&quot;methods&quot;</span>:<span class="hljs-number">271</span><br>            &#125;,<br>            ...<br>        ],<br>        <span class="hljs-attr">&quot;total-external-classes&quot;</span>:<span class="hljs-number">481</span>,<br>        <span class="hljs-attr">&quot;total-external-methods&quot;</span>:<span class="hljs-number">3598</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>可以看出我们的 dex 中，使用 framework 的方法有 3598 个。</p><p>这里原始的输出，但是经过格式化之后，只能看到这样的信息，不太清楚为啥要减少字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Count methods in dex file, output results group by class name or package name.&quot;</span>,<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 23:19:26:927&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 23:19:28:421&quot;</span>,<br>  <span class="hljs-attr">&quot;total-methods&quot;</span>: <span class="hljs-number">16057</span>,<br>  <span class="hljs-attr">&quot;groups&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Android System&quot;</span>,<br>      <span class="hljs-attr">&quot;method-count&quot;</span>: <span class="hljs-number">15486</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;java system&quot;</span>,<br>      <span class="hljs-attr">&quot;method-count&quot;</span>: <span class="hljs-number">531</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;[others]&quot;</span>,<br>      <span class="hljs-attr">&quot;method-count&quot;</span>: <span class="hljs-number">40</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>关于 dex 的 class 的信息没有了。</p><h3 id="MultiSTLCheckTask"><a href="#MultiSTLCheckTask" class="headerlink" title="MultiSTLCheckTask"></a>MultiSTLCheckTask</h3><p>这个检测是与 so 有关，但是这方面我不熟，里面的检测主要是使用 nm 工具的输出信息，所以我就不介绍了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里不熟悉 nm 工具。所以不太清楚在做什么</span><br><span class="hljs-comment">// 使用 arm-linux-androideabi-nm 分析指定的 so 文件，-D -C 参数</span><br><span class="hljs-comment">// 参数意义：https://manned.org/arm-linux-androideabi-nm/07ad85eb</span><br><span class="hljs-comment">// 判断输出的每一行内容</span><br><span class="hljs-comment">// 0001df70 T std::get_unexpected()</span><br><span class="hljs-comment">// 0001df50 T std::set_unexpected(void (*)())</span><br><span class="hljs-comment">// 00016780 T std::get_new_handler()</span><br><span class="hljs-comment">// 00016760 T std::set_new_handler(void (*)())</span><br><span class="hljs-comment">// 0001dd90 T std::current_exception()</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStlLinked</span><span class="hljs-params">(File libFile)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder(toolnmPath, <span class="hljs-string">&quot;-D&quot;</span>, <span class="hljs-string">&quot;-C&quot;</span>, libFile.getAbsolutePath());<br>    Process process = processBuilder.start();<br>    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(process.getInputStream()));<br>    String line = reader.readLine();<br>    <span class="hljs-keyword">while</span> (line != <span class="hljs-keyword">null</span>) &#123;<br>        String[] columns = line.split(<span class="hljs-string">&quot; &quot;</span>);<br>        Log.d(TAG, <span class="hljs-string">&quot;%s&quot;</span>, line);<br>        <span class="hljs-keyword">if</span> (columns.length &gt;= <span class="hljs-number">3</span> &amp;&amp; columns[<span class="hljs-number">1</span>].equals(<span class="hljs-string">&quot;T&quot;</span>) &amp;&amp; columns[<span class="hljs-number">2</span>].startsWith(<span class="hljs-string">&quot;std::&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        line = reader.readLine();<br>    &#125;<br>    reader.close();<br>    process.waitFor();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MultiLibCheckTask"><a href="#MultiLibCheckTask" class="headerlink" title="MultiLibCheckTask"></a>MultiLibCheckTask</h3><p>这个很简单，就是判断  libs 下是否有超过1个目录，很简单，就不贴代码了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 这个 task 很简单，就是输出 lib 下的各个目录</span><br><span class="hljs-comment">//   &quot;lib-dirs&quot;: [</span><br><span class="hljs-comment">//    &quot;arm64-v8a&quot;,</span><br><span class="hljs-comment">//    &quot;armeabi&quot;,</span><br><span class="hljs-comment">//    &quot;armeabi-v7a&quot;,</span><br><span class="hljs-comment">//    &quot;mips&quot;,</span><br><span class="hljs-comment">//    &quot;mips64&quot;,</span><br><span class="hljs-comment">//    &quot;x86&quot;,</span><br><span class="hljs-comment">//    &quot;x86_64&quot;</span><br><span class="hljs-comment">//  ],</span><br><span class="hljs-comment">//  &quot;multi-lib&quot;: true,</span><br></code></pre></td></tr></table></figure><h3 id="ResProguardCheckTask"><a href="#ResProguardCheckTask" class="headerlink" title="ResProguardCheckTask"></a>ResProguardCheckTask</h3><p>这个task是判断apk的资源是否被混淆了。</p><p>咋判断呢？</p><p>第一种情况，如果存在 r 目录，则肯定是被混淆了，因为是配合的 AndResGuard 使用的。</p><p>第二种情况，如果存在 res 目录，需要判断厘米的各个目录是否被混淆了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">fileNamePattern = Pattern.compile(<span class="hljs-string">&quot;[a-z_0-9]&#123;1,3&#125;&quot;</span>);<br><br><span class="hljs-keyword">if</span> (dir.isDirectory() &amp;&amp; !fileNamePattern.matcher(dir.getName()).matches()) &#123;<br>    hasProguard = <span class="hljs-keyword">false</span>;<br>    Log.i(TAG, <span class="hljs-string">&quot;directory &quot;</span> + dir.getName() + <span class="hljs-string">&quot; has a non-proguard name!&quot;</span>);<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断方法很简单，看看混淆后的目录名字是否超过了3个即可。</p><h3 id="ShowFileSizeTask"><a href="#ShowFileSizeTask" class="headerlink" title="ShowFileSizeTask"></a>ShowFileSizeTask</h3><p>这个 task 是用来找出超过一定大小的文件的。这个还是挺有用，可以找出ui切的大图。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;taskType&quot;</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">&quot;taskDescription&quot;</span>: <span class="hljs-string">&quot;Show files whose size exceed limit size in order.&quot;</span>,<br>  <span class="hljs-attr">&quot;files&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;entry-name&quot;</span>: <span class="hljs-string">&quot;resources.arsc&quot;</span>,<br>      <span class="hljs-attr">&quot;entry-size&quot;</span>: <span class="hljs-number">265548</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;entry-name&quot;</span>: <span class="hljs-string">&quot;res/mipmap-xxxhdpi-v4/ic_launcher_round.png&quot;</span>,<br>      <span class="hljs-attr">&quot;entry-size&quot;</span>: <span class="hljs-number">16570</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;entry-name&quot;</span>: <span class="hljs-string">&quot;res/mipmap-xxhdpi-v4/ic_launcher_round.png&quot;</span>,<br>      <span class="hljs-attr">&quot;entry-size&quot;</span>: <span class="hljs-number">11873</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;entry-name&quot;</span>: <span class="hljs-string">&quot;res/mipmap-xxxhdpi-v4/ic_launcher.png&quot;</span>,<br>      <span class="hljs-attr">&quot;entry-size&quot;</span>: <span class="hljs-number">10652</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">&quot;start-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 23:22:35:851&quot;</span>,<br>  <span class="hljs-attr">&quot;end-time&quot;</span>: <span class="hljs-string">&quot;2020-08-03 23:22:35:863&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为，解压的时候记录了每个文件的大小，所以直接进行分组就好了。这里是因为过滤了指定后缀文件，所以才这么少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Pair&lt;Long, Long&gt;&gt; entry : entrySizeMap.entrySet()) &#123;<br>    <span class="hljs-comment">// 文件后缀</span><br>    <span class="hljs-keyword">final</span> String suffix = getSuffix(entry.getKey());<br>    Pair&lt;Long, Long&gt; size = entry.getValue();<br>    <span class="hljs-comment">// 文件大小超过下限</span><br>    <span class="hljs-keyword">if</span> (size.getFirst() &gt;= downLimit * ApkConstants.K1024) &#123;<br>        <span class="hljs-comment">// 有在参数指定该后缀，则统计</span><br>        <span class="hljs-comment">// 没有指定任何后缀，也统计</span><br>        <span class="hljs-comment">// 否则，忽略</span><br>        <span class="hljs-keyword">if</span> (filterSuffix.isEmpty() || filterSuffix.contains(suffix)) &#123;<br>            entryList.add(Pair.of(entry.getKey(), size.getFirst()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;file: %s, filter by suffix.&quot;</span>, entry.getKey());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;file:%s, size:%d B, downlimit:%d KB&quot;</span>, entry.getKey(), size.getFirst(), downLimit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UncompressedFileTask"><a href="#UncompressedFileTask" class="headerlink" title="UncompressedFileTask"></a>UncompressedFileTask</h4><p>该任务是输出压缩前后大小仍然相等的文件，apk 实质上是一个压缩文件，所以里面的文件都是经过压缩的才对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Pair&lt;Long, Long&gt;&gt; entry : entrySizeMap.entrySet()) &#123;<br>    <span class="hljs-keyword">final</span> String suffix = getSuffix(entry.getKey());<br>    Pair&lt;Long, Long&gt; size = entry.getValue();<br>    <span class="hljs-comment">// 将压缩前的文件放入 uncompressSizeMap</span><br>    <span class="hljs-comment">// 将压缩后的文件放入 compressSizeMap</span><br>    <span class="hljs-keyword">if</span> (filterSuffix.isEmpty() || filterSuffix.contains(suffix)) &#123;<br>        <span class="hljs-keyword">if</span> (!uncompressSizeMap.containsKey(suffix)) &#123;<br>            uncompressSizeMap.put(suffix, size.getFirst());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            uncompressSizeMap.put(suffix, uncompressSizeMap.get(suffix) + size.getFirst());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!compressSizeMap.containsKey(suffix)) &#123;<br>            compressSizeMap.put(suffix, size.getSecond());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            compressSizeMap.put(suffix, compressSizeMap.get(suffix) + size.getSecond());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;file: %s, filter by suffix.&quot;</span>, entry.getKey());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断压缩前后的文件大小是否相等</span><br><span class="hljs-keyword">if</span> (uncompressSizeMap.get(suffix).equals(compressSizeMap.get(suffix))) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>是因为解压apk的时候，统计了每个文件的大小，压缩前后的大小，所以可以直接使用。</p><h4 id="UnStrippedSoCheckTask"><a href="#UnStrippedSoCheckTask" class="headerlink" title="UnStrippedSoCheckTask"></a>UnStrippedSoCheckTask</h4><p>这个任务，同样使用到了 nm 工具，所以我不熟。因为使用到了 nm 工具，所以，需要配置该工具的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSoStripped</span><span class="hljs-params">(File libFile)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 使用 arm-linux-androideabi-nm 分析指定的 so 文件，不带参数</span><br>    ProcessBuilder processBuilder = <span class="hljs-keyword">new</span> ProcessBuilder(toolnmPath, libFile.getAbsolutePath());<br>    Process process = processBuilder.start();<br>    BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(process.getErrorStream()));<br>    String line = reader.readLine();<br>    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// aarch64-linux-android-nm: libcrashlytics.so: no symbols</span><br>    <span class="hljs-comment">// 如果输出上面的信息，则通过，当然这里我是不太懂到底是个啥</span><br>    <span class="hljs-keyword">if</span> (!Util.isNullOrNil(line)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;%s&quot;</span>, line);<br>        String[] columns = line.split(<span class="hljs-string">&quot;:&quot;</span>);<br>        <span class="hljs-keyword">if</span> (columns.length == <span class="hljs-number">3</span> &amp;&amp; columns[<span class="hljs-number">2</span>].trim().equalsIgnoreCase(<span class="hljs-string">&quot;no symbols&quot;</span>)) &#123;<br>            result = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    reader.close();<br>    process.waitFor();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>009-Matrix源码分析：ApkChecker解压apk.md</title>
    <link href="/2020/08/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/009-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E8%A7%A3%E5%8E%8Bapk/"/>
    <url>/2020/08/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/009-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E8%A7%A3%E5%8E%8Bapk/</url>
    
    <content type="html"><![CDATA[<p>这篇本来无甚难度，之所以单独一篇，是因为它输出的一些结果，后面的 task 都会用上。</p><h4 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskInitException </span>&#123;<br>    <span class="hljs-keyword">super</span>.init();<br>    inputFile = <span class="hljs-keyword">new</span> File(config.getApkPath());<br><br>    outputFile = <span class="hljs-keyword">new</span> File(config.getUnzipPath());<br><br>    mappingTxt = <span class="hljs-keyword">new</span> File(config.getMappingFilePath());<br><br>    resMappingTxt = <span class="hljs-keyword">new</span> File(config.getResMappingFilePath());<br>&#125;<br></code></pre></td></tr></table></figure><p>inputFile 是 apk 的路径。</p><p>outputFile 是 apk 解压后的输出路径。ApkChecker运行完成之后，会删除该目录。</p><p>mappingTxt 是 mapping 文件，因为 R.string 等类可能会被混淆。</p><p>resMappingTxt 是使用了 AndResGuard 的工程会有这个，是因为资源名会被混淆，比如 res/layout/activity_main 混淆成了 r/l/a，输出混淆后的名称出来，根本看不懂。</p><h4 id="call-函数"><a href="#call-函数" class="headerlink" title="call 函数"></a>call 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TaskResult <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskExecuteException </span>&#123;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br><br>        <span class="hljs-comment">// 读 mappping 文件</span><br>        readMappingTxtFile();<br>        config.setProguardClassMap(proguardClassMap);<br>        <span class="hljs-comment">// 读 resource_mapping 文件</span><br>        readResMappingTxtFile();<br>        config.setResguardMap(resguardMap);<br><br>        Enumeration entries = zipFile.entries();<br>        JsonArray jsonArray = <span class="hljs-keyword">new</span> JsonArray();<br>        String outEntryName = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (entries.hasMoreElements()) &#123;<br>            ZipEntry entry = (ZipEntry) entries.nextElement();<br>            <span class="hljs-comment">// writeEntry 里面只是将文件解压出来了</span><br>            <span class="hljs-comment">// 返回的 outEntryName 是资源未混淆之前的名字</span><br>            outEntryName = writeEntry(zipFile, entry);<br>            <span class="hljs-keyword">if</span> (!Util.isNullOrNil(outEntryName)) &#123;<br>                JsonObject fileItem = <span class="hljs-keyword">new</span> JsonObject();<br>                fileItem.addProperty(<span class="hljs-string">&quot;entry-name&quot;</span>, outEntryName);<br>                fileItem.addProperty(<span class="hljs-string">&quot;entry-size&quot;</span>, entry.getCompressedSize());<br>                jsonArray.add(fileItem);<br>                <span class="hljs-comment">// key：文件未混淆时名字</span><br>                <span class="hljs-comment">// value： &lt;文件大小，文件压缩后大小&gt;</span><br>                entrySizeMap.put(outEntryName, Pair.of(entry.getSize(), entry.getCompressedSize()));<br>                <span class="hljs-comment">// key： 文件混淆时名字</span><br>                <span class="hljs-comment">// value：文件未混淆时名字</span><br>                entryNameMap.put(entry.getName(), outEntryName);<br>            &#125;<br>        &#125;<br><br>        config.setEntrySizeMap(entrySizeMap);<br>        config.setEntryNameMap(entryNameMap);<br>        ...<br>        <span class="hljs-keyword">return</span> taskResult;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TaskExecuteException(e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心代码还是比较简单的。</p><p>先读取 mapping 文件，好还原 R$xxx.class 是啥。读取的代码就不分析了，对着 mapping 文件的格式来看还是很好理解的。</p><p><code>config.setProguardClassMap(proguardClassMap);</code> 这行代码比较重要，因为 proguardClassMap 这个 map 后面的 task 会常常用到，可以用于还原类名。</p><p>在读取，resMapping 文件，好还原资源名。读取代码也不分析了，生成 resMapping 需要接入 AndResGuard，可以试试，会长不少见识。也是对着生成的文件看代码，没啥好说的。</p><p><code>config.setResguardMap(resguardMap);</code>，这个resguardMap后面的task也是会用到的。</p><p>entrySizeMap 与 entryNameMap ，后面的 task 也会用到。</p><p>总结，这个 task 里面做了如下动作：</p><ul><li>mapping</li><li>resMapping</li><li>文件名字（混淆前后，主要针对资源文件），文件大小（压缩前后）</li></ul><p>更详细的注释，查看 github 的 note 分支。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>010-Matrix源码分析：ApkChecker检查无用资源</title>
    <link href="/2020/07/30/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/010-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E6%A3%80%E6%9F%A5%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90/"/>
    <url>/2020/07/30/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/010-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E6%A3%80%E6%9F%A5%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>分析无用资源，Android studio 本身就提供了lint工具。但是有个缺点就是无法配合proguard使用，无用代码引用的资源是不会被计算出来的。</p><p>ApkChecker里面提供了两个小工具，可以直接分析apk包里面的无用资源（res目录与asset目录）。</p><h3 id="UnusedAssetsTask"><a href="#UnusedAssetsTask" class="headerlink" title="UnusedAssetsTask"></a>UnusedAssetsTask</h3><p>我们先看简单一些的 UnusedAssetsTask 类，该类用于寻找出没有使用的 asset 资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnusedAssetsTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApkTask</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>ApkChecker里面提供了十来个小工具，都是继承于 ApkTask，但是 ApkTask 里面啥都没有，只是做了输入参数处理，与提供一个统一处理核心逻辑的地方。</p><p>Task 的分析，主要是3部分</p><ul><li><p>第一部分是构造函数，里面有个 type 比较重要，输出 task 分析的结果会用到，后面会有展示。</p></li><li><p>第二部分是 init 函数，用于初始化一些变量。</p></li><li><p>第三部分是 call 函数，里面是 task 的核心逻辑。</p></li></ul><p>后面的 task 都会按照这个模板来分析。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnusedAssetsTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApkTask</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;Matrix.UnusedAssetsTask&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnusedAssetsTask</span><span class="hljs-params">(JobConfig config, Map&lt;String, String&gt; params)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(config, params);<br>        type = TaskFactory.TASK_TYPE_UNUSED_ASSETS;<br>        dexFileNameList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ignoreSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        assetsPathSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        assetRefSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    &#125;<br></code></pre></td></tr></table></figure><p>JobConfig 是从命令行输入读取的配置信息解析而成的对象。ApkChecker 除了提供了十几个小工具用于分析与优化APK，由于它是一个命令行工具，所以还有一部分代码都是与读取参数有关，就比如我们平时使用的 <code>ls -l</code> 命令，会带些参数，还是一套比较完整的解析代码，而且对于结果输出，也有json与html两个格式，这也涉及到些设计模式，与重构还是代码大全的某个例子有点类似，有兴趣的可以研究研究。</p><h4 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskInitException </span>&#123;<br>    <span class="hljs-keyword">super</span>.init();<br><br>    String inputPath = config.getUnzipPath();<br>    inputFile = <span class="hljs-keyword">new</span> File(inputPath);<br>    ...<br><br>    <span class="hljs-comment">// 收集 dex 文件</span><br>    File[] files = inputFile.listFiles();<br>    <span class="hljs-keyword">if</span> (files != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.DEX_FILE_SUFFIX)) &#123;<br>                dexFileNameList.add(file.getName());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>config.getUnzipPath</code>是获取解压的路径，09 篇说了 <code>UnzipTask</code> 任务，它将需要分析的 apk 解压，这里的路径就是解压目录路径。</p><p>这个函数主要是获取所有 .dex 文件。</p><h4 id="call-函数"><a href="#call-函数" class="headerlink" title="call 函数"></a>call 函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs @Override">@Override<br>public TaskResult call() throws TaskExecuteException &#123;<br>    try &#123;<br>        ...<br>        <br>        // 收集 asset 目录下文件<br>        findAssetsFile(assetDir);<br>        <br>        // 收集相对路径，里面去除了配置的忽略文件<br>        // 因为写忽略配置文件，肯定是相对 assets 目录的<br>        // --ignoreAssets<br>        //  assetsPathSet 里面存放的是 asset 目录下的所有文件<br>        generateAssetsSet(assetDir.getAbsolutePath());<br>        <br>        Log.i(TAG, &quot;find all assets count: %d&quot;, assetsPathSet.size());<br>        decodeCode();<br>        // assetRefSet 里面存放的是 配置的忽略的资源 + smali 中引用到的资源<br>        Log.i(TAG, &quot;find reference assets count: %d&quot;, assetRefSet.size());<br>        assetsPathSet.removeAll(assetRefSet);<br>        ...<br>    &#125; catch (Exception e) &#123;<br>        throw new TaskExecuteException(e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以自己先想一下，如何才能找出 assets 目录下的未使用的资源？</p><p>访问 asset 资源的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">webView.loadUrl(<span class="hljs-string">&quot;file:///android_asset/win8_Demo/index.html&quot;</span>);<br>getAssets().open(<span class="hljs-string">&quot;wpics/0ZR424L-0.jpg&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以看到，我们都是使用的字符串来表示 assets 目录下的某一特定资源。</p><p>当 .dex 反编译为 .smail 代码的时候，对于常量字符串，都是以 <code>const-string</code> 开头的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smail">// const-string 的语法：<br>// const-string v0, &quot;LOG&quot;        # 将v0寄存器赋值为字符串常量&quot;LOG&quot;<br>// 这算是一种简单的分析方式<br></code></pre></td></tr></table></figure><p>所以，以这种方式，我们可以得出一个大致正确的结果。</p><p>所以思路就是：<strong>以读取文件的方式，遍历 smali 代码文件，找到所有使用常量字符串的地方。</strong></p><p>需要先反编译 .dex 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decodeCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">for</span> (String dexFileName : dexFileNameList) &#123;<br>        <span class="hljs-comment">// 使用 apktool 加载 dex 文件</span><br>        DexBackedDexFile dexFile = DexFileFactory.loadDexFile(<span class="hljs-keyword">new</span> File(inputFile, dexFileName), Opcodes.forApi(<span class="hljs-number">15</span>));<br><br>        BaksmaliOptions options = <span class="hljs-keyword">new</span> BaksmaliOptions();<br>        <span class="hljs-comment">// class 类按自然排序</span><br>        List&lt;? extends ClassDef&gt; classDefs = Ordering.natural().sortedCopy(dexFile.getClasses());<br><br>        <span class="hljs-keyword">for</span> (ClassDef classDef : classDefs) &#123;<br>            <span class="hljs-comment">// 从 ClassDef 中获取该 class 对应的 smali 代码</span><br>            String[] lines = ApkUtil.disassembleClass(classDef, options);<br>            <span class="hljs-keyword">if</span> (lines != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 分析 smali 代码</span><br>                readSmaliLines(lines);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的是 APKTOOL 的 api，就不介绍了，我也不熟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readSmaliLines</span><span class="hljs-params">(String[] lines)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lines == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (String line : lines) &#123;<br>        line = line.trim();<br>        <span class="hljs-comment">// 找 常量字符串，因为使用 assets 中的资源文件，方式是很单一的，需要指定文件的名字</span><br>        <span class="hljs-comment">// 所以遍历 smali 代码，找到所有使用常量字符串的地方</span><br>        <span class="hljs-comment">// const-string 的语法：</span><br>        <span class="hljs-comment">// const-string v0, &quot;LOG&quot;        # 将v0寄存器赋值为字符串常量&quot;LOG&quot;</span><br>        <span class="hljs-comment">// 这算是一种简单的分析方式</span><br>        <span class="hljs-keyword">if</span> (!Util.isNullOrNil(line) &amp;&amp; line.startsWith(<span class="hljs-string">&quot;const-string&quot;</span>)) &#123;<br>            String[] columns = line.split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">if</span> (columns.length == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// 获取 , 后面的</span><br>                String assetFileName = columns[<span class="hljs-number">1</span>].trim();<br>                <span class="hljs-comment">// 去除双引号</span><br>                assetFileName = assetFileName.substring(<span class="hljs-number">1</span>, assetFileName.length() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (!Util.isNullOrNil(assetFileName)) &#123;<br>                    <span class="hljs-comment">// 遍历之前收集的所有资源文件的路径</span><br>                    <span class="hljs-keyword">for</span> (String path : assetsPathSet) &#123;<br>                        <span class="hljs-comment">// 如果包含该文件</span><br>                        <span class="hljs-keyword">if</span> (assetFileName.endsWith(path)) &#123;<br>                            <span class="hljs-comment">// 存放到 assetRefSet 里面</span><br>                            assetRefSet.add(path);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是判断，<strong>const-string 的字符串里面有没有与 asset 目录下资源名一样的，有的话就算这个资源文件被使用了。</strong></p><p>当然，如果恰好你的字符串与资源名相同，那就会误判。</p><p>如何分析 asset 资源文件有没有被使用，ApkChecker 提供了一个简单的判断方式，虽然不完全准确，但是对我们应该也有启发。</p><p>那么，可以思考一下，如何判断 libs 文件夹下的 jar 包有没有被引用？这个 ApkChecker 中并没有实现，如果有思路可以提pr。</p><p>下面再介绍一下，如何分析res中的资源有没有被引用？</p><h3 id="UnusedResourcesTask"><a href="#UnusedResourcesTask" class="headerlink" title="UnusedResourcesTask"></a>UnusedResourcesTask</h3><p>分析 res 下无用资源与 assets 下无用资源是相似的，但是需要弄清楚一件事：</p><p>当我们在 layout 等xml资源中使用了 values 文件中的资源，这个在代码中是无法找到的，所以需要理清思路，分析各个资源的引用关系。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>ApkChecker 里面提供的思路如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">首先，代码里面引用的资源肯定需要标记为已使用。比如：<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.activity_main，其次，<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.activity_main 文件引用的资源，也需要标记为已使用。<br>所以，我们需要想办法收集到 res 目录下资源的相互引用关系。<br></code></pre></td></tr></table></figure><p>ApkChecker 将 res 下的资源分为两部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ResPackage pkg : resTable.listMainPackages()) &#123;<br>    aXmlResourceParser.getAttrDecoder().setCurrentPackage(pkg);<br>    <span class="hljs-comment">// layout</span><br>    <span class="hljs-comment">// drawable</span><br>    <span class="hljs-comment">// anim</span><br>    <span class="hljs-comment">// menu</span><br>    <span class="hljs-comment">// animator</span><br>    <span class="hljs-comment">// color</span><br>    <span class="hljs-comment">// 等等 .xml 文件</span><br>    <span class="hljs-keyword">for</span> (ResResource resSource : pkg.listFiles()) &#123;<br>        decodeResResource(resSource, resDir, aXmlResourceParser, nonValueReferences);<br>    &#125;<br><br>    <span class="hljs-comment">// 这里直接读取的 values 下的文件</span><br>    <span class="hljs-keyword">for</span> (ResValuesFile valuesFile : pkg.listValuesFiles()) &#123;<br>        Log.e(<span class="hljs-string">&quot;ResValuesFile&quot;</span>, <span class="hljs-string">&quot;path = &quot;</span> + valuesFile.getPath());<br>        decodeResValues(valuesFile, xmlPullParser, serializer, valueReferences);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nonValueReferences 最后储存的是 非values 下资源文件的引用关系，比如，R.layout.activity_main 引用了哪些资源。</p><p>valueReferences 储存的是 values 下资源的引用关系，比如，R.string.app_namex 引用了哪些资源。</p><p>获取了 res 下资源的相互引用关系之后，就可以开始标记有用资源了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readChildReference</span><span class="hljs-params">(String resource)</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br>    <span class="hljs-keyword">if</span> (nonValueReferences.containsKey(resource)) &#123;<br>        visitPath.push(resource);<br>        <span class="hljs-comment">// 获取该资源引用的其他资源</span><br>        Set&lt;String&gt; childReference = nonValueReferences.get(resource);<br>        <span class="hljs-comment">// 资源有被引用则从 unusedResSet 里面移除</span><br>        <span class="hljs-comment">// 验证一下，如果 a 引用 b，a没有用到，b会被发现吗？</span><br>        unusedResSet.removeAll(childReference);<br>        <span class="hljs-keyword">for</span> (String reference : childReference) &#123;<br>            <span class="hljs-keyword">if</span> (!visitPath.contains(reference)) &#123;<br>                readChildReference(reference);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                visitPath.push(reference);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Found resource cycle! &quot;</span> + visitPath.toString());<br>            &#125;<br>        &#125;<br>        visitPath.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个深度遍历。</p><p>resource参数是<strong>代码中引用的资源</strong> + <strong>valueReferences 集合</strong>中的元素。</p><p>我们继续分析上面的深度遍历代码，假设resource 是一个 layout 资源，按照上面的逻辑，该 layout 引用的所有 string，dimen， drawable 都会从 unusedResSet 集合中移除。这也就是说明它们被人引用过了，即判断它是有用资源。</p><p>这显然是一个有bug的逻辑，当一个无用资源A引用了无用资源B，那无用资源B岂不是被标记为有用，确实！！！</p><p>所以，有必要的话可以删除一批无用资源后，再次重新运行该工具，直到资源无变化。</p><p>这里非 values 资源的逻辑是处理完了，那么 values 资源的逻辑呢，除了被 layout 等 xml 资源引用，代码中直接引用的情况有没有处理呢？</p><p>其实是有的，我们看 call 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TaskResult <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TaskExecuteException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>        unusedResSet.removeAll(resourceRefSet);<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TaskExecuteException(e.getMessage(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在最后，它将 resourceRefSet 里面的所有资源都标记为引用了。从这里可以看出，resourceRefSet 里面的元素，都是根。</p><p>所以，总结一下：<strong>是以代码为根（不准确，values的引用也是根，可能与后面的删除资源有关系，values不好删除？？？），然后深度遍历所有引用的资源</strong>。</p><h4 id="smali-引用方式分析"><a href="#smali-引用方式分析" class="headerlink" title="smali 引用方式分析"></a>smali 引用方式分析</h4><p>我们接下来，看看，如何从代码中找到资源的引用。有四种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> <span class="hljs-keyword">const</span><br><br><span class="hljs-keyword">const</span> v6, <span class="hljs-number">0x7f0c0061</span><br><br><span class="hljs-number">2.</span> sget<br><br><span class="hljs-comment">// app 生成的是 static int 的，所以直接转换为了数值</span><br><span class="hljs-comment">// 但是 lib 里面不是  final 的，所以会是引用的方式</span><br>sget v6, Lcom/tencent/mm/R$string;-&gt;chatting_long_click_menu_revoke_msg:I<br>sget v1, Lcom/tencent/mm/libmmui/R$id;-&gt;property_anim:I<br><br><span class="hljs-number">3.</span> sput<br><br>sput-object v0, Lcom/tencent/mm/plugin_welab_api/R$styleable;-&gt;ActionBar:[I   <span class="hljs-comment">//define resource in R.java</span><br><br><span class="hljs-number">4.</span> array-data<br><br>:array_0<br>.array-data <span class="hljs-number">4</span><br>    <span class="hljs-number">0x7f0a0022</span><br>    <span class="hljs-number">0x7f0a0023</span><br>.end array-data<br></code></pre></td></tr></table></figure><p>第一种最简单，直接是以 R.layout.xxx 的方式。</p><p>第二种稍微绕一点，也是以 R.layout.xxx 的方式，但是不知在  app 中，而是在 modules 中，因为 modules 生成的资源不是 final 的（因为如果是 final 的，那资源id 就固定了，而 app 引用modules 的时候，是需要一起计算 id 的，id 是按顺序的）。</p><p>由于不是 final 的，所以就不是 const 语法，而是 sget 语法。</p><p>第三种，是 R.styleable，它的 R.java 是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] SwitchCompat=&#123;<br>  <span class="hljs-number">0x01010124</span>, <span class="hljs-number">0x01010125</span>, <span class="hljs-number">0x01010142</span>, <span class="hljs-number">0x7f020101</span>, <br>  <span class="hljs-number">0x7f020107</span>, <span class="hljs-number">0x7f020112</span>, <span class="hljs-number">0x7f020113</span>, <span class="hljs-number">0x7f020115</span>, <br>  <span class="hljs-number">0x7f020123</span>, <span class="hljs-number">0x7f020124</span>, <span class="hljs-number">0x7f020125</span>, <span class="hljs-number">0x7f02013a</span>, <br>  <span class="hljs-number">0x7f02013b</span>, <span class="hljs-number">0x7f02013c</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对应的 smali 就是 sput 了。</p><p>第四种，就是 array 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<br>    R.layout.activity_main, R.string.app_name<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意 3 4 的区别。</p><p>以上，就是所有资源的引用分析了，具体代码就不贴了，无非就是如何根据 smali 语法分割出我们想要的资源id，然后从 build/intermediates/symbols/debug/R.txt 中，根据资源id找出对应的资源名（如果资源做了混淆，还要处理一下 resMapping）。</p><p>还有一个问题，就是使用 <code>android.content.res.Resources#getIdentifier</code>这种方式引用的资源是无法分析出来的。</p><p>我们看一下反编译的 smali 代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">invoke-virtual &#123;v0, v1, v2, v3&#125;, Landroid<span class="hljs-regexp">/content/</span>res<span class="hljs-regexp">/Resources;-&gt;getIdentifier(Ljava/</span>lang<span class="hljs-regexp">/String;Ljava/</span>lang<span class="hljs-regexp">/String;Ljava/</span>lang/String;)I<br></code></pre></td></tr></table></figure><p>v1-v3是参数。</p><p>如果都是直接传递的字符串常量，那么ok，勉强是可以分析出来的，但是如果使用了局部变量，而且不是紧邻 getIdentifier 代码，那么可能连资源id都拿不到，就算拿到了资源id，也几乎分析不出来它的资源类型是啥。</p><p>而且，有时候还会使用动态拼接资源名的方式，这就更没法搞了。</p><p>所以，ApkChecker 里面是没有支持这种引用方式的，这个暂时无思路，可能的话，只能从侧面入手，比如写个插件，遇到 getIdentifier 就提醒一下，让开发者把资源添加到白名单里面去。</p><h4 id="xml文件资源引用分析"><a href="#xml文件资源引用分析" class="headerlink" title="xml文件资源引用分析"></a>xml文件资源引用分析</h4><p>这个 task 里面涉及到的东西还是比较多的，比如分析 .xml 文件的资源引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">String value = mParser.getAttributeValue(i);<br>String attributeName = mParser.getAttributeName(i);<br><span class="hljs-keyword">if</span> (!Util.isNullOrNil(value)) &#123;<br>    <span class="hljs-keyword">if</span> (value.startsWith(<span class="hljs-string">&quot;@&quot;</span>)) &#123;<br>        <span class="hljs-keyword">int</span> index = value.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">1</span>) &#123;<br>            String type = value.substring(<span class="hljs-number">1</span>, index);<br>            resourceRefSet.add(ApkConstants.R_PREFIX + type + <span class="hljs-string">&quot;.&quot;</span> + value.substring(index + <span class="hljs-number">1</span>).replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.startsWith(<span class="hljs-string">&quot;?&quot;</span>)) &#123;<br>        <span class="hljs-keyword">int</span> index = value.indexOf(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">1</span>) &#123;<br>            resourceRefSet.add(ApkConstants.R_ATTR_PREFIX + <span class="hljs-string">&quot;.&quot;</span> + value.substring(index + <span class="hljs-number">1</span>).replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 xml 中引用资源，都会使用 @ 方式，而 xml 编译之后，@还是存在的，所以以 @ 为标识来添加资源引用关系。</p><p>这里有个疑问，不知道是不是 bug。我们引用属性，通常会使用 <code>?attr/xxx</code>的方式，但是 xml 编译之后，会变成 <code>?xxx</code> ，所以 else if 里面的 if 条件是进不去的。这里我没搞懂，else if 是干啥的。</p><p>如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;vector android:tint=<span class="hljs-string">&quot;?colorControlNormal&quot;</span> <br><br>&lt;size android:height=<span class="hljs-string">&quot;@dimen/abc_progress_bar_height_material&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Matrix源码分析番外篇：arsc文件结构</title>
    <link href="/2020/07/15/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9Aarsc%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2020/07/15/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9Aarsc%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>在 gradle 中，配置如下代码可以将无用的资源移除：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    buildTypes &#123;<br>        release &#123;<br>            shrinkResources <span class="hljs-literal">true</span><br>            minifyEnabled <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>“shrinkResources”资源压缩功能，它需要配合ProGurad的“minifyEnabled”功能同时使用。</p><p>如果ProGuard把部分无用代码移除，这些代码所引用的资源也会被标记为无用资源，然后通过资源压缩功能将它们移除。</p><p>这个看起来很不错，但是实际上却有些待改进的地方。</p><ul><li>对于一些无用的 String、ID、Attr、Dimen 等资源，实际上还存在于 .arsc 文件中。</li><li>对于Drawable、Layout这些无用资源，shrinkResources也没有真正把它们删掉，而是仅仅替换为一个空文件。</li></ul><p>还是用例子说话吧，我们写一个初始demo（为了减少资源，这里连一个依赖库都不引入，appcompat 也不要），里面有些无用的资源：</p><blockquote><p>strings.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;unused_string&quot;</span>&gt;</span>这是个无用的字符串<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>activity_old_main.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;old main activity&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.constraint.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>build.gradle</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildTypes &#123;<br>    debug &#123;<br>        proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br>    release &#123;<br>        shrinkResources <span class="hljs-literal">true</span><br>        minifyEnabled <span class="hljs-literal">true</span><br>        proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里，有一个无用的字符串：unused_string，有一个无用布局文件：activity_old_main，可以打 debug 与 release 包，release 包配置了混淆，先使用 010Editor 分析一下 debug 包的 .arsc 文件，看看这两个文件的信息是否存在。</p><h4 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h4><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc1.png?raw=true" alt="image-20200715145733039"></p><p>可以看到，这个无用文件的路径是存在的。路径存在字符串池中，这里储存了<strong>资源路径与strings.xml中定义的字符串</strong>等等一些资源。</p><h4 id="资源名称字符串池"><a href="#资源名称字符串池" class="headerlink" title="资源名称字符串池"></a>资源名称字符串池</h4><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc2.png?raw=true" alt="image-20200715145935250"></p><p>在package中，也是有这两个资源的数据，它们也是在字符串池中，注意与上面的字符串池的区别。</p><h4 id="资源类型字符串池"><a href="#资源类型字符串池" class="headerlink" title="资源类型字符串池"></a>资源类型字符串池</h4><p>这里的字符串池储存的是资源的 <strong>类型</strong>  与 <strong>名称</strong>。我们展开 typeStrings 可以看到类型：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc3.png?raw=true" alt="image-20200715150514262"></p><h4 id="ResTable-type"><a href="#ResTable-type" class="headerlink" title="ResTable_type"></a>ResTable_type</h4><p>注意到，string 是 strdata 数组第 6+1 个元素，所以，我们展开  <code>ResTable_typeSpec typeSpec[6]</code> 后面的 typeType，可以看到：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc4.png?raw=true" alt="image-20200715151305634"></p><p>这里可以看到，我们定义的 app_name，unused_string，但是他们的值却看不到，我刚开始以为是模板出错了，后来想了一下，可能是因为不好判断资源的类型，解析出正确的结果是很麻烦的，这里的 value 是指向的第一个字符串池，里面储存的是资源路径，拿到资源路径后再去加载资源。<strong>理论上值就是上面字符串池中的索引引用</strong>，但是还要根据不同资源类型做不同的逻辑处理。</p><p>layout 也是一样的，这里就不贴图了。</p><p>有的 typeType 会有多个，是因为不同配置的原因：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc5.png?raw=true" alt="image-20200715151657788"></p><p>可以看到，这里 mipmap 有6个，是因为我们的 res 目录里面就有 6 个 mipmap 文件夹，其作用就是用作适配的。不同的手机会从不同的结构体中读取资源。</p><h4 id="ResTable-entry-与-Res-value"><a href="#ResTable-entry-与-Res-value" class="headerlink" title="ResTable_entry 与 Res_value"></a>ResTable_entry 与 Res_value</h4><p>还是要重点说一下， ResTable_entry 与 Res_value，最简单的理解就是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bool</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;abc_action_bar_embed_tabs&quot;</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ResTable_entry  里面存了 abc_action_bar_embed_tabs，但是不是直接存的，存的是上面字符串池的字符索引。</p><p>Res_value 里面存的就是StringPoolType常量池中 ResStringPool_string 的数组索引，但是还要根据不同资源类型做不同的逻辑处理。</p><p>我们拿，app_name 来说明一下，arsc 是如何根据 resourceId 来获取资源的。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc6.png?raw=true" alt="image-20200715155705882"></p><p>我们可以看到，该资源的类型 id 为 7。其 entry 的偏移为 0（它是 entry 数组的第 1 项）。</p><p>所以它的 resourceId 为 0x7F070000。</p><p>那么这个是怎么的出来的呢？</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript">首先，<span class="hljs-number">7</span>F 是 packageId，包的命名空间，取值范围为[<span class="hljs-number">0x01</span>, <span class="hljs-number">0x7F</span>]，一般第三方应用均为<span class="hljs-number">7</span>F，系统的为 <span class="hljs-number">01</span>。<br><br><span class="hljs-number">07</span> 是资源类型<span class="hljs-built_in">id</span>，这里代表的是 <span class="hljs-built_in">string</span>。<br><br><span class="hljs-number">0000</span> 就是在 entry 中的偏移。<br></code></pre></td></tr></table></figure><p>它的data为0，指向的是第一个字符串池中的第1项，其内容是 Sample。</p><p>OK，这里我们对 arsc 应该有一定的了解了，再回到主题，看看 release 包有哪些变化呢？</p><p>这里，我就不贴图了，结果就是 .arsc 文件是一样的，连大小都一样。但是我们去 res 目录里面发现，activity_old_main.xml 文件变了。debug 包里面的文件，有 540 个字节，但是 release 包里面的文件只有 104 个字节，使用编辑器打开，发现 release 包里面的文件数据都是 null，与上面的提到的类似，变成了一个空文件。</p><p>所以，shrinkResources 并没有我们想的那么美好。</p><h4 id="ResTable-map-entry"><a href="#ResTable-map-entry" class="headerlink" title="ResTable_map_entry"></a>ResTable_map_entry</h4><p>还有，对于 style 与 attr 来说，他们的储存方式又不一样，为啥呢？从写法就可以看出来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;buttonTintMode&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;src_over&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;src_in&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;src_atop&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;9&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multiply&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;14&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;screen&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">enum</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">attr</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.DarkActionBar&quot;</span>&gt;</span><span class="xml"></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种写法，显然不能像 string drawable 一样，搞个键值对，只能使用 map：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc7.png?raw=true" alt="image-20200715164958314"></p><p>这个map 里面没啥东西，是因为我把 AppTheme 里面的东西都删了。</p><p>最后，再贴一张 .arsc 的结构图</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/arsc.png?raw=true"></p><p>有了上面的经验，再看这张图应该会清晰一点吧。</p><p>其实，我这里讲的很粗，但是我研究了几天这个文件结构，发现比较重要的东西就是这些了，除非你想对 arsc 做自定义处理，否则的话了解上面的东西也就够了。再深入的话，需要去查看对应的 C 结构，然后搞懂每个字段的意义。</p><p>老罗的文章讲这个讲的很细，但是对于现在的我来说，看完就忘，因为用不到，所以我暂时只深入到这里吧…</p><p>有个额外的东西需要说一下，我特么还在 stackoverflow 上提了问题。</p><p>关于字符串常量头的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ResStringPool_header</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ResChunk_header</span> <span class="hljs-title">header</span>;</span><br> <br>    <span class="hljs-comment">// Number of strings in this pool (number of uint32_t indices that follow</span><br>    <span class="hljs-comment">// in the data).</span><br>    <span class="hljs-keyword">uint32_t</span> stringCount;<br> <br>    <span class="hljs-comment">// Number of style span arrays in the pool (number of uint32_t indices</span><br>    <span class="hljs-comment">// follow the string indices).</span><br>    <span class="hljs-keyword">uint32_t</span> styleCount;<br> <br>    <span class="hljs-comment">// Flags.</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>        <span class="hljs-comment">// If set, the string index is sorted by the string values (based</span><br>        <span class="hljs-comment">// on strcmp16()).</span><br>        SORTED_FLAG = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>,<br> <br>        <span class="hljs-comment">// String pool is encoded in UTF-8</span><br>        UTF8_FLAG = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span><br>    &#125;;<br>    <span class="hljs-keyword">uint32_t</span> flags;<br> <br>    <span class="hljs-comment">// Index from header of the string data.</span><br>    <span class="hljs-keyword">uint32_t</span> stringsStart;<br> <br>    <span class="hljs-comment">// Index from header of the style data.</span><br>    <span class="hljs-keyword">uint32_t</span> stylesStart;<br>&#125;<br></code></pre></td></tr></table></figure><p>string 与 stringStart 都好理解，style 是个啥，字符串还有样式？？？</p><p>老罗的文章中说，<code>&lt;b&gt;man&lt;/b&gt;&lt;i&gt;go&lt;/i&gt;</code>  b 与 i 就是字符串样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">注意到第四个字符串“&lt;<span class="hljs-selector-tag">b</span>&gt;man&lt;/<span class="hljs-selector-tag">b</span>&gt;&lt;<span class="hljs-selector-tag">i</span>&gt;go&lt;/<span class="hljs-selector-tag">i</span>&gt;”，它实际表示的是一个字符串“mango”，不过它的前三个字符“man”通过<span class="hljs-selector-tag">b</span>标签来描述为粗体的，而后两个字符通过<span class="hljs-selector-tag">i</span>标签来描述为斜体的。字符串“mango”来有两个sytle，第一个style表示第<span class="hljs-number">1</span>到第<span class="hljs-number">3</span>个字符是粗体的，第二个style表示第<span class="hljs-number">4</span>到第<span class="hljs-number">5</span>个字符是斜体的。<br></code></pre></td></tr></table></figure><p>我使用 010Editor 打开后，发现 styleCount 为 1。</p><p>这里我没有搞懂读取带标签的 string 的时候，是怎么一个流程。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://blog.islinjw.cn/2019/05/18/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%B8%80/">http://blog.islinjw.cn/2019/05/18/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%B8%80/</a></p><p><a href="http://blog.islinjw.cn/2019/05/21/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%BA%8C/">http://blog.islinjw.cn/2019/05/21/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%BA%8C/</a></p><p><a href="https://juejin.im/post/5d4e60c15188255d2a78b86d">https://juejin.im/post/5d4e60c15188255d2a78b86d</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/8744683">https://blog.csdn.net/luoshengyang/article/details/8744683</a></p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>008-Matrix源码分析：插桩逻辑</title>
    <link href="/2020/07/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/008-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%8F%92%E6%A1%A9%E9%80%BB%E8%BE%91/"/>
    <url>/2020/07/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/008-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%8F%92%E6%A1%A9%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>前面几篇基本上将 matrix-trace-canary 的功能分析完毕了，只剩下插桩部分没有说，这里就来分析一下。</p><p>先上个图，了解一下流程。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/matrix_plugin.jpg?raw=true"></p><p>正式开始之前，需要了解的预备知识：Transform。不清楚的这个的，看着会很蛋疼，天赋异禀除外。</p><p>从插件的配置开始，要使用这个插件，我们需要引用它：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">classpath (<span class="hljs-string">&quot;com.tencent:matrix:1.0.1&quot;</span>)&#123;changing = <span class="hljs-literal">true</span>&#125;<br>-------------------------------------------------------<br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.tencent.matrix-plugin&#x27;</span><br>matrix &#123;<br>    trace &#123;<br>        enable = <span class="hljs-literal">true</span><br>        baseMethodMapFile = <span class="hljs-string">&quot;$&#123;project.projectDir&#125;/matrixTrace/methodMapping.txt&quot;</span><br>        blackListFile = <span class="hljs-string">&quot;$&#123;project.projectDir&#125;/matrixTrace/blackMethodList.txt&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>trace 里面有几个选项可以配置，就不说了，就是定义了一个 Extension。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixTraceExtension</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> enable;<br>    String baseMethodMapFile;<br>    String blackListFile;<br>    String customDexTransformName;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，插件运行的时候，会读取这里值。</p><p>我们从源头看起：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MatrixPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Plugin</span>&lt;<span class="hljs-title">Project</span>&gt; &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">&quot;Matrix.MatrixPlugin&quot;</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> apply(Project project) &#123;<br><br>        ...<br>        <span class="hljs-comment">// 创建 Extension</span><br>        project.matrix.extensions.create(<span class="hljs-string">&quot;trace&quot;</span>, MatrixTraceExtension)<br><br>        project.afterEvaluate &#123;<br>            <span class="hljs-keyword">def</span> android = project.extensions.android<br>            <span class="hljs-keyword">def</span> configuration = project.matrix<br>            android.applicationVariants.all &#123; variant -&gt;<br><br>                <span class="hljs-keyword">if</span> (configuration.trace.enable) &#123;<br>                    <span class="hljs-comment">// trace 处理</span><br>                    <span class="hljs-comment">// 读取 Extension 配置的值</span><br>                    com.tencent.matrix.trace.transform.MatrixTraceTransform.inject(project, configuration.trace, variant.getVariantData().getScope())<br>                &#125;<br><br>                ...<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接是调用了<code>com.tencent.matrix.trace.transform.MatrixTraceTransform#inject</code> 方法。</p><p><code>project.afterEvaluate</code>算是一个回调，它表示所有的模块都已经配置完了，可以准备执行task了。这个时机可以 Hook 我们想要的 transform。</p><p>inject 方法较长，只展示重要的一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Project project, MatrixTraceExtension extension, VariantScope variantScope)</span> </span>&#123;<br><br>    ...<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        String[] hardTask = getTransformTaskName(extension.getCustomDexTransformName(), variant.getName());<br>        <span class="hljs-keyword">for</span> (Task task : project.getTasks()) &#123;<br>            <span class="hljs-keyword">for</span> (String str : hardTask) &#123;<br>                <span class="hljs-comment">// 找到指定的任务名</span><br>                <span class="hljs-keyword">if</span> (task.getName().equalsIgnoreCase(str) &amp;&amp; task <span class="hljs-keyword">instanceof</span> TransformTask) &#123;<br>                    TransformTask transformTask = (TransformTask) task;<br>                    Log.i(TAG, <span class="hljs-string">&quot;successfully inject task:&quot;</span> + transformTask.getName());<br>                    Field field = TransformTask.class.getDeclaredField(<span class="hljs-string">&quot;transform&quot;</span>);<br>                    field.setAccessible(<span class="hljs-keyword">true</span>);<br>                    <span class="hljs-comment">// 替换为自己的 MatrixTraceTransform，对该task进行增强</span><br>                    field.set(task, <span class="hljs-keyword">new</span> MatrixTraceTransform(config, transformTask.getTransform()));<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Log.e(TAG, e.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是做了一件事：将指定的 transform 替换为我们自己的 transform。</p><p>extension.getCustomDexTransformName()， 说明我们自己也可以配置想要 hook 的 transform，因为 gradle 版本问题，transform 的名字会不一样。默认的两个 transform 是： transformClassesWithDexBuilderFor 与 transformClassesWithDexFor，都是在打 dex 的时候。</p><h3 id="MatrixTraceTransform"><a href="#MatrixTraceTransform" class="headerlink" title="MatrixTraceTransform"></a>MatrixTraceTransform</h3><p>它只处理 CLASS，整个工程的，支持增量。</p><p>看它 transform 的逻辑，可以先大致猜猜：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(TransformInvocation transformInvocation)</span> <span class="hljs-keyword">throws</span> TransformException, InterruptedException, IOException </span>&#123;<br>    <span class="hljs-keyword">super</span>.transform(transformInvocation);<br>    ...<br><br>    doTransform(transformInvocation); <span class="hljs-comment">// hack</span><br>    ...<br>    <span class="hljs-comment">// 进行原来的处理逻辑</span><br>    origTransform.transform(transformInvocation);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>就是插入了一段自己的逻辑。</p><p>doTransform 分为3步，我们一步一步介绍。</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">futures.add(executor.submit(<span class="hljs-keyword">new</span> ParseMappingTask(mappingCollector, collectedMethodMap, methodId)));<br><br><span class="hljs-comment">// 储存 class 输入输出关系的</span><br>Map&lt;File, File&gt; dirInputOutMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><span class="hljs-comment">// 储存 jar 输入输出关系的</span><br>Map&lt;File, File&gt; jarInputOutMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();<br><br><br><span class="hljs-comment">// 处理输入</span><br><span class="hljs-comment">// 主要是将输入类的字段替换掉，替换到指定的输出位置</span><br><span class="hljs-comment">// 里面做了增量的处理</span><br><span class="hljs-keyword">for</span> (TransformInput input : inputs) &#123;<br><br>    <span class="hljs-keyword">for</span> (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123;<br>        futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectDirectoryInputTask(dirInputOutMap, directoryInput, isIncremental)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (JarInput inputJar : input.getJarInputs()) &#123;<br>        futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectJarInputTask(inputJar, isIncremental, jarInputOutMap, dirInputOutMap)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 ParseMappingTask，读取 mapping 文件，因为这个时候 class 已经被混淆了，之所以选在混淆后，是因为避免插桩导致某些编译器优化失效，等编译器优化完了再插桩。读取 mapping 文件有几个用处，第一，需要输出某些信息，肯定不能输出混淆后的class信息。第二，配置文件的类是没有混淆过的，读取进来需要能够转换为混淆后的，才能处理。</p><p>创建了两个 map，储存 class jar 文件的输入输出位置。</p><p>创建 CollectDirectoryInputTask，收集 class 文件到 map。</p><p>创建 CollectJarInputTask，收集 jar 文件到 map。</p><p>CollectDirectoryInputTask 与  CollectJarInputTask 里面还用到了反射，更改了其输出目录到 build/output/traceClassout。所以我们可以在这里看到插桩后的类。这两个类就做了这些事，就不贴代码了。</p><p>后面就是调用 future 的 get 方法，等待这里 task 执行完成，再进行下一步。</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">MethodCollector methodCollector = <span class="hljs-keyword">new</span> MethodCollector(executor, mappingCollector, methodId, config, collectedMethodMap);<br>methodCollector.collect(dirInputOutMap.keySet(), jarInputOutMap.keySet());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collect</span><span class="hljs-params">(Set&lt;File&gt; srcFolderList, Set&lt;File&gt; dependencyJarList)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>    List&lt;Future&gt; futures = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (File srcFile : srcFolderList) &#123;<br>        <span class="hljs-comment">// 将 文件/目录下 class ，全部放到 list 中</span><br>        ArrayList&lt;File&gt; classFileList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (srcFile.isDirectory()) &#123;<br>            listClassFiles(classFileList, srcFile);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            classFileList.add(srcFile);<br>        &#125;<br><br>        <span class="hljs-comment">// 每个 class 都分配一个 CollectSrcTask</span><br>        <span class="hljs-keyword">for</span> (File classFile : classFileList) &#123;<br>            futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectSrcTask(classFile)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 每个 jar 分配一个 CollectJarTask</span><br>    <span class="hljs-keyword">for</span> (File jarFile : dependencyJarList) &#123;<br>        futures.add(executor.submit(<span class="hljs-keyword">new</span> CollectJarTask(jarFile)));<br>    &#125;<br><br>    <span class="hljs-comment">// 等待任务完成</span><br>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;<br>        future.get();<br>    &#125;<br>    futures.clear();<br><br>    futures.add(executor.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 将被忽略的 方法名 存入 ignoreMethodMapping.txt 中</span><br>            saveIgnoreCollectedMethod(mappingCollector);<br>        &#125;<br>    &#125;));<br><br>    futures.add(executor.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 将被插桩的 方法名 存入 methodMapping.txt 中</span><br>            saveCollectedMethod(mappingCollector);<br>        &#125;<br>    &#125;));<br><br>    <span class="hljs-keyword">for</span> (Future future : futures) &#123;<br>        future.get();<br>    &#125;<br>    futures.clear();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>collect 方法里面又开了两个任务：</p><p>CollectSrcTask </p><p>CollectJarTask</p><p>它们的逻辑差不多，就介绍一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>        is = <span class="hljs-keyword">new</span> FileInputStream(classFile);<br>        <span class="hljs-comment">// ASM 的使用</span><br>        <span class="hljs-comment">// 访问者模式，就是将对数据结构访问的操作分离出去</span><br>        <span class="hljs-comment">// 代价就是需要将数据结构本身传递进来</span><br>        ClassReader classReader = <span class="hljs-keyword">new</span> ClassReader(is);<br>        <span class="hljs-comment">// 修改字节码，有时候需要改动本地变量数与stack大小，自己计算麻烦，可以直接使用这个自动计算</span><br>        ClassWriter classWriter = <span class="hljs-keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);<br>        <span class="hljs-comment">// ASM5 api版本</span><br>        ClassVisitor visitor = <span class="hljs-keyword">new</span> TraceClassAdapter(Opcodes.ASM5, classWriter);<br>        classReader.accept(visitor, <span class="hljs-number">0</span>);<br>     ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>最后走到，TraceClassAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.visit(version, access, name, signature, superName, interfaces);<br>    <span class="hljs-keyword">this</span>.className = name;<br>    <span class="hljs-comment">// 是否抽象类</span><br>    <span class="hljs-keyword">if</span> ((access &amp; Opcodes.ACC_ABSTRACT) &gt; <span class="hljs-number">0</span> || (access &amp; Opcodes.ACC_INTERFACE) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.isABSClass = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 保存父类，便于分析继承关系</span><br>    collectedClassExtendMap.put(className, superName);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MethodVisitor <span class="hljs-title">visitMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> access, String name, String desc,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 String signature, String[] exceptions)</span> </span>&#123;<br>    <span class="hljs-comment">// 跳过抽象类，接口</span><br>    <span class="hljs-keyword">if</span> (isABSClass) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasWindowFocusMethod) &#123;<br>            <span class="hljs-comment">// 是否有 onWindowFocusChanged 方法，针对 activity 的</span><br>            hasWindowFocusMethod = isWindowFocusChangeMethod(name, desc);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CollectMethodNode(className, access, name, desc, signature, exceptions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面没有主要逻辑，主要逻辑在 CollectMethodNode：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitEnd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.visitEnd();<br>    TraceMethod traceMethod = TraceMethod.create(<span class="hljs-number">0</span>, access, className, name, desc);<br><br>    <span class="hljs-comment">// 是否构造方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&lt;init&gt;&quot;</span>.equals(name)) &#123;<br>        isConstructor = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断类是否 被配置在了 黑名单中</span><br>    <span class="hljs-keyword">boolean</span> isNeedTrace = isNeedTrace(configuration, traceMethod.className, mappingCollector);<br>    <span class="hljs-comment">// filter simple methods</span><br>    <span class="hljs-comment">// 跳过 空方法，get/set 方法，以及 isSingleMethod ，这个没太搞懂</span><br>    <span class="hljs-keyword">if</span> ((isEmptyMethod() || isGetSetMethod() || isSingleMethod())<br>            &amp;&amp; isNeedTrace) &#123;<br>        ignoreCount.incrementAndGet();<br>        <span class="hljs-comment">// 存入 ignore map</span><br>        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 不在黑名单中</span><br>    <span class="hljs-keyword">if</span> (isNeedTrace &amp;&amp; !collectedMethodMap.containsKey(traceMethod.getMethodName())) &#123;<br>        traceMethod.id = methodId.incrementAndGet();<br>        <span class="hljs-comment">// 存入 map</span><br>        collectedMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>        incrementCount.incrementAndGet();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isNeedTrace &amp;&amp; !collectedIgnoreMethodMap.containsKey(traceMethod.className)) &#123;<br>        ignoreCount.incrementAndGet();<br>        <span class="hljs-comment">// 存入 ignore map</span><br>        collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最终是将 class 中满足条件的方法，都存入到了 collectedMethodMap，忽略的方法存入了 collectedIgnoreMethodMap。</p><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">MethodTracer methodTracer = <span class="hljs-keyword">new</span> MethodTracer(executor, mappingCollector, config, methodCollector.getCollectedMethodMap(), methodCollector.getCollectedClassExtendMap());<br>methodTracer.trace(dirInputOutMap, jarInputOutMap);<br></code></pre></td></tr></table></figure><p>调用 trace 方法，trace 方法调用层次较深，最终会调用到 TraceClassAdapter，这个 TraceClassAdapter 与 第二步的 TraceClassAdapter 逻辑差不多，有一点点不一样，主要是它们关心的逻辑不同，这个 TraceClassAdapter 也是没有主要逻辑，主要逻辑在 TraceMethodAdapter 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMethodEnter</span><span class="hljs-params">()</span> </span>&#123;<br>    TraceMethod traceMethod = collectedMethodMap.get(methodName);<br>    <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-keyword">null</span>) &#123;<br>        traceMethodCount.incrementAndGet();<br>        mv.visitLdcInsn(traceMethod.id);<br>        <span class="hljs-comment">// 插入 i 方法</span><br>        mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMethodExit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> opcode)</span> </span>&#123;<br>    TraceMethod traceMethod = collectedMethodMap.get(methodName);<br>    <span class="hljs-keyword">if</span> (traceMethod != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果该方法是 onWindowFocusChanged 方法</span><br>        <span class="hljs-comment">// 还需要插桩 at 方法</span><br>        <span class="hljs-keyword">if</span> (hasWindowFocusMethod &amp;&amp; isActivityOrSubClass &amp;&amp; isNeedTrace) &#123;<br>            TraceMethod windowFocusChangeMethod = TraceMethod.create(-<span class="hljs-number">1</span>, Opcodes.ACC_PUBLIC, className,<br>                    TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS);<br>            <span class="hljs-keyword">if</span> (windowFocusChangeMethod.equals(traceMethod)) &#123;<br>                traceWindowFocusChangeMethod(mv, className);<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 插入 o 方法</span><br>        traceMethodCount.incrementAndGet();<br>        mv.visitLdcInsn(traceMethod.id);<br>        mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;(I)V&quot;</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就完成了插桩了。</p><p>更加详细的注释，我放在了 GitHub 上：</p><p><a href="https://github.com/aprz512/matrix/tree/note">https://github.com/aprz512/matrix/tree/note</a></p><p>注意，这是 note 分支。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>拿到项目的所有的  class，拿到所有的方法，去掉需要忽略的方法，然后对方法进行插桩：</p><ul><li>方法前面插入 i</li><li>方法后面插入 o</li><li>如果是 activity 还要在 它的 WindowFocusChange 方法里面插入 at  方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>006-Matrix源码分析：FrameTracer 监控帧率</title>
    <link href="/2020/07/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/006-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AFrameTracer%20%E7%9B%91%E6%8E%A7%E5%B8%A7%E7%8E%87/"/>
    <url>/2020/07/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/006-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AFrameTracer%20%E7%9B%91%E6%8E%A7%E5%B8%A7%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>FrameTracer 与前面的两个 tracer 一样，都是继承的 Tracer。所以分析的套路也是一样的简单。</p><p>而且它没有覆盖 <code>dispatchBegin</code> 与 <code>dispatchEnd</code> 这两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(String focusedActivityName, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end, <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">long</span> inputCostNs, <span class="hljs-keyword">long</span> animationCostNs, <span class="hljs-keyword">long</span> traversalCostNs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isForeground()) &#123;<br>        notifyListener(focusedActivityName, end - start, frameCostMs, frameCostMs &gt;= <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在前台才会进行帧率分析。这里的帧率采用的是累加的方式，即使</p><p>notifyListener 是 FrameTracer 内部可以注册监听，然后这里会回调这些监听。我们看看监听会回调一些什么信息过去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyListener</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String visibleScene, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> taskCostMs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isContainsFrame)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (listeners) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> IDoFrameListener listener : listeners) &#123;<br>                <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;<br>                    listener.time = SystemClock.uptimeMillis();<br>                &#125;<br>                <span class="hljs-comment">// 掉了几帧，这里是整除</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dropFrame = (<span class="hljs-keyword">int</span>) (taskCostMs / frameIntervalMs);<br><br>                <span class="hljs-comment">// taskCostMs 与 frameCostMs 差不多，多执行几行代码的时间差别</span><br>                <span class="hljs-comment">// 不过 frameCostMs 有可能为 0，当处理的message 是普通消息，而不是 doFrame 消息的时候</span><br>                <span class="hljs-comment">// visibleScene 是当前 activity 的名字</span><br>                <span class="hljs-comment">// isContainsFrame 我没搞懂，这个不是肯定为 true 吗？</span><br>                listener.doFrameSync(visibleScene, taskCostMs, frameCostMs, dropFrame, isContainsFrame);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != listener.getExecutor()) &#123;<br>                    <span class="hljs-comment">// 将回调转给 Executor 去执行</span><br>                    listener.getExecutor().execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                            listener.doFrameAsync(visibleScene, taskCostMs, frameCostMs, dropFrame, isContainsFrame);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;<br>                    listener.time = SystemClock.uptimeMillis() - listener.time;<br>                    MatrixLog.d(TAG, <span class="hljs-string">&quot;[notifyListener] cost:%sms listener:%s&quot;</span>, listener.time, listener);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">long</span> cost = System.currentTimeMillis() - start;<br>        <span class="hljs-keyword">if</span> (config.isDebug() &amp;&amp; cost &gt; frameIntervalMs) &#123;<br>            MatrixLog.w(TAG, <span class="hljs-string">&quot;[notifyListener] warm! maybe do heavy work in doFrameSync! size:%s cost:%sms&quot;</span>, listeners.size(), cost);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>notifyListener 就是将该消息的耗时，丢了多少帧，当前 activity 的名字传递过去。而且会在 listener 的 Executor 里面执行。</p><p>我们看一个 listener 的实现类：</p><blockquote><p>com.tencent.matrix.trace.tracer.FrameTracer.FPSCollector</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPSCollector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IDoFrameListener</span> </span>&#123;<br><br><br>    <span class="hljs-comment">// 也是放到了MatrixHandlerThread中去执行</span><br>    <span class="hljs-keyword">private</span> Handler frameHandler = <span class="hljs-keyword">new</span> Handler(MatrixHandlerThread.getDefaultHandlerThread().getLooper());<br><br>    <span class="hljs-comment">// 转到 MatrixHandlerThread 里面去执行</span><br>    Executor executor = <span class="hljs-keyword">new</span> Executor() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>            frameHandler.post(command);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> HashMap&lt;String, FrameCollectItem&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrameAsync</span><span class="hljs-params">(String visibleScene, <span class="hljs-keyword">long</span> taskCost, <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">int</span> droppedFrames, <span class="hljs-keyword">boolean</span> isContainsFrame)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.doFrameAsync(visibleScene, taskCost, frameCostMs, droppedFrames, isContainsFrame);<br>        <span class="hljs-keyword">if</span> (Utils.isEmpty(visibleScene)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 存放到 map 集合里面，以activity为单位</span><br>        FrameCollectItem item = map.get(visibleScene);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == item) &#123;<br>            item = <span class="hljs-keyword">new</span> FrameCollectItem(visibleScene);<br>            map.put(visibleScene, item);<br>        &#125;<br><br>        <span class="hljs-comment">// 进行数据收集</span><br>        item.collect(droppedFrames, isContainsFrame);<br><br>        <span class="hljs-comment">// 当统计时间超过 10000 ms 时进行上报</span><br>        <span class="hljs-keyword">if</span> (item.sumFrameCost &gt;= timeSliceMs) &#123; <span class="hljs-comment">// report</span><br>            map.remove(visibleScene);<br>            item.report();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看它上报了什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">collect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> droppedFrames, <span class="hljs-keyword">boolean</span> isContainsFrame)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> frameIntervalCost = UIThreadMonitor.getMonitor().getFrameIntervalNanos();<br>    <span class="hljs-comment">// 总的帧数耗时</span><br>    sumFrameCost += (droppedFrames + <span class="hljs-number">1</span>) * frameIntervalCost / Constants.TIME_MILLIS_TO_NANO;<br>    <span class="hljs-comment">// 总的掉帧数</span><br>    sumDroppedFrames += droppedFrames;<br>    <span class="hljs-comment">// 总帧数</span><br>    sumFrame++;<br>    <span class="hljs-keyword">if</span> (!isContainsFrame) &#123;<br>        sumTaskFrame++;<br>    &#125;<br><br>    <span class="hljs-comment">// 按本次掉帧数来判断警戒级别</span><br>    <span class="hljs-comment">// 在该页面，级别严重的越多，说明这个页面有问题，可以采取措施</span><br>    <span class="hljs-keyword">if</span> (droppedFrames &gt;= frozenThreshold) &#123;<br>        dropLevel[DropStatus.DROPPED_FROZEN.index]++;<br>        dropSum[DropStatus.DROPPED_FROZEN.index] += droppedFrames;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (droppedFrames &gt;= highThreshold) &#123;<br>        dropLevel[DropStatus.DROPPED_HIGH.index]++;<br>        dropSum[DropStatus.DROPPED_HIGH.index] += droppedFrames;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (droppedFrames &gt;= middleThreshold) &#123;<br>        dropLevel[DropStatus.DROPPED_MIDDLE.index]++;<br>        dropSum[DropStatus.DROPPED_MIDDLE.index] += droppedFrames;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (droppedFrames &gt;= normalThreshold) &#123;<br>        dropLevel[DropStatus.DROPPED_NORMAL.index]++;<br>        dropSum[DropStatus.DROPPED_NORMAL.index] += droppedFrames;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dropLevel[DropStatus.DROPPED_BEST.index]++;<br>        dropSum[DropStatus.DROPPED_BEST.index] += (droppedFrames &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : droppedFrames);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，将这些数据上报，<code>report</code>方法只是拼接了一个 JSONObject，就不说了。</p><p>最后看下来，这个类就只是做了上报，没有输出日志。但是我在运行demo的时候，有个悬浮窗显示出来了，看看是在哪里做的。再次戳一下 IDoFrameListener 的实现类，看看有哪些，果然发现了一个 <code>FrameDecorator</code>。这个类实际上与性能优化没啥关系，它只是提供一个实时限制帧率信息的一个悬浮窗，这里我们只介绍它展示了哪些信心，不去探究如何实现一个悬浮穿，画实时的线条之类的。</p><p>我们直接看它的 doFrameAsync 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrameAsync</span><span class="hljs-params">(String visibleScene, <span class="hljs-keyword">long</span> taskCost, <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">int</span> droppedFrames, <span class="hljs-keyword">boolean</span> isContainsFrame)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.doFrameAsync(visibleScene, taskCost, frameCostMs, droppedFrames, isContainsFrame);<br>    sumFrameCost += (droppedFrames + <span class="hljs-number">1</span>) * UIThreadMonitor.getMonitor().getFrameIntervalNanos() / Constants.TIME_MILLIS_TO_NANO;<br>    sumFrames += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> duration = sumFrameCost - lastCost[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">long</span> collectFrame = sumFrames - lastFrames[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 至少要累积到200ms才做一次更新</span><br>    <span class="hljs-keyword">if</span> (duration &gt;= <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-comment">// 拿到帧率</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> fps = Math.min(<span class="hljs-number">60.f</span>, <span class="hljs-number">1000.f</span> * collectFrame / duration);<br>        updateView(view.fpsView, fps);<br>        view.chartView.addFps((<span class="hljs-keyword">int</span>) fps);<br>        lastCost[<span class="hljs-number">0</span>] = sumFrameCost;<br>        lastFrames[<span class="hljs-number">0</span>] = sumFrames;<br>        <span class="hljs-comment">// 没有消息处理了，就显示 60FPS</span><br>        mainHandler.removeCallbacks(updateDefaultRunnable);<br>        mainHandler.postDelayed(updateDefaultRunnable, <span class="hljs-number">130</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>FrameDecorator 其实就显示了一个帧率，只不过使用悬浮窗现实的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果一个 Message 处理的时候间隔小于 16.7ms，那么就可以认为它的帧率为 60fps，反之大于这个时间间隔，那么就说明掉帧了。</p><p>其实，还可以使用 Choreographer 的 FrameCallback 来检测帧率。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>007-Matrix源码分析：StartupTracer 监控冷启动时间</title>
    <link href="/2020/07/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/007-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AStartupTracer%20%E7%9B%91%E6%8E%A7%E5%86%B7%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <url>/2020/07/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/007-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AStartupTracer%20%E7%9B%91%E6%8E%A7%E5%86%B7%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>StartupTracer 也继承了 Tracer，但是由于它监控的是冷启动，所以它需要知道第一个 activity 是什么时候启动的，故它也实现了 ActivityLifecycleCallbacks 接口。</p><p>我们先看它是如何判断冷启动还是温启动的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isColdStartup</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> coldCost == <span class="hljs-number">0</span>;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWarmStartUp</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> isWarmStartUp;<br>   &#125;<br><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (activeActivityCount == <span class="hljs-number">0</span> &amp;&amp; coldCost &gt; <span class="hljs-number">0</span>) &#123;<br>           isWarmStartUp = <span class="hljs-keyword">true</span>;<br>       &#125;<br>       activeActivityCount++;<br>   &#125;<br></code></pre></td></tr></table></figure><p>冷启动直接是使用的 coldCost 是否为0，因为后面会有改变该值的逻辑，所以就相当于一个boolean变量的用法。</p><p>温启动是activity没有了，但是进程还在，StartupTracer 还在运行，所以 coldCost 的值也还在，这是就会认为是温启动。</p><p>我们看一下该类的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">* &lt;p&gt;<br>* firstMethod.i       LAUNCH_ACTIVITY   onWindowFocusChange   LAUNCH_ACTIVITY    onWindowFocusChange<br>* ^                         ^                   ^                     ^                  ^<br>* |                         |                   |                     |                  |<br>* |---------app---------|---|---firstActivity---|---------...---------|---careActivity---|<br>* |&lt;--applicationCost--&gt;|<br>* |&lt;--------------firstScreenCost--------------&gt;|<br>* |&lt;---------------------------------------coldCost-------------------------------------&gt;|<br>* .                         |&lt;-----warmCost----&gt;|<br>*<br></code></pre></td></tr></table></figure><p>这个图还是挺清楚的。</p><p>我们继续看该类的一些方法，该类的 <code>onActivityFocused</code> 会在activity的<code>onWindowFocusChanged</code>方法执行的时候调用（使用的是插桩，这部分后面再讲）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityFocused</span><span class="hljs-params">(String activity)</span> </span>&#123;<br>    <span class="hljs-comment">// 冷启动</span><br>    <span class="hljs-keyword">if</span> (isColdStartup()) &#123;<br>        <span class="hljs-keyword">if</span> (firstScreenCost == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从 application 创建到第一个activity 回调 onActivityFocused 的时间</span><br>            <span class="hljs-comment">// ActivityThreadHacker.getEggBrokenTime() 是 application 创建的时间，不知道为啥要起这么个蛋疼的名字</span><br>            <span class="hljs-keyword">this</span>.firstScreenCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hasShowSplashActivity) &#123;<br>            <span class="hljs-comment">// coldCost 还算上了 splash 显示的时间，从 application 创建到 &quot;mainActivity&quot;</span><br>            coldCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (splashActivities.contains(activity)) &#123;<br>                hasShowSplashActivity = <span class="hljs-keyword">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (splashActivities.isEmpty()) &#123;<br>                MatrixLog.i(TAG, <span class="hljs-string">&quot;default splash activity[%s]&quot;</span>, activity);<br>                coldCost = firstScreenCost;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                MatrixLog.w(TAG, <span class="hljs-string">&quot;pass this activity[%s] at duration of start up! splashActivities=%s&quot;</span>, activity, splashActivities);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (coldCost &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 分析</span><br>            analyse(ActivityThreadHacker.getApplicationCost(), firstScreenCost, coldCost, <span class="hljs-keyword">false</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">// 温启动</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWarmStartUp()) &#123;<br>        isWarmStartUp = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// 计算的是第一个 activity 从启动到 onActivityFocused 的时间</span><br>        <span class="hljs-comment">// ActivityThreadHacker hook 了 H 的 LAUNCH_ACTIVITY</span><br>        <span class="hljs-comment">// 温启动，application 还在</span><br>        <span class="hljs-keyword">long</span> warmCost = uptimeMillis() - ActivityThreadHacker.getLastLaunchActivityTime();<br>        <span class="hljs-keyword">if</span> (warmCost &gt; <span class="hljs-number">0</span>) &#123;<br>            analyse(ActivityThreadHacker.getApplicationCost(), firstScreenCost, warmCost, <span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>无论是冷启动还是温启动，都需要分析这些数据，然后上报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">analyse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> applicationCost, <span class="hljs-keyword">long</span> firstScreenCost, <span class="hljs-keyword">long</span> allCost, <span class="hljs-keyword">boolean</span> isWarmStartUp)</span> </span>&#123;<br>    MatrixLog.i(TAG, <span class="hljs-string">&quot;[report] applicationCost:%s firstScreenCost:%s allCost:%s isWarmStartUp:%s&quot;</span>, applicationCost, firstScreenCost, allCost, isWarmStartUp);<br>    <span class="hljs-keyword">long</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 冷启动不得超过 10s</span><br>    <span class="hljs-keyword">if</span> (!isWarmStartUp &amp;&amp; allCost &gt;= coldStartupThresholdMs) &#123; <span class="hljs-comment">// for cold startup</span><br>        <span class="hljs-comment">// 分析 ApplicationCreateBeginMethodIndex 的方法栈</span><br>        data = AppMethodBeat.getInstance().copyData(ActivityThreadHacker.sApplicationCreateBeginMethodIndex);<br>        ActivityThreadHacker.sApplicationCreateBeginMethodIndex.release();<br><br>    &#125;<br>    <span class="hljs-comment">// 温启动不得超过 4s</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isWarmStartUp &amp;&amp; allCost &gt;= warmStartupThresholdMs) &#123;<br>        <span class="hljs-comment">// 分析 LastLaunchActivityMethodIndex 的方法栈</span><br>        data = AppMethodBeat.getInstance().copyData(ActivityThreadHacker.sLastLaunchActivityMethodIndex);<br>        ActivityThreadHacker.sLastLaunchActivityMethodIndex.release();<br>    &#125;<br><br>    MatrixHandlerThread.getDefaultHandler().post(<span class="hljs-keyword">new</span> AnalyseTask(data, applicationCost, firstScreenCost, allCost, isWarmStartUp, ActivityThreadHacker.sApplicationCreateScene));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是从 sBuffer 里面截取对应的 index 段来分析里面涉及到的方法，对 sBuffer 这里就不分析了，跟前面是一样的，这里说一下几个变量的意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">AnalyseTask(<span class="hljs-keyword">long</span>[] data, <span class="hljs-keyword">long</span> applicationCost, <span class="hljs-keyword">long</span> firstScreenCost, <span class="hljs-keyword">long</span> allCost, <span class="hljs-keyword">boolean</span> isWarmStartUp, <span class="hljs-keyword">int</span> scene) &#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>    <span class="hljs-comment">// 当前 activity</span><br>    <span class="hljs-keyword">this</span>.scene = scene;<br>    <span class="hljs-comment">// application 耗时</span><br>    <span class="hljs-keyword">this</span>.applicationCost = applicationCost;<br>    <span class="hljs-comment">// 启动直到用户看到第一个 activity 耗时</span><br>    <span class="hljs-keyword">this</span>.firstScreenCost = firstScreenCost;<br>    <span class="hljs-comment">// 冷启动/温启动耗时</span><br>    <span class="hljs-keyword">this</span>.allCost = allCost;<br>    <span class="hljs-comment">// 是冷启动还是温启动</span><br>    <span class="hljs-keyword">this</span>.isWarmStartUp = isWarmStartUp;<br>&#125;<br></code></pre></td></tr></table></figure><p>传进来 data，是为了两件事：</p><ul><li>修正启动时间，与 data 里面的方法耗时累积做比较</li><li>计算 data 的 key，方便聚合</li></ul><p>那么，启动监测就分析完成了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里的冷启动，检测的是从第一个 i 方法执行，一直到我们的app的界面展示出来（不是 splash 页面）。</p><p>因为 i 方法插入到所有方法的前面，所以第一个执行的肯定是 i 方法。又因为 i 方法里面有逻辑处理，有个逻辑只会执行一次，所以在这个逻辑里面，我们可以记录一下当前时间。然后记录主界面 focus 的时间，两者时间之差就是冷启动时间。</p><p>当然，有的项目不是计算的 activity 的 focus 的时间，而是界面真正展示出来的时间。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>005-Matrix源码分析：EvilMethodTracer 监控慢方法</title>
    <link href="/2020/07/05/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/005-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AEvilMethodTracer%20%E7%9B%91%E6%8E%A7%E6%85%A2%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/05/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/005-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AEvilMethodTracer%20%E7%9B%91%E6%8E%A7%E6%85%A2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这里我们来分析一下如何监测主线程里面的一些慢方法。</p><p>我们先写一个例子，例子很简单，点击一个按钮，执行一个方法，这个方法里面又调用了许多别的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">Button test = findViewById(R.id.test);<br>test.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        f();<br>    &#125;<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    A();<br>    A();<br>    A();<br>    A();<br>    B();<br>    C();<br>    D();<br>    E();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;<br>    SystemClock.sleep(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span> <span class="hljs-params">()</span> </span>&#123;<br>    SystemClock.sleep(<span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">C</span><span class="hljs-params">()</span> </span>&#123;<br>    SystemClock.sleep(<span class="hljs-number">300</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">D</span><span class="hljs-params">()</span> </span>&#123;<br>    SystemClock.sleep(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">E</span><span class="hljs-params">()</span> </span>&#123;<br>    SystemClock.sleep(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以想一下，如果是你自己的话，你希望得出一个什么样的足够直观的监测结果呢？</p><p>这里其实 A B C 三个方法都比较耗时，我们看看日志输出：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; maybe happens Jankiness!(<span class="hljs-number">916</span>ms) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br><span class="hljs-string">|* scene: com.example.sample.MainActivity</span><br><span class="hljs-string">|* [ProcessStat]</span><br><span class="hljs-string">|*Priority: 10</span><br><span class="hljs-string">|*Nice: -10</span><br><span class="hljs-string">|*Foreground: true</span><br><span class="hljs-string">|* [CPU]</span><br><span class="hljs-string">|*usage: 0.33%</span><br><span class="hljs-string">|* [doFrame]</span><br><span class="hljs-string">|*inputCost: 120000</span><br><span class="hljs-string">|*animationCost: 418100</span><br><span class="hljs-string">|*traversalCost: 6311100</span><br><span class="hljs-string">|* [Trace]</span><br><span class="hljs-string">|*StackSize: 8</span><br><span class="hljs-string">|*StackKey: 2|</span><br><span class="hljs-string">|*TraceStack:</span><br><span class="hljs-string">|*[id count cost]</span><br><span class="hljs-string">|*1048574 1 916</span><br><span class="hljs-string">|*.1 1 913</span><br><span class="hljs-string">|*..2 1 913</span><br><span class="hljs-string">|*...3 4 403</span><br><span class="hljs-string">|*...4 1 198</span><br><span class="hljs-string">|*...5 1 300</span><br><span class="hljs-string">|*...6 1 6</span><br><span class="hljs-string">|*...7 1 6</span><br>=========================================================================<br></code></pre></td></tr></table></figure><p>doFrame 项里面的参数都是 ns，所以他们都是正常范围的。</p><p>我们看 trace 项，发现有个方法耗时 913 毫秒，这个肯定就是不正常了。</p><p>看下 methodMapping：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">1</span>,<span class="hljs-selector-tag">4</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">onCreate</span> (Landroid.os.Bundle;)<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">2</span>,<span class="hljs-selector-tag">0</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">f</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">3</span>,<span class="hljs-selector-tag">0</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">A</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">4</span>,<span class="hljs-selector-tag">0</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">B</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">5</span>,<span class="hljs-selector-tag">0</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">C</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">6</span>,<span class="hljs-selector-tag">2</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">D</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">7</span>,<span class="hljs-selector-tag">2</span>,<span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.MainActivity</span> <span class="hljs-selector-tag">E</span> ()<span class="hljs-selector-tag">V</span><br><span class="hljs-selector-tag">1048574</span>,<span class="hljs-selector-tag">1</span>,<span class="hljs-selector-tag">android</span><span class="hljs-selector-class">.os</span><span class="hljs-selector-class">.Handler</span> <span class="hljs-selector-tag">dispatchMessage</span> (Landroid.os.Message;)<span class="hljs-selector-tag">V</span><br></code></pre></td></tr></table></figure><p>与堆栈一对应，发现就是我们例子的方法。</p><p>仔细想一下，这个的工作原理应该是与 AnrTracer 是一样的，都是以单个 message 为单位，分析所有调用的函数，然后生成堆栈信息。</p><p>我们看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginMs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dispatchBegin(beginMs, cpuBeginMs, token);<br>    indexRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;EvilMethodTracer#dispatchBegin&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个 IndexRecord。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(String focusedActivityName, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end, <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">long</span> inputCostNs, <span class="hljs-keyword">long</span> animationCostNs, <span class="hljs-keyword">long</span> traversalCostNs)</span> </span>&#123;<br>    queueTypeCosts[<span class="hljs-number">0</span>] = inputCostNs;<br>    queueTypeCosts[<span class="hljs-number">1</span>] = animationCostNs;<br>    queueTypeCosts[<span class="hljs-number">2</span>] = traversalCostNs;<br>&#125;<br></code></pre></td></tr></table></figure><p>记录 doFrame 三个队列的耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginMs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endMs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isBelongFrame)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dispatchEnd(beginMs, cpuBeginMs, endMs, cpuEndMs, token, isBelongFrame);<br>    <span class="hljs-keyword">long</span> start = config.isDevEnv() ? System.currentTimeMillis() : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">long</span> dispatchCost = endMs - beginMs;<br>        <span class="hljs-comment">// 消息处理耗时超过 700ms</span><br>        <span class="hljs-keyword">if</span> (dispatchCost &gt;= evilThresholdMs) &#123;<br>            <span class="hljs-keyword">long</span>[] data = AppMethodBeat.getInstance().copyData(indexRecord);<br>            <span class="hljs-keyword">long</span>[] queueCosts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">3</span>];<br>            System.arraycopy(queueTypeCosts, <span class="hljs-number">0</span>, queueCosts, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>            String scene = AppMethodBeat.getVisibleScene();<br>            <span class="hljs-comment">// 发送到子线程去分析</span><br>            MatrixHandlerThread.getDefaultHandler().post(<span class="hljs-keyword">new</span> AnalyseTask(isForeground(), scene, data, queueCosts, cpuEndMs - cpuBeginMs, endMs - beginMs, endMs));<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        indexRecord.release();<br>        <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;<br>            String usage = Utils.calculateCpuUsage(cpuEndMs - cpuBeginMs, endMs - beginMs);<br>            MatrixLog.v(TAG, <span class="hljs-string">&quot;[dispatchEnd] token:%s cost:%sms cpu:%sms usage:%s innerCost:%s&quot;</span>,<br>                    token, endMs - beginMs, cpuEndMs - cpuBeginMs, usage, System.currentTimeMillis() - start);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法最重要，就是在每个 message 处理完成后，分析一下设计到的所有方法的执行时间。</p><p>我们看看 AnalyseTask 做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">analyse</span><span class="hljs-params">()</span> </span>&#123;<br><br>         <span class="hljs-comment">// process</span><br>         <span class="hljs-keyword">int</span>[] processStat = Utils.getProcessPriority(Process.myPid());<br>         String usage = Utils.calculateCpuUsage(cpuCost, cost);<br>         LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> LinkedList();<br>         <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;<br>             TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-keyword">true</span>, endMs);<br>             TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> TraceDataUtils.IStructuredDataFilter() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> during, <span class="hljs-keyword">int</span> filterCount)</span> </span>&#123;<br>                     <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;<br>                 &#125;<br><br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFilterMaxCount</span><span class="hljs-params">()</span> </span>&#123;<br>                     <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;<br>                 &#125;<br><br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>                     MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);<br>                     Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));<br>                     <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                         iterator.next();<br>                         iterator.remove();<br>                     &#125;<br>                 &#125;<br>             &#125;);<br>         &#125;<br><br><br>         StringBuilder reportBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>         StringBuilder logcatBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>         <span class="hljs-keyword">long</span> stackCost = Math.max(cost, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));<br>         String stackKey = TraceDataUtils.getTreeKey(stack, stackCost);<br><br>         MatrixLog.w(TAG, <span class="hljs-string">&quot;%s&quot;</span>, printEvil(scene, processStat, isForeground, logcatBuilder, stack.size(), stackKey, usage, queueCost[<span class="hljs-number">0</span>], queueCost[<span class="hljs-number">1</span>], queueCost[<span class="hljs-number">2</span>], cost)); <span class="hljs-comment">// for logcat</span><br>...<br><br>     &#125;<br></code></pre></td></tr></table></figure><p>这里差不多与 AnrTracer 一样的流程，因该很好看懂，就不多说了。</p><p>其实只要理清核心之处就好了，AnrTracer 是延迟5s发送分析任务，EvilMethodTracer 是每个消息处理结束后分析，但是它设定了阈值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在每个 Message 处理的时候，检测了两个方法调用的时间间隔：</p><ul><li>dispatchBegin 记录一个时间</li><li>dispatchEnd 记录一个时间</li></ul><p>如果这两个时间超过了 700ms，那么就分析这两个时间段之间的 long 数组，然后分析堆栈与耗时。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>004-Matrix源码分析：AnrTracer 监控ANR</title>
    <link href="/2020/07/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/004-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAnrTracer%20%E7%9B%91%E6%8E%A7ANR/"/>
    <url>/2020/07/02/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/004-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAnrTracer%20%E7%9B%91%E6%8E%A7ANR/</url>
    
    <content type="html"><![CDATA[<p>AnrTracer是用来监测ANR的，可以打印出ANR发生的具体位置。打印log如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; maybe happens ANR(<span class="hljs-number">5001</span> ms)! &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br><span class="hljs-string">|* scene: com.example.sample.MainActivity</span><br><span class="hljs-string">|* [ProcessStat]</span><br><span class="hljs-string">|*Priority: 10</span><br><span class="hljs-string">|*Nice: -10</span><br><span class="hljs-string">|*Foreground: true</span><br><span class="hljs-string">|* [Memory]</span><br><span class="hljs-string">|*DalvikHeap: 2076kb// 占用的堆内存</span><br><span class="hljs-string">|*NativeHeap: 17137kb // 占用的本地内存，使用 Debug 得到</span><br><span class="hljs-string">|*VmSize: 5256708kb// 虚拟内存大小，从 proc/[pid]/stat 文件中取得</span><br><span class="hljs-string">|* [doFrame]</span><br><span class="hljs-string">|*inputCost: 0</span><br><span class="hljs-string">|*animationCost: 0</span><br><span class="hljs-string">|*traversalCost: 0</span><br><span class="hljs-string">|* [Thread]</span><br><span class="hljs-string">|*State: RUNNABLE</span><br><span class="hljs-string">|*Stack:  </span><br><span class="hljs-string">|*at android.view.View:performClickInternal(6574)</span><br><span class="hljs-string">|*at android.view.View:access$3100(778)</span><br><span class="hljs-string">|*at android.view.View$PerformClick:run(25885)</span><br><span class="hljs-string">|*at android.os.Handler:handleCallback(873)</span><br><span class="hljs-string">|*at android.os.Handler:dispatchMessage(99)</span><br><span class="hljs-string">|*at android.os.Looper:loop(193)</span><br><span class="hljs-string">|*at android.app.ActivityThread:main(6669)</span><br><span class="hljs-string">|* [Trace]</span><br><span class="hljs-string">|*StackSize: 2</span><br><span class="hljs-string">|*StackKey: 1|</span><br><span class="hljs-string">|*TraceStack:</span><br><span class="hljs-string">|*[id count cost]</span><br><span class="hljs-string">|*1048574 1 5005</span><br><span class="hljs-string">|*.1 1 5004</span><br>========================================================================= <br>postTime:<span class="hljs-number">1734934</span> curTime:<span class="hljs-number">1739939</span><br></code></pre></td></tr></table></figure><p>第一项是进程状态。</p><p>从 proc/[pid]/stat 文件中获取的，主要描述了进程的优先级与前后台状态。nice 值与 oom_adj 有关，越低越好。</p><p>进程前后台状态是根据 ActivityLifecycleCallbacks 来判断的，没啥稀奇的。有一个地方需要注意，它判断进入后台是使用的</p><p><code>com.tencent.matrix.AppActiveMatrixDelegate#getTopActivityName</code> 这个方法，里面使用反射查找 ActivityThread 的 mActivities 集合中 activity 的状态。不清楚这样是否会更好一点。我们通常是直接在 onStop 里面直接做了处理，没有这么麻烦。</p><p>第二项是内存状态。</p><p>第三项是 doFrame 的状态，是看看 3 个队列分别耗时多少。由于我写了一个死循环，所以他们都是0。</p><p>第四项是线程状态与当前堆栈信息，可以看到堆栈信息只能在ANR的附近，并不能准确的指出ANR是哪个函数导致的。</p><p>第五项是 trace，就是被插桩的方法的调用链。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">* [Trace]</span><br><span class="hljs-string"></span>|<span class="hljs-string">*StackSize: 2</span><br><span class="hljs-string"></span>|<span class="hljs-string">*StackKey: 1</span>|<br>|<span class="hljs-string">*TraceStack:</span><br><span class="hljs-string"></span>|<span class="hljs-string">*[id count cost]</span><br><span class="hljs-string"></span>|<span class="hljs-string">*1048574 1 5005</span><br><span class="hljs-string"></span>|<span class="hljs-string">*.1 1 5004</span><br></code></pre></td></tr></table></figure><p>这个堆栈的意义需要解释一下，我们先看demo中的methodMapping：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,com.example.sample.MainActivity$<span class="hljs-number">2</span> onClick (Landroid.view.View<span class="hljs-comment">;)V</span><br><span class="hljs-number">1048574</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">android.os.Handler </span><span class="hljs-keyword">dispatchMessage </span>(Landroid.os.Message<span class="hljs-comment">;)V</span><br></code></pre></td></tr></table></figure><p>数据格式的意义为：methodId，方法的访问符，类， 函数。实现的函数为 <code>com.tencent.matrix.trace.item.TraceMethod#toString</code>。</p><p>所以上面的 traceStack 我们逆推一下，就是 Handler#dispatchMessage 调用了<code> MainActivity$2#onClick</code>，而 <code>MainActivity$2#onClick</code> 耗时 5004 毫秒，所以可以得出 <code>MainActivity$2#onClick</code> 这个方法里面有耗时操作。</p><p>实际上，我的demo里面确实是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">test.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> s = System.currentTimeMillis();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; s + <span class="hljs-number">6000</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>所以，这个 AnrTracer 还是挺准确的。</p><p>我们看看它的实现代码吧。</p><p>Tracer 类都是继承了 LooperObserver，我们从这个类的3个方法入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginMs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> token)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dispatchBegin(beginMs, cpuBeginMs, token);<br>    anrTask = <span class="hljs-keyword">new</span> AnrHandleTask(AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;AnrTracer#dispatchBegin&quot;</span>), token);<br>    <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;<br>        MatrixLog.v(TAG, <span class="hljs-string">&quot;* [dispatchBegin] token:%s index:%s&quot;</span>, token, anrTask.beginRecord.index);<br>    &#125;<br>    anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - (SystemClock.uptimeMillis() - token));<br>&#125;<br></code></pre></td></tr></table></figure><p>anrHandler 会将消息 post 到一个子线程，所以该类对插桩方法堆栈的分析都是在子线程。<strong>注意这里延迟了大约 5s</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFrame</span><span class="hljs-params">(String focusedActivityName, <span class="hljs-keyword">long</span> start, <span class="hljs-keyword">long</span> end, <span class="hljs-keyword">long</span> frameCostMs, <span class="hljs-keyword">long</span> inputCost, <span class="hljs-keyword">long</span> animationCost, <span class="hljs-keyword">long</span> traversalCost)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;<br>        MatrixLog.v(TAG, <span class="hljs-string">&quot;--&gt; [doFrame] activityName:%s frameCost:%sms [%s:%s:%s]ns&quot;</span>, focusedActivityName, frameCostMs, inputCost, animationCost, traversalCost);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>doFrame 可以忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> beginMs, <span class="hljs-keyword">long</span> cpuBeginMs, <span class="hljs-keyword">long</span> endMs, <span class="hljs-keyword">long</span> cpuEndMs, <span class="hljs-keyword">long</span> token, <span class="hljs-keyword">boolean</span> isBelongFrame)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.dispatchEnd(beginMs, cpuBeginMs, endMs, cpuEndMs, token, isBelongFrame);<br>    <span class="hljs-keyword">if</span> (traceConfig.isDevEnv()) &#123;<br>        MatrixLog.v(TAG, <span class="hljs-string">&quot;[dispatchEnd] token:%s cost:%sms cpu:%sms usage:%s&quot;</span>,<br>                token, endMs - beginMs, cpuEndMs - cpuBeginMs, Utils.calculateCpuUsage(cpuEndMs - cpuBeginMs, endMs - beginMs));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != anrTask) &#123;<br>        anrTask.getBeginRecord().release();<br>        anrHandler.removeCallbacks(anrTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个与 dispatchBegin 对应，如果 dispatchEnd 在 5s 内执行完了，那么就不用处理 AnrHandleTask 了，如果在 5s 内该方法没有调用，就需要分析方法调用，看看是哪里出了问题。我们看看 AnrHandleTask 里面做了什么：</p><blockquote><p>com.tencent.matrix.trace.tracer.AnrTracer.AnrHandleTask#run</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> curTime = SystemClock.uptimeMillis();<br>    <span class="hljs-keyword">boolean</span> isForeground = isForeground();<br>    <span class="hljs-comment">// process</span><br>    <span class="hljs-keyword">int</span>[] processStat = Utils.getProcessPriority(Process.myPid());<br>    <span class="hljs-keyword">long</span>[] data = AppMethodBeat.getInstance().copyData(beginRecord);<br>    beginRecord.release();<br>    String scene = AppMethodBeat.getVisibleScene();<br><br>    <span class="hljs-comment">// memory</span><br>    <span class="hljs-keyword">long</span>[] memoryInfo = dumpMemory();<br><br>    <span class="hljs-comment">// Thread state</span><br>    Thread.State status = Looper.getMainLooper().getThread().getState();<br>    StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();<br>    String dumpStack = Utils.getStack(stackTrace, <span class="hljs-string">&quot;|*\t\t&quot;</span>, <span class="hljs-number">12</span>);<br><br>    <span class="hljs-comment">// frame</span><br>    UIThreadMonitor monitor = UIThreadMonitor.getMonitor();<br>    <span class="hljs-keyword">long</span> inputCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token);<br>    <span class="hljs-keyword">long</span> animationCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token);<br>    <span class="hljs-keyword">long</span> traversalCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token);<br><br>    <span class="hljs-comment">// trace</span><br>    LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> LinkedList();<br>    <span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 将 buffer 中的 long 转为 MethodItem</span><br>        TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-keyword">true</span>, curTime);<br>        <span class="hljs-comment">//</span><br>        TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> TraceDataUtils.IStructuredDataFilter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> during, <span class="hljs-keyword">int</span> filterCount)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFilterMaxCount</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>                MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);<br>                Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    iterator.next();<br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    StringBuilder reportBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    StringBuilder logcatBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">long</span> stackCost = Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));<br><br>    <span class="hljs-comment">// stackKey</span><br>    String stackKey = TraceDataUtils.getTreeKey(stack, stackCost);<br>    MatrixLog.w(TAG, <span class="hljs-string">&quot;%s \npostTime:%s curTime:%s&quot;</span>,<br>            printAnr(scene, processStat, memoryInfo, status, logcatBuilder, isForeground, stack.size(),<br>                    stackKey, dumpStack, inputCost, animationCost, traversalCost, stackCost), token, curTime); <span class="hljs-comment">// for logcat</span><br><br>    <span class="hljs-keyword">if</span> (stackCost &gt;= Constants.DEFAULT_ANR_INVALID) &#123;<br>        MatrixLog.w(TAG, <span class="hljs-string">&quot;The checked anr task was not executed on time. &quot;</span><br>                + <span class="hljs-string">&quot;The possible reason is that the current process has a low priority. just pass this report&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// report</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        TracePlugin plugin = Matrix.with().getPluginByClass(TracePlugin.class);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == plugin) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();<br>        jsonObject = DeviceUtil.getDeviceInfo(jsonObject, Matrix.with().getApplication());<br>        jsonObject.put(SharePluginInfo.ISSUE_STACK_TYPE, Constants.Type.ANR);<br>        jsonObject.put(SharePluginInfo.ISSUE_COST, stackCost);<br>        jsonObject.put(SharePluginInfo.ISSUE_STACK_KEY, stackKey);<br>        jsonObject.put(SharePluginInfo.ISSUE_SCENE, scene);<br>        jsonObject.put(SharePluginInfo.ISSUE_TRACE_STACK, reportBuilder.toString());<br>        jsonObject.put(SharePluginInfo.ISSUE_THREAD_STACK, Utils.getStack(stackTrace));<br>        jsonObject.put(SharePluginInfo.ISSUE_PROCESS_PRIORITY, processStat[<span class="hljs-number">0</span>]);<br>        jsonObject.put(SharePluginInfo.ISSUE_PROCESS_NICE, processStat[<span class="hljs-number">1</span>]);<br>        jsonObject.put(SharePluginInfo.ISSUE_PROCESS_FOREGROUND, isForeground);<br>        <span class="hljs-comment">// memory info</span><br>        JSONObject memJsonObject = <span class="hljs-keyword">new</span> JSONObject();<br>        memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_DALVIK, memoryInfo[<span class="hljs-number">0</span>]);<br>        memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_NATIVE, memoryInfo[<span class="hljs-number">1</span>]);<br>        memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_VM_SIZE, memoryInfo[<span class="hljs-number">2</span>]);<br>        jsonObject.put(SharePluginInfo.ISSUE_MEMORY, memJsonObject);<br><br>        Issue issue = <span class="hljs-keyword">new</span> Issue();<br>        issue.setKey(token + <span class="hljs-string">&quot;&quot;</span>);<br>        issue.setTag(SharePluginInfo.TAG_PLUGIN_EVIL_METHOD);<br>        issue.setContent(jsonObject);<br>        plugin.onDetectIssue(issue);<br><br>    &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;[JSONException error: %s&quot;</span>, e);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出里面就是输出上面我们看到的一些日志信息。</p><p>这里只详细说一下方法堆栈的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// trace</span><br>LinkedList&lt;MethodItem&gt; stack = <span class="hljs-keyword">new</span> LinkedList();<br><span class="hljs-keyword">if</span> (data.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 将 buffer 中的 long 转为 MethodItem</span><br>    TraceDataUtils.structuredDataToStack(data, stack, <span class="hljs-keyword">true</span>, curTime);<br>    <span class="hljs-comment">//</span><br>    TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, <span class="hljs-keyword">new</span> TraceDataUtils.IStructuredDataFilter() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> during, <span class="hljs-keyword">int</span> filterCount)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFilterMaxCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> Constants.FILTER_STACK_MAX_COUNT;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>            MatrixLog.w(TAG, <span class="hljs-string">&quot;[fallback] size:%s targetSize:%s stack:%s&quot;</span>, size, Constants.TARGET_EVIL_METHOD_STACK, stack);<br>            Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK));<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                iterator.next();<br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><br>StringBuilder reportBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>StringBuilder logcatBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">long</span> stackCost = Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder));<br><br></code></pre></td></tr></table></figure><p>第一个关键函数：<code>com.tencent.matrix.trace.util.TraceDataUtils#structuredDataToStack</code></p><p>它就是将 sBuffer 转成一个 LinkedList。之前我们有一张图，这里再看一下：</p><p><img src="https://github.com/Tencent/matrix/wiki/images/trace/stack.jpg" alt="Alt text"></p><p>还是只看上半部分，对于 4 5 6 7 这4个方法来说，经过转换后，就变为了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">List</span> list = &#123;&#123;<span class="hljs-number">4</span>， <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">5</span>，<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">6</span>， <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">7</span>， <span class="hljs-number">1</span>&#125;&#125; 。<br></code></pre></td></tr></table></figure><p>这个列表里面是一个对象，我只写了 methodId 与 depth：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodItem</span> </span>&#123;<br><br>    <span class="hljs-comment">// 方法的id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> methodId;<br>    <span class="hljs-comment">// 耗费的时间</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> durTime;<br>    <span class="hljs-comment">// 调用的深度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> depth;<br>    <span class="hljs-comment">// 被调用的次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>拿到了所有的调用栈之后，有可能调用栈特别大，所以需要裁剪： <code>TraceDataUtils.trimStack</code> 。</p><p>这个方法就是用来过滤一些不耗时的函数，过滤类是<code>IStructuredDataFilter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IStructuredDataFilter</span> </span>&#123;<br>    <span class="hljs-comment">// 将满足过滤条件的删掉</span><br>    <span class="hljs-comment">// filterCount  是当前的过滤次数，可以根据过滤次数来做动态的调整，更改过滤条件，使之更宽</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isFilter</span><span class="hljs-params">(<span class="hljs-keyword">long</span> during, <span class="hljs-keyword">int</span> filterCount)</span></span>;<br><br>    <span class="hljs-comment">// 最大的过滤次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getFilterMaxCount</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 如果达到最大过滤次数后，还是太多了，则在这个方法里面处理，一般就是直接丢弃掉多余的</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fallback</span><span class="hljs-params">(List&lt;MethodItem&gt; stack, <span class="hljs-keyword">int</span> size)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将方法堆栈裁剪完之后，就可以打印输出了。这个类的核心就介绍完毕了。</p><p>哦，对了，还有一个较重要的函数：<code>com.tencent.matrix.trace.util.TraceDataUtils#getTreeKey(java.util.List&lt;com.tencent.matrix.trace.items.MethodItem&gt;, long)</code></p><p>这个就是为堆栈生成一个 key，因为上报到后台，没有一个 key 的话很麻烦，而且将堆栈简化为key，可以更容易的做处理。具体就是：分析出主要耗时的那一级函数，作为代表卡顿堆栈的key。就是上图的下半部分。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果主线程中的一个Message的处理超过了 5000ms，那么既有可能会发生 anr，所以我们可以这样做：</p><ul><li>在 dispatchBegin 的时候，记录一下 long 数组的索引（以 post 延迟5s消息的方式）</li><li>在 dispatchEnd 的时候，记录一下 long 数组的索引（将消息移除，如果间隔超过了5s，就会执行下面的逻辑）</li><li>拿到这两个索引之间的数据，然后分析调用堆栈以及耗时</li></ul>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>003-Matrix源码分析：方法监控</title>
    <link href="/2020/07/01/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/003-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9B%91%E6%8E%A7/"/>
    <url>/2020/07/01/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/003-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>在上一节中，我们看到过 AppMethodBeat 这个类，但是却没有介绍它，是因为这个玩意特别的难搞，需要单独的起一篇。</p><p>这个类其实是用来统计每个函数的耗时的，具体的可以看官方文档：</p><p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary</a></p><p>知道了每个函数的耗时，就可以找出卡顿的原因。</p><p>下面我们来分析这个类，首先来看一个字段。</p><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat#status</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> status = STATUS_DEFAULT;<br></code></pre></td></tr></table></figure><p>这个字段还是挺重要的，它涉及到该类的状态的管理。</p><p>一开始是 STATUS_DEFAULT 状态</p><p>然后当我们调用了  i 方法之后，会变为 STATUS_READY 状态。</p><p>然后当我们调用了 onStart 方法之后，会变为 STATUS_STARTED 状态。</p><p>然后当我们调用了 onStop 方法之后，会变为 STATUS_STOPPED 状态。</p><p>需要注意一下调用的顺序，如果顺序不对，有些逻辑是不会走的。</p><p>由于，i 与 o 方法会插桩到我们的代码中，所以 i 肯定是会先于 onStart 方法执行，这个没有问题。</p><p>状态搞清楚了，我们看看 i 与 o 这两个方法。</p><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat#i</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-keyword">int</span> methodId)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (status &lt;= STATUS_STOPPED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (methodId &gt;= METHOD_ID_MAX) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>        <span class="hljs-keyword">synchronized</span> (statusLock) &#123;<br>            <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT) &#123;<br>                <span class="hljs-comment">// 逻辑只会执行一次</span><br>                realExecute();<br>                status = STATUS_READY;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">long</span> threadId = Thread.currentThread().getId();<br>    <span class="hljs-keyword">if</span> (sMethodEnterListener != <span class="hljs-keyword">null</span>) &#123;<br>        sMethodEnterListener.enter(methodId, threadId);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (threadId == sMainThreadId) &#123;<br>        <span class="hljs-keyword">if</span> (assertIn) &#123;<br>            android.util.Log.e(TAG, <span class="hljs-string">&quot;ERROR!!! AppMethodBeat.i Recursive calls!!!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        assertIn = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sIndex = <span class="hljs-number">0</span>;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">true</span>);<br>        &#125;<br>        ++sIndex;<br>        assertIn = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用插件之后，在每个方法的前面都会加上这个 i 方法。该方法里面做了两件事：</p><ul><li>realExecute();</li><li>mergeData</li></ul><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat#realExecute</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">realExecute</span><span class="hljs-params">()</span> </span>&#123;<br>    MatrixLog.i(TAG, <span class="hljs-string">&quot;[realExecute] timestamp:%s&quot;</span>, System.currentTimeMillis());<br><br>    sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;<br><br>    sHandler.removeCallbacksAndMessages(<span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 开线程更新时间</span><br>    sHandler.postDelayed(sUpdateDiffTimeRunnable, Constants.TIME_UPDATE_CYCLE_MS);<br>    <span class="hljs-comment">// 启动过期检查，可以忽略</span><br>    sHandler.postDelayed(checkStartExpiredRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">synchronized</span> (statusLock) &#123;<br>                MatrixLog.i(TAG, <span class="hljs-string">&quot;[startExpired] timestamp:%s status:%s&quot;</span>, System.currentTimeMillis(), status);<br>                <span class="hljs-keyword">if</span> (status == STATUS_DEFAULT || status == STATUS_READY) &#123;<br>                    status = STATUS_EXPIRED_START;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;, Constants.DEFAULT_RELEASE_BUFFER_DELAY);<br><br>    <span class="hljs-comment">// hack H </span><br>    ActivityThreadHacker.hackSysHandlerCallback();<br>    <span class="hljs-comment">// 注册回调</span><br>    LooperMonitor.register(looperMonitorListener);<br>&#125;<br></code></pre></td></tr></table></figure><p>realExecute 只会调用一次，里面启动了一个线程专门用来更新时间（隔5ms循环一次），原因是：</p><blockquote><p>考虑到每个方法执行前后都获取系统时间（System.nanoTime）会对性能影响比较大，而实际上，单个函数执行耗时小于 5ms 的情况，对卡顿来说不是主要原因，可以忽略不计，如果是多次调用的情况，则在它的父级方法中可以反映出来，所以为了减少对性能的影响，通过另一条更新时间的线程每 5ms 去更新一个时间变量，而每个方法执行前后只读取该变量来减少性能损耗。</p></blockquote><p>方法里面还hack了 ActivityThread 的 H 的 callback，主要是用来拦截消息的处理，是一种很常用的 hook 方式，里面做了启动的耗时监测，暂时不深入，后面再说。</p><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat#mergeData</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> methodId, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">boolean</span> isIn)</span> </span>&#123;<br>    <span class="hljs-comment">// 看注释这里是修复了一个bug，anr时间计算有问题，没看懂</span><br>    <span class="hljs-keyword">if</span> (methodId == AppMethodBeat.METHOD_ID_DISPATCH) &#123;<br>        sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime;<br>    &#125;<br>    <span class="hljs-keyword">long</span> trueId = <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">if</span> (isIn) &#123;<br>        trueId |= <span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">63</span>;<br>    &#125;<br>    trueId |= (<span class="hljs-keyword">long</span>) methodId &lt;&lt; <span class="hljs-number">43</span>;<br>    trueId |= sCurrentDiffTime &amp; <span class="hljs-number">0x7FFFFFFFFFFL</span>;<br>    <span class="hljs-comment">// sBuffer 是一个long数组，long的结构：</span><br>    <span class="hljs-comment">// 第1位是 1或者0，1是函数入口，0是函数出口</span><br>    <span class="hljs-comment">// 2-21位是 methodId</span><br>    <span class="hljs-comment">// 22-64位是 函数的执行前后距离 MethodBeat 模块初始化的时间，一个函数会有占两个位置，根据 methodId 就可以计算出函数耗时</span><br>    sBuffer[index] = trueId;<br>    <span class="hljs-comment">// 该方法用于处理循环问题，sBuffer满了，会重头开始覆盖旧数据，主要是更新 indexRecord 链表头位置</span><br>    checkPileup(index);<br>    sLastIndex = index;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法也不难，就是往 sBuffer 里面添加数据，数据的结构注释也解释的很清楚了。</p><p>最终sBuffer大致长这样：</p><p><img src="https://github.com/Tencent/matrix/wiki/images/trace/run_store.jpg" alt="Alt text"></p><p>我们再看看 o 方法：</p><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat#o</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">o</span><span class="hljs-params">(<span class="hljs-keyword">int</span> methodId)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (status &lt;= STATUS_STOPPED) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (methodId &gt;= METHOD_ID_MAX) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread().getId() == sMainThreadId) &#123;<br>        <span class="hljs-keyword">if</span> (sIndex &lt; Constants.BUFFER_SIZE) &#123;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sIndex = <span class="hljs-number">0</span>;<br>            mergeData(methodId, sIndex, <span class="hljs-keyword">false</span>);<br>        &#125;<br>        ++sIndex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就做了一件事就是 mergeData，这里就没啥好说的了。再看一下 sBuffer 的结构图，<strong>只看上半部分</strong>：</p><p><img src="https://github.com/Tencent/matrix/wiki/images/trace/stack.jpg" alt="Alt text"></p><p>我们在 sBuffer 中找到 methodId 一致的，就可以拿到该函数的耗时。</p><p>一般情况下，我们需要获取的是 sBuffer 中的一段数据，比如执行 doFrame 消息的时候，我们想知道，它里面调用到了哪些函数，这个时候就需要记录一下 doFrame 前后的 sIndex，有一个内部类是专门做这个的：</p><blockquote><p>com.tencent.matrix.trace.core.AppMethodBeat.IndexRecord</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexRecord</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-keyword">private</span> IndexRecord next;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isValid = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">public</span> String source;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>index 字段是用来记录 sBuffer 中的位置的。next 说明它是一个链表。</p><p>用法如下：</p><p>比如我们在，分发消息之前，首先调用 <code>com.tencent.matrix.trace.core.AppMethodBeat#maskIndex</code> 方法，传递一个 source 作为参数，得到一个 IndexRecord 对象，然后在分发消息结束后，再获取到 sIndex 的值，这样就有了两个 sIndex。取出这个范围里面的数据就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">AppMethodBeat.IndexRecord beginRecord = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;AnrTracer#dispatchBegin&quot;</span>);<br><span class="hljs-comment">// 方法的调用栈信息在 data 里面</span><br><span class="hljs-keyword">long</span>[] data = AppMethodBeat.getInstance().copyData(beginRecord);<br>beginRecord.release();<br></code></pre></td></tr></table></figure><p>AppMethodBeat 里面重要的方法就分析完了，我们看看上面忽略的 ActivityThreadHacker 这个类。这个类也很简单，主要就是 hook  ActivityThread的内部类 H 这个类。</p><p>hook Hanlder 一般使用 callback 的方式，不清楚的可以看下消息分发优先级。</p><blockquote><p>com.tencent.matrix.trace.hacker.ActivityThreadHacker#hackSysHandlerCallback</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hackSysHandlerCallback</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        sApplicationCreateBeginTime = SystemClock.uptimeMillis();<br>        sApplicationCreateBeginMethodIndex = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;ApplicationCreateBeginMethodIndex&quot;</span>);<br>        Class&lt;?&gt; forName = Class.forName(<span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>);<br>        Field field = forName.getDeclaredField(<span class="hljs-string">&quot;sCurrentActivityThread&quot;</span>);<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object activityThreadValue = field.get(forName);<br>        Field mH = forName.getDeclaredField(<span class="hljs-string">&quot;mH&quot;</span>);<br>        mH.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object handler = mH.get(activityThreadValue);<br>        Class&lt;?&gt; handlerClass = handler.getClass().getSuperclass();<br>        Field callbackField = handlerClass.getDeclaredField(<span class="hljs-string">&quot;mCallback&quot;</span>);<br>        callbackField.setAccessible(<span class="hljs-keyword">true</span>);<br>        Handler.Callback originalCallback = (Handler.Callback) callbackField.get(handler);<br>        HackCallback callback = <span class="hljs-keyword">new</span> HackCallback(originalCallback);<br>        callbackField.set(handler, callback);<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;hook system handler completed. start:%s SDK_INT:%s&quot;</span>, sApplicationCreateBeginTime, Build.VERSION.SDK_INT);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        MatrixLog.e(TAG, <span class="hljs-string">&quot;hook system handler err! %s&quot;</span>, e.getCause().toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，我们直接看 HackCallback 做了什么：</p><blockquote><p>com.tencent.matrix.trace.hacker.ActivityThreadHacker.HackCallback</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (!AppMethodBeat.isRealTrace()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span> isLaunchActivity = isLaunchActivity(msg);<br>    <span class="hljs-keyword">if</span> (hasPrint &gt; <span class="hljs-number">0</span>) &#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;[handleMessage] msg.what:%s begin:%s isLaunchActivity:%s&quot;</span>, msg.what, SystemClock.uptimeMillis(), isLaunchActivity);<br>        hasPrint--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isLaunchActivity) &#123;<br>        ActivityThreadHacker.sLastLaunchActivityTime = SystemClock.uptimeMillis();<br>        ActivityThreadHacker.sLastLaunchActivityMethodIndex = AppMethodBeat.getInstance().maskIndex(<span class="hljs-string">&quot;LastLaunchActivityMethodIndex&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!isCreated) &#123;<br>        <span class="hljs-keyword">if</span> (isLaunchActivity || msg.what == CREATE_SERVICE || msg.what == RECEIVER) &#123; <span class="hljs-comment">// todo for provider</span><br>            ActivityThreadHacker.sApplicationCreateEndTime = SystemClock.uptimeMillis();<br>            ActivityThreadHacker.sApplicationCreateScene = msg.what;<br>            isCreated = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>是对 activity 的启动做了监控。记录了 activity 启动的时间，记录了对应的 sIndex，以便后面进行启动分析。</p><p>还记录了 application 的启动情况，原理是，如果是第一次启动一个 activity，那么记录当前时间，这个时间就当成 application 创建完成的时间，还记录了启动场景，因为启动APP的，可以有 Activity，Service，BroadcastReceiver 等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>检测UI线程方法耗时的原理：在每个方法的前后都插入 i / o 方法。</p><p>i / o 方法里面会记录当前方法的 id，当前方法执行的时间。这些信息都储存在一个 long 型变量里面，最后所有的方法形成一个 long 型数组。</p><p>我们可以获取 long 型数组里面的 Message 执行的那一段数据，然后就可以获取到方法调用堆栈，以及每个方法的耗时情况。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>002-Matrix源码分析：UIThreadMonitor监测主线程</title>
    <link href="/2020/06/30/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/002-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AUIThreadMonitor%E7%9B%91%E6%B5%8B%E4%B8%BB%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/06/30/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/002-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AUIThreadMonitor%E7%9B%91%E6%B5%8B%E4%B8%BB%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>常说的一个问题：为啥Looper有个死循环却不会阻塞主线程？？？</p><p>这是因为我们所谓的主线程就是这个死循环。我们的每一帧都是封装成了消息然后被分发，在主线程处理，主线程是不断的在处理这些消息，如果什么时候有个特别耗时的消息来了，那么主线程就会卡死。</p><p>上面说了一个题外话，我们现在来看看如何监测主线程。了解这个类还需要一点预备知识：</p><p>FrameDisplayEventReceiver 在收到 VSYNC 信号之后，会调用 doFrame 方法，而 doFrame 方法就会处理 Choreographer.CALLBACK_INPUT，</p><p>Choreographer.CALLBACK_ANIMATION，Choreographer.CALLBACK_TRAVERSAL这些东西。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/uithreadmonitor1.png?raw=true" alt="uithreadmonitor1.png"></p><p>他们分别是 事件处理，动画，界面绘制相关的东西。比如对于属性动画，它注册了帧回调，会将相关代码添加到 Choreographer 的动画队列里面，然后下一帧就会被执行，动画也就得到了处理。</p><p>doFrame方法本身也是一个 message：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Message msg = mHandler.obtainMessage(MSG_DO_FRAME);<br></code></pre></td></tr></table></figure><p>这里发送了一个消息，然后接受者会处理消息，处理这个消息的时候会调用 doFrame 方法，可以认为这个 doFrame 方法是在Looper的Printer的两个打印代码之间执行的。</p><p>所以相当于这个类将消息的处理过程更加细化了，我们看看代码：</p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#init</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">choreographer = Choreographer.getInstance();<br>callbackQueueLock = reflectObject(choreographer, <span class="hljs-string">&quot;mLock&quot;</span>);<br>callbackQueues = reflectObject(choreographer, <span class="hljs-string">&quot;mCallbackQueues&quot;</span>);<br><br>addInputQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_INPUT], ADD_CALLBACK, <span class="hljs-keyword">long</span>.class, Object.class, Object.class);<br>addAnimationQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_ANIMATION], ADD_CALLBACK, <span class="hljs-keyword">long</span>.class, Object.class, Object.class);<br>addTraversalQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_TRAVERSAL], ADD_CALLBACK, <span class="hljs-keyword">long</span>.class, Object.class, Object.class);<br>frameIntervalNanos = reflectObject(choreographer, <span class="hljs-string">&quot;mFrameIntervalNanos&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里是使用反射获取了 Choreographer 类的一些字段与方法，后面会用于向队列里面添加回调。</p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#init</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">LooperMonitor.register(<span class="hljs-keyword">new</span> LooperMonitor.LooperDispatchListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isAlive;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchStart</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchStart();<br>        UIThreadMonitor.<span class="hljs-keyword">this</span>.dispatchBegin();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.dispatchEnd();<br>        UIThreadMonitor.<span class="hljs-keyword">this</span>.dispatchEnd();<br>    &#125;<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>接下来就是注册了监听，这个监听的触发时机上一节我们分析过，分发消息的时候会成对的回调。</p><p>我们继续看 dispatchBegin 与 dispatchEnd：</p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#dispatchBegin</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchBegin</span><span class="hljs-params">()</span> </span>&#123;<br>    token = dispatchTimeMs[<span class="hljs-number">0</span>] = SystemClock.uptimeMillis();<br>    dispatchTimeMs[<span class="hljs-number">2</span>] = SystemClock.currentThreadTimeMillis();<br>    AppMethodBeat.i(AppMethodBeat.METHOD_ID_DISPATCH);<br><br>    <span class="hljs-keyword">synchronized</span> (observers) &#123;<br>        <span class="hljs-keyword">for</span> (LooperObserver observer : observers) &#123;<br>            <span class="hljs-keyword">if</span> (!observer.isDispatchBegin()) &#123;<br>                observer.dispatchBegin(dispatchTimeMs[<span class="hljs-number">0</span>], dispatchTimeMs[<span class="hljs-number">2</span>], token);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记录了一些时间：</p><p>dispatchTimeMs[0] 是手机从启动到现在的时间。</p><p>dispatchTimeMs[2] 是线程运行的时间。</p><p>然后是通知自己的 observers，<strong>相当于又转了一下</strong>，利用 LooperDispatchListener 来通知<strong>自己的 LooperObserver</strong>。</p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#dispatchEnd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (isBelongFrame) &#123;<br>        doFrameEnd(token);<br>    &#125;<br><br>    <span class="hljs-keyword">long</span> start = token;<br>    <span class="hljs-keyword">long</span> end = SystemClock.uptimeMillis();<br><br>    <span class="hljs-keyword">synchronized</span> (observers) &#123;<br>        <span class="hljs-keyword">for</span> (LooperObserver observer : observers) &#123;<br>            <span class="hljs-keyword">if</span> (observer.isDispatchBegin()) &#123;<br>                observer.doFrame(AppMethodBeat.getVisibleScene(), token, SystemClock.uptimeMillis(), isBelongFrame ? end - start : <span class="hljs-number">0</span>, queueCost[CALLBACK_INPUT], queueCost[CALLBACK_ANIMATION], queueCost[CALLBACK_TRAVERSAL]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    dispatchTimeMs[<span class="hljs-number">3</span>] = SystemClock.currentThreadTimeMillis();<br>    dispatchTimeMs[<span class="hljs-number">1</span>] = SystemClock.uptimeMillis();<br><br>    AppMethodBeat.o(AppMethodBeat.METHOD_ID_DISPATCH);<br><br>    <span class="hljs-keyword">synchronized</span> (observers) &#123;<br>        <span class="hljs-keyword">for</span> (LooperObserver observer : observers) &#123;<br>            <span class="hljs-keyword">if</span> (observer.isDispatchBegin()) &#123;<br>                observer.dispatchEnd(dispatchTimeMs[<span class="hljs-number">0</span>], dispatchTimeMs[<span class="hljs-number">2</span>], dispatchTimeMs[<span class="hljs-number">1</span>], dispatchTimeMs[<span class="hljs-number">3</span>], token, isBelongFrame);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>dispatchEnd 方法要稍微复杂一点，但是还是一样的，它也是记录了一些时间：</p><p>dispatchTimeMs[3] 是线程运行时间，与 dispatchTimeMs[2] 对应起来看就可以知道线程执行这个消息的耗时。</p><p>dispatchTimeMs[1] 是手机从启动到现在的时间，dispatchTimeMs[0] 对应就可以知道该方法现实时间的耗时。注意两个耗时的区别，现实耗时是大于线程耗时的，因为线程会切片运行。</p><p>这个方法，<strong>也主要是回调了 observer.doFrame 和 observer.dispatchEnd 两个方法，这两个方法几乎是同时调用的，方法里面的参数是我们需要的</strong>。</p><p>这里有个地方有点疑问：按照 LooperObserver 的3个方法来看，显然是要监测 doFrame 的运行情况，而 doFrame 只是一个特定的消息才会回调，假如我随便发送了一个普通的消息，也会触发这3个回调，那不是有问题吗？</p><p>我调试了一下这个回调，发现如下日志：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">activityName[<span class="hljs-keyword">com</span>.example.sample.MainActivity] frame <span class="hljs-built_in">cos</span><span class="hljs-variable">t:0ms</span> [<span class="hljs-number">104300</span>|<span class="hljs-number">2480</span>|<span class="hljs-number">218640</span>]ns<br><span class="hljs-number">000000000</span><br>activityName[<span class="hljs-keyword">com</span>.example.sample.MainActivity] frame <span class="hljs-built_in">cos</span><span class="hljs-variable">t:0ms</span> [<span class="hljs-number">104300</span>|<span class="hljs-number">2480</span>|<span class="hljs-number">218640</span>]ns<br></code></pre></td></tr></table></figure><p>我使用hander发送了一个message，打印出来的日志是这样的，就是说如果不是执行的 doFrame 的消息，frameCostMs 是 0，其余的是上一帧的值。我们注意一下就行了。</p><p>上面的函数中，开头就有一个 if 判断，这个很重要，里面涉及到我们上面所说的3个队列。</p><p>让我们从头道来，首先，外部会调用该类的 onStart 方法：</p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#onStart</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isInit) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;never init!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isAlive) &#123;<br>        <span class="hljs-keyword">this</span>.isAlive = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            MatrixLog.i(TAG, <span class="hljs-string">&quot;[onStart] callbackExist:%s %s&quot;</span>, Arrays.toString(callbackExist), Utils.getStack());<br>            callbackExist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-comment">// queueStatus 存放状态，队列开始执行时，置为 DO_QUEUE_BEGIN，队列执行完毕时，置为 DO_QUEUE_END。</span><br>        queueStatus = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// queueCost 存放队列执行完毕的时间。</span><br>        queueCost = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[CALLBACK_LAST + <span class="hljs-number">1</span>];<br>        addFrameCallback(CALLBACK_INPUT, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里做了些初始化的判断，以及创建了一些数组，这个数组就是用来存放那3个队列的相关信息的。</p><p>最后一行代码，往  input 队列里面添加了一个 runnable，这个 runnable 就是自己，所以当input队列执行的时候会运行该类的 run 方法。 </p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#run</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个方法里面就做了一件事，就是将 isBelongFrame 置为 true</span><br>        doFrameBegin(token);<br>        <span class="hljs-comment">// 开始执行 input 队列</span><br>        doQueueBegin(CALLBACK_INPUT);<br><br>        <span class="hljs-comment">// 向 animation 队列添加一个 runnable</span><br>        addFrameCallback(CALLBACK_ANIMATION, <span class="hljs-keyword">new</span> Runnable() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// input队列执行结束</span><br>                doQueueEnd(CALLBACK_INPUT);<br>                <span class="hljs-comment">// 开始执行 animation 队列</span><br>                doQueueBegin(CALLBACK_ANIMATION);<br>            &#125;<br>        &#125;, <span class="hljs-keyword">true</span>);<br><br>        <span class="hljs-comment">// 向 traversal 队列添加一个 runnable</span><br>        addFrameCallback(CALLBACK_TRAVERSAL, <span class="hljs-keyword">new</span> Runnable() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// animation 队列执行结束</span><br>                doQueueEnd(CALLBACK_ANIMATION);<br>                <span class="hljs-comment">// 开始执行 traversal 队列</span><br>                doQueueBegin(CALLBACK_TRAVERSAL);<br>            &#125;<br>        &#125;, <span class="hljs-keyword">true</span>);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (config.isDevEnv()) &#123;<br>            MatrixLog.d(TAG, <span class="hljs-string">&quot;[UIThreadMonitor#run] inner cost:%sns&quot;</span>, System.nanoTime() - start);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里其实就是向3个队列的头部插入 runnable，然后执行runnable的时候，计算出时差，调用对应的 begin与end方法。</strong></p><blockquote><p>com.tencent.matrix.trace.core.UIThreadMonitor#doQueueBegin</p><p>com.tencent.matrix.trace.core.UIThreadMonitor#doQueueEnd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doQueueBegin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    queueStatus[type] = DO_QUEUE_BEGIN;<br>    queueCost[type] = System.nanoTime();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doQueueEnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    queueStatus[type] = DO_QUEUE_END;<br>    queueCost[type] = System.nanoTime() - queueCost[type];<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        callbackExist[type] = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两方法啊就是设置队列的运行状态，计算队列的执行耗时。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在主线程的消息队列里面，我们主要分析的是由 doFrame 构成的消息。该消息主要由3个队列组成：</p><ul><li>input</li><li>animation</li><li>traversal</li></ul><p>往这3个队列里面的头部插入一个自定义的 callback，这样我们就可以记录这3个队列的执行耗时。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HttpDnsLib分析</title>
    <link href="/2020/06/30/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/HttpDnsLib/HttpDnsLib%E5%88%86%E6%9E%90/"/>
    <url>/2020/06/30/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/HttpDnsLib/HttpDnsLib%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>框架地址：</p><p><a href="https://github.com/CNSRE/HTTPDNSLib">https://github.com/CNSRE/HTTPDNSLib</a></p><p>先从，框架的几个模块开始介绍。</p><h3 id="测速模块"><a href="#测速模块" class="headerlink" title="测速模块"></a>测速模块</h3><p>对于一个大型app来说，在全国会有多个服务器， 每个服务器的ip地址肯定也是不一致的，所以对于不同地区的用户，一般情况下与之最近的服务器肯定访问最快，测速模块就是找到访问最快的服务器。</p><p>测速有两种方法，第一种是使用 ping 命令，第二种是使用 socket。下面分别介绍：</p><h4 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ping</span> </span>&#123;<br>    <span class="hljs-comment">// ping -c1 -s1 -w1 www.baidu.com //-w 超时单位是s</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG_BYTES_FROM = <span class="hljs-string">&quot;bytes from &quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runcmd</span><span class="hljs-params">(String cmd)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Runtime runtime = Runtime.getRuntime();<br>        Process proc = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">final</span> String command = cmd.trim();<br>        <span class="hljs-comment">// 这里计算的是命令跑完的时间，而不是ping输出的时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        proc = runtime.exec(command);<br>        proc.waitFor();<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        InputStream inputStream = proc.getInputStream();<br>        String result = <span class="hljs-string">&quot;unknown ip&quot;</span>;<br><br>        BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream));<br>        StringBuilder resultBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        String line = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">null</span> != (line = reader.readLine())) &#123;<br>            resultBuilder.append(line);<br>        &#125;<br>        reader.close();<br>        String responseStr = resultBuilder.toString();<br>        result = responseStr.toLowerCase().trim();<br>        <span class="hljs-keyword">if</span> (isValidResult(result)) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (endTime - startTime);<br>        &#125;<br>        <span class="hljs-keyword">return</span> SpeedtestManager.OCUR_ERROR;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidResult</span><span class="hljs-params">(String result)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(result)) &#123;<br>            <span class="hljs-keyword">if</span> (result.indexOf(TAG_BYTES_FROM) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码其实就是使用 Runtime 执行了一个 ping 命令，但是它测的时间是这个命令同步执行耗费的时间，而不是命令返回的结果里面的时间。</p><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">speedTest</span><span class="hljs-params">(String ip, String host)</span> </span>&#123;<br>    Socket socket = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 计算的是 socket 的 connect 连接时间</span><br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        Socket s1 = <span class="hljs-keyword">new</span> Socket();<br>        s1.connect(<span class="hljs-keyword">new</span> InetSocketAddress(ip, <span class="hljs-number">80</span>), TIMEOUT);<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-keyword">int</span> rtt = (<span class="hljs-keyword">int</span>) (end - begin);<br>        <span class="hljs-keyword">return</span> rtt;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != socket) &#123;<br>                socket.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> SpeedtestManager.OCUR_ERROR;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的 Socket 的 connect 方法来测量访问速度。</p><p>在进行测速的时候，会优先使用 Socket 来测速，如果 Socket 测通了，那么就不会再使用 Ping 来测速了。</p><h3 id="评分模块"><a href="#评分模块" class="headerlink" title="评分模块"></a>评分模块</h3><p>框架里面虽然缓存了各个域名的IP地址，但是有效期只有1分钟，所以开了一个任务来不断的更新过期的域名IP。</p><p>更新了IP之后，也会对新IP进行测速，在测速后会统计该IP测试通过– 成功的次数，失败的次数，最后成功的时间，以及RTT值，另外还有一个HttpDns服务器返回IP的时候会带一个优先级，这个也计入评分项。</p><blockquote><p>RTT 的概念可以自己搜索一下。</p></blockquote><h4 id="成功的次数"><a href="#成功的次数" class="headerlink" title="成功的次数"></a>成功的次数</h4><p>使用上面的测速模块对IP进行测速之后，我们记录一下测速状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (IpModel ipModel : ipArray) &#123;<br>    <span class="hljs-keyword">int</span> rtt = speedtestManager.speedTest(ipModel.ip, domainModel.domain);<br>    <span class="hljs-keyword">boolean</span> succ = rtt &gt; SpeedtestManager.OCUR_ERROR;<br>    <span class="hljs-keyword">if</span> (succ) &#123;<br>        ipModel.rtt = String.valueOf(rtt);<br>        ipModel.success_num = String.valueOf((Integer.parseInt(ipModel.success_num) + <span class="hljs-number">1</span>));<br>        ipModel.finally_success_time = String.valueOf(System.currentTimeMillis());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ipModel.rtt = String.valueOf(SpeedtestManager.MAX_OVERTIME_RTT);<br>        ipModel.err_num = String.valueOf((Integer.valueOf(ipModel.err_num) + <span class="hljs-number">1</span>));<br>        ipModel.finally_fail_time = String.valueOf(System.currentTimeMillis());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码逻辑很简单：</p><p>如果成功了，记录RTT值，成功次数加一，记录成功时间。</p><p>如果失败了，RTT记为9999，失败次数加一，记录失败时间。</p><p>我们看一下成功次数这一项对评分的影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ArrayList&lt;IpModel&gt; list)</span> </span>&#123;<br>    <span class="hljs-comment">// 查找到最大历史成功次数</span><br>    <span class="hljs-keyword">float</span> MAX_SUCCESSNUM = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (IpModel temp : list) &#123;<br>        <span class="hljs-keyword">if</span> (temp.success_num == <span class="hljs-keyword">null</span> || temp.success_num.equals(<span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">float</span> successNum = Float.parseFloat(temp.success_num);<br>        MAX_SUCCESSNUM = Math.max(MAX_SUCCESSNUM, successNum);<br>    &#125;<br>    <span class="hljs-comment">// 计算比值</span><br>    <span class="hljs-keyword">if</span> (MAX_SUCCESSNUM == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">float</span> bi = getWeight() / MAX_SUCCESSNUM;<br>    <span class="hljs-comment">// 计算得分</span><br>    <span class="hljs-keyword">for</span> (IpModel temp : list) &#123;<br>        <span class="hljs-keyword">if</span> (temp.success_num == <span class="hljs-keyword">null</span> || temp.success_num.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">float</span> successNum = Float.parseFloat(temp.success_num);<br>        temp.grade += (successNum * bi);<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> PlugInManager.SuccessNumPluginNum;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>逻辑不负责，使用的是比较简单的评分算法，找到所有IP的最大成功次数，然后按照自己的成功次数计算出一个比例，在诚意一个固定的值。</p><p>这种算法最神奇的地方就是参数了，没人知道为什么是这个参数，但是它就是可以工作。所以调参是个技术活。</p><p>其他项的评分算法其实是一样的逻辑，就不过多的介绍了，再拿RTT举个例子吧。</p><h4 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ArrayList&lt;IpModel&gt; list)</span> </span>&#123;<br>    <span class="hljs-comment">// 查找到最大速度</span><br>    <span class="hljs-keyword">float</span> MAX_SPEED = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (IpModel temp : list) &#123;<br>        <span class="hljs-keyword">if</span> (temp.rtt == <span class="hljs-keyword">null</span> || temp.rtt.equals(<span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">float</span> finallySpeed = Float.parseFloat(temp.rtt);<br>        MAX_SPEED = Math.max(MAX_SPEED, finallySpeed);<br>    &#125;<br>    <span class="hljs-comment">// 计算比值</span><br>    <span class="hljs-keyword">if</span> (MAX_SPEED == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">float</span> bi = getWeight() / MAX_SPEED;<br>    <span class="hljs-comment">// 计算得分</span><br>    <span class="hljs-keyword">for</span> (IpModel temp : list) &#123;<br>        <span class="hljs-keyword">if</span> (temp.rtt == <span class="hljs-keyword">null</span> || temp.rtt.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">float</span> finallySpeed = Float.parseFloat(temp.rtt);<br>        temp.grade += (getWeight() - (finallySpeed * bi));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> PlugInManager.SpeedTestPluginNum;<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一不同点就是，RTT越小，评分应该越高，所以采用的是减法。</p><h3 id="DNS服务器模块"><a href="#DNS服务器模块" class="headerlink" title="DNS服务器模块"></a>DNS服务器模块</h3><p>我一直以为HttpDns服务器要一个就够用了，没想到真是开了眼界了。这个库里面有4个DNS服务器，其中有一个是本地服务器。</p><h4 id="PodDns"><a href="#PodDns" class="headerlink" title="PodDns"></a>PodDns</h4><p>这个是一个免费的HttpDns。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpDnsPack <span class="hljs-title">requestDns</span><span class="hljs-params">(String domain)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果新浪自家的服务器没有拿到数据，或者数据有问题，则使用 dnspod 提供的接口获取数据</span><br>    String jsonDataStr = <span class="hljs-keyword">null</span>;<br>    HttpDnsPack dnsPack = <span class="hljs-keyword">null</span>;<br><br>    String dnspod_httpdns_api_url = DnsConfig.DNSPOD_SERVER_API + DNSPodCipher.Encryption(domain);<br>    jsonDataStr = netWork.requests(dnspod_httpdns_api_url);<br>    <span class="hljs-keyword">if</span> (jsonDataStr == <span class="hljs-keyword">null</span> || jsonDataStr.equals(<span class="hljs-string">&quot;&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 如果dnspod 也没提取到数据 则返回空</span><br><br>    jsonDataStr = DNSPodCipher.Decryption(jsonDataStr);<br><br>    dnsPack = <span class="hljs-keyword">new</span> HttpDnsPack();<br>    <span class="hljs-keyword">try</span> &#123;<br>        String IP_TTL[] = jsonDataStr.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        String IPArr[] = IP_TTL[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;;&quot;</span>);<br>        String TTL = IP_TTL[<span class="hljs-number">1</span>];<br>        dnsPack.rawResult = jsonDataStr;<br>        dnsPack.domain = domain;<br>        dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress();<br>        dnsPack.device_sp = NetworkManager.getInstance().getSPID() ; <br><br>        dnsPack.dns = <span class="hljs-keyword">new</span> HttpDnsPack.IP[IPArr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; IPArr.length; i++) &#123;<br>            dnsPack.dns[i] = <span class="hljs-keyword">new</span> HttpDnsPack.IP();<br>            dnsPack.dns[i].ip = IPArr[i];<br>            dnsPack.dns[i].ttl = TTL;<br>            dnsPack.dns[i].priority = <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        dnsPack = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dnsPack;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就没啥好说的了，就是按照文档里面的来就好了。值得一提的是，因为这个免费的返回数据里面并没有提供Model里面的各个字段（比自身的HttpDns服务器返回的字段少了一些，所以有些字段需要自己拼一下）。</p><p>比如，设备的ip与运营商。关于运营商还有个小知识点需要说一下：</p><blockquote><p>在客户端内如果是手机网络可以知道网络类型（2G、3G、4G）也可以知道当前SP（移动、联通、电信）.</p><p>如果是Wifi网络环境可以知道SSID，但是无法知道当前SP.</p></blockquote><h4 id="LocalDns"><a href="#LocalDns" class="headerlink" title="LocalDns"></a>LocalDns</h4><p>这个是本地的Dns，使用的是 InetAddress 来获取对应的域名 IP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpDnsPack <span class="hljs-title">requestDns</span><span class="hljs-params">(String domain)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        InetAddress[] addresses = InetAddress.getAllByName(domain);<br>        String[] ipList = <span class="hljs-keyword">new</span> String[addresses.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; addresses.length; i++) &#123;<br>            ipList[i] = addresses[i].getHostAddress();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != ipList &amp;&amp; ipList.length &gt; <span class="hljs-number">0</span>) &#123;<br>            HttpDnsPack dnsPack = <span class="hljs-keyword">new</span> HttpDnsPack();<br>            String IPArr[] = ipList;<br>            String TTL = <span class="hljs-string">&quot;60&quot;</span>;<br>            dnsPack.domain = domain;<br>            dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress();<br>            dnsPack.device_sp = NetworkManager.getInstance().getSPID() ;<br>            dnsPack.rawResult = <span class="hljs-string">&quot;domain:&quot;</span> + domain + <span class="hljs-string">&quot;;\nipArray:&quot;</span>;<br>            dnsPack.dns = <span class="hljs-keyword">new</span> HttpDnsPack.IP[IPArr.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; IPArr.length; i++) &#123;<br>                String ip = IPArr[i];<br>                <span class="hljs-keyword">if</span> (i == IPArr.length - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//去掉最后的逗号</span><br>                    dnsPack.rawResult += (ip);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dnsPack.rawResult += (ip + <span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                dnsPack.dns[i] = <span class="hljs-keyword">new</span> HttpDnsPack.IP();<br>                dnsPack.dns[i].ip = ip;<br>                dnsPack.dns[i].ttl = TTL;<br>                dnsPack.dns[i].priority = <span class="hljs-string">&quot;0&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dnsPack;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个也很简单，就是利用一些信息，在本地自己拼出来一个HttpDnsPack对象。</p><h4 id="SinaHttpDns"><a href="#SinaHttpDns" class="headerlink" title="SinaHttpDns"></a>SinaHttpDns</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpDnsPack <span class="hljs-title">requestDns</span><span class="hljs-params">(String domain)</span> </span>&#123;<br>    String jsonDataStr = <span class="hljs-keyword">null</span>;<br>    HttpDnsPack dnsPack = <span class="hljs-keyword">null</span>;<br>    ArrayList&lt;String&gt; serverApis = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    serverApis.addAll(DnsConfig.SINA_HTTPDNS_SERVER_API);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">null</span> == dnsPack &amp;&amp; serverApis.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            String api = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">int</span> index = serverApis.indexOf(usingServerApi);<br>            <span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) &#123;<br>                api = serverApis.remove(index);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                api = serverApis.remove(<span class="hljs-number">0</span>);<br>            &#125;<br>            String sina_httpdns_api_url = api + domain;<br>            jsonDataStr = netWork.requests(sina_httpdns_api_url);<br>            dnsPack = jsonObj.JsonStrToObj(jsonDataStr);<br>            usingServerApi = api;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            usingServerApi = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dnsPack;<br>&#125;<br></code></pre></td></tr></table></figure><p>自身的服务器，返回的数据直接使用 Json 转对象了，没啥好说的。</p><p>里面的逻辑有做一个循环，是因为它的请求地址有多个，一个不行再试另外一个。</p><h4 id="UdpDns"><a href="#UdpDns" class="headerlink" title="UdpDns"></a>UdpDns</h4><p>这个应该是访问的公共的DNS服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpDnsPack <span class="hljs-title">requestDns</span><span class="hljs-params">(String domain)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        UdpDnsInfo info = UdnDnsClient.query(DnsConfig.UDPDNS_SERVER_API, domain);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != info &amp;&amp; info.ips.length &gt; <span class="hljs-number">0</span>) &#123;<br>            HttpDnsPack dnsPack = <span class="hljs-keyword">new</span> HttpDnsPack();<br>            String IPArr[] = info.ips;<br>            String TTL = String.valueOf(info.ttl);<br>            dnsPack.rawResult = <span class="hljs-string">&quot;domain : &quot;</span> + domain + <span class="hljs-string">&quot;\n&quot;</span> + info.toString();<br>            dnsPack.domain = domain;<br>            dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress();<br>            dnsPack.device_sp = NetworkManager.getInstance().getSPID();<br><br>            dnsPack.dns = <span class="hljs-keyword">new</span> HttpDnsPack.IP[IPArr.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; IPArr.length; i++) &#123;<br>                dnsPack.dns[i] = <span class="hljs-keyword">new</span> HttpDnsPack.IP();<br>                dnsPack.dns[i].ip = IPArr[i];<br>                dnsPack.dns[i].ttl = TTL;<br>                dnsPack.dns[i].priority = <span class="hljs-string">&quot;0&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dnsPack;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一共有4个服务器，他们也是有优先级的，与测速一样，优先级高的跑通了，后面的就不再跑了。</p><p>我们总结一下上面的3个模块：</p><p>DNS模块是获取域名对应的IP地址</p><p>测速模块是对IP地址进行测速</p><p>评分模块是对IP地址的访问状况做评分，选出最好的</p><p>基本上，经过这3个模块后，我们就可以拿到表现最好的IP地址了。但是这还不够，接下来还有几个模块需要介绍。</p><h3 id="缓存模块"><a href="#缓存模块" class="headerlink" title="缓存模块"></a>缓存模块</h3><p>我们从 HttpDns 服务器里面请求下来了那么多数据，而且我们还设置了IP的有效期为一分钟，会不断的更新这些数据，所以将这些数据进行缓存是非常有必要的。</p><p>缓存分为两部分，内存与数据库。</p><p>内存就比较简单，就是一个ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 缓存链表，域名与 DomainModel 的键值对。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> ConcurrentHashMap&lt;String, DomainModel&gt; data = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, DomainModel&gt;(INIT_SIZE, MAX_CACHE_SIZE);<br></code></pre></td></tr></table></figure><p>数据库是分为了三个表：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">db.execSQL(CREATE_DOMAIN_TABLE_SQL)<span class="hljs-comment">;</span><br>db.execSQL(CREATE_IP_TEBLE_SQL)<span class="hljs-comment">;</span><br>db.execSQL(CREATE_CONNECT_FAIL_TABLE_SQL)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>DOMAIN表 是域名。</p><p>IP表 是域名对应的IP集合。</p><p>DOMAIN 与 IP 是关联的。</p><p>CONNECT_FAIL表 是用于上报，这里不分析。</p><p>我们先来看一下数据模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DomainModel</span> </span>&#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自增id &lt;br&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_ID 字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> id = -<span class="hljs-number">1</span> ;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 域名 &lt;br&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_DOMAIN 字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String domain = <span class="hljs-string">&quot;&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 运营商 &lt;br&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_SP 字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String sp = <span class="hljs-string">&quot;&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 域名过期时间 &lt;br&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_TTL 字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String ttl = <span class="hljs-string">&quot;0&quot;</span> ;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 域名最后查询时间 &lt;br&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_TIME 字段 &lt;br&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String time = <span class="hljs-string">&quot;0&quot;</span> ;<br><br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 域名关联的ip数组 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ArrayList&lt;IpModel&gt; ipModelArr = <span class="hljs-keyword">null</span> ; <br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IpModel</span> </span>&#123;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自增id &lt;br&gt;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_ID &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> id = -<span class="hljs-number">1</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * domain id 关联id</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_DOMAIN_ID &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> d_id = -<span class="hljs-number">1</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务器ip地址</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PORT &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String ip = <span class="hljs-string">&quot;&quot;</span> ;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器对应的端口</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PORT &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> port = -<span class="hljs-number">1</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器对应的sp运营商</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_SP &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String sp = <span class="hljs-string">&quot;&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip过期时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_TTL &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String ttl = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器优先级-排序算法策略使用</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PRIORITY &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String priority = <span class="hljs-string">&quot;0&quot;</span> ; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问ip服务器的往返时延</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PRIORITY &#125;&#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String rtt = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器链接产生的成功数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_SUCCESS_NUM &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String success_num = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器链接产生的错误数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_ERR_NUM &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String err_num = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器最后成功链接时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_FINALLY_SUCCESS_TIME &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String finally_success_time = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ip服务器最后失败链接时间</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 该字段映射类 &#123;<span class="hljs-doctag">@link</span> com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_FINALLY_FAIL_TIME &#125;字段 &lt;br&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String finally_fail_time = <span class="hljs-string">&quot;0&quot;</span> ; <br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 评估体系 评分分值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> grade = <span class="hljs-number">0</span> ; <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出。数据库就是储存了这些对象的信息。</p><p>我们看一下缓存对外暴露的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取 domain 缓存</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sp</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> domain</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DomainModel <span class="hljs-title">getDnsCache</span><span class="hljs-params">(String sp, String domain)</span></span>;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入一条缓存记录</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dnsPack</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DomainModel <span class="hljs-title">insertDnsCache</span><span class="hljs-params">(HttpDnsPack dnsPack)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取缓存中全部的 DomainModel数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;DomainModel&gt; <span class="hljs-title">getAllMemoryCache</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这里我只列出了3个，还有很多，但是这3个可以说明缓存的大致作用，就是将服务器请求的数据缓存起来，然后用时可以查找取出。</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>定时器是属于缓存模块的，但是我个人是觉得很重要的，因为只有开了定时器，才会不断的去 HttpDns 服务器中去同步IP地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TimerTask task = <span class="hljs-keyword">new</span> TimerTask() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        timerTaskOldRunTime = System.currentTimeMillis();<br>        <span class="hljs-comment">//无网络情况下不执行任何后台任务操作</span><br>        <span class="hljs-keyword">if</span> (NetworkManager.Util.getNetworkType() == Constants.NETWORK_TYPE_UNCONNECTED || NetworkManager.Util.getNetworkType() == Constants.MOBILE_UNKNOWN) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/************************* 更新过期数据 ********************************/</span><br>        Thread.currentThread().setName(<span class="hljs-string">&quot;HTTP DNS TimerTask&quot;</span>);<br>        <span class="hljs-keyword">final</span> ArrayList&lt;DomainModel&gt; list = dnsCacheManager.getExpireDnsCache();<br>        <span class="hljs-keyword">for</span> (DomainModel model : list) &#123;<br>            checkUpdates(model.domain, <span class="hljs-keyword">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>        <span class="hljs-comment">/************************* 测速逻辑 ********************************/</span><br>        <span class="hljs-keyword">if</span> (now - lastSpeedTime &gt; SpeedtestManager.time_interval - <span class="hljs-number">3</span>) &#123;<br>            lastSpeedTime = now;<br>            RealTimeThreadPool.getInstance().execute(<span class="hljs-keyword">new</span> SpeedTestTask());<br>        &#125;<br><br>        <span class="hljs-comment">/************************* 日志上报相关 ********************************/</span><br>        now = System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (HttpDnsLogManager.LOG_UPLOAD_SWITCH &amp;&amp; now - lastLogTime &gt; HttpDnsLogManager.time_interval) &#123;<br>            lastLogTime = now;<br>            <span class="hljs-comment">// 判断当前是wifi网络才能上传</span><br>            <span class="hljs-keyword">if</span> (NetworkManager.Util.getNetworkType() == Constants.NETWORK_TYPE_WIFI) &#123;<br>                RealTimeThreadPool.getInstance().execute(<span class="hljs-keyword">new</span> LogUpLoadTask());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个任务逻辑很清晰：</p><p>先更新缓存中过期的数据，然后对缓存中所有的IP，重新进行测速。</p><p>这样，一个完整的库就差不多写好了。</p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程007：QUIC协议</title>
    <link href="/2020/06/22/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B007%EF%BC%9AQUIC%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/06/22/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B007%EF%BC%9AQUIC%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>TCP协议在创建连接之前需要进行三次握手：</p><p><img src="http://www.52im.net/data/attachment/forum/201910/31/222033u1b3zwxj1m05cr3g.png" alt="网络编程懒人入门(十)：一泡尿的时间，快速读懂QUIC协议_11111.png"></p><p>如果是传输加密数据的话，还需要建立 TLS 连接，握手次数更多：</p><p><img src="http://www.52im.net/data/attachment/forum/201910/31/201028q2e00d2zsas6ac23.png" alt="网络编程懒人入门(十)：一泡尿的时间，快速读懂QUIC协议_2.png"></p><p>前面我们说过，TCP在网络稳定的情况下性能会比较好，但是在弱网情况下就会暴露出许多问题。</p><h3 id="QUIC协议登场"><a href="#QUIC协议登场" class="headerlink" title="QUIC协议登场"></a>QUIC协议登场</h3><p>QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。</p><p>UDP 协议是无连接协议。它无需在传输层对数据包进行确认，为了确保数据传输的可靠性，应用层协议需要自己完成包传输情况的确认。</p><p>这其实是一种很常见的优化思路：由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。所以采用UDP，然后将TCP的一些特性自己接管过来实现，这样就可以自由选择，甚至根据应用场景自由调整优化。</p><h3 id="QUIC-核心特性"><a href="#QUIC-核心特性" class="headerlink" title="QUIC 核心特性"></a>QUIC 核心特性</h3><h4 id="建立连接需要的-RTT-少"><a href="#建立连接需要的-RTT-少" class="headerlink" title="建立连接需要的 RTT 少"></a>建立连接需要的 RTT 少</h4><blockquote><p>RTT(Round-Trip Time)：往返时延。 是客户端发送数据，到收到回应的时间。</p></blockquote><p><img src="http://www.52im.net/data/attachment/forum/201801/04/113826ga5tuc1hjfcchfj1.jpeg" alt="技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解_1.jpeg"></p><p>TCP协议的RTT主要是多在 TCP的三次握手上。TLS1.3的握手只需要一个 RTT。所以QUIC的握手应该是和1.3差不多的，或者它会直接使用TLS1.3，囧，我也没去细看这些。</p><h4 id="改进的拥塞控制"><a href="#改进的拥塞控制" class="headerlink" title="改进的拥塞控制"></a>改进的拥塞控制</h4><p>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点。</p><h5 id="单调递增的-Packet-Number"><a href="#单调递增的-Packet-Number" class="headerlink" title="单调递增的 Packet Number"></a>单调递增的 Packet Number</h5><p>TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。</p><p>但是这样会导致一个问题：</p><p><img src="http://www.52im.net/data/attachment/forum/201801/04/115848rp2apnj3a3msh3n2.jpeg" alt="技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解_2.jpeg"></p><p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，<strong>这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢</strong>？不好判断！！！</p><blockquote><p>RTT 采样的结果会影响RTO，而 RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</p></blockquote><p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。</p><p><img src="http://www.52im.net/data/attachment/forum/201801/04/115928zw25wvzeneezjinz.jpeg" alt="技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解_3.jpeg"></p><p>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p><h5 id="没有队头阻塞的多路复用"><a href="#没有队头阻塞的多路复用" class="headerlink" title="没有队头阻塞的多路复用"></a>没有队头阻塞的多路复用</h5><p><img src="http://www.52im.net/data/attachment/forum/201801/04/120441vx7hgqphme3qpcqy.jpeg" alt="技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解_12.jpeg"></p><p>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。</p><p>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞。</p><blockquote><p>Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。</p><p>当 Record 大小超过了 MTU 的时候，就会分多个数据包发送。</p></blockquote><p><strong>那 QUIC 多路复用为什么能避免上述问题呢？</strong></p><ul><li>QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞；</li><li>Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。</li></ul><p><img src="http://www.52im.net/data/attachment/forum/201801/04/120556muuvqdaq3aya1d0w.jpeg" alt="技术扫盲：新一代基于UDP的低延时网络传输层协议——QUIC详解_14.jpeg"></p><h5 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h5><p>一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。</p><p>什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。</p><p>比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。</p><p>那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。</p><p>由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。</p><p>还有其他的新特性，暂时就不介绍了。</p><p>最新的HTTP3也是基于QUIC的，所以，是一种趋势。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-1309-1-1.html">http://www.52im.net/thread-1309-1-1.html</a></p><p><a href="http://www.52im.net/thread-2816-1-1.html">http://www.52im.net/thread-2816-1-1.html</a></p><p><a href="https://liudanking.com/network/tls1-3-quic-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%81%9A%E5%88%B0-0-rtt-%E7%9A%84/">https://liudanking.com/network/tls1-3-quic-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%81%9A%E5%88%B0-0-rtt-%E7%9A%84/</a></p><p><a href="http://www.52im.net/thread-515-1-1.html">http://www.52im.net/thread-515-1-1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程007：IP地址与MAC地址</title>
    <link href="/2020/06/18/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B006%EF%BC%9AIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80/"/>
    <url>/2020/06/18/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B006%EF%BC%9AIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>经过前面几篇文章的洗礼，你应该知道IP地址与MAC地址各自的作用。</p><p>我自己的理解就是：IP地址是用来连接子网的，MAC地址是用来处理子网内部的。</p><p>但是这只是比较粗浅的理解，如果有人问到：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">有了<span class="hljs-built_in">IP</span>地址，为何还要用MAC地址？<br>或者，有了MAC地址，为何还要<span class="hljs-built_in">IP</span>地址？<br></code></pre></td></tr></table></figure><p>对于这些问题，你该如何给他解释清楚呢？</p><h4 id="我们先来探讨一下，没有IP地址的情况："><a href="#我们先来探讨一下，没有IP地址的情况：" class="headerlink" title="我们先来探讨一下，没有IP地址的情况："></a>我们先来探讨一下，没有IP地址的情况：</h4><p>一开始时，网络中的机器并不多。大家都连到同一个集线器就可以了，就可以实现互通。这时，机器 A 发消息到机器 B ，消息头里附上机器 B 的MAC，集线器收到消息后就广播给所有连到集线器的机器。</p><p>机器 C 收到消息，发现消息里的 MAC 地址和自己的不一样，就丢弃。机器B发现消息里的 MAC 地址和自己一样，就收到下并解析。</p><p><img src="http://www.52im.net/data/attachment/forum/201811/11/221435zigm2fjme1iiejjm.jpg" alt="网络编程懒人入门(九)：通俗讲解，有了IP地址，为何还要用MAC地址？_1.jpg"></p><p>这样机制带来问题很明显：首先每次广播，给所在网络带来不必要的浪费。所以，就出现了交换机。它能识别消息里的目标 MAC 地址后，直接就消息丢到机器 B 所连接的端口中。另一个角度，<strong>交换机必须记住所有的 MAC 地址和端口之间的关系</strong>。</p><p>这样的机制在网络规规模小的时候是高效的。但是当网络规模扩大到全球的时候，不可能让一台交换机记录下全球这么多的网络设备，也不可能让全球的机器连接到一台交换机上。</p><p>一个交换机无法解决，那么多个交换机可以解决吗？可以解决部分问题，如下图：</p><p><img src="http://www.52im.net/data/attachment/forum/201811/11/221516f7rlwl3l0l6wy072.jpg" alt="网络编程懒人入门(九)：通俗讲解，有了IP地址，为何还要用MAC地址？_2.jpg"></p><p>但是随着网络越来越大，交换机越来越多，那么交换机之间还是只能<strong>采用广播的方式来通信</strong>，显然是不可取的。</p><p>也就是说，当两个网络互接时，MAC 地址 + 交换机还能解决问题广播问题，但是两个以上的网络互连时，MAC 地址 + 交换机就没有办法解决广播问题了。</p><h4 id="我们再来探讨一下，没有MAC地址的情况："><a href="#我们再来探讨一下，没有MAC地址的情况：" class="headerlink" title="我们再来探讨一下，没有MAC地址的情况："></a>我们再来探讨一下，没有MAC地址的情况：</h4><p>我们知道OSI 7层模型，IP、TCP分别对应第三层和四层，因特网协议族并没有覆盖完整的7层 。</p><p>因特网并不存粹，还包括以太网。因为因特网是第三层协议，是没有根基的“空中楼阁”，需要以太网这样的2层网具体落地实施，而MAC地址又是2层概念，所以MAC地址就这样进入了因特网的体系结构。</p><p>当然了，如果因特网从开始制定之初，就定义了从物理层到传输层的协议，那么因特网就不再依赖于其它任何的网络，这个纯粹的因特网就只需要纯粹的IP地址，网线所插上的也不再是以太网卡，而是“因特网卡”，既然没有了以太网，也就不用什么MAC地址了。</p><p>说了历史原因，我们再说一个现实的问题：</p><p>因为 IP 地址是要设备上线以后，才能根据他进入了哪个子网来分配的，在设备还没有 IP 地址的时候（或者分配 IP 地址的过程中），我们还需要用 MAC 地址来区分不同的设备。</p><p>所以说，在现在的这个模型体系下，MAC地址是不能被省去的。</p><h4 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h4><p>ARP（Address Resolution Protocol），即地址解析协议，我们前面的文章说到过，是根据IP地址解析物理地址的一个TCP/IP协议。</p><p>我们通过图解的方式来深入了解ARP攻击是如何实现的。</p><p><img src="https://pic4.zhimg.com/80/v2-816508f970cea1daf14f0610569c53db_720w.jpg" alt="img"></p><p>在这个局域网里面，PC1、PC2、PC3三台主机共同连接到交换机SW1上面，对应3个接口port1/2/3。假设PC3这台主机安装了ARP攻击软件或遭受ARP病毒，成为这个网络的攻击者（hacker），接下来，PC3是如何攻击的？先不急，先来回顾下PC1和PC2是如何通信的。</p><p><img src="https://pic1.zhimg.com/80/v2-6522b0e3e1b7e7058152e70953428c74_720w.jpg" alt="img"></p><p>我们来看看PC3（Hacker）是如何发起ARP攻击的=&gt;</p><p><img src="https://pic1.zhimg.com/80/v2-383f86e253b689d40ff20d648ce7afac_720w.jpg" alt="img"></p><p>正常情况下，若收到的ARP请求不是给自己的，则直接丢弃；而这里PC3（Hacker）在监听之后，发起了ARP回应包：<strong>我就是PC2（IP2-MAC3）</strong>。</p><p>从拓扑可以出现，PC3明明是IP3对应MAC3，很显然这就是一个ARP欺骗行为。于此同时，PC2正常的ARP回应包也交到了PC1手中，我们来看PC1接下来如何处理的：</p><p><img src="https://pic2.zhimg.com/80/v2-d234cb3ec99e072f16c7000358284641_720w.jpg" alt="img"></p><p>PC1收到两个ARP回应包，内容分别如下：</p><p>③我是PC2，我的IP地址是<strong>IP2</strong>，我的MAC地址是<strong>MAC2</strong>；</p><p>③我是PC2，我的IP地址是<strong>IP2</strong>，我的MAC地址是<strong>MAC3</strong>；</p><p>PC1一脸懵：<strong>咋回事？还有这操作？不管了，我选最新的！（后到优先）</strong></p><p>那么问题来了，上面两个ARP回应包到底哪个先到哪个后到呢？</p><p>作为初学者，可能还在纠结前后这种naive的问题；而作为hacker，只要持续不停发出ARP欺骗包，就一定能够覆盖掉正常的ARP回应包。<strong>稳健的ARP嗅探/渗透工具，能在短时间内高并发做网络扫描（例如1秒钟成千上百的数据包），能够持续对外发送欺骗包。</strong></p><p>无论如何，当PC1和PC2这种”小白”用户遇到PC3（hacker）时，最终的结果一定是这样的：</p><p><img src="https://pic2.zhimg.com/80/v2-f898793fd3a4f37272dfc31d2ecbaa55_720w.jpg" alt="img"></p><p>其实就是，不断和发送 ARP 回复包，包里面的是自己的 MAC 地址，这样，后续的通信内容就会发送到自己的PC上。</p><p>就是利用 IP -&gt; MAC 的漏洞。</p><p>这个漏洞被IPV6堵上了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.zhihu.com/question/21546408">https://www.zhihu.com/question/21546408</a></p><p><a href="http://www.52im.net/thread-2067-1-1.html">http://www.52im.net/thread-2067-1-1.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/28818627">https://zhuanlan.zhihu.com/p/28818627</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程005：实现基于TCP的长连接</title>
    <link href="/2020/06/17/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B005%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <url>/2020/06/17/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B005%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="Socket-的基本用法"><a href="#Socket-的基本用法" class="headerlink" title="Socket 的基本用法"></a>Socket 的基本用法</h3><p>Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。</p><p>先看服务端的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>Socket client = serverSocket.accept();<br>InputStream in = client.getInputStream();<br>OutputStream out = client.getOutputStream();<br><span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-comment">// 将客户端发送过来的数据原封不动的发送回去</span><br><span class="hljs-keyword">while</span> ((n = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>    out.write(buffer, <span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>再看客户端的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket socket = <span class="hljs-keyword">new</span> Socket(host, port);<br><span class="hljs-comment">// 发送数据</span><br>OutputStream out = socket.getOutputStream();<br><span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span> ((n = System.in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>    out.write(buffer, <span class="hljs-number">0</span>, n);<br>&#125;<br><span class="hljs-comment">// 读取响应</span><br>Thread readerThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    InputStream in = socket.getInputStream();<br>                    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-keyword">int</span> n;<br>                    <span class="hljs-keyword">while</span> ((n = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                        System.out.write(buffer, <span class="hljs-number">0</span>, n);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>readerThread.start();<br></code></pre></td></tr></table></figure><p>这里客户端的既要发送数据，又要展示接收到的响应数据，所以开了一个线程来处理。</p><h3 id="Socket-与-ServerSocket"><a href="#Socket-与-ServerSocket" class="headerlink" title="Socket 与 ServerSocket"></a>Socket 与 ServerSocket</h3><p>先说 ServerSocket，我们在 IDE 里面查看一下它的构造方法，发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getImpl().bind(epoint.getAddress(), epoint.getPort());<br>getImpl().listen(backlog);<br></code></pre></td></tr></table></figure><p>它实际上是调用了 bind 与 listen 这两个方法。</p><p>而 getImpl 是返回的一个成员变量，你可以理解为它是将 SocketImpl 对象给包装了一下，提供给我们使用。</p><p>所以，一切最终走的是 SocketImpl 的方法。</p><p>同样的，Socket 也是包装的 SocketImpl 的一些方法，所以我们可以理解为 Socket 与 ServerSocket 都是一个包装类，简化了 SocketImpl 的使用。</p><p>还有一点需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Socket client = serverSocket.accept();<br></code></pre></td></tr></table></figure><p>这行代码创建了一个新的 Socket。我们的 ServerSocket 包装的 Socket 是用来做监听的，它不处理别的事，所以每次有连接到来都会创建一个新的返回。</p><p>所以实际上，连接成功之后，会产生3个 Socket。</p><p>关于accept创建的这个 socket，还有一个很有意思的地方。它的端口号跟 ServerSocket 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。</p><p>Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 (source_ip, source_port, destination_ip, destination_port) 这个四元组：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 服务器的IP<br><span class="hljs-bullet">2.</span> 服务器的Port<br><span class="hljs-bullet">3.</span> 客户端的IP<br><span class="hljs-bullet">4.</span> 客户端的Port<br><br>假设，我们的 ServerSocket 长这样：&lt;<span class="hljs-emphasis">*:*</span>, <span class="hljs-emphasis">*:9877&gt;。</span><br><span class="hljs-emphasis">accept 返回的 Socket 则是这样：&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;，xxxx 是客户端的端口号。</span><br><span class="hljs-emphasis">如果是客户端要发起连接，这时候只有 &lt;*</span>:<span class="hljs-emphasis">*, *</span>:9877&gt; 会匹配成功。<br>如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。<br></code></pre></td></tr></table></figure><h3 id="实现长连接"><a href="#实现长连接" class="headerlink" title="实现长连接"></a>实现长连接</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">socket.setKeepAlive(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>我们要实现一个 socket 的长连接，只需要这一个调用即可。Socket 的这个 keep alive 选项如果打开并且两个小时内没有通信，那么底层会发一个心跳，看看对方是不是还活着。</p><p><strong>注意：</strong>两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。</p><p>我们自己实现长连接，实际上就是隔一段时间发送一个数据包：就是不断地给对方写数据，然后读取对方的数据，也就是所谓的<strong>心跳</strong>。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。</p><p>这里有一个简单的例子：<a href="https://github.com/Jekton/Echo">https://github.com/Jekton/Echo</a></p><p>我们来分析一下这个例子是如何做的：</p><blockquote><p>首先，Socket 自带的方法肯定是无法满足我们的要求的，那么只能对 Socket 进行增强。</p><p>这里我们使用包装类来完成这个功能。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeepAliveSocket</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Socket mSocket;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们一样的建立连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;<br>    Socket socket = <span class="hljs-keyword">new</span> Socket(mHost, mPort);<br>    mSocket = socket;<br>    <span class="hljs-comment">// 每次创建新的 socket，会开一个线程来读数据</span><br>    Thread reader = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ReaderTask(socket), <span class="hljs-string">&quot;socket-reader&quot;</span>);<br>    reader.start();<br>    <span class="hljs-comment">// 发送心跳包</span><br>    mWriterHandler.post(mHeartBeatTask);<br>&#125;<br></code></pre></td></tr></table></figure><p>连接建立起来之后，我们会开启一个线程去读取回应。</p><p>这里发送心跳包是通过 HandlerThread 来做的，所以也是运行在一个线程里面，所以需要考虑同步问题，为了理清逻辑，这里省去同步代码。</p><p>我们看看是如何发送心跳包的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable mHeartBeatTask = <span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] mHeartBeat = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        ++mSeqNumHeartBeatSent;<br>        <span class="hljs-comment">// 我们使用长度为 0 的数据作为 heart beat</span><br>        write(mHeartBeat, <span class="hljs-keyword">new</span> WritingCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次</span><br>                mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS);<br>                <span class="hljs-comment">// At this point, the heart-beat might be received and handled</span><br>                <span class="hljs-keyword">if</span> (mSeqNumHeartBeatRecv &lt; mSeqNumHeartBeatSent) &#123;<br>                    <span class="hljs-comment">// 没收到服务端的回应，超时判断</span><br>                    mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS);<br>                    <span class="hljs-comment">// double check</span><br>                    <span class="hljs-keyword">if</span> (mSeqNumHeartBeatRecv == mSeqNumHeartBeatSent) &#123;<br>                        mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFail</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是发送了一个空的数据过去，然后客户端还记录了心跳包的编号。</p><p>这里是一个常见的循环代码，就不多说了。里面处理了心跳包超时等情况。</p><p>我们再看看心跳包编号的相关代码，上面说到我们单独开了一个线程去读取响应：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readResponse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// For simplicity, assume that a msg will not exceed 1024-byte</span><br>    <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>    InputStream inputStream = mSocket.getInputStream();<br>    DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(inputStream);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> nbyte = in.readInt();<br>        <span class="hljs-keyword">if</span> (nbyte == <span class="hljs-number">0</span>) &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;readResponse: heart beat received&quot;</span>);<br>            mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);<br>            mSeqNumHeartBeatRecv = mSeqNumHeartBeatSent;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nbyte &gt; buffer.length) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Receive message with len &quot;</span> + nbyte +<br>                                            <span class="hljs-string">&quot; which exceeds limit &quot;</span> + buffer.length);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (readn(in, buffer, nbyte) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Socket might be closed twice but it does no harm</span><br>            silentlyClose(mSocket);<br>            <span class="hljs-comment">// Socket will be re-connected by writer-thread if you want</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        mDataCallback.onData(buffer, <span class="hljs-number">0</span>, nbyte);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到对心跳包和其他数据做了一定程度的区分，如果是心跳包，则更新收到的编号，如果是数据会触发回调。</p><p>对于心跳包的处理考虑这样的一种情况，假设服务端没有对心跳包做出回应，那么 mHeartBeatTask 就会进入心跳超时的逻辑代码中，如果在超时之前服务器回应了，那么当作啥都没有发生，如果在超时时间内没有回应，就会进入到 mHeartBeatTimeoutTask。</p><p>此时会关闭 Socket：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable mHeartBeatTimeoutTask = () -&gt; &#123;<br>    Log.e(TAG, <span class="hljs-string">&quot;mHeartBeatTimeoutTask#run: heart beat timeout&quot;</span>);<br>    closeSocket();<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然这只是一个例子，所以就做了最直接的处理。实际上不会这么做的。</p><p>这个例子的主要内容就是这些了，有兴趣了下载下来自己运行一下看看。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-1722-1-1.html">http://www.52im.net/thread-1722-1-1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程003：TCP与UDP</title>
    <link href="/2020/06/16/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B003%EF%BC%9ATCP%E4%B8%8EUDP/"/>
    <url>/2020/06/16/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B003%EF%BC%9ATCP%E4%B8%8EUDP/</url>
    
    <content type="html"><![CDATA[<h3 id="建立链接的差异"><a href="#建立链接的差异" class="headerlink" title="建立链接的差异"></a>建立链接的差异</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP是面向链接的，也就是我们通常说的三次握手。</p><p><img src="http://www.52im.net/data/attachment/forum/201710/27/110528h9iiyaqrryaijdgi.jpg" alt="网络编程懒人入门(四)：快速理解TCP和UDP的差异_1915184-43e91a9185faa031.jpg"></p><p>这里有张图描述的有点蛋疼，大致看没问题，仔细看为题很多。我刚开始看到这张图的时候，对图里面的 ACK 值感到疑惑。</p><p>因为我发现了有两个 ack，一个大写，一个小写，他们的意义是不同的：</p><p>具体的解释可以看这里：<a href="https://blog.csdn.net/baiyan3212/article/details/81302448">https://blog.csdn.net/baiyan3212/article/details/81302448</a></p><p>上图中的 ACK 应该表示的是“确认编号”。</p><blockquote><p>一个是确认值(Acknowledgement)，为1便是确认连接。<br>另一个是确认编号(Acknowledgement Number)。</p></blockquote><p>还有一个问题，有的发送过程只写了 ACK，没有写 seq，难道是侧重点不同？？？我哪里没get到吗？？？</p><p>好的，我们仔细分析这个图，可以看出其实三次握手的主要目的是：</p><ul><li>通知对方，自己发送包的初始编号。</li></ul><p><strong>所以三次握手的次序是这样子的：</strong></p><ol><li>client端首先发送一个SYN包告诉Server端我的初始序列号是X；</li><li>Server端收到SYN包后回复给client一个ACK确认包，告诉client说我收到了；</li><li>接着Server端也需要告诉client端自己的初始序列号，于是Server也发送一个SYN包告诉client我的初始序列号是Y；</li><li>Client收到后，回复Server一个ACK确认包说我知道了。</li></ol><p>其中的 2 、3 步骤可以简化为一步，也就是说将 ACK 确认包和 SYN 序列化包一同发送给 Client 端。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP 压根不会建立什么连接。UDP 只需要知道对方的 ip 地址，将数据报一份一份的发送过去就可以了，其他的作为发送方，都不需要关心。</p><h3 id="数据发送方式的差异"><a href="#数据发送方式的差异" class="headerlink" title="数据发送方式的差异"></a>数据发送方式的差异</h3><p>差异主要体验在对数据包大小的限制上：</p><ul><li><strong>TCP：</strong><br>由于 TCP 是建立在两端连接之上的协议，所以理论上发送的数据流不存在大小的限制。但是由于缓冲区有大小限制，所以你如果用 TCP 发送一段很大的数据，可能会截断成好几段，接收方依次的接收。</li><li><strong>UDP：</strong><br>由于 UDP 本身发送的就是一份一份的数据报，所以自然而然的就有一个上限的大小。</li></ul><p>我们知道，当一个数据包超过了以太网数据帧的大小时，IP层会将数据进行分片，这对于TCP来说，没什么问题，应为它有重传与确认机制。但是UDP没有这个机制，假设一个数据包分为了 10 片，那么就需要传输10次，而只要其中某一个片丢失了，那么UDP会弃掉整个数据包，影响范围就变大了。所以最好我们使用UDP的时候，一个数据包不要超过这里的限制。</p><p>有关UDP协议的最大包长限制，详见《<a href="http://www.52im.net/thread-29-1-1.html">UDP中一个包的大小最大能多大？</a>》</p><h3 id="有序性的差异"><a href="#有序性的差异" class="headerlink" title="有序性的差异"></a>有序性的差异</h3><p>TCP有序，UDP无序。</p><h3 id="可靠性的差异"><a href="#可靠性的差异" class="headerlink" title="可靠性的差异"></a>可靠性的差异</h3><p>TCP可靠，UDP不可靠。</p><p><strong>研究下，什么情况会导致 UDP 丢包：</strong></p><ul><li><strong>数据报分片重组丢失：</strong>在文章之前我们就说过，UDP 的每个数据报大小多少最合适，事实上 UDP 协议本身规定的大小是 64kb，但是在数据链路层有 MTU 的限制，大小大概在 5kb（这些数据dou），所以当你发送一个很大的 UDP 包的时候，这个包会在 IP 层进行分片，然后重组。这个过程就有可能导致分片的包丢失。UDP 本身有 CRC 检测机制，会抛弃掉丢失的 UDP 包；</li><li><strong>UDP 缓冲区填满：</strong>当 UDP 的缓冲区已经被填满的时候，接收方还没有处理这部分的 UDP 数据报，这个时候再过来的数据报就没有地方可以存了，自然就都被丢弃了。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>先来说 UDP 的吧，有很多人都会觉得 UDP 与 TCP 相比，在性能速度上是占优势的。因为 UDP 并不用保持一个持续的连接，也不需要对收发包进行确认。但事实上经过这么多年的发展 TCP 已经拥有足够多的算法和优化，在网络状态不错的情况下，TCP 的整体性能是优于 UDP 的。</p><p><strong>那在什么时候我们非用 UDP 不可呢？</strong></p><ul><li><p><strong>对实时性要求高：</strong>比如实时会议，实时视频这种情况下，如果使用 TCP，当网络不好发生重传时，画面肯定会有延时，甚至越堆越多。如果使用 UDP 的话，即使偶尔丢了几个包，但是也不会影响什么，这种情况下使用 UDP 比较好；</p><blockquote><p>对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有 sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p></blockquote></li><li><p><strong>流媒体：</strong>采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。</p></li><li><p><strong>多点通信：</strong>TCP 需要保持一个长连接，那么在涉及多点通讯的时候，肯定需要和多个通信节点建立其双向连接，然后有时在NAT环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，而 UDP 可以无需保持连接，直接发就可以了，所以成本会很低，而且穿透性好。这种情况下使用 UDP 也是没错的。</p></li></ul><p>以上我们说了 UDP 的使用场景，在此之外的其他情况，使用 TCP 准没错。</p><p><strong>毕竟有一句话嘛：</strong></p><blockquote><p>when in doubt，use TCP。</p></blockquote><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-29-1-1.html">http://www.52im.net/thread-29-1-1.html</a></p><p><a href="http://www.52im.net/thread-1160-1-1.html">http://www.52im.net/thread-1160-1-1.html</a></p><p><a href="http://www.52im.net/thread-1277-1-1.html">http://www.52im.net/thread-1277-1-1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程004：理解HTTP协议</title>
    <link href="/2020/06/16/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B004%EF%BC%9A%E7%90%86%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/06/16/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B004%EF%BC%9A%E7%90%86%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.52im.net/data/attachment/forum/201806/15/144336adhfhh6ao1dfj9hj.jpeg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpeg"></p><h3 id="HTTP的工作过程"><a href="#HTTP的工作过程" class="headerlink" title="HTTP的工作过程"></a>HTTP的工作过程</h3><p><strong>HTTP请求响应模型：</strong></p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/150222j96nx292xu7nwz87.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.jpg"></p><p><strong>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</strong></p><ol><li>建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</li><li>客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：GET/sample/hello.jsp HTTP/1.1；</li><li>客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</li><li>服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： HTTP/1.1 200 OK<br>响应的第一部分是协议的版本号和响应状态码；</li><li>服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</li><li>服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</li><li>服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ol><h3 id="HTTP协议基础"><a href="#HTTP协议基础" class="headerlink" title="HTTP协议基础"></a>HTTP协议基础</h3><h4 id="HTTP协议是不保存状态的"><a href="#HTTP协议是不保存状态的" class="headerlink" title="HTTP协议是不保存状态的"></a>HTTP协议是不保存状态的</h4><p>不保存状态为了更快地处理大量事务。</p><p>但是现在我们的很多业务都需要对通信状态进行保存。Cookie技术随之而来。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>服务端发送一个 Set-Cookie 首部字段，客户端就会保存 Cookie。</p><p>客户端后续的请求会在请求报文中带上 Cookie 值。</p><p>服务端会处理该 Cookie，用于辨别客户端的身份，做处理。</p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/150708wk6wefkkxs8gzwpq.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.jpg"></p><h4 id="持久链接与管线化"><a href="#持久链接与管线化" class="headerlink" title="持久链接与管线化"></a>持久链接与管线化</h4><p> 最开始的 HTTP 协议，每次请求都会创建一个新的 TCP 连接，请求完成之后会断开 TCP 连接。如果一个页面里面有很多图片，就会浪费资源。</p><p>持久连接就是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</p><p>管线化就是在持久连接的基础上进一步提升请求响应时间：之前的 HTTP 请求都是串行的，一个请求接着一个响应，使用管线化之后可以一次发送多个 HTTP 请求（可以理解为批量 HTTP 请求），这样就不用等前一个请求返回响应了下一个才能开始。</p><p>注意管线化的请求发送顺序与响应顺序是一致的，不会乱序，这样就会出现一些问题，嗯，了解一下就行了。</p><h4 id="一些常见头部字段"><a href="#一些常见头部字段" class="headerlink" title="一些常见头部字段"></a>一些常见头部字段</h4><h5 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h5><p><img src="http://www.52im.net/data/attachment/forum/201806/15/162745p1cm8xqa6aczttvq.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.png"></p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/162757l6llgpk844ht4wjt.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.png"></p><p>Last-Modified：资源的最后修改日期。</p><blockquote><p> Last-Modified 是由服务器往客户端发送的 HTTP 头，另一个 If-Modified-Since是由客户端往服务器发送的头。</p><p>再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了。</p></blockquote><p>ETag：资源的标识，可以当成id来理解。它的作用与 Last-Modified 一样，但是它可以解决 Last-Modified 无法解决的一些问题。</p><blockquote><p>ETag 是由服务器往客户端发送的 HTTP 头，另一个 If-None-Match 是由客户端往服务器发送的头。</p><p>1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;</p><p>2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)</p><p>3、某些服务器不能精确的得到文件的最后修改时间；</p></blockquote><h5 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">GET  /bigfile.html  HTTP/1.1<br>Host: [url=<span class="hljs-link">http://www.sample.com]www.sample.com</span>[<span class="hljs-string">/url</span>]<br>Range: bytes=20224-<br>···<br></code></pre></td></tr></table></figure><p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。</p><p>有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，<strong>那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过</strong>。</p><h4 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h4><p>就是使用压缩技术对报文主体进行压缩，然后再进行传输。</p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/160444jrcu77utb4fg1733.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.png"></p><p>压缩的是上图左边的主体部分。</p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/160922rjfhtzvhqdrt3vt1.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpg"></p><h4 id="传输编码-分块编码"><a href="#传输编码-分块编码" class="headerlink" title="传输编码-分块编码"></a>传输编码-分块编码</h4><p>使用传输编码是为了改变报文中的数据在网络上传输的方式。</p><p>拿分块编码来举例：</p><p>当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。</p><p>分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号。</p><p><img src="http://www.52im.net/data/attachment/forum/201806/15/161011bzsn1hzlt3nxgp3h.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png"></p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><img src="http://www.52im.net/data/attachment/forum/201806/15/162822u9kop17v57v7v1kw.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png"></p><p>将 HTTP 流量转换成其他的协议。</p><h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p><img src="http://www.52im.net/data/attachment/forum/201806/15/162831nzz7vototoi1zoww.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.png"></p><p>HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p><p>上面这句话，我第一看到是一脸懵逼了，我查了一些资料，总算了解一点了。</p><p>我们先了解一下什么是 HTTP 代理服务器。</p><p>在一次请求中，客户端（浏览器）明文的请求代理服务器。代理服务器明文去请求远端服务器（网站），拿到返回结果，再将返回结果返回给客户端。代理服务器可以看到请求中的任何东西。</p><p>那么你可以想一下，如果是 HTTPS 请求会怎么样呢？</p><p>如果我们想在复用现有的HTTP proxy的传输方式来代理HTTPS流量，那么就会变成浏览器和代理握手跑TLS，代理拿到明文的请求报文，代理和网站握手跑TLS。但是代理没有，也不可能有网站的私钥证书，所以这么做会导致浏览器和代理之间的TLS无法建立，证书校验根本通不过。HTTP tunnel解决了这个问题，代理服务器不再作为中间人，不再改写浏览器的请求，而是把浏览器和远端服务器之间通信的数据原样透传，这样浏览器就可以直接和远端服务器进行TLS握手并传输加密的数据。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-1677-1-1.html">http://www.52im.net/thread-1677-1-1.html</a></p><p><a href="https://www.cnblogs.com/flysnow-z/archive/2012/08/17/2644420.html">https://www.cnblogs.com/flysnow-z/archive/2012/08/17/2644420.html</a></p><p><a href="https://www.zhihu.com/question/21955083">https://www.zhihu.com/question/21955083</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程002：快速理解TCP协议</title>
    <link href="/2020/06/15/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B002%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/06/15/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B002%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.52im.net/data/attachment/forum/201710/12/154924b4p49zqhrrr3rlj5.jpg" alt="网络编程懒人入门(三)：快速理解TCP协议一篇就够_72539919.jpg"></p><p>以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><p>IP 协议实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。</p><p>TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。</p><h3 id="TCP数据包的大小"><a href="#TCP数据包的大小" class="headerlink" title="TCP数据包的大小"></a>TCP数据包的大小</h3><p><img src="http://www.52im.net/data/attachment/forum/201710/12/152505inpkwuqxkqn5dpsn.jpg" alt="网络编程懒人入门(三)：快速理解TCP协议一篇就够_7.jpg"></p><p>以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。</p><p>这些字节里面包含了很多头，所以真正的数据大约为 1400 字节。所以我们的 HTTP 请求可能会分为多个数据包来发送。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><h3 id="TCP数据包的编号"><a href="#TCP数据包的编号" class="headerlink" title="TCP数据包的编号"></a>TCP数据包的编号</h3><p>我们常听说TCP的三次握手，但是这三次握手是干嘛呢？</p><p>我们发送一个1M的文件，必然要分成很多个数据包发送，其中如果有丢包，那么怎么知道是丢了哪个包呢？</p><p>其实是在发送的时候，TCP 协议为每个包编号了。</p><p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。</p><p>而由于TCP是两端都可以发送数据的，所以三次握手的情况大致如下：</p><table><thead><tr><th>序号</th><th>方向</th><th>seq</th><th>ack</th></tr></thead><tbody><tr><td>1</td><td>A-&gt;B</td><td>10000（随机数）</td><td>0</td></tr><tr><td>2</td><td>B-&gt;A</td><td>20000（随机数）</td><td>10000+1=10001</td></tr><tr><td>3</td><td>A-&gt;B</td><td>10001</td><td>20000+1=20001</td></tr></tbody></table><p><strong>确认序号（ack）</strong>应当是上次已成功收到数据字节序号加1，它的作用是告知发送端的数据接受成功，期望下一个包的字节为此序号。</p><p><strong>字节序号（seq）</strong>是上次已成功收到的确认序号，它的作用就是发送接收端期望的下一个包的数据。</p><p>在三次握手的过程中，ACK是直接加一了，但是在正式通信的时候，会不一样：</p><table><thead><tr><th>序号</th><th>方向</th><th>seq</th><th>ack</th><th>数据长度</th><th>数据包长度</th></tr></thead><tbody><tr><td>23</td><td>A-&gt;B</td><td>40000</td><td>70000</td><td>1460</td><td>1514</td></tr><tr><td>24</td><td>B-&gt;A</td><td>70000</td><td>40000+1514-54=41460</td><td>0</td><td>54</td></tr><tr><td>25</td><td>A-&gt;B</td><td>41460</td><td>70000+54-54=70000</td><td>1460</td><td>1514</td></tr><tr><td>26</td><td>B-&gt;A</td><td>70000</td><td>41460+1514-54=42920</td><td>0</td><td>54</td></tr></tbody></table><p>可以看到这里的 ACK 是加上了数据包的数据的长度。你可以理解为，握手的时候只发送了一个字节的数据。</p><p>四次挥手的过程与握手类似，就不多说了。</p><p>另外提一下，在三次握手的过程中，还有一个叫做 SYN 的标识，它标识希望建立链接，所以只有开始两次会有这个标识。同样的在四次握手会有 FIN 标识，标识希望断开链接。</p><h3 id="数据包的遗失处理"><a href="#数据包的遗失处理" class="headerlink" title="数据包的遗失处理"></a>数据包的遗失处理</h3><p>每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。</p><blockquote><p>举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。</p></blockquote><p>如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-1107-1-1.html">http://www.52im.net/thread-1107-1-1.html</a></p><p><a href="https://blog.csdn.net/huaishu/article/details/93739446">https://blog.csdn.net/huaishu/article/details/93739446</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程001:快速理解网络通信协议</title>
    <link href="/2020/06/14/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B001%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/06/14/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B001%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="互联网的五层模型"><a href="#互联网的五层模型" class="headerlink" title="互联网的五层模型"></a>互联网的五层模型</h3><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150735oly7l6bu5cffff7h.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_1.jpg"></p><h3 id="层与协议"><a href="#层与协议" class="headerlink" title="层与协议"></a>层与协议</h3><p><strong>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守的规则，就叫做”协议”（protocol）。</strong></p><h3 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h3><p>通过网线传输的数据都是 0 和 1，但是单纯的 0 与 1 并没有意义，没法被解读，传输再多又有个鬼用。</p><p>“链接层”的功能：确定了0和1的分组方式。</p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150929cw8a20dzzlonkene.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_3.jpg"></p><p>“标头”包含数据包的一些说明项，比如<strong>发送者、接受者、数据类型</strong>等等；”标头”的长度，固定为18字节。</p><p>“数据”则是数据包的具体内容。”数据”的长度，最短为46字节，最长为1500字节。</p><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><p>以太网数据包的”标头”中的发送者和接受者需要使用 MAC 地址来标识。</p><p>每块网卡出厂的时候，<strong>都有一个全世界独一无二的MAC地址</strong>，长度是48个二进制位，通常用12个十六进制数表示。</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150918zzkluk96tufsl3bs.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_5.jpg"></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>以太网使用“广播”的方式向<strong>本网络内</strong>的所有计算机发送数据包，让计算机自己判断是不是接收方！！！</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150935p07k2g2y6y7k74e0.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_6.jpg"></p><p>这里还有一个问题：通常我们发送只需要一个 ip 地址和端口就行了，那么我们是没法知道接受方的 MAC 地址的啊，那么帧数据该怎么构建呢？</p><p><strong>这里又可以分成两种情况：</strong></p><ul><li><strong>1）第一种情况：</strong>如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理；所以对方的MAC地址这一栏，填的是网关的 MAC 地址（网关是在同一个子网，使用ARP得到MAC地址）。</li><li><strong>2）第二种情况：</strong>如果两台主机在同一个子网络，那么我们可以用<strong>ARP</strong>协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>使用广播传递数据包会有问题：</p><blockquote><p> 广播只能在子网生效，如果不这样设计，将会引发广播风暴！一台上海的电脑能与一台纽约的电脑在同一个子网吗，显然是不可能的！</p></blockquote><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。</p><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p><strong>IPv4这个版本规定，网络地址由32个二进制位组成：</strong></p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150947elp4lvaiiesuvlyu.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_8.jpg"></p><p>地址分为两部分，前面一部分为网络，后面一部分为主机。但是我们没法知道前面几位是网络，有肯能是24位，有可能是28位。所以我们需要子网掩码来判断。</p><blockquote><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p></blockquote><p>最终，我们只需要将子网掩码与IP地址做位与运算，结果相等就是在子网内。</p><h4 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h4><p><strong>IP数据包也分为”标头”和”数据”两个部分：</strong></p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/150954xykms5d9vscynnsz.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_9.jpg"></p><p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样：</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/151007ibebhdrudjqof1qp.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_10.jpg"></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>我们的电脑中有多个程序，那么传输过来的数据应该给哪个程序使用呢？需要<strong>端口</strong>来标识。</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p><strong>UDP数据包，也是由”标头”和”数据”两部分组成：</strong></p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/151048jboz0nm3kommnbim.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_11.jpg"></p><p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分：</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/151011eysfi272f6nveevs.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_12.jpg"></p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/151016iaeia7apeacny25l.jpg" alt="网络编程懒人入门(一)：快速理解网络通信协议（上篇）_13.jpg"></p><h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p>计算机开机后，会自动分配到一个IP地址。每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p><img src="http://www.52im.net/data/attachment/forum/201811/01/153032wppxuuvdmupaqiy6.jpg" alt="网络编程懒人入门(二)：快速理解网络通信协议（下篇）_5.jpg"></p><ul><li><strong>1）最前面的”以太网标头”：</strong>设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</li><li><strong>2）后面的”IP标头”：</strong>设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</li><li><strong>3）最后的”UDP标头”：</strong>设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</li></ul><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.52im.net/thread-1095-1-1.html">http://www.52im.net/thread-1095-1-1.html</a></p><p><a href="http://www.52im.net/thread-1103-1-1.html">http://www.52im.net/thread-1103-1-1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Protobuf 通信协议详解</title>
    <link href="/2020/06/14/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/Protobuf%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/06/14/blog_bak/Blog/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/Protobuf%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Protobuf-通信协议详解"><a href="#Protobuf-通信协议详解" class="headerlink" title="Protobuf 通信协议详解"></a>Protobuf 通信协议详解</h2><p>在移动互联网时代，手机流量、电量是最为有限的资源，而移动端的即时通讯应用无疑必须得直面这两点。</p><p>解决流量过大的基本方法就是<strong>使用高度压缩的通信协议</strong>，而数据压缩后流量减小带来的自然结果也就是省电：因为大数据量的传输必然需要更久的网络操作、数据序列化及反序列化操作，这些都是电量消耗过快的根源。</p><p>当前即时通讯应用中最热门的通信协议无疑就是Google的Protobuf了。本文将详细介绍Protobuf的使用、原理等。</p><h3 id="protobuf-简介"><a href="#protobuf-简介" class="headerlink" title="protobuf 简介"></a>protobuf 简介</h3><p>github地址：<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。</p><p>看了这些介绍，可能你和我一样刚开始都是一脸懵逼，不过不要紧，我们写一个小例子来帮助我们理解。</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><h4 id="安装-Google-Protocol-Buffer"><a href="#安装-Google-Protocol-Buffer" class="headerlink" title="安装 Google Protocol Buffer"></a>安装 Google Protocol Buffer</h4><p>首先，我们去Github地址，里面有  Protobuf 的源码，你可以 clone 下来自己编译。当然，Google 也提供已经编译好了的程序供我们直接使用。这里就不说如何自己编译了，有兴趣的搜索一下。我们直接去 release 页面，下载对应平台的编译器，我的是  windows 系统，所以我选择下载 protoc-3.12.3-win64.zip 文件。</p><p>下载完成之后，打开，里面有如下文件：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">bin</span><br><span class="ruby"></span>-<span class="ruby"><span class="hljs-keyword">include</span></span><br><span class="ruby"></span>-<span class="ruby">readme.txt</span><br></code></pre></td></tr></table></figure><p>bin 里面就是存放的编译器了，专门编译 .proto 文件，类似于 javac。</p><p>include 里面是 Google 提供的一些标准 proto 文件，你可以把它当作 sample 看待。</p><p>这里，我们只需要使用 bin 里面的 protoc.exe 程序。你可以把它放到一个特定的目录，然后添加到 path，因为之后需要在 terminal 中使用，或者你直接拷贝到你的工程目录下。</p><h4 id="关于例子的简单描述"><a href="#关于例子的简单描述" class="headerlink" title="关于例子的简单描述"></a>关于例子的简单描述</h4><p>这里我是用 java 来写这个简单的程序，程序分为两部份，一个 Writer，一个 Reader。</p><p>Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。</p><p>准备用于演示的结构化数据是 HelloWorld，它包含两个基本数据：</p><ul><li>ID，为一个整数类型的数据</li><li>Str，这是一个字符串</li></ul><h4 id="写-proto-文件"><a href="#写-proto-文件" class="headerlink" title="写 .proto 文件"></a>写 .proto 文件</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">//文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。</span><br><br><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.aprz.proto&quot;</span>; <span class="hljs-comment">// 生成的类的包名</span><br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;HelloWorldProto&quot;</span>; <span class="hljs-comment">// 生成的外部类的名字，该文件定义的消息体都是这个类的内部类</span><br><br><span class="hljs-comment">// 如果我们使用 java，这个消息体的类名就是：com.aprz.proto.HelloWorldProto.HelloWord</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-built_in">int32</span> number = <span class="hljs-number">1</span>; <span class="hljs-comment">// proto3 不用写 required 修饰符了</span><br>    <span class="hljs-built_in">string</span> text = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloWorld2</span> </span>&#123;<br>    <span class="hljs-built_in">float</span> money = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">string</span> text = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面的 option 只针对 java 才生效。</p><p>在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。</p><h4 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 .proto 文件"></a>编译 .proto 文件</h4><p>这个就很简单了，会 javac 的肯定会这个。</p><p>假设您的 proto 文件存放在 $SRC_DIR 下面，您也想把生成的文件放在同一个目录下，则可以使用如下命令：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">protoc -I=<span class="hljs-variable">$SRC_DIR</span> --java_out=<span class="hljs-variable">$DST_DIR</span> addressbook.<span class="hljs-keyword">proto</span><br><br>-I 后面是 <span class="hljs-keyword">proto</span> 文件所在目录<br>--java_out 后面是生成的 java 文件存放的地址<br>最后是 <span class="hljs-keyword">proto</span> 文件名称 <br></code></pre></td></tr></table></figure><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>执行编译命令之后，发现生成了 HelloWorldProto.java 文件，但是却有很多地方报错，这里因为该类里面引用到了很多 protobuf 库里面的类，所以我们需要在工程里面导入该依赖库。</p><p>这里，我导入的是 ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">com</span>.google.protobuf:protobuf-java:<span class="hljs-number">3</span>.<span class="hljs-number">12</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>导入完成后，发现类中没有了错误。有兴趣的可以自己看一下生成的消息类，由于生成的消息类的代码太多（一个600多行），所以这里就不贴代码了。</p><h4 id="编写-Writer-与-Reader"><a href="#编写-Writer-与-Reader" class="headerlink" title="编写 Writer 与 Reader"></a>编写 Writer 与 Reader</h4><p>在编写 Writer 与 Reader 之前，我们先看看如何使用生成的消息体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder()<br>    .setNumber(<span class="hljs-number">10</span>)<br>    .setText(<span class="hljs-string">&quot;123&quot;</span>)<br>    .build();<br></code></pre></td></tr></table></figure><p>可以看到，protobuf 为我们定义的每一个消息体都生成了一个 builder 类，所以使用起来是很方便的。</p><p>编写 Writer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File dst = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;protobuf-text&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(dst));<br>    helloWorld.writeTo(bos);<br>    bos.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的类提供了 writeTo 方法，可以直接写进输出流，当然你也可以自己做处理，里面有很多方法可以使用。</p><p>编写 Reader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">File tar = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;protobuf-text&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    HelloWorldProto.HelloWorld helloWorld1 = HelloWorldProto.HelloWorld.parseFrom(<span class="hljs-keyword">new</span> FileInputStream(tar));<br>    System.out.println(helloWorld1.getNumber());<br>    System.out.println(helloWorld1.getText());<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>直接从输入流中解析出 java 对象，也很方便。其实这就是一个反序列化的过程，将二进制流转成一个对象的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> tag = input.readTag();<br><span class="hljs-keyword">switch</span> (tag) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        done = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: &#123;<br><br>        number_ = input.readInt32();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: &#123;<br>        java.lang.String s = input.readStringRequireUtf8();<br><br>        text_ = s;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-keyword">if</span> (!parseUnknownField(<br>            input, unknownFields, extensionRegistry, tag)) &#123;<br>            done = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这段代码应该可以看出一点东西，不过这里面涉及到 protobuf 序列化的规则，后面会介绍到。</p><p>这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 socket，那么就可以实现基于网络的数据交换任务。而存储和交换正是 Protobuf 最有效的应用领域。</p><h3 id="Protobuf-的优点"><a href="#Protobuf-的优点" class="headerlink" title="Protobuf 的优点"></a>Protobuf 的优点</h3><p>Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p><p>它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。</p><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><h3 id="Protobuf-的不足"><a href="#Protobuf-的不足" class="headerlink" title="Protobuf 的不足"></a>Protobuf 的不足</h3><p>Protbuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。</p><p>XML 已经成为多种行业标准的编写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h3 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（import）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import <span class="hljs-string">&quot;myproject/other_protos.proto&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h4><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchResponse</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Result</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> url = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">string</span> title = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// repeated 在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）,一般对应数组或者List</span><br>    <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> snippets = <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>同 XML 相比， Protobuf 的主要优点在于性能高。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。</p><p>对于这样的说法，严格的程序员需要一个解释。因此在本文的最后，让我们稍微深入 Protobuf 的内部实现吧。</p><p>有两项技术保证了采用 Protobuf 的程序能获得相对于 XML 极大的性能提高。</p><p>第一点，我们可以考察 Protobuf 序列化后的信息内容。您可以看到 Protocol Buffer 信息的表示非常紧凑，这意味着消息的体积减少，自然需要更少的资源。比如网络上传输的字节数更少，需要的 IO 更少等，从而提高性能。</p><p>第二点我们需要理解 Protobuf 封解包的大致过程，从而理解为什么会比 XML 快很多。</p><h4 id="Google-Protocol-Buffer-的-Encoding"><a href="#Google-Protocol-Buffer-的-Encoding" class="headerlink" title="Google Protocol Buffer 的 Encoding"></a>Google Protocol Buffer 的 Encoding</h4><p>Protobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。</p><p>考察消息结构之前，让我首先要介绍一个叫做 Varint 的术语。</p><p>Varint 说的通俗一点，就是“<strong>变长</strong>”。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。（那么问个问题，让你设计一个变长类型，你如何设计？？？）</p><p>比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。</p><p>变长类型还是挺常见的，比如描述 dex 的结构里面，就会有很多类型都是变长的，为了节省空间。</p><p>Varint 中的<strong>每个 byte 的最高位</strong> bit 有特殊的含义，<strong>如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束</strong>。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1010 1100</span> <span class="hljs-number">0000 0010</span><br>我们用计算器看一下 <span class="hljs-number">300</span> 的二进制表示：‭<br><span class="hljs-number">0001 0010</span> <span class="hljs-number">1100</span>‬ -&gt; <br><span class="hljs-number">0000010</span> <span class="hljs-number">0101100</span> -&gt; <br><span class="hljs-number">00000010</span> <span class="hljs-number">10101100</span> -&gt; <br><span class="hljs-number">10101100</span> <span class="hljs-number">00000010</span><br></code></pre></td></tr></table></figure><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image006.jpg" alt="图 6. Varint 编码"></p><p>看这张图应该会比较好理解，它将300的二进制表示分成了两段（7 bit 为一段，不足的补0），由于Google Protocol Buffer 字节序采用 little-endian 的表示方式，所以需要将字节倒过来看。</p><p>消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 Key-Value 对。如下图所示：</p><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image007.jpg" alt="图 7. Message Buffer"></p><p>采用这种 Key-Pair 结构<strong>无需使用分隔符来分割不同的 Field</strong>。对于可选的 Field，如果消息中不存在该 field，那么在最终的 Message Buffer 中就没有该 field，这些特性都有助于节约消息本身的大小。</p><p>假设我们的消息体中有两个字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-built_in">int32</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">string</span> text = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 number 的 key 为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(field_number &lt;&lt; <span class="hljs-number">3</span>) | wire_type<br></code></pre></td></tr></table></figure><p>field_number 就是我们定义的数字标识符了，这里 number 的为 1。 那么 wire_type 是什么呢？wire_type 需要查表才能得到：</p><table><thead><tr><th><strong>Type</strong></th><th><strong>Meaning</strong></th><th><strong>Used For</strong></th></tr></thead><tbody><tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Length-delimi</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>Start group</td><td>Groups (deprecated)</td></tr><tr><td>4</td><td>End group</td><td>Groups (deprecated)</td></tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>可以看到 int32 的 wire_type 为 0 。</p><p>所以 number 的 key 为 (1 &lt;&lt; 3 | 0) = 8，text 的 key 为 （2 &lt;&lt; 3 | 2） = 18，这两个数是不是有点熟悉，是的！就是上面生成的代码里面，我们见过的。那部分代码其实就是反序列话，根据 key 读取 value，然后给创建的对象赋值。</p><p>看到这里，你是不是觉得变长类型就已经很吊了呢？那么我有一个问题，表示正数 1 可以只需要一个字节，那么表示负数 -1，需要几个字节呢？</p><p>我们看一下 -1 的二进制代码：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">‭<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span><br></code></pre></td></tr></table></figure><p>一共有32位，这显然没法用一个字节表示，需要 5 个字节，那怎么办呢？</p><p>为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。</p><p>Zigzag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词的含义了。</p><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image008.jpg" alt="图 8. ZigZag 编码"></p><p>使用 zigzag 编码，绝对值小的数字，无论正负都可以采用较少的 byte 来表示，充分利用了 Varint 这种技术。</p><p>我们运行程序来看一下是不是这样吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder()<br>    .setNumber(<span class="hljs-number">10</span>)<br>    .setText(<span class="hljs-string">&quot;1123&quot;</span>).build();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : helloWorld.toByteArray()) &#123;<br>    System.out.println(b + <span class="hljs-string">&quot; = &quot;</span> + Integer.toBinaryString((b &amp; <span class="hljs-number">0xFF</span>) + <span class="hljs-number">0x100</span>).substring(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>看一下输出的结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span>= <span class="hljs-number">00001000</span> // number 的 <span class="hljs-keyword">key</span><br><span class="hljs-symbol">10 </span>= <span class="hljs-number">00001010</span> // number 的 value<br><span class="hljs-symbol">18 </span>= <span class="hljs-number">00010010</span> // text 的 <span class="hljs-keyword">key</span><br><span class="hljs-symbol">4 </span>= <span class="hljs-number">00000100</span>  // text 的 value 的长度<br><span class="hljs-symbol">49 </span>= <span class="hljs-number">00110001</span> // <span class="hljs-number">1</span><br><span class="hljs-symbol">49 </span>= <span class="hljs-number">00110001</span> // <span class="hljs-number">1</span><br><span class="hljs-symbol">50 </span>= <span class="hljs-number">00110010</span> // <span class="hljs-number">2</span><br><span class="hljs-symbol">51 </span>= <span class="hljs-number">00110011</span> // <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这里需要知道的一点是<strong>：字符串等则采用类似数据库中的 varchar 的表示方法</strong>，即用一个 varint 表示长度，然后将其余部分紧跟在这个长度部分之后即可。</p><p>text 的 value 是 4 个长度，每个字节可以查 ascii 码得到。这里的编码不太清楚，可能是 utf8。</p><p>我们设置一个负数来看看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder()<br>    .setNumber(-<span class="hljs-number">1</span>)<br>    .setText(<span class="hljs-string">&quot;李&quot;</span>).build();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> b : helloWorld.toByteArray()) &#123;<br>    System.out.println(b + <span class="hljs-string">&quot; = &quot;</span> + Integer.toBinaryString((b &amp; <span class="hljs-number">0xFF</span>) + <span class="hljs-number">0x100</span>).substring(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">8</span> = <span class="hljs-number">00001000</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">-1</span> = <span class="hljs-number">11111111</span><br><span class="hljs-attr">1</span> = <span class="hljs-number">00000001</span><br><span class="hljs-attr">18</span> = <span class="hljs-number">00010010</span><br><span class="hljs-attr">3</span> = <span class="hljs-number">00000011</span><br><span class="hljs-attr">-26</span> = <span class="hljs-number">11100110</span><br><span class="hljs-attr">-99</span> = <span class="hljs-number">10011101</span><br><span class="hljs-attr">-114</span> = <span class="hljs-number">10001110</span><br></code></pre></td></tr></table></figure><p>可以看到，-1 的表示非常的长，用了 10 个字节。那么问题就来了，我们不是声明的 int32 吗，为啥实际上是 int64，还有王法吗，还有法律吗！！！</p><p>我查了些资料：</p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding">https://developers.google.com/protocol-buffers/docs/encoding</a></p><blockquote><p> If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long – it is, effectively, treated like a very large unsigned integer.</p></blockquote><p>这个我是没想到为啥要这样搞！！！</p><p>我们改一下 proto 中消息体的定义，使用 sint32 重新生成一下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">===== Byte 开始 =====</span><br>8 = 00001000<br>1 = 00000001<br>18 = 00010010<br>1 = 00000001<br>49 = 00110001<br><span class="hljs-section">===== Byte 结束 =====</span><br></code></pre></td></tr></table></figure><p>看到，生成的二进制是短了很多。</p><p>那么为啥这个就能生成的短些呢？难道 number 字段在源代码里面不是 int 吗？我们可以分析源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number_; <span class="hljs-comment">// 是 int 类型没变</span><br><br><span class="hljs-comment">// 但是它序列化与反序列化的时候使用的是不同的方法</span><br>output.writeSInt32(<span class="hljs-number">1</span>, number_);<br>number_ = input.readSInt32();<br></code></pre></td></tr></table></figure><p>更细节的部分，可以自行查看。</p><h3 id="封解包的速度"><a href="#封解包的速度" class="headerlink" title="封解包的速度"></a>封解包的速度</h3><p>首先我们来了解一下 XML 的封解包过程。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</p><p>反观 Protobuf，它只需要简单地将一个二进制序列，按照指定的格式读取到 Java 对应的结构类型中就可以了。从上一节的描述可以看到消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。</p><p>述可以看到消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。</p><p>为了说明这并不是我拍脑袋随意想出来的说法，下面让我们简单分析一下 Protobuf 解包的代码流程吧。</p><p>以代码清单 3 中的 Reader 为例，该程序首先调用 msg1 的 ParseFromIstream 方法，这个方法解析从文件读入的二进制数据流，并将解析出来的数据赋予 helloworld 类的相应数据成员。</p><p>该过程可以用下图表示：</p><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/image009.jpg" alt="图 9. 解包流程图"></p><p>整个解析过程需要 Protobuf 本身的框架代码和由 Protobuf 编译器生成的代码共同完成。Protobuf 提供了基类 Message 以及 Message_lite 作为通用的 Framework，，CodedInputStream 类，WireFormatLite 类等提供了对二进制数据的 decode 功能，从 5.1 节的分析来看，Protobuf 的解码可以通过几个简单的数学运算完成，无需复杂的词法语法分析，因此 ReadTag() 等方法都非常快。 在这个调用路径上的其他类和方法都非常简单，感兴趣的读者可以自行阅读。 相对于 XML 的解析过程，以上的流程图实在是非常简单吧？这也就是 Protobuf 效率高的第二个原因了。</p><h3 id="编解码性能测试"><a href="#编解码性能测试" class="headerlink" title="编解码性能测试"></a>编解码性能测试</h3><p>建议看看这篇文章，有从各个方面对比。</p><p>得出的结论是，protobuf <strong>在整形与浮点型</strong> 编解码方面具有很大的优势。但是在<strong>字符串与对象</strong>的编解码方面性能不如 <a href="https://github.com/ngs-doo/dsl-json">DSL-JSON</a>。</p><p><a href="http://www.52im.net/thread-772-1-1.html">http://www.52im.net/thread-772-1-1.html</a></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.csdn.net/u011518120/article/details/54604615">http://blog.csdn.net/u011518120/article/details/54604615</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/overview">https://developers.google.com/protocol-buffers/docs/overview</a></p><p><a href="https://www.jianshu.com/p/bb3ac7e5834e">https://www.jianshu.com/p/bb3ac7e5834e</a></p>]]></content>
    
    
    <categories>
      
      <category>网络优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本地广播</title>
    <link href="/2020/04/20/blog_bak/Blog/Android/%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD/"/>
    <url>/2020/04/20/blog_bak/Blog/Android/%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD/</url>
    
    <content type="html"><![CDATA[<p>在没有看本地广播的源码之前，我一直以为本地广播是借用了Broadcast实现的，它也会走进程间通信。但是看完之后，我发现完全不是这样的，它其实就是一个简单的观察者模式而已。</p><p>我们先来看本地广播的好处：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">1. 发送的广播只会在自己<span class="hljs-keyword">App</span>内传播，不会泄露给其他<span class="hljs-keyword">App</span>，确保隐私数据不会泄露<br>2. 其他<span class="hljs-keyword">App</span>也无法向你的<span class="hljs-keyword">App</span>发送该广播，不用担心其他<span class="hljs-keyword">App</span>会来搞破坏比系统全局广播更加高效<br></code></pre></td></tr></table></figure><p>这肯定是必然的，因为它就是一个观察者模式，和我们自己写的是没有什么实质上的区别的，不能支持进程间通信，肯定别的APP收不到我们发的广播，我们也收不到别的APP的广播。</p><p>关于本地广播的这个名字，我其实很想吐槽，因为这个名字给人的感觉就是广播的阉割版，会误让人以为是系统做了什么处理，才会有上面的好处。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-comment">// 订阅</span><br>lbm.registerReceiver(<span class="hljs-keyword">new</span> BroadcastReceiver() &#123;  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;  <br>        <span class="hljs-comment">// TODO Handle the received local broadcast  </span><br>        &#125;  <br>    &#125;, <span class="hljs-keyword">new</span> IntentFilter(LOCAL_ACTION));  <br><br><span class="hljs-comment">// 发布</span><br>lbm.sendBroadcast(<span class="hljs-keyword">new</span> Intent(LOCAL_ACTION));  <br></code></pre></td></tr></table></figure><p>上面就是本地广播的使用了。接下来，我们正式进入源码环节。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalBroadcastManager <span class="hljs-title">getInstance</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) &#123;<br>            mInstance = <span class="hljs-keyword">new</span> LocalBroadcastManager(context.getApplicationContext());<br>        &#125;<br>        <span class="hljs-keyword">return</span> mInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地广播是一个单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerReceiver</span><span class="hljs-params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (mReceivers) &#123;<br>        ReceiverRecord entry = <span class="hljs-keyword">new</span> ReceiverRecord(filter, receiver);<br>        <span class="hljs-comment">//从映射表取得receiver对应的IntentFilter</span><br>        ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);<br>        <span class="hljs-comment">//如果没有找到，就添加这个映射</span><br>        <span class="hljs-keyword">if</span> (filters == <span class="hljs-keyword">null</span>) &#123;<br>            filters = <span class="hljs-keyword">new</span> ArrayList&lt;IntentFilter&gt;(<span class="hljs-number">1</span>);<br>            mReceivers.put(receiver, filters);<br>        &#125;<br>        filters.add(filter);<br>        <span class="hljs-comment">//遍历filter,保存action到mActions中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;filter.countActions(); i++) &#123;<br>            String action = filter.getAction(i);<br>            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);<br>            <span class="hljs-keyword">if</span> (entries == <span class="hljs-keyword">null</span>) &#123;<br>                entries = <span class="hljs-keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="hljs-number">1</span>);<br>                mActions.put(action, entries);<br>            &#125;<br>            entries.add(entry);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们分析一下订阅的逻辑。</p><ul><li>首先将 receiver 与 filter 封装成为一个 ReceiverRecord。</li><li>我们知道一个 action 也能会对应多个广播接收者，所以 mReceivers 肯定是 <code>HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt;</code> 这样的。</li><li>我们知道一个广播接收者也可能会对应多个 action，所以 mActions 肯定是 <code>HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt;</code> 这样的。</li></ul><p>所以，这个方法的作用，其实就是在建立 IntentFilter 与 BroadcastReceiver 的相互映射关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendBroadcast</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (mReceivers) &#123;<br>        <span class="hljs-keyword">final</span> String action = intent.getAction();<br>        <span class="hljs-keyword">final</span> String type = intent.resolveTypeIfNeeded(<br>            mAppContext.getContentResolver());<br>        <span class="hljs-keyword">final</span> Uri data = intent.getData();<br>        <span class="hljs-keyword">final</span> String scheme = intent.getScheme();<br>        <span class="hljs-keyword">final</span> Set&lt;String&gt; categories = intent.getCategories();<br><br>        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());<br>        <span class="hljs-keyword">if</span> (entries != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (debug) Log.v(TAG, <span class="hljs-string">&quot;Action list: &quot;</span> + entries);<br><br>            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;entries.size(); i++) &#123;<br>                ReceiverRecord receiver = entries.get(i);<br>                <span class="hljs-comment">// 省略代码</span><br><br>                <span class="hljs-keyword">int</span> match = receiver.filter.match(action, type, scheme, data,<br>                                                  categories, <span class="hljs-string">&quot;LocalBroadcastManager&quot;</span>);<br>                <span class="hljs-keyword">if</span> (match &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (debug) Log.v(TAG, <span class="hljs-string">&quot;  Filter matched!  match=0x&quot;</span> +<br>                                     Integer.toHexString(match));<br>                    <span class="hljs-keyword">if</span> (receivers == <span class="hljs-keyword">null</span>) &#123;<br>                        receivers = <span class="hljs-keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();<br>                    &#125;<br>                    receivers.add(receiver);<br>                    receiver.broadcasting = <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//省略代码</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (receivers != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;receivers.size(); i++) &#123;<br>                    receivers.get(i).broadcasting = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                mPendingBroadcasts.add(<span class="hljs-keyword">new</span> BroadcastRecord(intent, receivers));<br>                <span class="hljs-keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;<br>                    <span class="hljs-comment">// 核心代码</span><br>                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然，sendBroadcast 方法有点长，但是大致的逻辑就是根据 intent 找到所有需要接受的 receivers，然后将他们添加到 mPendingBroadcasts 中，最后发送一个消息，让 handler 去处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LocalBroadcastManager</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    mAppContext = context;<br>    mHandler = <span class="hljs-keyword">new</span> Handler(context.getMainLooper()) &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:<br>                    executePendingBroadcasts();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 handler 直接调用了 executePendingBroadcasts 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executePendingBroadcasts</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        BroadcastRecord[] brs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (mReceivers) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mPendingBroadcasts.size();<br>            <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            brs = <span class="hljs-keyword">new</span> BroadcastRecord[N];<br>            mPendingBroadcasts.toArray(brs);<br>            mPendingBroadcasts.clear();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;brs.length; i++) &#123;<br>            BroadcastRecord br = brs[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;br.receivers.size(); j++) &#123;<br>                br.receivers.get(j).receiver.onReceive(mAppContext, br.intent);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>逻辑还是很简单的，直接调用了 onReceive 方法，这样订阅者就可以接收到了。</p><p>LocalBroadcastManager 的核心实现实际上还是Handler，只是利用到了IntentFilter的match功能，至于BroadcastReceiver换成其他接口也无所谓，顺便利用了现成的类和概念而已。</p><p>而且还需要注意，因为使用的是主线程的 Looper，所以不要在接收者里面搞事情。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap的扩容原理(基于JDK1.8)</title>
    <link href="/2020/04/11/blog_bak/Blog/Java/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/11/blog_bak/Blog/Java/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="寻找储存的位置"><a href="#寻找储存的位置" class="headerlink" title="寻找储存的位置"></a>寻找储存的位置</h2><p>将一个键值对放到HashMap里面的时候，需要计算这个键值对存放到哪个位置，该位置的计算方式如下：</p><ul><li><p>计算 key 的 hashCode</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 key 的 hashCode 方法来计算</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span><br>    <span class="hljs-comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>根据容量大小与key的hashCode来算出位置</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里 i 就是计算出来的位置，hash 就是上面 hash() 函数返回的值。</span><br>i = (n - <span class="hljs-number">1</span>) &amp; hash<br></code></pre></td></tr></table></figure></li></ul><p><strong>代码解析：</strong><br>因为 n 始终是2的幂次方，所以结果就是 hash &amp; （二进制位数全部为1的数），效果就相当于截取hash的最后几位，如果n=32，那么就是截取最后5位。</p><p>唯一的疑问就是为什么要将 key 的 hashCode 异或自己的高16位？其实计算hashCode的那段代码叫“<strong>扰动函数</strong>”。那它有什么作用呢？</p><p>假设我们没有这段代码，直接使用 key 的 hashCode 来计算 table 中的位置，由于 key 可以是任意对象，这里再次假设它是一个自定义的对象，并且它的 hashCode 方法实现的非常糟糕，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i &lt;&lt; <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出来，无论i的值是多少，计算出来的 hashCode 的值，它的低 4 位全是 0 。那么使用这个 hashCode 去计算 table 的位置会发生什么呢？我们先认为这个HashMap 的容量是默认的 16，那么使用上面的 hashCode 计算出来的结果就全部是 0，所有的数据都会放在同一个位置，那么散列表就变成了链表。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/hashmap/find_pos.png?raw=true"></p><p>可以看到，无论 hashCode 的高位是多少，&amp; 计算出来的结果，全都是0，所以就会导致非常高的碰撞几率。</p><p>其实，这都由于只取了散列值的最后几位引起的，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p><p>那么为了减少这种情况，扰动函数的作用就出来了，就是让 hashCode 的每一位都参与的计算中去，使用异或的方式，让结果保留一点高位的影子，这样它的低位值就是随机的了，即使 key 的 hashCode 实现的很糟糕。</p><h2 id="2次方与扩容"><a href="#2次方与扩容" class="headerlink" title="2次方与扩容"></a>2次方与扩容</h2><ul><li><p><strong>为什么HashMap的容量要设计成2的幂次方呢？</strong><br>  默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么HashMap会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16)</p><p>  因为HashMap的底层结构是数组，要将key的hashCode映射到这个数组中，最方便的办法就是取余，用<code>hashCode % 容量大小</code>就ok了。将容量设计为2的幂次方时，计算位置时，<code>(n-1)&amp;hash 相当于 hash%n</code>，而计算机里面位运算是基本运算，位运算的效率是远远高于取余%运算的。这是第一个考虑，还有一个好处，后面再说。</p></li><li><p><strong>容量初始化算法</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 右移1位，第一个为1的位的后面的位也变成了1，就有了两个连续的1</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 因为有两个为1的位，所以右移2位，将那两个连续的1扩展为4个连续的1</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 扩展为 8 位</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 扩展为 16 位</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 扩展为 32 位，正所谓星星之火可以燎原。</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这里其实是很简单的一个思想：<strong>对于一个数字的二进制，从第一个不为0的位开始，把后面的所有位都设置成1</strong>。比如说一个数为1000,0000,0000，它的变化过程如下：</p>  <figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console">1000,0000,0000<br>1100,0000,0000<br>1111,0000,0000<br>1111,1111,0000<br>1111,1111,1111<br></code></pre></td></tr></table></figure><p>  <img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/hashmap/cap_init.png?raw=true"></p></li><li><p>扩容的小技巧</p><p>  扩容每次都是在原来的基础上变为2倍，这个比较简单，需要注意的是一个叫做<strong>负载因子</strong>的东西。HashMap扩容时，并不是装满容量了之后才扩容，而是有一个阈值：<code>容量的大小 * 负载因子</code>。那么负载因子的取值会有什么影响呢？</p><p>  <img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/hashmap/loadfactor.jpg?raw=true" alt="从网上copy过来的一个图"></p><p>  上面说了这么多，都不是我们的目标，我们这次的目的是探究一下，每一个entry里面的元素是扩容之后是如何分配的？这要从hash碰撞说起。</p><p>  无论Hash函数设计的多么精妙，总免不了hash碰撞，所以HashMap的结构才是数组加上链表加上红黑树，我们现在探究的就是如果一个entry是链表的时候，这个entry里面的数据是如何分配到扩容之后的HashMap中的。</p><p>  看看源码的算法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    ...<br>    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>    Node&lt;K,V&gt; next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        next = e.next;<br>        <span class="hljs-comment">// 注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap)</span><br>        <span class="hljs-comment">// (e.hash &amp; oldCap) 得到的是元素的在数组中的位置是否需要移动</span><br>        <span class="hljs-comment">// 这里是一个非常巧妙的地方，计算位置用的是 e.hash &amp; oldCap -1</span><br>        <span class="hljs-comment">// oldCap -1 的二进制位全部位1，比如32：1,1111，有5位</span><br>        <span class="hljs-comment">// oldCap 的二进制位只有第一位为1，后面的全部为0，比如32：10,0000，有6位</span><br>        <span class="hljs-comment">// 所以利用高出来的一位来计算新数组中的位置（这样就可以认为是随机分散的）</span><br>        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// 高位为0，则位置不变</span><br>    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>        loTail.next = <span class="hljs-keyword">null</span>;<br>        newTab[j] = loHead;<br>    &#125;<br>    <span class="hljs-comment">// 高位为1，则位置变化</span><br>    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>        hiTail.next = <span class="hljs-keyword">null</span>;<br>        newTab[j + oldCap] = hiHead;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这是JDK1.8的算法，e就是entry的头节点。可以看出来，它将原来的一个链表分成了两个链表loHead与hiHead，分割的条件就是<code>(e.hash &amp; oldCap) == 0</code>，e的hash其实就是上面分析的hash函数的值。因为代码中给了详尽的注释，所以这里不在赘述这行代码的意思。</p><p>  容量为2的幂次方的第二个好处在<code>newTab[j + oldCap] = hiHead;</code>这行代码里面体现了出来，计算新的位置时，只需要在原来的基础上加上oldCap就行了。由于新分配的空间是原来的2倍，所以有一般还没有利用起来，这个时候，随机的（因为不知道hash值的高位是0还是1，所以可以认为是随机的）将原来的entry分为2个，一个放在原位置，一个放在新分配的位置，就完美的分散了原来的数据，并且将新的空间利用了起来。</p><p>  上图说话：<br>  <img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/hashmap/resize.png?raw=true"></p></li></ul><h2 id="初始化时，强烈建议给定容量大小"><a href="#初始化时，强烈建议给定容量大小" class="headerlink" title="初始化时，强烈建议给定容量大小"></a>初始化时，强烈建议给定容量大小</h2><ul><li><p>这个容量如何确定呢？<br>在《阿里巴巴Java开发手册》有以下建议：<br>initialCapacity = (需要储存的元素个数 / 负载因子) + 1。负载因子默认是0.75，如果实在是无法确定大小，可以给出默认值16。</p></li><li><p>为何需要给定大小？<br>是因为如果需要put的数据非常多，而默认值是16的话，就需要进行很多次扩容操作，而扩容操作需要先申请新的内存，将原数据copy过去，再分配，比较耗时。</p></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://blog.csdn.net/carson_ho/article/details/79373134">https://blog.csdn.net/carson_ho/article/details/79373134</a></li><li><a href="https://www.zhihu.com/question/20733617">https://www.zhihu.com/question/20733617</a></li><li><a href="http://www.hollischuang.com/archives/2431">http://www.hollischuang.com/archives/2431</a></li><li><a href="https://blog.csdn.net/u013494765/article/details/77837338">https://blog.csdn.net/u013494765/article/details/77837338</a></li><li><a href="https://blog.csdn.net/witsmakemen/article/details/78820410">https://blog.csdn.net/witsmakemen/article/details/78820410</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedHashMap与LruCache</title>
    <link href="/2020/04/11/blog_bak/Blog/Java/LinkedHashMap%E4%B8%8ELruCache/"/>
    <url>/2020/04/11/blog_bak/Blog/Java/LinkedHashMap%E4%B8%8ELruCache/</url>
    
    <content type="html"><![CDATA[<h2 id="与HashMap的关系"><a href="#与HashMap的关系" class="headerlink" title="与HashMap的关系"></a>与HashMap的关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java?linenums">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="accessOrder-字段"><a href="#accessOrder-字段" class="headerlink" title="accessOrder 字段"></a>accessOrder 字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java?linenums">/**<br> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;<br> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.<br> *<br> * @serial<br> */<br>final boolean accessOrder;<br></code></pre></td></tr></table></figure><p>当这个字段为true的时候，迭代器的顺序是按照访问的顺序来输出的，为false的时候，是按照插入的顺序来输出的。</p><p>看几个例子：</p><ul><li><p><strong>当使用默认的构造函数，accessOrder为false</strong></p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java?linenums">public static void main(String[] args) &#123;<br>        LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;Integer, Integer&gt;();<br>        for (int i = 0; i &lt; 10; i++) &#123;//按顺序放入0~9<br>            map.put(i, i);<br>        &#125;<br>        System.out.println(&quot;原数据：&quot;+map.toString());<br>        map.get(3);<br>        System.out.println(&quot;查询存在的某一个：&quot;+map.toString());<br>        map.put(4, 4);<br>        System.out.println(&quot;插入已存在的某一个：&quot;+map.toString()); //直接调用已存在的toString方法，不然自己需要用迭代器实现<br>        map.put(10, 10);<br>        System.out.println(&quot;插入一个原本没存在的：&quot;+map.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>  <strong>输出</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console?linenums">//  输出结果<br>//  原数据：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;<br>//  查询存在的某一个：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;<br>//  插入已存在的某一个：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;<br>//  插入一个原本没存在的：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9, 10=10&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用带参数的构造函数</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedHashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(<span class="hljs-number">20</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<span class="hljs-comment">//按顺序放入1~9</span><br>        map.put(i, i);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;原数据：&quot;</span>+map.toString());<br>    map.get(<span class="hljs-number">3</span>);<br>    System.out.println(<span class="hljs-string">&quot;查询存在的某一个：&quot;</span>+map.toString());<br>    map.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br>    System.out.println(<span class="hljs-string">&quot;插入已存在的某一个：&quot;</span>+map.toString()); <span class="hljs-comment">//直接调用已存在的toString方法，不然自己需要用迭代器实现</span><br>    map.put(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>    System.out.println(<span class="hljs-string">&quot;插入一个原本没存在的：&quot;</span>+map.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>输出</strong>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  输出结果</span><br><span class="hljs-comment">//  原数据：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;</span><br><span class="hljs-comment">//  查询存在的某一个：&#123;0=0, 1=1, 2=2, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3&#125;，被访问（get）的3放到了最后面</span><br><span class="hljs-comment">//  插入已存在的某一个：&#123;0=0, 1=1, 2=2, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3, 4=4&#125;，被访问（put）的4放到了最后面</span><br><span class="hljs-comment">//  插入一个原本没存在的：&#123;0=0, 1=1, 2=2, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3, 4=4, 10=10&#125;，新增一个放到最后面</span><br></code></pre></td></tr></table></figure></li></ul><p>迭代顺序正如注释所说。那么为何会这样呢？让我们慢慢来揭开LinkedHashMap神秘的面纱。</p><h2 id="头尾指针"><a href="#头尾指针" class="headerlink" title="头尾指针"></a>头尾指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java?linenums">/**<br> * The head (eldest) of the doubly linked list.<br> */<br>transient LinkedHashMapEntry&lt;K,V&gt; head;<br><br>/**<br> * The tail (youngest) of the doubly linked list.<br> */<br>transient LinkedHashMapEntry&lt;K,V&gt; tail;<br></code></pre></td></tr></table></figure><p>head是双链表的头节点，tail自然是双链表的尾节点。那么这两个变量有什么用呢？他们与accesOrder有啥关系？</p><p>我们先来分析，上面例子的行为。在第二个例子中，设置了 accessOrder 为 true，当我们调用 get() 方法之后，发现被访问的那个元素移动到了最后面。顺着get()方法来分析，为何为出现这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> ((e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (accessOrder)<br>        afterNodeAccess(e);<br>    <span class="hljs-keyword">return</span> e.value;<br>&#125;<br></code></pre></td></tr></table></figure><p>getNode 是父类的方法，没有什么可以说的，值得深入的地方是最后的那个判断语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (accessOrder)<br>    afterNodeAccess(e);<br></code></pre></td></tr></table></figure><p>只有 accessOrder 为 true 的时候，才会执行 afterNodeAccess 这个判断似乎比较符合上面的行为。看来一切玄机都在这个方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">afterNodeAccess</span><span class="hljs-params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="hljs-comment">// move node to last</span><br>    LinkedHashMapEntry&lt;K,V&gt; last;<br>    <span class="hljs-keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;<br>        LinkedHashMapEntry&lt;K,V&gt; p =<br>            (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;<br>        p.after = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>)<br>            head = a;<br>        <span class="hljs-keyword">else</span><br>            b.after = a;<br>        <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>)<br>            a.before = b;<br>        <span class="hljs-keyword">else</span><br>            last = b;<br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>            head = p;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p.before = last;<br>            last.after = p;<br>        &#125;<br>        tail = p;<br>        ++modCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法名后面的注释解释了这个方法的作用：将参数节点移动到双向链表的最后面去，即让 tail 节点指向 e。<br>下面用一幅图来解释这个方法运作的原理：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/link_haskmap/access_order.png?raw=true"></p><p>如此这般，就将访问的节点e，移动到了双链表的尾节点。</p><p>同样的，我们在看看put()方法，由于LinkedHashMap没有覆盖put()方法，我们就去HashMap的源码中找找源头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>    V oldValue = e.value;<br>    <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>        e.value = value;<br>    afterNodeAccess(e);<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个陷阱，你突然猛地一看，感觉是那么回事，调用了 afterNodeAccess 方法，但是调用这个方法的前提条件是 e != null，用普通话说就是 如果key已经在map里面存在的时候，才会调用这个方法，那么当 e == null 的时候呢，源码里面调用了 newNode 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// tab[i] 为null的时候</span><br>tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment">// 红黑树上添加一个</span><br>TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);<br><br><span class="hljs-comment">// 链表上添加一个</span><br>p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>这里又有一个坑，当我天真的查看 newNode 与 newTreeNode 的时候，发现根本就只是调用了一个构造方法，突然就懵逼了，这根本说不通啊，按照之前的例子的行为，每次添加一个新的元素，也应该要放到双链表的最后才对。在我翻了几篇博客的时候突然想到，这两个方法会不会被LinkedHashMap重写了，查看源码，果然：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;<br>    LinkedHashMapEntry&lt;K,V&gt; p =<br>        <span class="hljs-keyword">new</span> LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e);<br>    linkNodeLast(p);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">newTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);<br>    linkNodeLast(p);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个货都调用了 linkNodeLast 方法，这个方法看名字就知道是将节点放到最后面，虽然它没有调用 afterNodeAccess，但是他们的作用确是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// link at the end of list</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkNodeLast</span><span class="hljs-params">(LinkedHashMapEntry&lt;K,V&gt; p)</span> </span>&#123;<br>    LinkedHashMapEntry&lt;K,V&gt; last = tail;<br>    tail = p;<br>    <span class="hljs-keyword">if</span> (last == <span class="hljs-keyword">null</span>)<br>        head = p;<br>    <span class="hljs-keyword">else</span> &#123;<br>        p.before = last;<br>        last.after = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个很简单，就不多说了。稍微提一下，按照源码的逻辑，每次新增的元素都是放在迭代器最后的，无论有没有开启 accessOrder，因为这里没有判断 accessOrder 字段，可以写demo验证一下。</p><p>还有一个忽略的地方，就是 LinkedHashMapEntry 这个 Entry 里面有两个变量 before，after，他们是前后指针，有了他们才能形成双链表。</p><h2 id="LinkedHashMap的结构"><a href="#LinkedHashMap的结构" class="headerlink" title="LinkedHashMap的结构"></a>LinkedHashMap的结构</h2><p>上面也说到过，LinkedHashMap是继承HashMap的，所以底层的数据结构与HashMap一样，不过它有自己的成员变量：head与tail。也就是说它增强了HashMap，在HashMap的基础上又维护了一个双链表。上图便于理解：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/link_haskmap/structure.png?raw=true"></p><p>红色的箭头就是LinkedHashMap自己维护的双链表，其他的还是HashMap自己的东西。</p><h2 id="LruCache-原理"><a href="#LruCache-原理" class="headerlink" title="LruCache 原理"></a>LruCache 原理</h2><p>LruCache 解释：LRU是Least Recently Used的缩写，即最近最少使用。</p><p><strong>为什么会有这个算法？</strong></p><p>LRU算法的提出，是基于这样一个事实：之前使用过的数据，很可能在后面会频繁的使用到。反过来说，已经很久没有使用的数据很可能在未来较长的一段时间内不会被用到。这个，就是著名的局部性原理。因此，我们只需要在每次缓存满了的时候，移除最长时间没有使用的元素就好了。</p><p>其实看了这段解释，你应该能够想到LinkedHashMap，因为这个货设置 accessOrder 为 true的时候，每次都会将访问的元素放在双链表的最后面，那么当存放的数据满了之后，我们只需要移除head指向的元素就好了，这样的行为非常符合Lru的原理。</p><p>先上类图，搞清楚关系：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/link_haskmap/LruCache_class_uml.png?raw=true"></p><p>根据类图可以看出一个大概，LruCache的核心还是利用LinkedHashMap来实现的。LruCache的代码并不多，而且不难，300行不到，我们一点一点来看。</p><h3 id="LruCache-构造函数"><a href="#LruCache-构造函数" class="headerlink" title="LruCache 构造函数"></a>LruCache 构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> maxSize for caches that do not override &#123;<span class="hljs-doctag">@link</span> #sizeOf&#125;, this is</span><br><span class="hljs-comment"> *     the maximum number of entries in the cache. For all other caches,</span><br><span class="hljs-comment"> *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (maxSize &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;maxSize &lt;= 0&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">this</span>.maxSize = maxSize;<br>    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>look，它将 accessOrder 字段设置为 true，负载因子使用推荐（默认）的0.75。</p><h3 id="LruCache-get-方法"><a href="#LruCache-get-方法" class="headerlink" title="LruCache get 方法"></a>LruCache get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the value for &#123;<span class="hljs-doctag">@code</span> key&#125; if it exists in the cache or can be</span><br><span class="hljs-comment"> * created by &#123;<span class="hljs-doctag">@code</span> #create&#125;. If a value was returned, it is moved to the</span><br><span class="hljs-comment"> * head of the queue. This returns null if a value is not cached and cannot</span><br><span class="hljs-comment"> * be created.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;key == null&quot;</span>);<br>    &#125;<br><br>    V mapValue;<br>    <span class="hljs-comment">// 统计 hitCount 与 missCount</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        mapValue = map.get(key);<br>        <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;<br>            hitCount++;<br>            <span class="hljs-keyword">return</span> mapValue;<br>        &#125;<br>        missCount++;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Attempt to create a value. This may take a long time, and the map</span><br><span class="hljs-comment">     * may be different when create() returns. If a conflicting value was</span><br><span class="hljs-comment">     * added to the map while create() was working, we leave that value in</span><br><span class="hljs-comment">     * the map and release the created value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 如果key值不存在与map中，那么调用 create 方法创建一个，注意这个方法没有同步</span><br>    V createdValue = create(key);<br>    <span class="hljs-comment">// create 方法默认返回 </span><br>    <span class="hljs-keyword">if</span> (createdValue == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        createCount++;<br>        <span class="hljs-comment">// 将创建的值放入map中，如果map在前面的过程中有别的线程放入了这对key-value，那么会返回放入的value</span><br>        mapValue = map.put(key, createdValue);<br>        <span class="hljs-comment">// 不为空，说明不需要我们所创建的值，所以又把返回的值放进去</span><br>        <span class="hljs-comment">// 将新创建的值丢弃</span><br>        <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// There was a conflict so undo that last put</span><br>            map.put(key, mapValue);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//为空，说明我们更新了这个key的值，需要重新计算大小</span><br>            size += safeSizeOf(key, createdValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mapValue != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 通知创建的值需要被移除，已经有别的线程创建了对应的key-value</span><br>        entryRemoved(<span class="hljs-keyword">false</span>, key, createdValue, mapValue);<br>        <span class="hljs-keyword">return</span> mapValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有冲突时，因为放入了新创建的值，大小已经有变化，所以需要修整大小</span><br>        trimToSize(maxSize);<br>        <span class="hljs-keyword">return</span> createdValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本来是不想贴代码的，因为贴了之后自己记不住，别人也懒得看，但是这个类确实很简单，自己看看就明白了。不帖代码也不知道该怎么写。</p><h2 id="LruCache-put-方法"><a href="#LruCache-put-方法" class="headerlink" title="LruCache put 方法"></a>LruCache put 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;key == null || value == null&quot;</span>);<br>    &#125;<br><br>    V previous;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        putCount++;<br>        <span class="hljs-comment">// 计算该 value 占用的缓存大小</span><br>        size += safeSizeOf(key, value);<br>        previous = map.put(key, value);<br>        <span class="hljs-comment">// 如果 key 存在，总的大小需要减去key对应的旧value的大小</span><br>        <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;<br>            size -= safeSizeOf(key, previous);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 调用钩子函数</span><br>    <span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;<br>        entryRemoved(<span class="hljs-keyword">false</span>, key, previous, value);<br>    &#125;<br>    <span class="hljs-comment">// 查看是否需要释放缓存空间</span><br>    trimToSize(maxSize);<br>    <span class="hljs-keyword">return</span> previous;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LruCache-trimToSize-方法"><a href="#LruCache-trimToSize-方法" class="headerlink" title="LruCache trimToSize 方法"></a>LruCache trimToSize 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            K key;<br>            V value;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(getClass().getName()<br>                            + <span class="hljs-string">&quot;.sizeOf() is reporting inconsistent results!&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (size &lt;= maxSize) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// BEGIN LAYOUTLIB CHANGE</span><br>                <span class="hljs-comment">// get the last item in the linked list.</span><br>                <span class="hljs-comment">// This is not efficient, the goal here is to minimize the changes</span><br>                <span class="hljs-comment">// compared to the platform version.</span><br>                Map.Entry&lt;K, V&gt; toEvict = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">for</span> (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;<br>                    toEvict = entry;<br>                &#125;<br>                <span class="hljs-comment">// END LAYOUTLIB CHANGE</span><br><br>                <span class="hljs-keyword">if</span> (toEvict == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                key = toEvict.getKey();<br>                value = toEvict.getValue();<br>                map.remove(key);<br>                size -= safeSizeOf(key, value);<br>                evictionCount++;<br>            &#125;<br><br>            entryRemoved(<span class="hljs-keyword">true</span>, key, value, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看起来很长，但是其实就是不断的删除Head节点，直到缓存大小小于我们设置的最大缓存大小。没啥说的。</p><h2 id="LruCahe-使用例子"><a href="#LruCahe-使用例子" class="headerlink" title="LruCahe 使用例子"></a>LruCahe 使用例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">    mMemoryCache = <span class="hljs-keyword">new</span> LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Notify the removed entry that is no longer being cached</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evicted, String key,</span></span><br><span class="hljs-params"><span class="hljs-function">                BitmapDrawable oldValue, BitmapDrawable newValue)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (RecyclingBitmapDrawable.class.isInstance(oldValue)) &#123;<br>                <span class="hljs-comment">// The removed entry is a recycling drawable, so notify it</span><br>                <span class="hljs-comment">// that it has been removed from the memory cache</span><br>                ((RecyclingBitmapDrawable) oldValue).setIsCached(<span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// The removed entry is a standard BitmapDrawable</span><br>                <span class="hljs-keyword">if</span> (Utils.hasHoneycomb()) &#123;<br>                    <span class="hljs-comment">// We&#x27;re running on Honeycomb or later, so add the bitmap</span><br>                    <span class="hljs-comment">// to a SoftReference set for possible use with inBitmap later</span><br>                    mReusableBitmaps.add(<span class="hljs-keyword">new</span> SoftReference&lt;Bitmap&gt;(oldValue.getBitmap()));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Measure item size in kilobytes rather than units which is more practical</span><br><span class="hljs-comment">         * for a bitmap cache</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sizeOf</span><span class="hljs-params">(String key, BitmapDrawable value)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapSize = getBitmapSize(value) / <span class="hljs-number">1024</span>;<br>            <span class="hljs-keyword">return</span> bitmapSize == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : bitmapSize;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是Google很老的例子，因为Lru使用很简单，所以仍然用这个说明一下。</p><p>构造函数传递一个值，是用来限制缓存的大小的，比如你存放 bitmap，那么就需要根据App的可用内存来动态计算这个缓存应该占据多少。</p><p>entryRemoved 就是当资源被回收是会自动回调的一个钩子函数，如果你的缓存里面存放的资源被回收时，你还需要做一些别的操作，那么你需要实现这个方法。举个不恰当的例子，你想缓存一些连接，那么当这个连接被移除的时候，你肯定需要关闭这个连接，这个时候，在 entryRemoved 里面关闭就很容易了。</p><p>sizeOf 就是用来计算每个元素占用空间的大小。比如，图片一般的计算方式是计算图片被读取到内存中的大小，但是有时候可能产品脑子被驴踢了（不恰当的例子），它就要缓存固定个数的图片，不论图片大小，这个时候，sizeOf 就需要返回 1，只有这样才能满足要求。</p><h2 id="LruCache-工作流程图"><a href="#LruCache-工作流程图" class="headerlink" title="LruCache 工作流程图"></a>LruCache 工作流程图</h2><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/link_haskmap/LruCache_flow.png?raw=true"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/maosidiaoxian/article/details/51393753">https://blog.csdn.net/maosidiaoxian/article/details/51393753</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多指触控</title>
    <link href="/2020/04/08/blog_bak/Blog/Android-View/%E5%A4%9A%E6%8C%87%E8%A7%A6%E6%8E%A7/"/>
    <url>/2020/04/08/blog_bak/Blog/Android-View/%E5%A4%9A%E6%8C%87%E8%A7%A6%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>有的博文已经写的非常好了，而且我在项目中几乎没有使用过，所以就贴个链接吧。</p><p>请先阅读下面的参考文档，然后能够回答下面的问题：</p><ol><li><p>为什么要把mFirstTouchTarget设计成链表？</p></li><li><p>记录目标的TouchTarget的pointerIdBits又起到什么作用？</p></li><li><p>设ViewGroup中，有2个Button：A，B：</p><ul><li><p>按下A，再按下A（多点触控），为什么释放后A的点击事件只会触发一次？</p></li><li><p>按下A，按下 ViewGroup 的空白区域，为什么先释放A，却无法触发A的点击事件，继续释放VG，又会触发A的点击事件？</p></li><li><p>按下 ViewGroup 的空白区域，为什么点击A，B无响应？</p></li></ul></li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.gcssloop.com/customview/motionevent">安卓自定义View进阶-MotionEvent详解</a></p><p><a href="https://www.gcssloop.com/customview/multi-touch">安卓自定义View进阶-多点触控详解</a></p><p><a href="https://developer.android.com/training/gestures/multi?hl=zh-cn">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2020/04/06/blog_bak/Blog/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/04/06/blog_bak/Blog/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="几个参数"><a href="#几个参数" class="headerlink" title="几个参数"></a>几个参数</h3><p>我们先来看一下创建线程池的几个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,</span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>corePoolSize</strong>：核心线程数量。如果运行的线程少于该值，则<strong>直接创建新线程</strong>来处理任务，即使线程池中的其他线程是空闲的。</p></li><li><p><strong>maximumPoolSize</strong>：最大线程数量。当<strong>任务队列已经满</strong>了，才会创建新线程直到线程数量等于该值。</p></li><li><p><strong>workQueue</strong>：等待队列。当线程数量已经达到设置的<strong>核心线程</strong>的数量，仍然有新任务进来时，会进入该队列等待执行。</p></li><li><p><strong>handler</strong>：拒绝处理策略。当线程数量已经达到设置的<strong>最大线程</strong>的数量，且等待队列已满，仍然有新任务进来时，会将任务交给该 handler 处理。</p></li></ul><p>线程池的工作原理大致如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/thread_pool_1.png?raw=true"></p><p>这个过程是从分析源码得出来的逻辑，我们可以大致看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs ka">public void execute(Runnable command) &#123;<br>    if (command == null)<br>        throw new NullPointerException();<br>    /*<br>     * clt记录着runState和workerCount<br>     */<br>    int c = ctl.get();<br>    /*<br>     * workerCountOf方法取出低29位的值，表示当前活动的线程数；<br>     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；<br>     * 并把任务添加到该线程中。<br>     */<br>    if (workerCountOf(c) &lt; corePoolSize) &#123;<br>        /*<br>         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；<br>         * 如果为true，根据corePoolSize来判断；<br>         * 如果为false，则根据maximumPoolSize来判断<br>         */<br>        if (addWorker(command, true))<br>            return;<br>        /*<br>         * 如果添加失败，则重新获取ctl值<br>         */<br>        c = ctl.get();<br>    &#125;<br>    /*<br>     * 如果当前线程池是运行状态并且任务添加到队列成功<br>     */<br>    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        // 重新获取ctl值<br>        int recheck = ctl.get();<br>        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，<br>        // 这时需要移除该command<br>        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回<br>        if (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        /*<br>         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法<br>         * 这里传入的参数表示：<br>         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；<br>         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；<br>         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。<br>         */<br>        else if (workerCountOf(recheck) == 0)<br>            addWorker(null, false);<br>    &#125;<br>    /*<br>     * 如果执行到这里，有两种情况：<br>     * 1. 线程池已经不是RUNNING状态；<br>     * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。<br>     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；<br>     * 如果失败则拒绝该任务<br>     */<br>    else if (!addWorker(command, false))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到逻辑还是很清晰的。</p><p>那么，为什么会这样设计呢？为什么要等待队列满了之后才会创建更多的线程，而不是直接创建更多的线程？</p><p>我们先要理解线程池是做什么的？为什么要设计出这么一个东西？？？</p><p>我们先来说一下什么是线程，<strong>线程是一种轻量级的进程，是由进程派生出来的子任务，它是程序执行的一个路径；每个线程都有自己的局部变量表、程序计数器（指向真正执行的指令指针）以及各自的生命周期</strong>。</p><p>了解了这个定义，我们想一下，当 JVM 创建一个线程的时候，它创建线程需要消耗资源吗？不仅需要，而且这个消耗是无法忽略的。</p><p>那么，我们假设有这样的一种场景：任务请求数量非常多，但每个任务执行的时间很短，没有线程池会怎么样？会不断的创建然后销毁线程，这样就很影响系统性能。那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？</p><p>这就是线程池的目的了。知道了线程池的目的之后，我们应该就明白了为啥要等待队列满了之后才会创建更多的线程。其实，想一下我们的现实生活，比如银行排队，只有队列站的老长了，才会有可能新开窗口，新开窗口还不够，就直接不接待后面的人了。</p><h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><h4 id="当线程池没有任务的时候，里面的线程处于什么状态？"><a href="#当线程池没有任务的时候，里面的线程处于什么状态？" class="headerlink" title="当线程池没有任务的时候，里面的线程处于什么状态？"></a>当线程池没有任务的时候，里面的线程处于什么状态？</h4><p>处于阻塞状态。</p><p>这是因为如果线程是新创建的，那它肯定会直接去处理刚拿到的任务了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>        <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 command 就是 execute 传进来的，新创建的线程就会执行这个 runnable。</p><p>当线程执行完任务之后，它会做什么呢？我们发现，线程执行的其实是一个 while 循环，里面才执行了 runnable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 task 就是 execute 传进来的 runnable。当线程执行完，它会被置空，所以会走到 getTask 方法。而 getTask 实际上是从等待队列取任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable r = timed ?<br>    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :workQueue.take();<br></code></pre></td></tr></table></figure><p>所以，线程池没有任务的时候，线程会阻塞在 workQueue.take() 方法上。</p><h4 id="新创建了一个线程池，里面有线程吗？"><a href="#新创建了一个线程池，里面有线程吗？" class="headerlink" title="新创建了一个线程池，里面有线程吗？"></a>新创建了一个线程池，里面有线程吗？</h4><p>显然是没有的，只有执行了 execute 才会创建线程。不过有方法指定。</p><h4 id="如何关闭线程池？如何彻底关闭？"><a href="#如何关闭线程池？如何彻底关闭？" class="headerlink" title="如何关闭线程池？如何彻底关闭？"></a>如何关闭线程池？如何彻底关闭？</h4><p>我们知道，想让线程池关闭，就需要关闭线程。想关闭线程只有一个方法，跟它商量，怎么商量呢？使用中断。</p><p>我们看一下 shutdown 方法的注释：</p><p>shutdown 方法会将已经提交的任务执行完毕，但是不会接受新的任务，该方法不是阻塞的，所以不会等到任务全部结束才返回。</p><p>再看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(SHUTDOWN);<br>        interruptIdleWorkers();<br>        onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br></code></pre></td></tr></table></figure><p>interruptIdleWorkers 这个方法是中断空闲线程，所以它不会中断正在执行的线程，已经提交的任务，依然可以正常执行。</p><p>我们再看另一个方法 shutdownNow。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title">shutdownNow</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;Runnable&gt; tasks;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        checkShutdownAccess();<br>        advanceRunState(STOP);<br>        interruptWorkers();<br>        tasks = drainQueue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p>interruptWorkers() 这个方法会中断所有线程。另外它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。</p><p>所以 shutdownNow 比 shutdown 更彻底！但是还有一个问题，shutdownNow 会中止正在执行的任务吗？比如我有个任务超级耗时，调用 shutdownNow 的时候，才执行了 10%，那么这个线程会中止吗？其实这里就是为啥线程的中止需要两方协商了。假设A想要中止线程，但是线程不响应这个中止状态（比如做死循环），A能咋办呢？没办法！所以这个还是要看任务的具体状态，如果你在每次循环时都检查一下中断状态，就可以主动中止。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/entry/58fada5d570c350058d3aaad">https://juejin.im/entry/58fada5d570c350058d3aaad</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001-Matrix源码分析：LooperMonitor 监测基石</title>
    <link href="/2020/04/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/001-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ALooperMonitor%20%E7%9B%91%E6%B5%8B%E5%9F%BA%E7%9F%B3/"/>
    <url>/2020/04/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/001-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ALooperMonitor%20%E7%9B%91%E6%B5%8B%E5%9F%BA%E7%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>Matrix是一个APM库，它提供了许多功能供我们使用。我们从最简单的功能开始分析。</p><blockquote><p>com.tencent.matrix.trace.tracer.FrameTracer</p></blockquote><p>这个类是用来展示app的帧率的，我们知道收集一个帧率还是相当容易的，但是这个库里面有些小细节以及扩展我们可以学习以下。</p><p>这里我们不从Matrix的入口函数开始分析，因为这样函数的调用栈会显得很长，不利于阅读，我们直接从最低层的类开始说起，慢慢往上走，就像搭建房子一样。</p><p>我们介绍的第一个类是 LooperMonitor，它的作用是监听<strong>主线程</strong>Looper的消息处理回调。</p><p>我们知道，Looper在分发消息的时候，会打印日志：</p><blockquote><p>android.os.Looper#loop</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">         <span class="hljs-keyword">final</span> Printer logging = me.mLogging;<br>         <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>             logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                     msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>         &#125;<br><br>...<br>             <br>         <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>             logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>         &#125;<br></code></pre></td></tr></table></figure><p>我们可以利用这个机制来监控消息的分发。首先，我们设置一个 Printer 进去：</p><blockquote><p>com.tencent.matrix.trace.core.LooperMonitor#resetPrinter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetPrinter</span><span class="hljs-params">()</span> </span>&#123;<br>    Printer originPrinter = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isReflectLoggingError) &#123;<br>            originPrinter = ReflectUtils.get(looper.getClass(), <span class="hljs-string">&quot;mLogging&quot;</span>, looper);<br>            <span class="hljs-keyword">if</span> (originPrinter == printer &amp;&amp; <span class="hljs-keyword">null</span> != printer) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        isReflectLoggingError = <span class="hljs-keyword">true</span>;<br>        Log.e(TAG, <span class="hljs-string">&quot;[resetPrinter] %s&quot;</span>, e);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != printer) &#123;<br>        MatrixLog.w(TAG, <span class="hljs-string">&quot;maybe thread:%s printer[%s] was replace other[%s]!&quot;</span>,<br>                looper.getThread().getName(), printer, originPrinter);<br>    &#125;<br>    looper.setMessageLogging(printer = <span class="hljs-keyword">new</span> LooperPrinter(originPrinter));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != originPrinter) &#123;<br>        MatrixLog.i(TAG, <span class="hljs-string">&quot;reset printer, originPrinter[%s] in %s&quot;</span>, originPrinter, looper.getThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段逻辑不复杂，首先是使用反射来获取原来的 Printer，然后将它包装一下，在重新设置回去。</p><p>我们看一下这个 Printer 的包装类的实现：</p><blockquote><p>com.tencent.matrix.trace.core.LooperMonitor.LooperPrinter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperPrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Printer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Printer origin;<br>    <span class="hljs-keyword">boolean</span> isHasChecked = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> isValid = <span class="hljs-keyword">false</span>;<br><br>    LooperPrinter(Printer printer) &#123;<br>        <span class="hljs-keyword">this</span>.origin = printer;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != origin) &#123;<br>            origin.println(x);<br>            <span class="hljs-keyword">if</span> (origin == <span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(TAG + <span class="hljs-string">&quot; origin == this&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!isHasChecked) &#123;<br>            isValid = x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span> || x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>            isHasChecked = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">if</span> (!isValid) &#123;<br>                MatrixLog.e(TAG, <span class="hljs-string">&quot;[println] Printer is inValid! x:%s&quot;</span>, x);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isValid) &#123;<br>            dispatch(x.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;&gt;&#x27;</span>, x);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对 println 方法进行了增强，也没做啥，就是先调用了原来的 println 方法，然后做了一下校验，校验是否有输出 ‘&lt;’ 和 ‘&gt;’ 这两个特殊字符。</p><p>如果校验通过，则会进行分发处理。注意这里的校验只会进行一次。</p><blockquote><p>com.tencent.matrix.trace.core.LooperMonitor#dispatch</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isBegin, String log)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (LooperDispatchListener listener : listeners) &#123;<br>        <span class="hljs-keyword">if</span> (listener.isValid()) &#123;<br>            <span class="hljs-keyword">if</span> (isBegin) &#123;<br>                <span class="hljs-keyword">if</span> (!listener.isHasDispatchStart) &#123;<br>                    listener.onDispatchStart(log);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (listener.isHasDispatchStart) &#123;<br>                    listener.onDispatchEnd(log);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isBegin &amp;&amp; listener.isHasDispatchStart) &#123;<br>            listener.dispatchEnd();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>分发方法就是触发了 listener 的一些回调方法，里面的逻辑用了许多字段来判断，一下子不太好懂，有些逻辑理论上会重复，但是没错，建议多看几遍。</p><p>粗浅的理解就是遇到 ‘&gt;’ 字符，回调 onDispatchStart 方法，遇到 ‘&lt;’ 字符回调 onDispatchEnd 方法。</p><p>我们看看 LooperDispatchListener 的代码：</p><blockquote><p>com.tencent.matrix.trace.core.LooperMonitor.LooperDispatchListener</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperDispatchListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> isHasDispatchStart = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchStart</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@CallSuper</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDispatchStart</span><span class="hljs-params">(String x)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isHasDispatchStart = <span class="hljs-keyword">true</span>;<br>        dispatchStart();<br>    &#125;<br><br>    <span class="hljs-meta">@CallSuper</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDispatchEnd</span><span class="hljs-params">(String x)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isHasDispatchStart = <span class="hljs-keyword">false</span>;<br>        dispatchEnd();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchEnd</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也没做什么，就是自身使用一个变量来控制了回调必须成对。然后将回调又封装了一层，子类只需要处理无参的方法就好了。</p><p>LooperMonitor类我们就分析完了，<strong>主要是提供了一个监听，我们注册这个监听就可以知道消息分发的开始与结束</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每个消息在处理之前，Looper 会使用 printer 来打印一些消息，打印的消失是比较特殊的，我们可以利用打印出来的特殊字符串来做判断：</p><ul><li>消息被处理之前</li><li>消息被处理之后</li></ul><p>我们主要的目的是拿到这两个时间点。</p>]]></content>
    
    
    <categories>
      
      <category>Matrix</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>屏幕适配</title>
    <link href="/2020/04/05/blog_bak/Blog/Android/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <url>/2020/04/05/blog_bak/Blog/Android/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>我们先来理解一下屏幕适配这个概念。什么叫屏幕适配？屏幕适配是为了做什么？是为了让一个 10x10 的图标在所有屏幕上表现出一样的大小吗？</p><p>不是的！那是为了什么？是为了让这个图标在所有手机屏幕上占的比例是一样的。</p><p>比如，一个 320x480 的手机，10x10 的图标占手机宽度（讨论高度意义不大）的 1/32。而在一个 1080x1920 的手机上只占手机宽度的 1/108，这样就显得很奇怪。同样都是手机，你凭在我的手机上显示这么小，眼睛都看瞎了。</p><p>那么有没有什么办法能够解决这个问题呢？有的，Google提出了一个 dp 的概念。它能做什么呢？它可以让图标在所有屏幕上显示的是差不多一样大！！！但是这个解决了屏幕适配的问题吗？没有。</p><p>我们先看一下Google是如何借助于 dp 让图标在所有屏幕上显示的是差不多一样大的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">float</span> <span class="hljs-title">applyDimension</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unit, <span class="hljs-keyword">float</span> value,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   DisplayMetrics metrics)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (unit) &#123;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_PX:<br>            <span class="hljs-keyword">return</span> value;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_DIP:<br>            <span class="hljs-keyword">return</span> value * metrics.density;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_SP:<br>            <span class="hljs-keyword">return</span> value * metrics.scaledDensity;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_PT:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi * (<span class="hljs-number">1.0f</span>/<span class="hljs-number">72</span>);<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_IN:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi;<br>        <span class="hljs-keyword">case</span> COMPLEX_UNIT_MM:<br>            <span class="hljs-keyword">return</span> value * metrics.xdpi * (<span class="hljs-number">1.0f</span>/<span class="hljs-number">25.4f</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的代码就是Android的源代码，是用于单位转换的，我们看 COMPLEX_UNIT_DIP 这个 case。</p><p>它里面用到了一个叫做 density 的东西，那么什么是 density 呢？</p><blockquote><p>手机在出厂的时候，厂商就给手机设置了一个 dpi 值。按照规范来说，对于一个 320x480 的手机，它的 dpi 是 160。对于 1080 * 1920 的手机来说，它的 dpi 是 480。</p><p>density 就是 dpi/160</p></blockquote><p>我们来计算一下，当我们在 xml 指定一个图标的宽度为 10dp：</p><p>在 320x480 的手机上，它占了 10 * （160/160）个像素，也就是10px。</p><p>在 1080 * 1920 的手机上，它占了 10 * （480/160）个像素，也就是30px。</p><p>所以，我们在 xml 指定单位为 dp 的时候，在不同的手机上会占据不同的 px 像素，这就是为什么它可以让图标在所有屏幕上显示的是差不多一样大。</p><p>但是我们之前说过了，仅仅是这样还是不够的，我们需要的是让图标占据屏幕宽度的比例一样大。上面的例子中，图标占据屏幕宽度的比例一样大吗？不一样！</p><p>一个是 10/320，一个是 30/1080。</p><p>那么，有没有办法可以让他们的比例变得一样大呢？有，改变 density 的值。</p><h3 id="density-适配"><a href="#density-适配" class="headerlink" title="density 适配"></a>density 适配</h3><p>假如，我们以 320x480 为基准，那么想让 1080x1920 的比例也是 1/32，就应该修改 density 的值为 (1 * density) / 1080 = 1 / 320。density = 1080 / 320 。</p><p>得出了这个公式，我们再来反推一下，1080 / 320 是什么意思，就是 屏幕的宽/设计图的宽，就是将屏幕分成了320份，由于源码里面最后乘上density，所以我们只需要按照设计图来写就ok了。</p><p>所以，只要UI出了设计图，我们就可以取设计图的宽为基准，然后为每个手机计算出 density，这样就完成了屏幕适配。</p><p>这个方法不适用于老项目，以及依赖的三方库有图标等资源的项目。</p><h3 id="sw限定符适配"><a href="#sw限定符适配" class="headerlink" title="sw限定符适配"></a>sw限定符适配</h3><p>smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。</p><p>举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwM8N9ib5zKnRXY6SJWDpicUwhBdMsGEN4pic81MY6IFOEHJTGowPiaTYlQk7AlK1RPMKaKjr4seUJCDdw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>smallestWidth限定符适配和宽高限定符适配<strong>最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。</strong>这个特性就完美的解决了上文提到的宽高限定符的容错问题。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/post/5b7a29736fb9a019d53e7ee2">https://juejin.im/post/5b7a29736fb9a019d53e7ee2</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态代理与InvocationHandler</title>
    <link href="/2020/04/03/blog_bak/Blog/Android/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EInvocationHandler/"/>
    <url>/2020/04/03/blog_bak/Blog/Android/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EInvocationHandler/</url>
    
    <content type="html"><![CDATA[<p>在说动态代理之前，我们先看一下静态代理。说起静态代理，很多人都会会心一样，因为它太简单了。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>看下面的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Movie</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealMovie</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Movie</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;您正在观看电影 《肖申克的救赎》&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cinema</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Movie</span> </span>&#123;<br><br>    RealMovie movie;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cinema</span><span class="hljs-params">(RealMovie movie)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.movie = movie;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        guanggao(<span class="hljs-keyword">true</span>);<br>        movie.play();<br>        guanggao(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">guanggao</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isStart)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (isStart) &#123;<br>            System.out.println(<span class="hljs-string">&quot;电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码里面，Cinema就是一个代理类，它代理了 RealMovie 对象。一般来说，代理类与被代理类都会实现同一个接口，这样使用者就不用管它到底是不是代理类。使用者只需要知道它可以实现想要的功能就行了。</p><p>甚至有时候，我为了偷懒都不想去写接口，只是写一个包装类做些处理，然后将请求转发给被代理类。</p><p>所以，静态代理就是这样的一个东西，代理类可以预先处理一些东西，而被代理类是实现真正的功能。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>我们再来看看动态代理。Java 里面使用动态代理很简答，我们看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), DInvocationHandler());  <br></code></pre></td></tr></table></figure><p>Proxy.newProxyInstance 就是为了生成一个代理类，上面说静态代理的时候已经说了啥是代理类。这里我们不去追踪源码研究这个类是怎么生成的，我们直接看看它生成的类是个什么样子！！！</p><p>这是一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICook</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dealWithFood</span><span class="hljs-params">()</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是生成的代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICook</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m4;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler var1) <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">super</span>(var1);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object var1)</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ((Boolean)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var3) &#123;<br>            <span class="hljs-keyword">throw</span> var3;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var4) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var4);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cook</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dealWithFoot</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, (Object[])<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> ((Integer)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, (Object[])<span class="hljs-keyword">null</span>)).intValue();<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error var2) &#123;<br>            <span class="hljs-keyword">throw</span> var2;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(var3);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-keyword">new</span> Class[]&#123;Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>)&#125;);<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.company.ICook&quot;</span>).getMethod(<span class="hljs-string">&quot;cook&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m4 = Class.forName(<span class="hljs-string">&quot;com.company.ICook&quot;</span>).getMethod(<span class="hljs-string">&quot;dealWithFoot&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException var2) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(var2.getMessage());<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var3) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(var3.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是没什么惊喜！它和静态代理的代理类是一样的功能，将请求转发给被代理类。</p><p>只不过这里它多了一个东西，那就是 InvocationHandler。那么为什么要多一个 InvocationHandler 呢？</p><p>显然是因为这个类是动态生成的，我们无法修改它，那么我们想在代理类里面搞事的想法不就无法实现了吗！但是这难不倒Java设计人员，它搞了一个接口 InvocationHandler ，将每个请求的转发转给 InvocationHandler，然后由实现者自己再去将请求转发给代理类。</p><p>所以，动态代理的本质与静态代理是一样的，它只不过是将请求先转发到 InvocationHandler，然后由开发者自己再去将请求转发给被代理类。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬件加速了解一下</title>
    <link href="/2020/04/02/blog_bak/Blog/Android/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"/>
    <url>/2020/04/02/blog_bak/Blog/Android/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>应该还是有相当一部分开发者不知道硬件加速到底是个什么东西。这个名词跟硬件相关，可能是一个很高级的东西，潜意思里都不想去接触。但是实际上，以我们的能力理解起来是没有问题的。听我慢慢道来。</p><h3 id="系统变化"><a href="#系统变化" class="headerlink" title="系统变化"></a>系统变化</h3><p>在Android平台的演变过程中，针对图形渲染方面的改进：</p><ol><li>Android 3.0 Honeycomd 中，引入了硬件加速。</li><li>Android 4.0 Ice Cream Sandwich 中，默认开启硬件加速。</li></ol><p>随着平台带来的这个变化，视图以及所有的Canvas对象的绘制操作，原本由CPU来完成，现在都交由GPU来完成。</p><h3 id="硬件加速的主要原理"><a href="#硬件加速的主要原理" class="headerlink" title="硬件加速的主要原理"></a>硬件加速的主要原理</h3><p>通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，转由GPU完成。</p><p>可以看到，硬件加速的底层确实是与硬件相关，但是这个不是我们的主要了解对象。我们需要了解的是它对我们开发者有什么影响。</p><h3 id="从例子开始"><a href="#从例子开始" class="headerlink" title="从例子开始"></a>从例子开始</h3><p>我们开一个新项目：</p><ol><li><p>自定义两个View：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HardwareLinearLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : LinearLayout(context, attrs, defStyleAttr) &#123;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        setWillNotDraw(<span class="hljs-literal">false</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        Log.e(<span class="hljs-string">&quot;HardwareLinearLayout&quot;</span>, <span class="hljs-string">&quot;onDraw&quot;</span>)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HardwareTextView</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<br>    context: Context,<br>    attrs: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : TextView(context, attrs, defStyleAttr) &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;HardwareTextView&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(canvas: <span class="hljs-type">Canvas</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDraw(canvas)<br>        Log.e(TAG, <span class="hljs-string">&quot;onDraw&quot;</span>)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>给这两个控件都设置上背景颜色，如果没有给HardwareLinearLayout设置背景色，需要调用 setWillNotDraw(false)，在界面上的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">com.example.hardware.HardwareLinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/linear&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.example.hardware.HardwareTextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World!&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">com.example.hardware.HardwareLinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面非常的简单，一个 LinearLayout 包含了一个 TextView。</p></li><li><p>然后给添加点击事件，事件也很简单，重绘自己而已。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    text.setOnClickListener &#123; text.invalidate() &#125;<br>   <br>    linear.setOnClickListener &#123; linear.invalidate() &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>那么，有趣的问题来了！！！</p><p>测试会出现以下几种情况：</p><ol><li><p>给Application设置 android:hardwareAccelerated=”false” ，当我们点击这个TextView的时候：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">E/HardwareLinearLayout: onDraw<br>E/HardwareTextView: onDraw<br></code></pre></td></tr></table></figure></li><li><p>给Application设置 android:hardwareAccelerated=”true”，当我们点击这个TextView的时候：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">E/HardwareTextView: onDraw<br></code></pre></td></tr></table></figure></li><li><p>给Application设置 android:hardwareAccelerated=”false” ，当我们点击这个LinearLayout的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ko">E/HardwareLinearLayout: onDraw<br>E/HardwareTextView: onDraw<br></code></pre></td></tr></table></figure></li></ol><p>下面我们来说说为什么会这样。我们首先介绍一下两个绘制模型。</p><h3 id="基于软件的绘制模型"><a href="#基于软件的绘制模型" class="headerlink" title="基于软件的绘制模型"></a>基于软件的绘制模型</h3><p>也就是没有硬件加速之前的模型。</p><h4 id="基于软件的绘制模型主要由以下两步构成："><a href="#基于软件的绘制模型主要由以下两步构成：" class="headerlink" title="基于软件的绘制模型主要由以下两步构成："></a>基于软件的绘制模型主要由以下两步构成：</h4><ol><li><strong>Invalidation:</strong> 当视图层级需要更新，或者只是 View 的一个属性发生变化，View.invalidata() 方法就会被调用，该方法会传播到整个视图层级，使得整个视图层级被重绘。</li><li><strong>Redrawing:</strong> 每个 View 在重绘时，都会消耗大量的CPU性能。</li></ol><h4 id="基于软件的绘制模型缺点分析："><a href="#基于软件的绘制模型缺点分析：" class="headerlink" title="基于软件的绘制模型缺点分析："></a>基于软件的绘制模型缺点分析：</h4><ol><li>首先，这个模型需要在每个绘图过程中执行大量代码。 例如，如果您的应用程序界面中有一个按钮，并且该按钮位于另一个视图的顶部。 调用按钮的invalidate()方法，则Android系统会重新绘制整个视图（包括按钮下面的另一个视图），即使它没有更改。</li><li>第二个问题是绘图模型可以隐藏应用程序中的错误。 由于Android系统在与脏区域相交时重绘视图，因此即使invalidate()方法没有在脏区域上调用，也可能会重绘它。 发生这种情况时，我们是依赖于另一个视图触发了invalidate()方法以获得正确的行为。 因此，每当修改影响视图绘图代码的数据或状态时，应始终在自定义视图上调用invalidate()。</li></ol><h4 id="基于软件绘制模型中调用-invalidate-所发生的事情"><a href="#基于软件绘制模型中调用-invalidate-所发生的事情" class="headerlink" title="基于软件绘制模型中调用 invalidate() 所发生的事情:"></a>基于软件绘制模型中调用 invalidate() 所发生的事情:</h4><ul><li>默认情况下，<code>View</code>的<code>clipChildren</code>属性为<code>true</code>，即每个<code>View</code>绘制区域不能超出其父<code>View</code>的范围。如果设置一个页面根布局的<code>clipChildren</code>属性为<code>false</code>，则子<code>View</code>可以超出父<code>View</code>的绘制区域。</li><li>当一个<code>View</code>触发<code>invalidate</code>，且没有播放动画、没有触发<code>layout</code>的情况下：<ul><li><code>clipChildren</code>为<code>true</code>时，脏区会被转换成<code>ViewRoot</code>中的<code>Rect</code>，刷新时层层向下判断，当<code>View</code>与脏区<strong>有重叠则重绘</strong>。如果一个<code>View</code>超出父<code>View</code>范围且与脏区重叠，但其父<code>View</code>不与脏区重叠，这个子<code>View</code>不会重绘。</li><li><code>clipChildren</code>为<code>false</code>时，<code>ViewGroup.invalidateChildInParent()</code>中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。</li></ul></li></ul><p>简而言之，<strong>就是基于软件绘制的模型不仅仅会重绘自己，还会影响到与自己相交的控件</strong>。</p><h3 id="基于硬件加速绘制模型"><a href="#基于硬件加速绘制模型" class="headerlink" title="基于硬件加速绘制模型"></a>基于硬件加速绘制模型</h3><h4 id="基于硬件加速绘制模型主要由以下三步构成："><a href="#基于硬件加速绘制模型主要由以下三步构成：" class="headerlink" title="基于硬件加速绘制模型主要由以下三步构成："></a>基于硬件加速绘制模型主要由以下三步构成：</h4><p>随着全新硬件加速绘制模型的引入，重绘并不会立即执行，因为View被存储起来了。所以步骤变成这样：</p><ol><li><strong>Invalidate:</strong> 与软件绘制模型一样。</li><li><strong>Storing：</strong> 在这种情况下，<strong>只有需要被更新的视图才进行重绘</strong>，并且在重绘之后被<strong>存储</strong>起来，以便重用，从而减少运行时的计算量。</li><li><strong>Redrawing:</strong> 每个View利用之前存储下来的<em>绘图</em>进行更新，也就是说，那些不需要被更新的View，可以通过上次被储存下来的<em>绘图</em>进行更新（注：绘图这个词可能描述的并不准确，希望自行体会）。</li></ol><p>优点很明显了，完全弥补了软件绘制模型的缺点，做到了按需更新，缓存更新操作。</p><h3 id="两个模型的View绘制流程图对比"><a href="#两个模型的View绘制流程图对比" class="headerlink" title="两个模型的View绘制流程图对比"></a>两个模型的View绘制流程图对比</h3><p>通过上面的介绍，开发者应该能有一个大致的了解，现在截取美团基于Android 6.0的绘制流程分析来具体的讲解硬件加速做了什么。</p><p><em>下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。</em></p><p><a href="https://github.com/aprz512/note-markdown/blob/master/%E6%80%A7%E8%83%BD%E7%AC%94%E5%BD%95/render-func.png"><img src="https://github.com/aprz512/note-markdown/raw/master/%E6%80%A7%E8%83%BD%E7%AC%94%E5%BD%95/render-func.png" alt="img"></a> </p><ul><li>从<code>ViewRootImpl.performTraversals</code>到<code>PhoneWindow.DecroView.drawChild</code>是每次遍历<code>View</code>树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行<code>Canvas</code>的创建等操作开始绘制。<ul><li>如果硬件加速不支持或者被关闭，则使用软件绘制，生成的<code>Canvas</code>即<code>Canvas.class</code>的对象；</li><li>如果支持硬件加速，则生成的是<code>DisplayListCanvas.class</code>的对象；</li><li>两者的<code>isHardwareAccelerated()</code>方法返回的值分别为<code>false</code>、<code>true</code>，<code>View</code>根据这个值判断是否使用硬件加速。</li></ul></li><li><code>View</code>中的<code>draw(canvas,parent,drawingTime) - draw(canvas) - onDraw - dispachDraw - drawChild</code>这条递归路径（下文简称<code>Draw</code>路径），调用了<code>Canvas.drawXxx()</code>方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建<code>DisplayList</code>。</li><li><code>View</code>中的<code>updateDisplayListIfDirty - dispatchGetDisplayList - recreateChildDisplayList</code>这条递归路径（下文简称<code>DisplayList</code>路径），仅在硬件加速时会经过，用于在遍历<code>View</code>树绘制的过程中更新<code>DisplayList</code>属性，并快速跳过不需要重建<code>DisplayList</code>的<code>View</code>。<ul><li><code>Android 6.0</code>中，和<code>DisplayList</code>相关的<code>API</code>目前仍被标记为<code>“@hide”</code>不可访问，表示还不成熟，后续版本可能开放。</li></ul></li><li>硬件加速情况下，<code>draw</code>流程执行结束后<code>DisplayList</code>构建完成，然后通过<code>ThreadedRenderer.nSyncAndDrawFrame()</code>利用<code>GPU</code>绘制<code>DisplayList</code>到屏幕上。</li></ul><p>从图中可以看出，只有父布局的 DisplayList 构建完成之后，才会去建构 child 的 DisplayList。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。</li><li>页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。</li><li>硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。</li><li>硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。</li><li>实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。</li></ol><p>当然这篇文章只是让你知道硬件加速做了什么，如果你想了解的更深入，应该去看看上面流程图的源码了。</p><h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><h4 id="离屏缓冲"><a href="#离屏缓冲" class="headerlink" title="离屏缓冲"></a>离屏缓冲</h4><p>每个View都能被渲染并保存为一个离屏位图，以供未来使用。首先通过调用Canvas.saveLayer()方法，渲染并保存位图，接着通过Canvas.restore()方法将所保存的位图绘制回画布。这些操作需要谨慎自行，因为绘制一个不需要的离屏位图同样需要消耗计算量。</p><p>上面我们说了硬件加速，但是不是所有的操作都支持硬件加速，<strong>如果你的绘制操作不支持硬件加速，你需要手动关闭硬件加速来绘制界面</strong>，关闭的方式是通过这行代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">view</span>.setLayerType(LAYER_TYPE_SOFTWARE, <span class="hljs-keyword">null</span>);  <br></code></pre></td></tr></table></figure><p>下面再截取Hencoder关于离屏缓冲的讲解：</p><p>有不少人都有过疑问：什么是 <code>layer type</code>？如果这个方法是硬件加速的开关，那么它的参数为什么不是一个 <code>LAYER_TYPE_SOFTWARE</code> 来关闭硬件加速以及一个 <code>LAYER_TYPE_HARDWARE</code> 来打开硬件加速这么两个参数，而是三个参数，在 <code>SOFTWARE</code> 和 <code>HARDWARE</code> 之外还有一个 <code>LAYER_TYPE_NONE</code>？难道还能既不用软件绘制，也不用硬件绘制吗？</p><p>事实上，这个方法的本来作用并不是用来开关硬件加速的，只是当它的参数为 <code>LAYER_TYPE_SOFTWARE</code> 的时候，可以「顺便」把硬件加速关掉而已；并且除了这个方法之外，<code>Android</code> 并没有提供专门的 <code>View</code> 级别的硬件加速开关，所以它就「顺便」成了一个开关硬件加速的方法。</p><p><code>setLayerType()</code> 这个方法，它的作用其实就是名字里的意思：设置 <code>View Layer</code> 的类型。所谓 <code>View Layer</code>，又称为离屏缓冲（Off-screen Buffer），<strong>它的作用是单独启用一块地方来绘制这个 <code>View</code> ，而</strong>不是<strong>使用软件绘制的 <code>Bitmap</code> 或者通过硬件加速的 <code>GPU</code>。这块「地方」可能是一块单独的 <code>Bitmap</code>，也可能是一块 <code>OpenGL</code> 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启</strong>。采用什么来绘制 <code>View</code> 不是关键，关键在于当设置了 <code>View Layer</code> 的时候，<strong>它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 <code>GPU</code> 的操作保存下来再交给 <code>GPU</code> 去计算</strong>。通过这样更进一步的缓存方式，<code>View</code> 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 <code>CPU</code> 绘制还是 <code>GPU</code> 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。</p><p>基于这样的原理，在进行移动、旋转等（无需调用 <code>invalidate()</code>）的属性动画的时候开启 <code>Hardware Layer</code> 将会极大地提升动画的效率，因为在动画过程中 <code>View</code> 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 <code>GPU</code> 通过简单计算就完成的，并不需要重绘整个 <code>View</code>。所以在这种动画的过程中开启 <code>Hardware Layer</code>，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">view.set<span class="hljs-constructor">LayerType(LAYER_TYPE_HARDWARE, <span class="hljs-params">null</span>)</span>;  <br>ObjectAnimator animator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">view</span>, <span class="hljs-string">&quot;rotationY&quot;</span>, 180)</span>;<br><br>animator.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> AnimatorListenerAdapter()</span> &#123;  <br>    @Override<br>    public void on<span class="hljs-constructor">AnimationEnd(Animator <span class="hljs-params">animation</span>)</span> &#123;<br>        view.set<span class="hljs-constructor">LayerType(LAYER_TYPE_NONE, <span class="hljs-params">null</span>)</span>;<br>    &#125;<br>&#125;);<br><br>animator.start<span class="hljs-literal">()</span>; <br></code></pre></td></tr></table></figure><p>或者如果是使用 ViewPropertyAnimator，那么更简单：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// withLayer() 可以自动完成上面这段代码的复杂操作</span><br><span class="hljs-selector-tag">view</span><span class="hljs-selector-class">.animate</span>()  <br>        <span class="hljs-selector-class">.rotationY</span>(<span class="hljs-number">90</span>)<br>        <span class="hljs-selector-class">.withLayer</span>(); <br></code></pre></td></tr></table></figure><p>不过一定要注意，只有你在对 <code>translationX</code> <code>translationY</code> <code>rotation</code> <code>alpha</code> 等无需调用 <code>invalidate()</code> 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生改变时，缓存未更新所带来的时间的节省。所以简单地说——<strong>这种方式不适用于基于自定义属性绘制的动画</strong>，一定记得这句话。</p><p>由于设置了 <code>View Layer</code> 后，<code>View</code> 在初次绘制时以及每次 <code>invalidate()</code> 后重绘时，需要进行两次的绘制工作（一次绘制到 <code>Layer</code>，一次从 <code>Layer</code> 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 <code>View Layer</code>，在需要用到它的时候再去使用。</p><p>每当你要让View执行一个Alpha动画，或者仅仅只是对其设置一个不同的Alpha值时，都可以考虑使用View.LAYER_TYPE_HARDWARE。这点非常重要，以至于Google改写了View.setAlpha()方法，从Android 6.0 开始，自动应用硬件层。所以，如果你的应用程序目标SDK大于等于23的话，就没有必要这样做了。</p><p><strong>最后，希望开发者能理解，硬件加速与离屏缓冲他们不是同一个东西，但是在API上又有一定的联系。两者都能加快渲染速度，一个缓存的是绘制操作，减少计算量，一个缓存的是绘制结果，只用绘制一次。</strong>同时开始硬件加速与硬件离屏缓存就能达到最好的效果，当然要注意View的内容不能改变。</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><ol><li><a href="https://www.mtyun.com/library/hardware-accelerate">https://www.mtyun.com/library/hardware-accelerate</a></li><li><a href="https://hencoder.com/ui-1-8/">https://hencoder.com/ui-1-8/</a></li><li><a href="https://juejin.im/post/5a1f7b3e6fb9a0451b0451bb">https://juejin.im/post/5a1f7b3e6fb9a0451b0451bb</a></li><li><a href="https://developer.android.com/guide/topics/graphics/hardware-accel">https://developer.android.com/guide/topics/graphics/hardware-accel</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动画原理</title>
    <link href="/2020/04/02/blog_bak/Blog/Android-View/%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/02/blog_bak/Blog/Android-View/%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Android 的动画分为两种：一种是补间动画，一种是属性动画。</p><h3 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h3><p>补间动画，很简答，就是我们使用的各种 Animation。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ScaleAnimation animation = <span class="hljs-keyword">new</span> ScaleAnimation(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>animation.setDuration(<span class="hljs-number">300</span>);<br>view.startAnimation(animation);<br></code></pre></td></tr></table></figure><p>这段代码就可以执行一个缩放动画，那么你知道补间动画到底是怎么运行的吗？</p><p>我们先来看一张图：</p><p><img src="https://raw.githubusercontent.com/aprz512/pic4aprz512/master/Blog/Android-View/View/1541341-4d6f77035fc31769.webp"></p><p>这是 View 的绘制流程，它与动画有什么关系呢？我们看一下 draw 方法的源码：</p><blockquote><p>android.view.View#draw(android.graphics.Canvas, android.view.ViewGroup, long)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>大致过一下里面的代码，很长，与动画相关的代码在很前面，很容易找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);<br></code></pre></td></tr></table></figure><p>这里其实是计算动画对脏区的影响。与动画是如何实现的并没有关系！！！</p><blockquote><p>android.view.View#applyLegacyAnimation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">applyLegacyAnimation</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime,</span></span><br><span class="hljs-params"><span class="hljs-function">        Animation a, <span class="hljs-keyword">boolean</span> scalingRequired)</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 这里主要是获取 invalidationTransform</span><br>    <span class="hljs-keyword">final</span> Transformation t = parent.getChildTransformation();<br>    <span class="hljs-keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="hljs-number">1f</span>);<br>    <span class="hljs-keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="hljs-number">1f</span>) &#123;<br>        <span class="hljs-keyword">if</span> (parent.mInvalidationTransformation == <span class="hljs-keyword">null</span>) &#123;<br>            parent.mInvalidationTransformation = <span class="hljs-keyword">new</span> Transformation();<br>        &#125;<br>        invalidationTransform = parent.mInvalidationTransformation;<br>        a.getTransformation(drawingTime, invalidationTransform, <span class="hljs-number">1f</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        invalidationTransform = t;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (more) &#123;<br>        <span class="hljs-keyword">if</span> (!a.willChangeBounds()) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>            <span class="hljs-comment">// 获取到 invalidationTransform，使用它去计算脏区</span><br>            a.getInvalidateRegion(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mRight - mLeft, mBottom - mTop, region,<br>                    invalidationTransform);<br><br>            ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> more;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们继续往下搜索动画相关的代码：</p><blockquote><p>android.view.View#draw(android.graphics.Canvas, android.view.ViewGroup, long)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);<br>concatMatrix = a.willChangeTransformationMatrix();<br><span class="hljs-keyword">if</span> (concatMatrix) &#123;<br>    mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;<br>&#125;<br>transformToApply = parent.getChildTransformation();<br></code></pre></td></tr></table></figure><p>这个 transformToApply 很像我们要找的东西，因为如果让你做动画，你怎么做呢？我们该如何将一个View平移？？有几种方案，一种是直接改变View的位置，一种是改变 child 画布的位置。而 Transformation 里面有一个 matrix 是可以进行变化画布的。</p><p>我们追踪这个 transformToApply，会发现如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Undo the scroll translation, apply the transformation matrix,</span><br><span class="hljs-comment">// then redo the scroll translate to get the correct result.</span><br>canvas.translate(-transX, -transY);<br>canvas.concat(transformToApply.getMatrix());<br>canvas.translate(transX, transY);<br></code></pre></td></tr></table></figure><p>这里证实了我们的猜想。<strong>在重绘的过程中，将动画某一时机的改变记录成 Matrix，然后应用到画布里面。这样动画就实现了</strong>。</p><p>那么，问个问题：<strong>当调用了 View.startAnimation() 之后，动画是马上就执行了么？</strong></p><h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画的原理其实也不难。</p><p>相较于补间动画，属性动画的优势在于，它不用在动画执行的时候不断的调用 View 的 draw 方法了，只是简单的更新了脏区，而且如果 View 支持硬件加速，只需要更新 DisplayList 即可。</p><p>我们知道，屏幕的显示都是由一帧一帧的画面组成的，属性动画其实就是利用了这一点。</p><ol><li><p>动画向 Choreographer 注册一个 callback，注册了监听之后，每次屏幕刷新的时候，它都会回调这个 callback，然后我们就可以在这里面处理动画逻辑了。</p></li><li><p>记录动画的起始时间，这个时间是用来计算动画的百分比。里面会用到插值器与估值器，不明白这两个概念的需要去补一下。</p><p>这里简单介绍。</p><p>我们将时间进行归一化，将动画时间范围归化到 [0, 1] 这个区间，下面我们称这个为时间进度。</p><p>插值器：根据时间进度计算出动画进度。什么意识呢？当你的动画不是匀速的时候，动画进度与时间进度不是一样的。比如加速动画，可能时间到了 50%，动画才到 25%，后面才越来越快。</p><p>估值器：当我们指定一个值从 20 变化到 100，那么估值器的作用就是根据动画进度（插值器计算出来的新的进度）计算出当前时刻的动画值。</p></li><li><p>其实有了上面两个步骤，我们自己应该也能写出一个动画效果。但是Android源码不满足于此，它还有更多东西：关键帧。关键帧可以看作是对动画某一重要时刻的数据的封装。</p><p>关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。</p><p>当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。</p></li><li><p>插值器，关键帧，估值器配合，就可计算出当前时间的动画值，然后拿到这个动画值，去更新 View。如何更新呢？使用反射：</p><blockquote><p>android.animation.PropertyValuesHolder#setAnimatedValue</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAnimatedValue</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mProperty != <span class="hljs-keyword">null</span>) &#123;<br>        mProperty.set(target, getAnimatedValue());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mSetter != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mTmpValueArray[<span class="hljs-number">0</span>] = getAnimatedValue();<br>            mSetter.invoke(target, mTmpValueArray);<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            Log.e(<span class="hljs-string">&quot;PropertyValuesHolder&quot;</span>, e.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的 mSetter 其实是对 View 反射方法的一个封装，它是调用了如 android.view.View#setTranslationX 之类的方法。</p><blockquote><p>android.view.View#setTranslationX</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTranslationX</span><span class="hljs-params">(<span class="hljs-keyword">float</span> translationX)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (translationX != getTranslationX()) &#123;<br>        invalidateViewProperty(<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>        mRenderNode.setTranslationX(translationX);<br>        invalidateViewProperty(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>   <br>        invalidateParentIfNeededAndWasQuickRejected();<br>        notifySubtreeAccessibilityStateChangedIfNeeded();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，View 的属性动画就完成了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2的doOnSubscribe引发的一个问题</title>
    <link href="/2020/04/01/blog_bak/Blog/Android-Bugs/RxJava2%E7%9A%84doOnSubscribe%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/01/blog_bak/Blog/Android-Bugs/RxJava2%E7%9A%84doOnSubscribe%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>接到一个需求，需要对一个旧功能做改动，由于网络部分的逻辑都很模板化（想念retrofit），所以我直接从别的地方copy了一份，在这里改吧改吧就运行了。但是运行时报错，<strong>报了在子线程访问UI的异常</strong>。这个异常很常见，也很好理解。</p><p>我们的代码逻辑大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Http.request(xxxx)<br>    <span class="hljs-comment">// 这里面弹出一个加载框</span><br>    .doOnSubscribe(xxx)<br>    .subscribeOn(io())<br>    .observerOn(main());<br></code></pre></td></tr></table></figure><p>对RxJava2比较熟悉的同学，立马就能知道问题出在了哪里！因该把 doOnSubscribe 放在 subscribeOn 后面才对。</p><p>这里贴一张图，便于理解RxJava2。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-Bugs/20200401211915.jpg?raw=true"></p><p>但是这里又有另外一个问题！！！这段代码是我从别的地方copy过来的，我copy的地方为什么没有问题？？？</p><p>我特意的断点查看，发现copy代码的地方，确实是在子线程执行的，那么它为什么没有报错呢？</p><p>经过一番排查，发现我copy地方弹出的加载框是使用的 DialogFragment，而老的代码加载框使用的是 ProgressDialog。</p><p>查看源码发现，DialogFragment 的 show 方法，实际上是显示了一个 Fragment。</p><p>我们知道，对 Fragment 的操作，都只是一个很简单的 addOp 操作，然后在 commit 的时候，会将这些操作一起执行，而 commit 操作的内部逻辑都是通过 handler.post 执行的。所以在子线程操作没有问题！！！</p><p>另外，有一个控件可以在子线程更新：ProgressBar。如果你去查看源码，会发现里面有不少同步代码！！！</p><p>再说一句，不让UI在子线程更新，是为了避免同步问题，如果可以在子线程更新UI，那UI框架非常容易导致死锁。输入事件处理与任何GUI组件背后的对象模型之间存在偶发的交互。用户发起的动作总会冒泡似的从操作系统传递给应用程序—先是由os检测到一次鼠标点击，然后工具集把它转化为“鼠标点击”事件，最终它会作为一个高层事件（比如“buttonpressed”事件）转发给应用程序的监听器。另一方面，应用程序发起的动作又会以冒泡的形式传回操作系统—应用程序发起一个动作要改变某个组件的背景颜色，这会被转发给一个特定的组件类，最终转发给os进行渲染。两种动作以完全相反的顺序访问相同的GUI对象，需要保证让每一个对象都是线程安全的，这会导致一系列的锁顺序的不一致，这会直接引发死锁。</p>]]></content>
    
    
    <categories>
      
      <category>bugs</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>004_如何测试一个没有返回值的函数？</title>
    <link href="/2020/03/19/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/004_%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F/"/>
    <url>/2020/03/19/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/004_%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>看下面的一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginViewModel</span> <span class="hljs-keyword">constructor</span></span>(<br>    <span class="hljs-keyword">val</span> loginRepository: LoginRepository,<br>    <span class="hljs-keyword">val</span> loginChecker: LoginChecker<br>) &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(username: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-comment">// .... 其他代码</span><br>        <span class="hljs-keyword">if</span> (loginChecker.check(username, password)) &#123;<br>            loginRepository.login(password, username)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRepository</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(username: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginChecker</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">check</span><span class="hljs-params">(username: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> checkUsername(username) &amp;&amp; checkPassword(password)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">(username: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkPassword</span><span class="hljs-params">(password: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个很简单例子！</p><p>现在，我们想测试：</p><ol><li>当 LoginViewModel 的 login 方法被调用的时候，loginChekc.check 是否执行了，且参数是否正确？</li><li>当 loginChekc.check 返回 true 的时候，loginRepository.login 是否执行了，且参数是否正确？</li></ol><p>让你写测试代码，你该如何做呢？</p><p>可以看到，login 方法没有返回值，我们没法使用 assert 等语句。</p><p>那，啥玩意可以知道方法被调用了几次，还能检查参数呢？？？</p><h3 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h3><p>我们先看看代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testViewModelLogin</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> loginRepository = mock(LoginRepository::<span class="hljs-keyword">class</span>.java)<br>    <span class="hljs-keyword">val</span> loginChecker = mock(LoginChecker::<span class="hljs-keyword">class</span>.java)<br>    <span class="hljs-keyword">val</span> loginViewModel = LoginViewModel(loginRepository, loginChecker)<br><br>    <span class="hljs-comment">// 让 loginChecker#check 返回 true</span><br>    `<span class="hljs-keyword">when</span>`(loginChecker.check(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)).thenReturn(<span class="hljs-literal">true</span>)<br><br>    loginViewModel.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)<br><br>    <span class="hljs-comment">// 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致</span><br>    verify(loginChecker).check(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)<br>    <span class="hljs-comment">// 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致</span><br>    verify(loginRepository).login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先使用 mock 方法创建了一个 mock 对象，注意这个参数接收的是一个 class！<strong>这个mock对象里面的方法都是空实现，返回值都是默认值</strong>。</p><p>其他的API可以去查一下文档，还是蛮简单的，这里就不说了，我要说的是其他东西。</p><p>当你运行这个单元测试的时候，会发现，报错了！！！</p><p>原因是 kotlin 的类默认是 final 的，而 Mockito 是无法 mock final 类的。</p><p>当我们给类加上 open 修饰符时，发现又出了另外一个错误，原因是 kotlin 类里面的方法也是 final 的，也没法mock，我们还要给方法加上 open 才能正常进行测试，那这样的话，我们用 Kotlin 写的代码基本就没法使用 Mockito 测试了，该怎么办呢？</p><p>###PowerMockito </p><p>powerMockito 是一个对 Mockito 增强的库，可以测试私有方法，final类等等，可以 配合Mockito 使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RunWith(PowerMockRunner::class)</span><br><span class="hljs-meta">@PowerMockRunnerDelegate(RobolectricTestRunner::class)</span><br><span class="hljs-meta">@Config(sdk = [28])</span><br><span class="hljs-meta">@PowerMockIgnore(<span class="hljs-meta-string">&quot;org.mockito.*&quot;</span>, <span class="hljs-meta-string">&quot;org.robolectric.*&quot;</span>, <span class="hljs-meta-string">&quot;android.*&quot;</span>)</span><br><span class="hljs-meta">@PrepareForTest(Server::class)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTest</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>powerMockito 的使用需要写多一点配置，具体可看官方文档。</p><p>@PowerMockIgnore 是用来忽略哪些类是不用处理的，因为 PowerMockito 使用了自己的类加载来加载所有类，而某些包里面的类也使用了别的类加载器，如果不忽略的话，就会出现 ClassCastException。</p><p>但是，使用 PowerMockito 还有一个更蛋疼的问题，当我们的代码中有 Android 代码的时候，就需要向上面的代码一样配置 PowerMockRunnerDelegate，但是我配置了之后，还是有问题（照着官方文档配置的，也不知道哪里出了问题），所以我就暂时放弃研究 PowerMockito 了。</p><h3 id="MOCKK"><a href="#MOCKK" class="headerlink" title="MOCKK"></a>MOCKK</h3><p>这个是我在搜索 kotlin 应该如何使用 Mockito 时发现的一个库，看起来比上面两个都好用，所以就研究记录一下。</p><p>我们仍然是测试LoginViewModel，看看应该如何做。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testViewModelLogin</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> loginRepository = mockk&lt;LoginRepository&gt;()<br>    <span class="hljs-keyword">val</span> loginChecker = mockk&lt;LoginChecker&gt;()<br>    <span class="hljs-keyword">val</span> loginViewModel = LoginViewModel(loginRepository, loginChecker)<br><br>    <span class="hljs-comment">// 无论参数是啥，让 loginChecker#check 返回 true</span><br>    every &#123;<br>        loginChecker.check(any(), any())<br>    &#125;.returns(<span class="hljs-literal">true</span>)<br><br>    <span class="hljs-comment">// 因為在 MockK 裡面，預設情況下 Mock 這個動作是很嚴謹的，你必須要指定所有的行為操作才行</span><br>    <span class="hljs-comment">// 因为 com.aprz.daggerexamples.ex04.LoginViewModel.login 这个操作调用到了 loginRepository 的方法</span><br>    <span class="hljs-comment">// 所以，我们必须指定该方法在什么情况下返回什么，不然会出现如下错误 ：</span><br>    <span class="hljs-comment">// io.mockk.MockKException: no answer found for: LoginRepository(#1).login(aprz512, niubi)</span><br>    every &#123; loginRepository.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>) &#125; just Runs<br><br>    loginViewModel.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)<br><br>    <span class="hljs-comment">// 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致</span><br>    verify &#123; loginChecker.check(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>) &#125;<br>    <span class="hljs-comment">// 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致</span><br>    verify &#123; loginRepository.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，基本的使用还是差不多，就是语法变化了，更加 kotlin。</p><p>运行没有出现任何问题，也不用将 class 与 方法 特地改为 open 的，但是唯一的缺点就是，我们需要手动的指定每个方法应该返回什么值。</p><p>假設今天 Class 的方法有 100 個，那豈不是要指定到天荒地老了嗎？有沒有辦法跟 Mockito 一樣不用指定行為也能做後續的 <code>verify</code> ？</p><ol><li><p>只要在 Mock 時，後面加上 <code>relaxed = true</code> 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mother = mockk&lt;LoginChecker&gt;(relaxed = <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure></li><li><p>也可以使用注解的方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RelaxedMockK</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> loginChecker: LoginChecker<br></code></pre></td></tr></table></figure><p>与 RelaxedMockK 对应的有 MockK，显然 MockK 注解不具有 （relaxed = true） 的功能。</p></li></ol><p>还有一种更细粒度的指定：对于没有返回值的函数无需显示指定，对于有返回值的函数需要手动指定。</p><ol><li><p>单个指定</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@MockK(relaxUnitFun = true)</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> loginChecker: LoginChecker<br></code></pre></td></tr></table></figure></li><li><p>全局指定</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@MockK</span><br><span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> loginChecker: LoginChecker<br><br><span class="hljs-meta">@Before</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span> &#123;<br>    MockKAnnotations.<span class="hljs-keyword">init</span>(<span class="hljs-keyword">this</span>, relaxUnitFun = <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>那，我们使用 relaxed = true 来试一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testViewModelLogin</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> loginRepository = mockk&lt;LoginRepository&gt;(relaxed = <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">val</span> loginChecker = mockk&lt;LoginChecker&gt;(relaxed = <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">val</span> loginViewModel = LoginViewModel(loginRepository, loginChecker)<br><br>    <span class="hljs-comment">// 无论参数是啥，让 loginChecker#check 返回 true</span><br>    every &#123;<br>        loginChecker.check(any(), any())<br>    &#125;.returns(<span class="hljs-literal">true</span>)<br><br>    loginViewModel.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>)<br><br>    <span class="hljs-comment">// 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致</span><br>    verify &#123; loginChecker.check(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>) &#125;<br>    <span class="hljs-comment">// 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致</span><br>    verify &#123; loginRepository.login(<span class="hljs-string">&quot;aprz512&quot;</span>, <span class="hljs-string">&quot;niubi&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，通过了测试！！！</p><h4 id="verify"><a href="#verify" class="headerlink" title="verify"></a>verify</h4><p>如果，我们<strong>想验证某个方法执行了多少次</strong>，可以这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">verify(exactly = <span class="hljs-number">0</span>) &#123; xxx &#125;<br>verify(exactly = <span class="hljs-number">10</span>) &#123; xxx &#125;<br></code></pre></td></tr></table></figure><p><code>exactly = 0</code> 代表這段方法不會被调用，<code>exactly = 10</code> 代表會被调用 10 次，其他以此類推⋯⋯</p><p>verify 代码块里面也可以放入多个语句，表示它们分别执行了 exactly 次。</p><p>还可以<strong>验证方法被调用的顺序</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">verifySequence &#123;<br>    fun1()<br>    fun2()<br>&#125;<br>verifyOrder &#123;<br>    fun1()<br>    fun2()<br>&#125;<br></code></pre></td></tr></table></figure><p>verifySequence 表示，fun2() 一定是接着 fun1()的。</p><p>verifyOrder 比较宽松，只要 fun2() 在 fun1() 后面调用就行。</p><h3 id="Capture"><a href="#Capture" class="headerlink" title="Capture"></a>Capture</h3><p>可以捕获方法的参数值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kid</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mother: Mother) &#123;<br>   <span class="hljs-keyword">var</span> money = <span class="hljs-number">0</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">wantMoney</span><span class="hljs-params">()</span></span> &#123;<br>       mother.inform(money)<br>       money += mother.giveMoney()<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mother</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inform</span><span class="hljs-params">(money: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;媽媽我現在有 <span class="hljs-variable">$money</span> 元，我要跟你拿錢！&quot;</span>)<br>    &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">giveMoney</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MotherTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@RelaxedMockK</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mother: Mother<br><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> kid: Kid<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span></span> &#123;<br>        MockKAnnotations.<span class="hljs-keyword">init</span>(<span class="hljs-keyword">this</span>)<br>        kid = Kid(mother)<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testMother</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// Given</span><br>        <span class="hljs-keyword">val</span> slot = slot&lt;<span class="hljs-built_in">Int</span>&gt;()<br>        every &#123; mother.inform(capture(slot)) &#125; just Runs<br>        <span class="hljs-comment">// When</span><br>        kid.wantMoney()<br>        <span class="hljs-comment">// Then</span><br>        assertEquals(<span class="hljs-number">0</span>, slot.captured)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们在 mother.inform(capture(slot)) 里面捕获了调用该方法的参数值，想要使用的时候，直接取就好了。</p><p>还有其他的用法，这里就不说了，请移步<a href="https://mockk.io/">官网</a>。</p><p>我们再测试，MockK配合Robolectric的使用情况。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kid</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mother: Mother) &#123;<br>    <span class="hljs-keyword">var</span> money = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">wantMoney</span><span class="hljs-params">()</span></span> &#123;<br>        mother.inform(money)<br>        money += mother.giveMoney()<br>        Log.e(<span class="hljs-string">&quot;Kid&quot;</span>, <span class="hljs-string">&quot;------&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加一个 Android 特有的 Log.e 方法，再运行发现保住了，因为 Log 没有 mock。</p><p>我们在测试类上添加代码：</p><figure class="highlight k"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs k">@RunWith(RobolectricTestRunner::class)<br>@Config(sdk = [<span class="hljs-number">28</span>])<br></code></pre></td></tr></table></figure><p>再次运行，会发现测试通过了！！！所以 MockK 与 Robolectric 配合是没有问题的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>003_单元测试中如何使用Android相关的类?</title>
    <link href="/2020/03/18/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/003_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Android%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9F/"/>
    <url>/2020/03/18/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/003_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Android%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>习惯写单元测试的人都会这样说：android unit testing不好做！！！</p><p>我们知道安卓的app需要运行在delvik上面，我们开发Android app是在JVM上面，在开发之前我们需要下载各个API-level的SDK的，下载的每个SDK都有一个android.jar的包，这些可以在你的<em>android_sdk_home</em>/platforms/下面看到。</p><p>当我们开发一个项目的时候，我们需要指定一个API-level，其实就是将对应的android.jar 加到这个项目的build path里面去。这样我们的项目就可以编译打包了。然而现在的问题是，<strong>我们的代码必须运行在emulator或者是device上面</strong>，说白了，就是我们的IDE和SDK只提供了开发和编译一个项目的环境，并没有提供运行这个项目的环境，原因是因为android.jar里面的class实现是不完整的，它们只是一些stub，如果你打开android.jar下面的代码去看看，你会发现所有的方法都只有一行实现：<br><code>throw RuntimeException(&quot;stub!!&quot;);</code> </p><p>而运行unit test，说白了还是个运行的过程，**所以如果你的unit test代码里面有android相关的代码的话，那运行的时候将会抛出RuntimeException(“stub!!”)**。</p><p>为了解决这个问题，现在业界提出了很多不同的程序架构，比如MVP、MVVM等等，这些架构的优势之一，就是将其中一层抽出来，变成pure Java实现，这样做unit testing就不会遇到上面这个问题了，因为其中没有android相关的代码。 </p><p>但是 MVP、MVVM这些架构模式虽然解决了部分问题，可以测试项目中不含android相关的类的代码，然而一个项目中还是有很大部分是android相关的代码的，所以上面那种解决方案，其实是放弃了其中一大块代码的unit test。 </p><p>当然，话说回来，android还是提供了他自己的testing framework，叫instrumentation，但是这套框架还是绕不开刚刚提到的问题，他们必须跑在emulator或者是device上面。这是个很慢的过程，因为要打包、dexing、上传到机器、运行起来界面。。。这个相信大家都有体会，尤其是项目大了以后，运行一次甚至需要一两分钟，项目小的话至少也要十几秒或几十秒。</p><p>那么怎么样即可以给android相关的代码做测试，又可以很快的运行这些测试呢？</p><h3 id="Robolectric-来也"><a href="#Robolectric-来也" class="headerlink" title="Robolectric 来也"></a>Robolectric 来也</h3><p>解决的办法就是使用一个开源的framework，叫<a href="http://robolectric.org/">robolectric</a>，他们的做法是通过实现一套JVM能运行的Android代码。</p><p>这样的话，调用 android 类就和调用普通类是一样的了。</p><h3 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h3><blockquote><p>com.aprz.daggerexamples.ex03.TipsHelper</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TipsHelper</span> <span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> status: <span class="hljs-built_in">Int</span>) &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">buildTips</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> doSomething() + LicenseStatusResouceResolver.getString(context, status)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>: String = <span class="hljs-string">&quot;doSomething&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> com.aprz.daggerexamples.ex03.LicenseStatusResourceResolver</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LicenseStatusResourceResolver</span> </span>&#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getString</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>, <span class="hljs-meta">@LicenseStatus</span> licenseStatus: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>            <span class="hljs-keyword">when</span> (licenseStatus) &#123;<br>                WILL_EXPIRE -&gt; &#123;<br>                    <span class="hljs-keyword">return</span> context.getString(R.string.license_will_expire)<br>                &#125;<br>                EXPIRED -&gt; &#123;<br>                    <span class="hljs-keyword">return</span> context.getString(R.string.license_expired)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> context.getString(R.string.unknown_error)<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> WILL_EXPIRE = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> EXPIRED = <span class="hljs-number">2</span><br><br><span class="hljs-meta">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)</span><br><span class="hljs-meta">@Retention(AnnotationRetention.SOURCE)</span><br><span class="hljs-meta">@IntDef(WILL_EXPIRE, EXPIRED)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LicenseStatus</span></span><br></code></pre></td></tr></table></figure><p>假如，让你测试一下<code>com.aprz.daggerexamples.ex03.TipsHelper#buildTips</code> 这个方法是否正常，你准备如何写做呢？</p><p>如果我们按照单元测试的写法，做测试的话，会发现一个问题，就是我们<strong>无法获取一个 Context 对象</strong>。就算我们强行创建一个对象的话，传递进去，也会报出各种错误。</p><p>但是使用了Robolectric，就可以很容易的获取 Context，甚至 Activity，还可以控制 Activity 的生命周期。</p><p>看具体代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RunWith(RobolectricTestRunner::class)</span><br><span class="hljs-meta">@Config(sdk = [28])</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TipsHelperTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> context: Context<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setupContext</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> activity = Robolectric.buildActivity(MainActivity::<span class="hljs-keyword">class</span>.java)<br>        context = activity.<span class="hljs-keyword">get</span>()<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testBuildTips</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">val</span> willExpireTips = TipsHelper(WILL_EXPIRE)<br>        assertEquals(<span class="hljs-string">&quot;doSomething您的证件即将过期！！！&quot;</span>, willExpireTips.buildTips(context))<br><br>        <span class="hljs-keyword">val</span> expiredTips = TipsHelper(EXPIRED)<br>        assertEquals(<span class="hljs-string">&quot;doSomething您的证件已过期！！！&quot;</span>, expiredTips.buildTips(context))<br><br>        <span class="hljs-keyword">val</span> unknownTips = TipsHelper(-<span class="hljs-number">1</span>)<br>        assertEquals(<span class="hljs-string">&quot;doSomething未知错误！！！&quot;</span>, unknownTips.buildTips(context))<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们在类上加了些注解。</p><p>@RunWith 表示该测试是运行在 Robolectric 的 testRunner 上的，写过 androidTest 的都知道<code>@RunWith(AndroidJUnit4::class)</code>，表示运行在 AndroidJUnit4 上。</p><p>@Config 是对 RobolectricTestRunner 的运行环境的一些配置，可以配置 sdk 等等，具体可以戳类里面进去看看。</p><p>想要获取一个 Context，有几种方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> activity = Robolectric.buildActivity(MainActivity::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><p>这可以创建出一个 MainActivity 的对象，而且它是有生命周期的。比如，我们可以调用 <code>activity.pause()</code> 方法让 activity 进入暂停状态。</p><p>当然，不要忘记Gradle配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    testOptions &#123;<br>        unitTests &#123;<br>            includeAndroidResources = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    testImplementation <span class="hljs-string">&#x27;org.robolectric:robolectric:4.3.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>想了解 Robolectric 更多的API信息，只能去<a href="http://robolectric.org/writing-a-test/">官网</a>了。就先简单的介绍到这。</p><p>最后说一下，Robolectric 到底是个啥？</p><p><strong>Robolectric就是一个能够让我们在JVM上跑测试时够调用安卓的类的框架</strong>。</p><p>在没有Robolectric的pure JUnit世界，我们是很难对一整个流程进行测试的，因为上层的界面是安卓的类，底层的数据库和SharedPreference等等是安卓的类。</p><p>然而有了robolectric以后，我们就可以这么做了：启动activity，向网络或数据库请求数据，更新界面。。。基本上覆盖的所有的逻辑。</p><p>我更倾向于使用 robolectric 做单元测试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001-做单元测试为何要使用Dagger2？</title>
    <link href="/2020/03/17/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/001-%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8Dagger2%EF%BC%9F/"/>
    <url>/2020/03/17/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/001-%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8Dagger2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>首先，我们说一下依赖注入（Dependency Injection，以下简称DI）。</p><p>为了解释以下概念，我将使用“权力的游戏”作为类比。如果你没有听说过，可以将（Targaryens和Dragons）替换为A和B。</p><p>举个例子，我们有一个叫做Targaryens的类。这个类里面用到了另一个叫做 Dragons 的类。我们称 Targaryens 依赖 Dragons 。当我们要想使用 Targaryens 类，就必须也要一个 Dragons 类，Targaryens 不能单独存在。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Targaryens</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Targaryens</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//Each  time we use Targaryens, we need to create Dragons instance</span><br>        Dragons dragons = <span class="hljs-keyword">new</span> Dragons();<br>        dragons.callForWar();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样写有什么不好的地方呢？其实会有很多问题，比如，可重用行，可维护性，但是这些问题都很模糊，没有刻骨经历过的人都是体会不到的。看了也会转头忘掉。</p><p>由于我是基于学习单元测试的原因学习的dagger，所以我就只说一点原因–可测试性。</p><p>继续上面的例子，我们想测试一下 Targaryens 的构造函数中，callForWar 方法是否被调用了一次 ：</p><p>那么我们就需要 mock 出一个 Dragons 对象来测试（这里不明白的需要先去补补 <a href="https://en.wikipedia.org/wiki/Mock_object">mock</a> 相关的东西再往下看）。现在问题就来了，就算我们 mock 出了一个 Dragons 对象出来后，怎么才能让这个 mock 对象替换构造函数里面的那个对象呢？？？这里是没法替换的！！！</p><p>由此可见，这里这样写代码的话，我们的测试很难进行下去。</p><p>那么应该如果做呢？我们可以使用<strong>构造函数注入</strong>。看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Targaryens</span> </span>&#123;<br>    <br>    Dragons dragons;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Targaryens</span><span class="hljs-params">(Dragons dragons)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dragons = dragons;<br>        dragons.callForWar();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样改写之后，我们 mock 出来的对象就可以传递到 Targaryens 中，接着就可以测试 callForWar 方法是否被正确的调用了，而且可以查看调用次数。</p><blockquote><p>假如你的代码里面，一个类用到了另外一个类，那么前者叫Client，后者叫Dependency。结合上面的例子，<code>Targaryens</code>用到了<code>Dragons</code>，那么<code>Targaryens</code>叫Client，<code>Dragons</code>叫Dependency。</p><p>当然，这是个相对的概念，一个类可以是某个类的Dependency，却是另外一个类的Client。</p><p>DI的基本思想就是，对于Dependency的创建过程，并不在Client里面进行，而是由外部创建好，然后通过某种方式set到Client里面。这种模式，就叫做依赖注入。</p><p>是的，依赖注入就是这么简单的一个概念，这边需要澄清的一点是，这个概念本身跟dagger2啊，RoboGuice这些框架并没有什么关系。现在很多介绍DI的文章往往跟dagger2是在一起的，因为dagger2的使用相对来说不是很直观，所以导致很多人认为DI是多么复杂的东西，甚至认为只能用dagger等框架来实现依赖注入，其实不是这样的。实现依赖注入很简单，dagger这些框架只是让这种实现变得<strong>更加</strong>简单，简洁，优雅而已。</p></blockquote><p>好了，了解了依赖注入之后，下面我们接着说，为何要使用 dagger 2！</p><p>依赖注入可以让我们更轻松的写单元测试（当然还有其它好处），那么有的人就会说，这很简单的，我只要遵循这个规则，永远把依赖在外部实例化，不就好了吗？为啥我要用 dagger2 呢？？</p><p>请看下面的一个例子：</p><p>假设有一个登录界面，<code>LoginActivity</code>，他有一个<code>LoginPresenter</code>，<code>LoginPresenter</code>用到了<code>UserManager</code>和<code>PasswordValidator</code>，为了让问题变得更明显一点，我们假设<code>UserManager</code>用到<code>SharedPreference</code>（用来存储一些用户的基本设置等）和<code>UserApiService</code>，而<code>UserApiService</code>又需要由<code>Retrofit</code>创建，而<code>Retrofit</code>又用到<code>OkHttpClient</code>（比如说你要自己控制timeout、cache等东西）。<br>应用DI模式，UserManager的设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SharedPreferences mPref;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserApiService mRestAdapter;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserManager</span><span class="hljs-params">(SharedPreferences preferences, UserApiService userApiService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mPref = preferences;<br>        <span class="hljs-keyword">this</span>.mRestAdapter = userApiService;<br>    &#125;<br><br>    <span class="hljs-comment">/**Other code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>LoginPresenter的设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPresenter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserManager mUserManager;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordValidator mPasswordValidator;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginPresenter</span><span class="hljs-params">(UserManager userManager, PasswordValidator passwordValidator)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mUserManager = userManager;<br>        <span class="hljs-keyword">this</span>.mPasswordValidator = passwordValidator;<br>    &#125;<br><br>    <span class="hljs-comment">/**Other code*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，最终的client LoginActivity里面要new一个presenter，需要做的事情如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> LoginPresenter mLoginPresenter;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        OkHttpClient okhttpClient = <span class="hljs-keyword">new</span> OkHttpClient.Builder()<br>                .connectTimeout(<span class="hljs-number">30</span>, TimeUnit.SECONDS)<br>                .build();<br>        Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()<br>                .client(okhttpClient)<br>                .baseUrl(<span class="hljs-string">&quot;https://api.github.com&quot;</span>)<br>                .build();<br>        UserApiService userApiService = retrofit.create(UserApiService.class);<br>        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(<span class="hljs-keyword">this</span>);<br>        UserManager userManager = <span class="hljs-keyword">new</span> UserManager(preferences, userApiService);<br><br>        PasswordValidator passwordValidator = <span class="hljs-keyword">new</span> PasswordValidator();<br>        mLoginPresenter = <span class="hljs-keyword">new</span> LoginPresenter(userManager, passwordValidator);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看到。我们想使用一个简单的 LoginPresenter ，却要实例化一大堆我们根本不关心的东西。</strong>我们遵循了依赖注入的规则，却陷入了另一个漩涡。</p><p>dagger2 就是帮助我们逃离这个漩涡的工具。大致过程是：我们提供依赖的实例化方法，dagger2会管理这些方法，当某个对象需要一个依赖时，对应的实例化方法就会被调用。这样我们就不用手动的去实例化一大堆的对象了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>002_Dagger2使用及原理（1）</title>
    <link href="/2020/03/17/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/002_Dagger2%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89/"/>
    <url>/2020/03/17/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/002_Dagger2%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>我们将上篇文章的例子用 dagger2 实现一下。</p><p>dagger2 的引入就不说了，<a href="https://github.com/google/dagger">github</a>文档很详细了。</p><p>首先我们实现 Dragons 类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dragons</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callForWar</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;EX01&quot;</span>, <span class="hljs-string">&quot;Dragons callForWar...&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看 Targaryens  类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Targaryens</span> <span class="hljs-keyword">constructor</span></span>(dragons: Dragons) &#123;<br><br>    <span class="hljs-comment">// 因为 dragons 是私有的，所以只能修饰 set 方法</span><br>    <span class="hljs-keyword">var</span> dragons = dragons<br>        <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        DaggerEx01Component.create().inject(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">war</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;EX01&quot;</span>, <span class="hljs-string">&quot;Targaryens call war...&quot;</span>)<br>        dragons.callForWar()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 @Inject 注解修饰了 dragons 变量的 set 方法，在Java里面是修饰的字段，kotlin的写法有点不一样。</p><p><code>@Inject</code> 注解是用来标记依赖的。它可以修饰字段与方法。这里表示这个字段需要注入，有点像butterknife。但是 @Inject 在不同的地方会有不同的意义，我们后面再说。</p><p>init 方法里的代码我们后面会说到。</p><p>现在，我们有了接收依赖（需要注入）的地方，那么哪里是生产依赖的地方呢？答案就是 @Module 注解了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Module</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex01Module</span> </span>&#123;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDragons</span><span class="hljs-params">()</span></span>: Dragons &#123;<br>        <span class="hljs-keyword">return</span> Dragons()<br>    &#125;<br><br>    <span class="hljs-meta">@Provides</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideTargaryens</span><span class="hljs-params">(dragons: <span class="hljs-type">Dragons</span>)</span></span>: Targaryens &#123;<br>        <span class="hljs-keyword">return</span> Targaryens(dragons)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，我们使用 @Module 修饰了这个类。类中有方法，使用 @Provides 修饰。</p><p>我们先说这个 <code>provideDragons</code> 方法的作用，显然就是提供一个 Dragons 的实例。看到这里，我们就立刻明白这里是生产依赖的地方。</p><p><code>provideTargaryens</code> 提供一个 Targaryens 实例，这个方法很重要。因为上一篇文章，我们说过，如果每次创建一个 Targaryens 实例的时候，还要自己去创建一个 Dragons 实例，那写起代码来就很痛苦了。那么怎么办呢？办法就是把这种麻烦事交给 Dagger2 。</p><p>这里我们提供一个创建 Targaryens 实例的方法，这个方法需要一个 Dragons 作为参数，神奇的是，Dagger2 会自动使用 <code> provideDragons</code> 创建 Dragons 实例。所以这个 <code>provideTargaryens</code> 方法不是给我们使用的，而是给 Dagger2 用的。那么我们怎么从 Dagger2 获取 Targaryens 实例呢？后面再说。</p><p>可以想象一下，一个接收，一个生产，这两处地方，需要有一根线将它们连接起来，才能正常工作。</p><p>那么，怎么牵这根线呢？？？答案是使用 @Component 注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component(modules = [Ex01Module::class])</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Ex01Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inject</span><span class="hljs-params">(targaryens: <span class="hljs-type">Targaryens</span>)</span></span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newTargaryens</span><span class="hljs-params">()</span></span>: Targaryens<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，Ex01Component 是<strong>一个接口</strong>，不是一个类！！！</p><p>@Component 注解可以设置参数值，是一个数组，里面是 class 值。我们传递了 Ex01Module 的 class 进去，这样就将 Module 连起来了。</p><p>接口里面有一个方法，这个方法相当于一个定义，因为我们要给 Targaryens 类的字段赋值，所以必须要声明一个方法。实际上，写完这个接口之后，对应的生成类就会生成了：</p><blockquote><p>com.aprz.daggerexamples.ex01.DaggerEx01Component</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaggerEx01Component</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ex01Component</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Ex01Module ex01Module;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DaggerEx01Component</span><span class="hljs-params">(Ex01Module ex01ModuleParam)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.ex01Module = ex01ModuleParam;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Builder <span class="hljs-title">builder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Ex01Component <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Builder().build();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Targaryens targaryens)</span> </span>&#123;<br>    injectTargaryens(targaryens);&#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Targaryens <span class="hljs-title">newTargaryens</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Ex01Module_ProvideTargaryensFactory.provideTargaryens(ex01Module, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));&#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> Targaryens <span class="hljs-title">injectTargaryens</span><span class="hljs-params">(Targaryens instance)</span> </span>&#123;<br>    Targaryens_MembersInjector.injectSetDragons(instance, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));<br>    <span class="hljs-keyword">return</span> instance;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Ex01Module ex01Module;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">ex01Module</span><span class="hljs-params">(Ex01Module ex01Module)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.ex01Module = Preconditions.checkNotNull(ex01Module);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Ex01Component <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (ex01Module == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">this</span>.ex01Module = <span class="hljs-keyword">new</span> Ex01Module();<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DaggerEx01Component(ex01Module);<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个类很简单，里面有一个 Builder 类。但是一般我们不需要使用，因为这个类又提供了一个 create 方法，将Builder 又简化了。我们可以直接使用这个方法。</p><p>DaggerEx01Component类实现了 Ex01Component，我们看它的 inject 方法是做了什么。</p><blockquote><p>com.aprz.daggerexamples.ex01.DaggerEx01Component#inject</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inject</span><span class="hljs-params">(Targaryens targaryens)</span> </span>&#123;<br>  injectTargaryens(targaryens);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Targaryens <span class="hljs-title">injectTargaryens</span><span class="hljs-params">(Targaryens instance)</span> </span>&#123;<br>  Targaryens_MembersInjector.injectSetDragons(instance, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法都很短，一看就明白，这里调用了 MembersInjector 类，一看就是给字段注入值。</p><blockquote><p>com.aprz.daggerexamples.ex01.Targaryens_MembersInjector#injectSetDragons</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectSetDragons</span><span class="hljs-params">(Targaryens instance, Dragons p0)</span> </span>&#123;<br>  instance.setDragons(p0);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法很简单，就是直接调用 set 方法就好了。</p><p>这里我没有看 Java 生成类是不是一样的，因为 Java 要求待注入的字段不能是私有的，所以是通过在同包下直接调用类的字段赋值，和 butterKnife 一样。</p><p>还有一个方法 :</p><blockquote><p>com.aprz.daggerexamples.ex01.DaggerEx01Component#newTargaryens</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Targaryens newTargaryens() &#123;<br>  <span class="hljs-keyword">return</span> Ex01Module_ProvideTargaryensFactory.provideTargaryens(ex01Module, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));&#125;<br></code></pre></td></tr></table></figure><p>这个就更简单了，其实就是调用了 Module 的 provide 方法创建了 Targaryens。可以看到，Dragons 也是由 Module 创建的。</p><p>到这里，基本就分析完了 dagger 最简单的运作原理。还是还有两个个地方。</p><p>第一个地方就是 <code>com.aprz.daggerexamples.ex01.DaggerEx01Component#inject</code> 这个方法应该在哪里调用呢？因为只有调用了这个方法，才算真正的赋值了。</p><p>因为 inject 方法需要一个 Targaryens 类的实例，所以，你可以在访问到该实例的任何地方调用。但是我们最好写在类里面，这样就不用没有实例都调用一遍，具体看上面的 Targaryens 类的 init 方法里面。</p><p>第二个地方是，如何获取 Targaryens 对象呢？显然是需要从 Component 里面获取。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> targaryens = DaggerEx01Component.create().newTargaryens()<br>targaryens.war()<br></code></pre></td></tr></table></figure><p>Dagger2 其实还有另外一种使用方式，不使用 Module 的方式。</p><blockquote><p>com.aprz.daggerexamples.ex02.Dragons2</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dragons2</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">callForWar</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;EX02&quot;</span>, <span class="hljs-string">&quot;Dragons callForWar...&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里与上面的不同之处，我们使用 @Inject 修饰了它的构造函数。</p><blockquote><p>com.aprz.daggerexamples.ex02.Ex02Component</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component(modules = [])</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Ex02Component</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inject</span><span class="hljs-params">(targaryens2: <span class="hljs-type">Targaryens2</span>)</span></span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们没有使用Module，所以不用传值，</p><blockquote><p>com.aprz.daggerexamples.ex02.Targaryens2</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Targaryens2</span> </span>&#123;<br><br>    <span class="hljs-comment">// 直接标注属性@Inject lateinit var car: Car，编译时会报错</span><br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> dragons: Dragons2<br>        <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        DaggerEx02Component.create().inject(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">war</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;EX02&quot;</span>,<span class="hljs-string">&quot;Targaryens call war...&quot;</span>)<br>        dragons.callForWar()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里与之前代码一样。</p><p>可以看到，实际上，我们使用 @Inject 修饰构造函数的方法，代替了 @Module，少写了不少东西。</p><p>我们再看看生成的类，其中的不同之处在于：</p><blockquote><p>com.aprz.daggerexamples.ex02.DaggerEx02Component#injectTargaryens2</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> Targaryens2 injectTargaryens2(Targaryens2 instance) &#123;<br>  Targaryens2_MembersInjector.injectSetDragons(instance, new Dragons2());<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是直接调用了 Dragons2 的构造函数，而 Module 写法是调用了 Module 类的 provide 方法。</p><p>所以有两种写法，这两种写法是可以配合使用的，看需要选择使用。</p><p>说明一下，这里如果我们使用的是 @Inject 修饰构造函数的方式，那么我们想 mock Dragons2 对象还是比较蛋疼的。但是我们可以取巧，我们直接 new 一个 Targaryens2 对象，mock 一个 Dragons2 对象出来，然后调用set方法设置进去就行了，但是这也只能对 kotlin 起作用，因为 java 不会自动生成 set 方法。所以最好还是使用 Module。</p><p>最后再总结一下各个注解的作用：</p><p>@Inject 是用来标记依赖的（修饰字段是表示该字段要被注入依赖实例，修饰构造函数是）。</p><p>@Module 是用来给 Dagger2 自己使用的，创建依赖图的。</p><p>@Component 是用来给开发者使用的，它的生成类实现了我们定义的接口，用于我们的开发。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>000_Android单元测试系列文章介绍</title>
    <link href="/2020/03/16/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/000-Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    <url>/2020/03/16/blog_bak/Blog/Android-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/000-Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>最近主要在看关于代码风格与设计方面的书，它们都提到了TDD，然而从业这么多年，我却没有用到过。不得不说有点沮丧，所谓知耻而后勇，所以我准备看一下单元测试的系列教程，然后在以后的工作中慢慢实现TDD。下面的这个系列是最符合我口味的文章，所以我决定将链接搬过来。</p><p>以下这个片段是最能触动我学习TDD的，先贴在这里，如果你也觉得说的不错，不妨再深入看看。</p><blockquote><h2 id="我为什么写单元测试"><a href="#我为什么写单元测试" class="headerlink" title="我为什么写单元测试"></a>我为什么写单元测试</h2><h3 id="首先，是因为我不够自信"><a href="#首先，是因为我不够自信" class="headerlink" title="首先，是因为我不够自信"></a>首先，是因为我不够自信</h3><p>我相信大家都有接手，或者说参与到一个新项目的经历，也许是因为换了工作，也许是因为职位调动，或其他原因。当我拿到一个新项目的时候，会有一种诚惶诚恐的感觉，因为一时间比较难理清楚整个app的结构是怎么划分的，各部分各模块之间又是什么样的关系。我怕我改了某一个地方，结果其他一个莫名其妙的地方的受到了影响，然后导致了一个bug。这对于用户群大的app，尤其严重。所以，那种时候就会希望，如果我改了某个地方，能有个东西告诉我，这个改动影响到哪些地方，这样改是不是有问题的，会不会导致bug。虽然我可以把app启动起来，看看是不是能正常工作，然而一种case能工作，并不代表所有影响到的case都能工作。尤其是在不知道有哪些地方用到了的情况下，我更加难以去遍历所有用到的地方，一个一个去验证这个改动有没有问题。哪怕我知道所有的case，这也是一个很痛苦很费时间的过程，而且很多的外部条件也很难满足，比如说需要什么样的网络条件，需要用户是会员等等。<br>在这种情况下，单元测试是才是最好的工具。首先，单元测试只是针对一个代码单元写的测试，保证一个代码单元的正确性总比保证整个app的正确性容易吧？遍历一个方法的所有参数和输出情况总比遍历一个app的所有用户场景容易吧？跑一次单元测试总比运行一次app快吧？<br>因此，在改现有的代码之前，我会先对要改的代码单元做好隔离，写好测试，再去改，改好以后跑一边单元测试，验证他们依然是通过的，这时候我才有信心，将代码合并进去。<br>同样的情况会发生在重构的时候，我是一个对烂代码不大有忍受能力的人，看到不好的代码，我会忍不住想要去重构，不然的话，没有办法写新的代码。而重构就会有风险。因为我不够自信，重构的时候，也会有一种诚惶诚恐的感觉。这时候如果有完备的单元测试的话，我就能知道我的这次重构到底破坏了哪些地方，是不是对的，这样相对来说，就会放心的多了。<br>因此，想用单元测试来保证代码的正确性，这个是我喜欢写单元测试的重要原因之一。</p><h3 id="再次，是因为我没有耐心"><a href="#再次，是因为我没有耐心" class="headerlink" title="再次，是因为我没有耐心"></a>再次，是因为我没有耐心</h3><p>对于有一定经验，有一定代码思想的人来说，当他拿到一个新的需求，他会先想想代码的结构，应该有那些类，那些组件，什么责任应该划分到哪里去，然后才开始动手写代码，这个是很自然的一个思维过程。然而在不写单元测试的情况下，我们可能要把整个feature都做完整，从model到controller(或Presenter、ViewModel）到view到util等等，一整套流程做下来，到最后才可能运行起来看看是不是对的，有的时候哪怕所有代码都写完了，也不一定能验证是不是对的，比如说后台还没有ready等等。总之，在没有单元测试的情况下，我们需要等到最后一刻才能手动验证代码是不是对的，然后发现原来这里错了一点，那里少了一点，然后一遍一遍的把app运行起来，改一点运行一遍。。。<br>当我开始写单元测试之后，我发现这个过程实在是太漫长了，我喜欢写完一部分功能独立的代码，就能立刻看到他们是不是正确的。如果不是的话，我可以立刻就改正，而不用等到所有代码都写完整。要达到这点，那就只有写单元测试了。<br>当然，哪怕有单元测试，最后还是要做一遍手动测试工作，然而因为前面我已经保证每一个单元都是对的，最后只不过是验证每一部分都是正确的串联起来了而已，这点相对来说，是很容易的。所以最后所需要的手动测试，可以少很多，顺利很多，也简单得多。</p><h3 id="最后，是因为我懒"><a href="#最后，是因为我懒" class="headerlink" title="最后，是因为我懒"></a>最后，是因为我懒</h3><p>如前所述，如果没有单元测试的话，那就只有手工测试，把app运行起来，如果有错的话，改一点东西，再运行起来。。。这个过程太漫长太痛苦，对于一个很懒的人来说，如果能写代码来代替手工测试，每次写完代码只需要按一次快捷键，就可以直接在IDE里面看到结果，那是多爽的一件事！所以冲着这点，我也不想回头。<br>我记得上一次使用“把app运行起来”这种开发方式，还是因为调试一个动画效果。因为动画效果是很难单元测试的，那就只有改一点代码，跑一边app，觉得不对，再改一点，跑一边，这样来来回回反反复复，那感觉真是。。。</p></blockquote><blockquote><h2 id="单元测试给我带来了什么"><a href="#单元测试给我带来了什么" class="headerlink" title="单元测试给我带来了什么"></a>单元测试给我带来了什么</h2><h3 id="更好的设计"><a href="#更好的设计" class="headerlink" title="更好的设计"></a>更好的设计</h3><p>当你为自己的代码写单元测试的时候，尤其是采用<a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a>的方式，你会很自觉地把每个类写的比较小，功能单一，这是软件设计里面很重要的<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a>原则。此外，你能把每个功能职责分配的很清楚，而不是把一堆代码都塞到一个类里面（比如Activity）。你会不自觉的更偏向于采用组合，而不是继承的方式去写代码。这些都是很好的一些代码实践。<br>至于为什么TDD能够改善代码的设计，网上有很多的文章去分析和论证这个结论。我看到比较印象深刻的一句话是（具体在哪看的搜不出来了）：当你TDD的时候，你是从一开始，就从一个代码的使用者，或者说维护者的角度，去写你的代码。这样写出来的代码，自然会有更好的设计。</p></blockquote><p>其实仅凭这一点，我就有足够的理由去学习TDD，在我优化自己的代码的过程中，无论如何处理，都会感觉自己处于一个瓶颈状态。而TDD刚好可以让我从使用者的角度来看待自己的代码，这是一个非常好的优化角度。</p><p><a href="https://chriszou.com/2016/04/13/android-unit-testing-start-from-what.html">Android单元测试（一）：首先，从是什么开始</a></p><p><a href="https://chriszou.com/2016/04/16/android-unit-testing-about-why.html">Android单元测试（二）：再来谈谈为什么</a></p><p><a href="https://chriszou.com/2016/04/18/android-unit-testing-junit.html">Android单元测试（三）：JUnit单元测试框架的使用</a></p><p><a href="https://chriszou.com/2016/04/25/android-unit-testing-wechat-group-share.html">Android单元测试在蘑菇街支付金融部门的实践</a></p><p>再往后面学习，可能需要<a href="https://github.com/google/dagger">Dragger2</a>、<a href="http://robolectric.org/">Robolectric</a>、<a href="http://mockito.org/">Mockito</a>相关的知识，后面的文章也会讲到，不用太过担心，但是还是建议系列学习一下。</p><p>Mockito 的 kotlin 版本，<a href="https://mockk.io/">MockK</a> 系列文章：</p><p><a href="%5Bhttps://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-1-4-39a85e42b8%5D(https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-1-4-39a85e42b8)">MockK：一款強大的 Kotlin Mocking Library (Part 1 / 4)</a></p><p><a href="%5Bhttps://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-2-4-4be059331110%5D(https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-2-4-4be059331110)">MockK：一款強大的 Kotlin Mocking Library (Part 2 / 4)</a></p><p><a href="%5Bhttps://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-3-4-79b40fb73964%5D(https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-3-4-79b40fb73964)">MockK：一款強大的 Kotlin Mocking Library (Part 3 / 4)</a></p><p><a href="%5Bhttps://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-4-4-f82443848a3a%5D(https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-4-4-f82443848a3a)">MockK：一款強大的 Kotlin Mocking Library (Part 4 / 4)</a></p><p>学完这个系列，对 Mock 应该就有自己的理解了。继续单元测试系列。</p><p><a href="https://chriszou.com/2016/04/29/android-unit-testing-mockito.html">Android单元测试（四）：Mock以及Mockito的使用</a></p><p><a href="https://chriszou.com/2016/05/06/android-unit-testing-di.html">Android单元测试（五）：依赖注入，将mock方便的用起来</a></p><p><a href="https://chriszou.com/2016/05/10/android-unit-testing-di-dagger.html">Android单元测试（六）：使用dagger2来做依赖注入，以及在单元测试中的应用</a></p><p><a href="https://chriszou.com/2016/06/05/robolectric-android-on-jvm.html">Android单元测试（七）：Robolectric，在JVM上调用安卓的类</a></p><p>看完了上面7篇文章，就可以写一些基本的测试了。但是还有一些高级用法可能不知道，下面开始介绍。</p><p><a href="https://chriszou.com/2016/07/09/junit-rule.html">Android单元测试（八）：Junit Rule的使用</a></p><p><a href="https://chriszou.com/2016/07/16/mockito-annotation.html">Android单元测试（九）：使用Mockito Annotation快速创建Mock</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment框架总览</title>
    <link href="/2020/01/01/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Fragment%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88/"/>
    <url>/2020/01/01/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Fragment%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>在做一个图片尺寸检查框架的时候，需要研究Activity与Fragment相关的源码，之前每次都分析过，但是却没有一个总体的影响，每次想要找一个什么东西的时候，都不得不从头找起，很蛋疼。</p><p>这篇文章的作用就是整理出一个Fragment的轮廓，Fragment大概会涉及一些什么东西。</p><p>首先，我们使用Fragment的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getSupportFragmentManager()<br>    .beginTransaction()<br>    .add(R.id.container, <span class="hljs-keyword">new</span> MyFragment())<br>    .commit();<br></code></pre></td></tr></table></figure><p>上面的代码中，getSupportFragmentManager 其实是调用的 FragmentController 类的方法。</p><h3 id="FragmentController"><a href="#FragmentController" class="headerlink" title="FragmentController"></a>FragmentController</h3><p>这里就出现了第一个需要了解的类：<strong>FragmentController</strong>.</p><p>了解一个类最好的方法就是看它的结构：</p><p><img src="fragment_01.png"></p><p>我们顺便点个方法进去看：</p><blockquote><p>android.app.FragmentController#onCreateView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mHost.mFragmentManager.onCreateView(parent, name, context, attrs);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>android.app.FragmentController#dispatchCreate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    mHost.mFragmentManager.dispatchCreate();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这些方法都是转发给了 mFragmentManager。mFragmentManager 是一个 FragmentManagerImpl 对象。</p><p>除了这个 <strong>FragmentManagerImpl</strong> ，还有一个需要注意的地方，就是那个 <strong>mHost</strong> 变量。mFragmentManager 也是通过它调用的。</p><p>我们看一下构造函数：</p><blockquote><p>android.app.FragmentController#FragmentController</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FragmentController</span><span class="hljs-params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;<br>    mHost = callbacks;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FragmentController <span class="hljs-title">createController</span><span class="hljs-params">(FragmentHostCallback&lt;?&gt; callbacks)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FragmentController(callbacks);<br>&#125;<br></code></pre></td></tr></table></figure><p>mHost 是传递进来的。搜索一下调用的地方，发现只有Activity调用。Activity 有个成员变量：</p><blockquote><p>android.app.Activity#mFragments</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> FragmentController mFragments = FragmentController.createController(<span class="hljs-keyword">new</span> HostCallbacks());<br></code></pre></td></tr></table></figure><p>所以，FragmentController 的 mHost 变量就是这里创建并传递进去的 HostCallbacks 了。</p><h3 id="HostCallbacks"><a href="#HostCallbacks" class="headerlink" title="HostCallbacks"></a>HostCallbacks</h3><p>HostCallbacks 是 Activity 的内部类，它的作用就和名字一样，是宿主的回调接口。</p><p>对于 Fragment 来说，Activity 就是宿主，这个类的作用，就是 Fragment 回调 Activity 方法的一个类。比如这个方法：</p><blockquote><p>android.app.Activity.HostCallbacks#onStartActivityFromFragment</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartActivityFromFragment</span><span class="hljs-params">(Fragment fragment, Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;<br>    Activity.<span class="hljs-keyword">this</span>.startActivityFromFragment(fragment, intent, requestCode, options);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，就是调用了 activity 的方法。</p><p>Activity，FragmentController，HostCallbacks 3个类的关系如下：</p><p><img src="fragment_02.png"></p><h3 id="FragmentManager"><a href="#FragmentManager" class="headerlink" title="FragmentManager"></a>FragmentManager</h3><p>我们平常操作 <code>fragment</code> 所调用的 <code>getSupportFragmentManager()</code> 返回的就是 <code>FragmentManager</code>对象。<code>FragmentManagerImpl</code> 是 <code>FragmentManager</code> 的一个实现类。</p><p><code>FragmentManager</code>是 fragment 的管理者，负责添加、删除、替换 fragment 等一些操作。</p><p>FragmentManager 做的一些操作，都是模仿数据库的，它会开启一个事务。实现这个事务的类叫做<code>BackStackRecord</code>。这个类不难，其实里面就是一个 ArrayList，然后将各种操作封装为 Op。事务就是将各种操作集合起来，然后一起执行。所以这个类的作用，就是将各种Op放到ArrayList里面，然后循环取出来执行。</p><p>最后，commit的时候，会调用到下面的这个方法：</p><blockquote><p>androidx.fragment.app.BackStackRecord#executeOps</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the operations contained within this transaction. The Fragment states will only</span><br><span class="hljs-comment"> * be modified if optimizations are not allowed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">executeOps</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> numOps = mOps.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> opNum = <span class="hljs-number">0</span>; opNum &lt; numOps; opNum++) &#123;<br>        <span class="hljs-keyword">final</span> Op op = mOps.get(opNum);<br>        <span class="hljs-keyword">final</span> Fragment f = op.fragment;<br>        <span class="hljs-keyword">if</span> (f != <span class="hljs-keyword">null</span>) &#123;<br>            f.setNextTransition(mTransition, mTransitionStyle);<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (op.cmd) &#123;<br>            <span class="hljs-keyword">case</span> OP_ADD:<br>                f.setNextAnim(op.enterAnim);<br>                mManager.addFragment(f, <span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_REMOVE:<br>                f.setNextAnim(op.exitAnim);<br>                mManager.removeFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_HIDE:<br>                f.setNextAnim(op.exitAnim);<br>                mManager.hideFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SHOW:<br>                f.setNextAnim(op.enterAnim);<br>                mManager.showFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_DETACH:<br>                f.setNextAnim(op.exitAnim);<br>                mManager.detachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_ATTACH:<br>                f.setNextAnim(op.enterAnim);<br>                mManager.attachFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_SET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(f);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> OP_UNSET_PRIMARY_NAV:<br>                mManager.setPrimaryNavigationFragment(<span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unknown cmd: &quot;</span> + op.cmd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!mReorderingAllowed &amp;&amp; op.cmd != OP_ADD &amp;&amp; f != <span class="hljs-keyword">null</span>) &#123;<br>            mManager.moveFragmentToExpectedState(f);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!mReorderingAllowed) &#123;<br>        <span class="hljs-comment">// Added fragments are added at the end to comply with prior behavior.</span><br>        mManager.moveToState(mManager.mCurState, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法里面就可以看到操纵 Fragment 的一些方法。然后这个方法里面又调用了另外一个很重要的方法：</p><blockquote><p>androidx.fragment.app.FragmentManagerImpl#moveToState(androidx.fragment.app.Fragment, int, int, int, boolean)</p></blockquote><p>在这个方法里面，就有涉及到触发 fragment 生命周期的方法。比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> Fragment.CREATED:<br><span class="hljs-keyword">if</span> (newState &gt; Fragment.CREATED) &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;moveto ACTIVITY_CREATED: &quot;</span> + f);<br>    <span class="hljs-keyword">if</span> (!f.mFromLayout) &#123;<br>        ViewGroup container = <span class="hljs-keyword">null</span>;<br>        ...<br>        f.mContainer = container;<br>        f.performCreateView(f.performGetLayoutInflater(<br>            f.mSavedFragmentState), container, f.mSavedFragmentState);<br><br></code></pre></td></tr></table></figure><p>这里就是调用 Fragment 的 onCreateView 方法的地方了，还有就是可以看到 inflater 的由来。</p><p>整体类图关系图如下：</p><p><img src="fragment_03.png"></p>]]></content>
    
    
    <categories>
      
      <category>Android-源码解析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0031-串</title>
    <link href="/2019/10/12/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0031-%E4%B8%B2/"/>
    <url>/2019/10/12/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0031-%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>想不到，一个国庆能让我断更20天，除了国庆9天左右的假期之外，还有11天居然什么都没做。其实也不算什么都没做，之不过是看 KMP 算法的时候卡住了，花了 4、5 天左右才真正的理解，当然还有 6、7 天我也不知道我为啥没有继续写笔记</p><p>这里仅为反思一下，不期望起任何作用，但作为一个开头，还是挺不错的，因为串本身没啥可以讲的。</p><p>在 Java 语言中，串就是 String 类型的变量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String hello1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br>String hello2 = <span class="hljs-string">&quot;你好&quot;</span>;<br></code></pre></td></tr></table></figure><p>String 与基本类型一样，都是 Java 内置的类型，足以说明它有多么重要。</p><h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><p>串一般都采用顺序储存，虽然有着空间限制，但是可以接受。如果采用链式储存的话，空间利用率太低了，因为一个界面除了储存了串的一个字符，还要储存一个指针，而且表示节点的这个对象，也要额外占用空间，再加上补齐之类的消耗，空间利用率实在是低得很。</p><h2 id="搜索匹配情景"><a href="#搜索匹配情景" class="headerlink" title="搜索匹配情景"></a>搜索匹配情景</h2><p>通常我们再看一个文档、网页之类的东西的时候，都希望它有一个检索的功能。比如我常常在 github 上的源码网页上搜索一些方法。</p><p>这个情景简化一下，其实就是在一个大的字符串（将源码当作一个大的有很多换行与空格的字符串）里面找一个特定的小字符串（我们要搜索的字符串）。</p><p>遇到这种字符串匹配的功能，应该如何做呢？</p><p>最简单的就是暴力匹配，从头开始一个一个的匹配，String 类自带的 indexOf 方法就是这样实现的。写两个循环就搞定了。</p><p>但是这个算法显然是不太高效的，那么有没有更好的算法呢？显然是有的，就是 KMP 算法了，下节介绍。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0032-KMP算法</title>
    <link href="/2019/10/12/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0032-KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2019/10/12/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0032-KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>KMP 算法并不是从一个全新的角度来思考字符串如何匹配会更快，它仍然是一个一个的比较两个字符串是否相等，但是它去除了暴力比较过程中一些无用的比较过程。</p><p>那我们自己举例，假设让你取寻找一个大的字符串中，是否有某一个特定的字串，我们也是从头开始寻找，这符合人的认知，算法也是人写出来的，所以这个思路是不会变的。</p><p>KMP 算法之所以高效，是因为它做了很多改进。我们一点一点来说明。</p><blockquote><p>下面的内容</p><p>主串代表前面例子中的源码</p><p>子串代表我们需要搜索的字符串</p><p>忽略主串与字串之间的空格，这个是为了更好看</p></blockquote><p>假设，我有这样的一个主串[aaa aaa aaa b]，和子串[aaa aaa aab]，它们看起来极为相似。如果让我们来判断是否有匹配的，我们应该一眼就能看出来，确实是有匹配的，主串截取[1, n]，就是与子串匹配的。</p><p>注意上面，我的说话，是<strong>一眼就看出来的</strong>，虽然我们大脑运作的很快，但是在你思考事情的时候，你应该知道你想了哪些步骤，与 O(n) 的考量一样，我们不关心你思考的速度，只关心你思考了几个步骤。</p><p>我想你一定没有傻乎乎的去一个一个去匹配，这需要归功于这个子串很简单，简单到我们能记住，所以我们才不会去一个一个的对着子串去和主串匹配。</p><p>那么这个时候，我们的大脑究竟做了什么呢？你可以先自己仔细想一想！</p><p>下面，我们再举一个例子：</p><p>假设，我有这样的一个主串[ababbababa]，和子串[ababa]。</p><p>我们先不考虑算法，而是用我们的脑子来找出主串里面是否包含子串。当我们匹配到第5个字符的时候，发现不一样了，这个时候我们该怎么做呢？？？</p><p>一般人的做法是，回到主串的第二个字符，再次比较字串。这种做法是什么？暴力匹配。是效率很低的！！！那么应该怎么做呢？</p><p>我们观察一下我们已经匹配过的串[abab]，发现什么没有，这个串是对称的（<strong>这里的对称是 ab ab 这样的对称，不是镜像对称</strong>）。那么对称能怎么样呢？</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp_3.png?raw=true"></p><p>上面的图中说的很清楚了，有了对称性，我们可以省不少事，至少不用回溯。我们可以从主串的第5个字符开始，直接与字串的第3个字符比较。</p><p>我们总结一下经验，发现只要我们匹配过的串是对阵的，我们就可以不用主串，那么发现匹配过的不对称，该怎么办呢？</p><p>这里就需要另外一个技巧了，这个技巧需要极强的记忆力。我们将主串的每一处的对称性都记录下来。当发现不对称了，我们就递归的回溯，直到找到对称的：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kmp_5.png?raw=true"></p><p>其实，最终就是找到 j 应该指向i的位置。</p><p>上面所说的就是 KMP 的主要思想了。了解了这个思想，我们再来看看算法的实现。</p><p>我们先看这一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * p, <span class="hljs-keyword">int</span> * next)</span></span><br><span class="hljs-function"></span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;<br> <br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">strlen</span>(p))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])<br>        &#123;<br>            ++i;<br>            ++j;<br>            next[i] = j;<br>        &#125;  <br>        <span class="hljs-keyword">else</span><br>            j = next[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你能看出这个函数做了什么吗？这个函数其实就是使用 next 数组记录了主串从[0, i]的每个位置有多长是对称的。</p><p><strong>当 p[i] == p[j] 说明[0, i]这个串两端有字符相等的，又因为 p[i] != p[j] 的时候，j 被重置过了，所以可以保证此时[0, i] 的两头是对称的。</strong></p><p>那么，我们之后，就可以直接使用这个数组来进行判断了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String main,String model,<span class="hljs-keyword">int</span>[] next)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;main.length()&amp;&amp;j&lt;model.length())&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">-1</span>==j||main.charAt(i) == model.charAt(j))&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//不相等,滑动</span><br>            j = next[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j==model.length())&#123;<br>        <span class="hljs-comment">//如果最后j到达模式串的尾部,则说明匹配上了</span><br>        <span class="hljs-keyword">return</span> i - j;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就搞定了，是不是很简单呢！</p><p>上面的算法是我copy的，不保证能正确运行，只是我看了没发现什么问题就直接用了。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Annotation Processor 的应用</title>
    <link href="/2019/09/29/blog_bak/Blog/Java/Annotation-Processor-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2019/09/29/blog_bak/Blog/Java/Annotation-Processor-%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>作为一个程序员，每天的生活都是平淡而且枯燥。先开需求会，再来画界面。画着画着，突然感觉有点不对劲，以前画个界面不应该这么麻烦的，不知道是不是错觉，感觉使用了 ConstraintLayout 之后，画个界面越来越慢了。</p><p>说到这里不得不吐槽一下，ConstraintLayout 虽然减少 了层级，但是阅读单独上升了不少，特比是对于刚接触的人来说，一个那么复杂的布局，就一层，里面十几个控件，位置乱放，毫无顺序，你要是不点一下右边的预览视图来看看它们之间的关系，根本看不懂。真希望谷歌出一个容器，将子控件可以包一下，但是却不参加编译。</p><p>画完了界面，就要开始写逻辑，有网络请求的页面，比如详情页面，应该还是要保存一下请求详情接口的 id 才行。</p><h2 id="DetailActivity"><a href="#DetailActivity" class="headerlink" title="DetailActivity"></a>DetailActivity</h2><p>于是就有了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。</span><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleIntent</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.handleIntent(intent, savedInstanceState);<br>       <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>           mId = savedInstanceState.getLong(KEY_ID);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span>) &#123;<br>           mId = intent.getLongExtra(KEY_ID, -<span class="hljs-number">1L</span>);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>       outState.putLong(KEY_ID, mId);<br>   &#125;<br></code></pre></td></tr></table></figure><p>这都不知道是我多少次写这样的代码了，写完之后，终于受不了了，先将需求（不多）抛在一遍，想办法将这些重复的东西搞一搞。</p><h2 id="BaseActivity"><a href="#BaseActivity" class="headerlink" title="BaseActivity"></a>BaseActivity</h2><p>首先，将 if - else if 封装一下再说，于是 Base 里面就多了一些下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSavedInt</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState, String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getSavedInt(intent, savedInstanceState, key, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSavedInt</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState, String key, <span class="hljs-keyword">int</span> defaultValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> savedInstanceState.getInt(key, defaultValue);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> intent.getIntExtra(key, defaultValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> defaultValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只列出了针对 int 的，当然还有其他类型的，按需添加。</p><h2 id="SavedFieldHandler"><a href="#SavedFieldHandler" class="headerlink" title="SavedFieldHandler"></a>SavedFieldHandler</h2><p>但是再一想，这个玩意虽然只在 Activity 里面用到，但是抽成一个工具类会不会更好一点，于是就有了一个工具类：</p><blockquote><p>SavedFieldHandler</p><p>将 Base 里面添加的方法，改为 public static 的，放入工具类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSavedInt</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState, String key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getSavedInt(intent, savedInstanceState, key, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSavedInt</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState, String key, <span class="hljs-keyword">int</span> defaultValue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> savedInstanceState.getInt(key, defaultValue);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> intent.getIntExtra(key, defaultValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> defaultValue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DetailActivity-1"><a href="#DetailActivity-1" class="headerlink" title="DetailActivity"></a>DetailActivity</h2><p>于是，我们的 Activity 里面的代码，就变成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。</span><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleIntent</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.handleIntent(intent, savedInstanceState);<br>       SavedFieldHandler.getSavedLong(intent, savedInstanceState, KEY_ID, <span class="hljs-number">0L</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>       outState.putLong(KEY_ID, mId);<br>   &#125;<br></code></pre></td></tr></table></figure><p>看起来舒服了一点，但是每次复写这两个方法也很烦。再仔细观察一下这两个方法，其实就是 key 不一样，然后由于储存的类型不一样，所以调用的 get put 方法名也不一样。</p><p>那么，如果将这两个方法往上浮到 BaseActivity 里面，需要做一些什么呢？</p><p>我们需要知道 <strong>字段的值</strong>，与<strong>字段对应的 KEY</strong>。那么怎么才能获取这两个东西呢？想一下，似乎直接获取有点难度，那么加点辅助信息呢，比如说注解，我们定义一个这样的注解：</p><blockquote><p>SaveField</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SaveField &#123;<br>    <span class="hljs-function">String <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">defaultValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>key() 方法表示 <strong>字段对应的 KEY</strong>。defaultValue() 方法表示 <strong>字段的值</strong>。然后我们使用反射可以获取被该注解修饰的字段的值，嗯，完美。</p><p>当我准备开始写代码的时候，突然感觉哪里不对劲，值有问题，如果我是一个 long 型的变量的话，那岂不是还需要调用 Long.parseLong 方法转一下，而且，我们写 long 型值的时候，都习惯添加一个 L 在后面的，比如：long x = 3L; ，为了兼容这样的情况，我特么不是要做的判断更多了。</p><p>想到长痛不如短痛，多做几个判断就多做几个吧。我灵光一现，既然一个注解搞不定，那多搞几个注解不就好了，于是下面的注解就出现了：</p><blockquote><p>FloatSavedField</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FloatSavedField &#123;<br>    <span class="hljs-function">String <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">defaultValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Retention 一定要是 RetentionPolicy.RUNTIME，因为要在反射的时候获取。</p><p>类似的还有 IntSavedField 等等，都是一样的代码，就不说了。</p><p>定义好了注解之后，我们就可以开始写 BaseActivity 的逻辑了。</p><h2 id="BaseActivity-1"><a href="#BaseActivity-1" class="headerlink" title="BaseActivity"></a>BaseActivity</h2><blockquote><p>BaseActivity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleIntent</span><span class="hljs-params">(Intent intent, Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.handleIntent(intent, savedInstanceState);<br><br>    <span class="hljs-comment">// 收集注解标识的字段</span><br>    Field[] declaredFields = <span class="hljs-keyword">this</span>.getClass().getDeclaredFields();<br>    <span class="hljs-keyword">for</span> (Field declaredField : declaredFields) &#123;<br>        declaredField.setAccessible(<span class="hljs-keyword">true</span>);<br>        Annotation[] annotations = declaredField.getAnnotations();<br>        injectField(annotations, declaredField, intent, savedInstanceState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是遍历所有的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectField</span><span class="hljs-params">(Annotation[] annotations, Field field, Intent intent, Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            Class&lt;?&gt; type = field.getType();<br>            <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> IntSavedField) &#123;<br>                <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">int</span>.class &amp;&amp; type != Integer.class) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;字段类型与注解类型不匹配&quot;</span>);<br>                &#125;<br>                IntSavedField savedField = (IntSavedField) annotation;<br>                <span class="hljs-keyword">int</span> defaultValue = savedField.defaultValue();<br>                String key = savedField.key();<br>                field.set(<span class="hljs-keyword">this</span>, SavedFieldHandler.getSavedInt(intent, savedInstanceState, key, defaultValue));<br>                mSavedFieldMap.put(field, savedField);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (...) &#123;...&#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看看字段上是否有我们定义的注解，如果有的话，将注解里面定义的 KEY 取出来，然后使用 SavedFieldHandler 去获取传递过来的值，最后设置到该字段里面。</p><p>mSavedFieldMap 是将有指定注解修饰的字段保存一下，以免在 onSaveInstanceState 又要重新遍历一下所有字段。</p><p>在 onSaveInstanceState  里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Map.Entry&lt;Field, Annotation&gt;&gt; entrySet = mSavedFieldMap.entrySet();<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Field, Annotation&gt; entry : entrySet) &#123;<br>            Field key = entry.getKey();<br>            Annotation value = entry.getValue();<br>            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> IntSavedField) &#123;<br>                outState.putInt(((IntSavedField) value).key(), (Integer) key.get(<span class="hljs-keyword">this</span>));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(...) &#123;...&#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑，也很简单，从字段里面取出值，然后储存到  outState  里面就好了。</p><p>运行一下demo，可以正常运行。但是这个 BaseActivity 里面的代码就不太好看了，是因为这两个方法里面有太长的 if - else if 了，那怎么解决呢？回想一下《重构》这本书，抽一个接口就好了：</p><blockquote><p>SavedFieldHandler</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SavedFieldHandler</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Annotation</span>&gt; </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">injectField</span><span class="hljs-params">(T annotation, Object target, Field field, Intent intent, Bundle savedInstanceState)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveField</span><span class="hljs-params">(Bundle outState, Object target, Field key, T annotation)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后分别为各种类型写一个实现：</p><blockquote><p>DoubleHandler</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SavedFieldHandler</span>&lt;<span class="hljs-title">DoubleSavedField</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectField</span><span class="hljs-params">(DoubleSavedField annotation, Object target, Field field, Intent intent, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> defaultValue = annotation.defaultValue();<br>        String key = annotation.key();<br>        <span class="hljs-keyword">try</span> &#123;<br>            field.set(target, SavedFieldHandler.getSavedDouble(intent, savedInstanceState, key, defaultValue));<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveField</span><span class="hljs-params">(Bundle outState, Object target, Field key, DoubleSavedField annotation)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            outState.putDouble(annotation.key(), (Double) key.get(target));<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再次重构 BaseActivity 的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleIntent</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = System.nanoTime()<br><br>    <span class="hljs-keyword">val</span> declaredFields = <span class="hljs-keyword">this</span>.javaClass.declaredFields<br>    <span class="hljs-keyword">for</span> (declaredField <span class="hljs-keyword">in</span> declaredFields) &#123;<br>        declaredField.isAccessible = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">val</span> annotations = declaredField.annotations<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-keyword">in</span> annotations) &#123;<br>            <span class="hljs-keyword">val</span> handler = HandlerFactory.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">annotation</span>)<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                handler.injectField(<span class="hljs-keyword">annotation</span>, <span class="hljs-keyword">this</span>, declaredField, intent, savedInstanceState)<br>                mSavedFieldMap[declaredField] = <span class="hljs-keyword">annotation</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    Log.e(TAG, <span class="hljs-string">&quot;获取耗时&quot;</span> + ((System.nanoTime() - s) / <span class="hljs-number">1000000.0</span>).toString() + <span class="hljs-string">&quot;毫秒&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)<br><br>    <span class="hljs-keyword">val</span> s = System.nanoTime()<br><br>    <span class="hljs-keyword">val</span> entrySet = mSavedFieldMap.entries<br>    <span class="hljs-keyword">for</span> (entry <span class="hljs-keyword">in</span> entrySet) &#123;<br>        <span class="hljs-keyword">val</span> key = entry.key<br>        <span class="hljs-keyword">val</span> value = entry.value<br>        HandlerFactory.<span class="hljs-keyword">get</span>(value)?.saveField(outState, <span class="hljs-keyword">this</span>, key, value)<br>    &#125;<br><br>    Log.e(TAG, <span class="hljs-string">&quot;保存耗时&quot;</span> + ((System.nanoTime() - s) / <span class="hljs-number">1000000.0</span>).toString() + <span class="hljs-string">&quot;毫秒&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这次看起来就舒服多了。运行一下，看看耗时情况，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">获取耗时第一次为 2-3 毫秒，再次运行在 0.5 毫秒左右<br>保存耗时 为 0.2 ~ 0.3 毫秒左右<br></code></pre></td></tr></table></figure><p>结果还是可以接收的。</p><p>在写完之后，又想了想，如果我不使用反射，那么耗时情况是怎么样的呢？既然不能使用反射，那么还要能给变量赋值与获取值，这咋办呢？给变量赋值…，ButterKnife 不就是给变量赋值，ButterKnife 的工作原理这里还是简单描述一下哈：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我们有一个目标类：<span class="hljs-keyword">SbActivity，它在 </span>com.<span class="hljs-keyword">sb </span>包下。<br><br>我们使用注解处理器生成一个类 <span class="hljs-keyword">SbActivity_ViewBinding，也让它生成到 </span>com.<span class="hljs-keyword">sb </span>包下面<br><br>给 <span class="hljs-keyword">SbActivity_ViewBinding </span>类搞一个构造函数，构造函数有两个参数：<br>第一个参数是 <span class="hljs-keyword">SbActivity，第二个参数是 </span><span class="hljs-keyword">SbActivity </span>的根 view<br><br>这样，我们可以在 <span class="hljs-keyword">SbActivity_ViewBinding类中拿到 </span><span class="hljs-keyword">SbActivity </span>的所有非私有变量，就可以给这个变量设置值，获取它的值<br></code></pre></td></tr></table></figure><p>了解了它的工作原理，这完全和我们的需求一摸一样啊，所以，我们直接按照 ButterKnife 来设计我们的结构。</p><h2 id="SaveHelper"><a href="#SaveHelper" class="headerlink" title="SaveHelper"></a>SaveHelper</h2><p>首先，我们需要一个工具类，它的作用与 ButterKnife 类一样，提供一个 bind 方法，返回一个 UnBinder 对象，这里我们另起一个方法名：</p><blockquote><p>SaveHelper</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@UiThread</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(target: <span class="hljs-type">Activity</span>, intent: <span class="hljs-type">Intent</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: SaveUnbinder &#123;<br>    <span class="hljs-keyword">return</span> createBinding(target, intent, savedInstanceState)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的逻辑，都不用我们自己想，直接从 ButterKnife 里面 copy 出来用就好了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createBinding</span><span class="hljs-params">(target: <span class="hljs-type">Activity</span>, intent: <span class="hljs-type">Intent</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: SaveUnbinder &#123;<br>    <span class="hljs-keyword">val</span> targetClass = target.javaClass<br>    Log.d(TAG, <span class="hljs-string">&quot;Looking up binding for &quot;</span> + targetClass.name)<br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">constructor</span> = findBindingConstructorForClass(targetClass) ?: <span class="hljs-keyword">return</span> EMPTY_UNBINDER<br><br>    <span class="hljs-comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">constructor</span>.newInstance(target, intent, savedInstanceState)<br>    &#125; <span class="hljs-keyword">catch</span> (e: IllegalAccessException) &#123;<br>        <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Unable to invoke <span class="hljs-variable">$constructor</span>&quot;</span>, e)<br>    &#125; <span class="hljs-keyword">catch</span> (e: InstantiationException) &#123;<br>        <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Unable to invoke <span class="hljs-variable">$constructor</span>&quot;</span>, e)<br>    &#125; <span class="hljs-keyword">catch</span> (e: InvocationTargetException) &#123;<br>        <span class="hljs-keyword">val</span> cause = e.cause<br>        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">is</span> RuntimeException) &#123;<br>            <span class="hljs-keyword">throw</span> cause<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">is</span> Error) &#123;<br>            <span class="hljs-keyword">throw</span> cause<br>        &#125;<br>        <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Unable to create binding instance.&quot;</span>, cause)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法，就是根据我们的 Activity，创建 Activity_ViewBinding 的一个对象，因为我们使用注解处理器创建的类的构造函数是有两个参数的，这里使用反射创建 Activity_ViewBinding  类的实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Nullable</span><br><span class="hljs-meta">@CheckResult</span><br><span class="hljs-meta">@UiThread</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findBindingConstructorForClass</span><span class="hljs-params">(cls: <span class="hljs-type">Class</span>&lt;*&gt;)</span></span>: Constructor&lt;<span class="hljs-keyword">out</span> SaveUnbinder&gt;? &#123;<br><br>    <span class="hljs-keyword">var</span> bindingCtor: Constructor&lt;<span class="hljs-keyword">out</span> SaveUnbinder&gt;? = BINDINGS[cls]<br>    <span class="hljs-keyword">if</span> (bindingCtor != <span class="hljs-literal">null</span>) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;HIT: Cached in binding map.&quot;</span>)<br>        <span class="hljs-keyword">return</span> bindingCtor<br>    &#125;<br><br>    <span class="hljs-keyword">val</span> clsName = cls.name<br>    <span class="hljs-keyword">if</span> (clsName.startsWith(<span class="hljs-string">&quot;android.&quot;</span>) || clsName.startsWith(<span class="hljs-string">&quot;java.&quot;</span>)) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> bindingClass = cls.classLoader?.loadClass(clsName + <span class="hljs-string">&quot;_FieldSaving&quot;</span>)<br>        bindingCtor =<br>            bindingClass?.getConstructor(<br>                cls,<br>                Intent::<span class="hljs-keyword">class</span>.java,<br>                Bundle::<span class="hljs-keyword">class</span>.java<br>            ) <span class="hljs-keyword">as</span> Constructor&lt;<span class="hljs-keyword">out</span> SaveUnbinder&gt;<br>        Log.d(TAG, <span class="hljs-string">&quot;HIT: Loaded binding class and constructor.&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: ClassNotFoundException) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;Not found. Trying superclass &quot;</span> + cls.superclass?.name)<br>        cls.superclass?.apply &#123;<br>            bindingCtor = findBindingConstructorForClass(<span class="hljs-keyword">this</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e: NoSuchMethodException) &#123;<br>        <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Unable to find binding constructor for <span class="hljs-variable">$clsName</span>&quot;</span>, e)<br>    &#125;<br><br>    bindingCtor?.apply &#123;<br>        BINDINGS[cls] = <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> bindingCtor<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是寻找 Activity_ViewBinding 这个类，然后加载这个类，获取它的 Constructor 并返回。</p><p>bindingCtor 缓存了对应的 Constructor 。</p><p>这里为了加以区分，我们注解处理器生成的类，后缀叫 _FieldSaving。</p><h2 id="SaveUnbinder"><a href="#SaveUnbinder" class="headerlink" title="SaveUnbinder"></a>SaveUnbinder</h2><p>SaveUnbinder 对象的生成解决了，那么这个接口应该有哪些方法呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SaveUnbinder</span> </span>&#123;<br><br>    <span class="hljs-meta">@UiThread</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">save</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span><br><br>    <span class="hljs-meta">@UiThread</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unbind</span><span class="hljs-params">()</span></span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口的定义还是很简单的。</p><h2 id="BaseActivity-2"><a href="#BaseActivity-2" class="headerlink" title="BaseActivity"></a>BaseActivity</h2><p>那么我们的 BaseActivity 就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity2</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;BaseActivity2&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> saveUnbinder: SaveUnbinder<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> s = System.nanoTime()<br>        saveUnbinder = <span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>, intent, savedInstanceState)<br>        Log.e(TAG, <span class="hljs-string">&quot;获取花费了 <span class="hljs-subst">$&#123;(System.nanoTime() - s) / <span class="hljs-number">1000000.0</span>&#125;</span> 毫秒&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(outState: <span class="hljs-type">Bundle</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onSaveInstanceState(outState)<br>        <span class="hljs-keyword">val</span> s = System.nanoTime()<br>        saveUnbinder.save(outState)<br>        Log.e(TAG, <span class="hljs-string">&quot;保存花费了 <span class="hljs-subst">$&#123;(System.nanoTime() - s) / <span class="hljs-number">1000000.0</span>&#125;</span> 毫秒&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDestroy()<br>        saveUnbinder.unbind()<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个看起来就更舒服了。</p><p>接下来，就只需要搞定注解生成对应的类就好了，注解处理器，另外一篇有讲到，就不说了，主要是 JavaPoet 的使用。</p><p>可以将 JavaPoet 理解为一个盒子，它可以帮助我们生成一个 Java 文件。我们写 Java 文件都是用 IDE 手写，但是使用 JavaPoet，我们可以使用 Java 语言来生成一个 Java 文件。</p><blockquote><p> 直接使用 IO 流来创建文件，然后添加各种字符不一样，JavaPoet 有自己的用法，它可以很简单的让你处理Java 类的导入，编写方法的结构体等等。唯一复杂的就是，需要我们掌握这些 API 的用法。用法其实很简单的，也无需记住，需要的时候再去查文档就好了，因为对我们理解别的东西没啥帮助，除非你想看一下它的设计实现与思想。</p></blockquote><p>它生成的类应该如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity_FieldSaving</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SaveUnbinder</span> </span>&#123;<br>  MainActivity target;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity_FieldSaving</span><span class="hljs-params">(MainActivity activity, Intent intent, Bundle bundle)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = activity;<br>    <span class="hljs-keyword">this</span>.target.testL = IntentHandlerKt.getSavedLong(intent, bundle, <span class="hljs-string">&quot;testL&quot;</span>, <span class="hljs-number">71L</span>);<br>    <span class="hljs-keyword">this</span>.target.testS = IntentHandlerKt.getSavedString(intent, bundle, <span class="hljs-string">&quot;testS&quot;</span>, <span class="hljs-string">&quot;74&quot;</span>);<br>    <span class="hljs-keyword">this</span>.target.testD = IntentHandlerKt.getSavedDouble(intent, bundle, <span class="hljs-string">&quot;testD&quot;</span>, <span class="hljs-number">7.3D</span>);<br>    <span class="hljs-keyword">this</span>.target.testI = IntentHandlerKt.getSavedInt(intent, bundle, <span class="hljs-string">&quot;testI&quot;</span>, <span class="hljs-number">70</span>);<br>    <span class="hljs-keyword">this</span>.target.testF = IntentHandlerKt.getSavedFloat(intent, bundle, <span class="hljs-string">&quot;testF&quot;</span>, <span class="hljs-number">7.2F</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;<br>    outState.putLong(<span class="hljs-string">&quot;testL&quot;</span>, <span class="hljs-keyword">this</span>.target.testL);<br>    outState.putString(<span class="hljs-string">&quot;testS&quot;</span>, <span class="hljs-keyword">this</span>.target.testS);<br>    outState.putDouble(<span class="hljs-string">&quot;testD&quot;</span>, <span class="hljs-keyword">this</span>.target.testD);<br>    outState.putInt(<span class="hljs-string">&quot;testI&quot;</span>, <span class="hljs-keyword">this</span>.target.testI);<br>    outState.putFloat(<span class="hljs-string">&quot;testF&quot;</span>, <span class="hljs-keyword">this</span>.target.testF);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>嗯，这样就搞定了。</p><p>最后将这些类分开，我们新建 3 个不同作用的 Module：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">save-api 用于存放给外部使用的类<br>save-<span class="hljs-keyword">annotation</span> 用于存放需要处理的注解<br>save-processor 用于处理注解<br></code></pre></td></tr></table></figure><p>运行 demo，却报了一个错，报的是字段不能是私有的，这个是我在注解处理器里面输出的错误，可是这就奇怪了啊，我的字段不是私有的啊，经旁边同事的提醒，查看一下它的 byteCode，果然是私有的，原来是 Kotlin 搞的鬼，它为字段生成了公有的 get set 方法，所以变量是私有的了。那这可咋办呢？我去翻了一下 ButterKnife 的注解处理器，它也没有处理这种情况。看来 Java 的注解处理器来兼容 Kotlin，是用前朝的剑来斩本朝的官啊。不过听说又有一个 KotlinPoet，但是还是得分开处理，很麻烦。</p><p>本来想着，参考一下 Gson 的代码，看它是怎么处理有 get set 方法的。但是想了想还是算了，感觉这样兼容很脆弱，而且我对 Kotlin 还不太熟，不知道它没有什么注解处理器来兼容 Java。</p><p>最后，使用 Java 来写 Activity，测试性能结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">获取耗时第一次为 <span class="hljs-number">1.7-2.3</span> 毫秒，再次运行在 <span class="hljs-number">0</span>.<span class="hljs-number">2</span> 毫秒左右<br>保存耗时 为 <span class="hljs-number">0</span>.<span class="hljs-number">06</span> 毫秒左右<br></code></pre></td></tr></table></figure><p>最后额外说一下，由于使用了注解处理器，注解的 Retention 可以改为了 SOURCE。</p><p>一个比较令人满意的依赖库就做好了。</p><p>项目代码并没有经过严格测试，只是写的有意思，所以分享一下，项目源代码地址如下：</p><p><a href="https://github.com/aprz512/SaveHelper">https://github.com/aprz512/SaveHelper</a></p>]]></content>
    
    
    <categories>
      
      <category>AnnotationProcessor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-AnnotationProcessor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-前言</title>
    <link href="/2019/09/25/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0001-%E5%89%8D%E8%A8%80/"/>
    <url>/2019/09/25/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LeakCanary/0001-%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>所有的三方框架里面，LeakCanary 简直是最老的伙伴了，经历的开发项目都用过这个，像网络图片的等加载框架每个项目的选择可能不一样， LeakCanary 一直都在。</p><p>可惜的是一直没有去看里面的源码，只是大致的了解了一下，现在想了起来，于是就开了这个系列。</p><p>不看不知道，看了是真的舒服。之前一段时间受过 Tangram 代码的摧残，现在看 LeakCanary 的代码就是一种享受。</p><h3 id="2021-3-11"><a href="#2021-3-11" class="headerlink" title="2021-3-11"></a>2021-3-11</h3><p>之前只写了 一篇就没写了，现在开始继续研究新版代码，顺便学点 Kotlin。</p>]]></content>
    
    
    <categories>
      
      <category>LeakCanary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-LeakCanary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler</title>
    <link href="/2019/09/25/blog_bak/Blog/Android/Handler/"/>
    <url>/2019/09/25/blog_bak/Blog/Android/Handler/</url>
    
    <content type="html"><![CDATA[<h2 id="Handler是如何切换线程的"><a href="#Handler是如何切换线程的" class="headerlink" title="Handler是如何切换线程的"></a>Handler是如何切换线程的</h2><p> handler这个线程切换的模型还是挺有意思的。想要让线程A中创建的一段代码，最终在线程B中执行，需要解决不少问题。</p><p>第一个问题，就是封装，创建的代码，肯定不能直接写到线程A中，否则这段代码肯定只能在线程 A 中执行。</p><p>第二个问题，封装之后，怎么将封装后的对象，传给线程B 呢？这个可以参考生产者消费者模式，就是使用一个仓库，存放封装后的对象，线程A放入，线程B取出执行。使用仓库只是解决了储存的问题，但是怎么确定我放入之后，是线程B来取，而不是别的线程。这里又涉及到一个叫做 ThreadLocal 的东西。</p><p>我们在使用 handler 的时候，首先需要创建一个对象出来，这里有两种方式：</p><ul><li>在主线程创建一个 handler，直接 new 一个对象出来，然后在子线程使用</li><li>直接在子线程创建一个 handler，然后传递一个 主线程的 Looper 进去</li></ul><p>这两种方式其实都是一样的，因为直接new一个handler对象的时候，默认传递的就是当前线程的 looper。而 looper 对象就是从 threadlocal 中取出来的，每个线程有一个，主线程的是在 activityThread 中创建的，所以，我们可以直接取就好了。如果是在子线程中，我们需要先 prepare，创建一个 looper 出来，才能使用。</p><p>looper 对象关联了一个 messageQueue，这个起的就是仓库的作用。所以每个线程都有一个自己的消息仓库，那么它是如何从仓库里面取出来消息并且执行的，也是在 ActivityThread 中，它调用了 looper 的 loop 方法，这个是一个循环，会不断的从仓库里面取消息，然后执行消息。这也就是我们常说的，主线程是由消息队列构成的，始终处于一个循环中的。其实这种设计方式很常见，比如一些游戏，它的画面UI更新，就是处于一个循环种，它只需要根据用户键盘的输入，计算各个元素的位置，然后重绘即可。</p><p>那么，整个模型应该就比较清楚了：</p><p>每个线程有一个 looper（子线程需要自己调用一些方法，参考 ActivityThread）。</p><p>Looper 里面有一个仓库，存放封装后的代码，Message。</p><p>Looper 开启了一个循环，不断的处理仓库里面的消息。</p><p>子线程，获取了主线程的 handler -&gt; looper，这样就将封装后的 message，放到了主线程的message queue 中。</p><h2 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h2><h3 id="文字版理解"><a href="#文字版理解" class="headerlink" title="文字版理解"></a>文字版理解</h3><ul><li><p>每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性。</p></li><li><p>ThreadLocalMap 类相当于一个Map，key 是 ThreadLocal 本身，value 就是我们的值。</p></li><li><p>当我们通过 threadLocal.set(new Integer(123)); ，我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 是 这个 threadlocal 自己，value 就是 new Integer(123)。</p></li><li><p>当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值。</p></li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>这个类比较简单，我们直接从 java.lang.ThreadLocal#set 这个方法看起：</p><blockquote><p> java.lang.ThreadLocal#set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment"> * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment"> * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment"> * method to set the values of thread-locals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment"> *        this thread-local.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 set 方法的第二行，由一个 getMap 方法获取了 ThreadLocalMap 的一个实例。</p><blockquote><p>java.lang.ThreadLocal#getMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment"> * InheritableThreadLocal.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  t the current thread</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了没，这里直接使用的是 Thread 类的变量。</p><blockquote><p>java.lang.Thread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment"> * by the ThreadLocal class. */</span><br>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>所以，我们储存的数据实际上时放入到了 Thread 类的成员变量中。<br>继续深入 ThreadLocalMap 这个类，上面的 set 方法调用它的 set 方法，所以我们直接看它的 set 方法。</p><blockquote><p>java.lang.ThreadLocal.ThreadLocalMap</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>看这个代码，思路还是满清晰的。要说一些这个 Entry 类，它是继承了 WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，注意这里是一个弱引用。有一个比较有趣的问题就是：网上有讨论说 ThreadLocal 有可能出现内存泄漏问题，就与它有关系。我们来看一下引用链：</p><ul><li>ThreadLocal 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; WeakReference -&gt; ThreadLocal</li><li>value 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</li></ul><p>可以看到，value 是被强引用的，所以如果没有其他对象引用 ThreadLocal 对象的话，ThreadLocal 可能会被回收，但是 value 不会被回收。而且这个时候，我们也没法访问到 value 了。这样就造成了内存泄露。一般的使用方式都是使用 static 的或者手动调用 set null。看看官方的使用方式：</p><blockquote><p>android.os.Looper</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Looper&gt;();<br></code></pre></td></tr></table></figure><p>回到正题，分析 set 方法的流程：<br>首先，利用 key 的 hashCode 获取索引值，然后查看索引值执行的位置有没有数据，没有数据就创建一个新的放进去，有的话，就比较 key ，key一样就直接替换 value 的值，key不一样就看下一个位置的值，再比较。</p><p>set 方法说完了，我们在看看 get 方法。</p><blockquote><p>java.lang.ThreadLocal#get</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了 set 方法，get 方法其实就是反过来的，与 set 的思路一样，由于 key 始终是自己（ThreadLocal&lt;?&gt;），所以总能取到正确的值。这里还有一个 setInitialValue 方法，它默认返回null，就是没有设置初始值的时候，就会触发这个方法，我们可以复写这个方法，返回一个默认值。</p><p>ThreadLocal 的大致原理就说完了，再说一下它的一般用法：<br>第一个比较普通，就是通过它来储存线程中的数据，只有当前线程可以获取到，其他线程获取的是另一份自己的数据。<br>第二个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实这个时候就可以采用 ThreadLocal，让监听器作为线程内的全局对象，在线程内部只要通过get方法就可以获取到监听器。如果不采用这种方式，那么一般会使用参数的传递或者使用静态变量。使用参数传递的话，如果方法调用栈不深还可以接收，如果调用栈很深，代码看起来就很糟糕了。使用静态变量的话，多个线程就难以维护了。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>这里不会走源码了，最多给个图。我只是梳理一下以前没有注意到的东西。</p><p>在讨论这个主题之前，我们先来认识一下GUI的单线程模型，嗯，想来了解一下问什么。<br>现代的 GUI 框架使用的模型：创建一个专门的线程，事件派发线程（event dispatch thread，RDT）来处理 GUI 事件。</p><p>有很多人都试图写出多线程的GUI框架，最终都由于竞争条件和死锁导致的稳定性问题，又回到了单线程化的事件队列模型的老路上来。多线程的GUI框架会尤其易受死锁的影响，部分原因在于：</p><blockquote><p>用户发起的动作总会冒泡似的从操作系统传递给应用程序。先是由os检测到一次鼠标点击，然后工具集把它转化为“鼠标点击”事件，最终它会作为一个高层事件（比如“buttonpressed”事件）转发给应用程序的监听器。</p><p>另一方面，应用程序发起的动作又会以冒泡的形式传回操作系统。应用程序发起一个动作要改变某个组件的背景颜色，这会被转发给一个特定的组件类，最终转发给os进行渲染。两种动作以完全相反的顺序访问相同的GUI对象，需要保证让每一个对象都是线程安全的，这会导致一系列的锁顺序的不一致，这会直接引发死锁。</p></blockquote><p><strong>虽然，单线程模式比较简单，但是单线程消息队列机制存在一个问题：</strong></p><blockquote><p>消息响应函数中不能有耗时长的、计算密集型的操作，因为主线程在努力地处理这样的操作的时候就无法去处理其它的积压在消息队列中的绘制消息、事件消息了（一个消息处理完了主线程才会去队列中取下一个消息），这时候就会出现按键无响应、点击无反应的情况。</p></blockquote><p>但这个问题有完美的解决方案，<strong>我们可以在消息响应函数中启动另一个工作线程（Worker Thread）来执行耗时操作</strong>，这样在线程启动起来后这个消息就算处理完了，主线程可以取下一个消息了，这时候主线程和还未执行完计算任务的工作线程就在操作系统的调度下并驾齐驱地狂奔了（调度算法会保证两个线程并发或并行地执行，不会专宠某个线程）。</p><p>Android 中也是采用的单线程消息队列，它是使用 Hanlder 来处理线程之间的消息传递的。一般我们在耗时任务执行完后还要更新界面展示计算的结果，正确的处理办法是将耗时任务改为异步通知机制，即工作线程向消息队列中添加消息以通知主线程耗时任务完成了，这样主线程在启动工作线程后就不需要主动地去调查任务的进展了。</p><p>了解了为什么，现在我们从几个问题来入手消息队列的运作过程。</p><ol><li>消息是如何延迟发送的？不同的延时长度的消息是如何排序的？</li><li>没有消息时，MessageQueue 在干什么，Looper在做什么？从没有消息到有消息，MessageQueue 是如何被唤醒的？</li><li>Message 分发的3种渠道？</li><li>Looper是死循环，为什么 UI 线程不会ANR?</li><li>IdleHandler 是什么?</li><li>异步消息与同步屏障了解不？</li></ol><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><p>放入Message时会根据msg.when这个时间戳进行顺序的排序,如果非延迟消息则msg.when为系统当前时间，延迟消息则为系统当前时间+延迟时间(如延迟发送3秒则为：SystemClock.uptimeMillis() + 3000)。</p><p>Message放入MessageQueue时会以msg.when对msg进行排序确认当前msg处于单链表中的位置,分为几种情况:</p><ol><li>头结点为null(代表MessageQueue没有消息),Message直接放入头结点。</li><li>头结点不为null时开启死循环遍历所有节点<ul><li>遍历出的节点的when大于放入message的when(说明当前message是一个比放入message延迟更久的消息，将放入的Message放入当前遍历的Message节点之前)。</li><li>遍历出的节点的next节点为null(说明当前链表已经遍历到了末尾，将放入的Message放入next节点)。</li></ul></li></ol><blockquote><p>android.os.MessageQueue#enqueueMessage</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-comment">// 退出循环</span><br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            ...<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        msg.markInUse();<br>        msg.when = when;<br>        Message p = mMessages;<br>        <span class="hljs-keyword">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// 没有其他消息，把它作为头结点</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>            <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>            <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-comment">// 根据时间来寻找节点的位置</span><br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 异步消息与屏障的处理，后面会说到</span><br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消息队列的阻塞与唤醒"><a href="#消息队列的阻塞与唤醒" class="headerlink" title="消息队列的阻塞与唤醒"></a>消息队列的阻塞与唤醒</h3><p>对于消息队列而言，从里面取出消息需要考虑多个方面：</p><ul><li>如果队列为空了，或者队列里面的消息没有可以取出的消息（时间都没到），那么应该阻塞消息队列。阻塞肯定不能用一般的方式，如果像流一样，直接阻塞了线程，浪费CPU，导致 ANR，那肯定是不行的，所以应该怎么办呢？</li><li>阻塞需要阻塞多长时间呢？怎么保存这个时间？ 这个比较简单，message 有个 when 字段保存了时间，由于 message 是排序了的，所以只需要去头部的 message 的 when 用来计算就好了。</li><li>阻塞后如何唤醒？</li></ul><p>我们根据代码来分析：</p><blockquote><p>android.os.MessageQueue#next</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>nativePollOnce(ptr, nextPollTimeoutMillis);<br>...<br></code></pre></td></tr></table></figure><p>nativePollOnce 这个方法是一个 native 方法，它就是用来阻塞消息队列的，nextPollTimeoutMillis 就是阻塞的时间。在说明这个方法做了什么之前，我们需要先了解一下 epoll 是什么！</p><h4 id="为什么Android的Handler采用管道？"><a href="#为什么Android的Handler采用管道？" class="headerlink" title="为什么Android的Handler采用管道？"></a>为什么Android的Handler采用管道？</h4><p>我们先来看一张图，图里展示的是Android整个Hander的设计。</p><p><img src="https://pic2.zhimg.com/80/28a5f0d87457d432727270313cfec3a9_720w.jpg"></p><ul><li><p>红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了Java如何调用C++代码，C++代码又是如何调用Java代码。</p></li><li><p>蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。</p></li></ul><p>我们可以看出，Handler的设计不仅仅只是Java层，还有对应的C++层。这是因为Handler不仅仅要处理同一进程中别的线程发过来的消息，还要处理系统底层发过来的消息。在整个消息机制中，<code>MessageQueue</code>是连接Java层和Native层的纽带，换言之，Java层可以向MessageQueue消息队列中添加消息，Native层也可以向MessageQueue消息队列中添加消息。</p><p>如果只是Java层的话，使用 wait 与 notify 也可以做到唤醒。</p><h3 id="分发优先级"><a href="#分发优先级" class="headerlink" title="分发优先级"></a>分发优先级</h3><p>当遍历出Message后Message会获取其中的Handler并调用Handler的dispatchMessage进行分发,这时也会有三个优先级。</p><blockquote><p>android.os.Handler#dispatchMessage</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Message的回调方法：message.callback.run()，优先级最高； 对应handler.post(new Runnable)的方式发送消息。</p></li><li><p>Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于上面； 对应新建Handler时传进CallBack接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Handler handler=<span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Handler.Callback());<br></code></pre></td></tr></table></figure><p>通常我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息，场景如：Hook <a href="http://activitythread.mh/">ActivityThread.mH</a>，在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p></li><li><p>Handler的默认方法：Handler.handleMessage(msg)，优先级最低。对应新建Handler并复写handleMessage方法。</p></li></ul><h3 id="Looper-的死循环"><a href="#Looper-的死循环" class="headerlink" title="Looper 的死循环"></a>Looper 的死循环</h3><p>我们知道Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，<strong>每一个点击触摸或者说Activity的生命周期都是运行在 Looper的控制之下，如果它停止了，应用也就停止了</strong>。</p><p>真正的阻塞是因为轮询出message后在处理message消息的时候由于执行了耗时操作导致了ANR，而不是死循环导致的阻塞，没有消息处理的时候消息队列是阻塞在nativePollOnce方法中的，<strong>这个方法使用的是epoll管道机制，Linux底层执行后会释放CPU避免不断死循环造成的CPU浪费。</strong></p><h3 id="IdleHandler-是什么"><a href="#IdleHandler-是什么" class="headerlink" title="IdleHandler 是什么"></a>IdleHandler 是什么</h3><p>简而言之，IdleHandler 是一个接口，就是在looper里面的message暂时处理完了，这个时候会回调这个接口，返回false，那么就会移除它，返回true就会在下次message处理完了的时候继续回调。</p><p>IdleHandler 可以用来提升提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（譬如UI线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。</p><p>当从消息链中取消息的时候，如果取到的消息还未到执行的时间或者没有取到消息，那么就会触发 IdleHandler （当然前提是你设置了），需要注意的是，这个回调只会执行一次，嗯，意思是如果在 5s 内，都没有消息需要处理，在这 5s 内，只会调用一次，而不会不断的调用。</p><blockquote><p>android.os.MessageQueue#next</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>可以看到，调用一次之后，就将 count 设置为 0，下次就不会调用了，直到再次触发 next 方法。</p><p>可以看一下<a href="https://blog.csdn.net/tencent_bugly/article/details/78395717">这篇文章</a>的使用。</p><p>有一个需要注意的地方，如果我们设置了 IdleHandler，而且在它的 <code>queueIdle</code>方法的返回值里面返回了 true。那么当消息队列为空的时候，这个方法会被不断的回调吗？</p><p>答案是不是，也只会被回调一次。但是当消息队列再次为空时，会被回调。我们看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <br><span class="hljs-comment">// 开始的时候，对这两个变量赋值</span><br><span class="hljs-comment">// 表示没有 IdleHandler</span><br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 睡眠时间为 0</span><br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 消息队列不为空</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>                ...<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 消息队列为空，表示无限制睡眠，等待唤醒</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            ...<br><br>            <span class="hljs-comment">// 第一次循环进来，pendingIdleHandlerCount 的值为 -1</span><br>            <span class="hljs-comment">// 然后判断消息队列是否为空（无消息或者无可执行消息）</span><br>            <span class="hljs-comment">// 为空，就给 pendingIdleHandlerCount 赋值</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-comment">// 没有 IdleHandler，直接继续循环</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                mBlocked = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            ...<br>        &#125;<br><br>        <span class="hljs-comment">// 调用 queueIdle 方法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            ...<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><span class="hljs-comment">// 如果 queueIdle 返回了 false，就移除监听</span><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 重置变量，这里将 pendingIdleHandlerCount 赋值为 0</span><br>        <span class="hljs-comment">// 那么，下一次循环的时候，由于将睡眠时间设置为了0</span><br>        <span class="hljs-comment">// 但是仍然没有消息，但是 pendingIdleHandlerCount 为 0，那么就不会进入 queueIdle 的回调逻辑</span><br>        <span class="hljs-comment">// 会进入无限制睡眠状态</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步分割栏"><a href="#同步分割栏" class="headerlink" title="同步分割栏"></a>同步分割栏</h3><p>所谓“同步分割栏”，可以被理解为一个<strong>特殊Message</strong>，它的target域为null。它不能通过sendMessageAtTime()等函数打入到消息队列里，而只能通过调用Looper的postSyncBarrier()来打入。</p><p>“同步分割栏”是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中摘取消息并进行处理时，一旦遇到这种“同步分割栏”，那么即使在分割栏之后还有若干已经到时的普通Message，也不会摘取这些消息了。请注意，此时只是不会摘取“普通Message”了，如果队列中还设置有“异步Message”，那么还是会摘取已到时的“异步Message”的。</p><blockquote><p>需要注意的一点是：</p><p>同步分隔栏插入到消息链表中的时候，也是按照时间的顺序来插入的。也就是说，如果分隔栏的时间是 10ms 后执行，那么从现在到10ms后的这个时间段，消息链表中的同步消息也能被执行。</p></blockquote><p>在Android的消息机制里，“普通Message”和“异步Message”也就是这点儿区别啦，也就是说，如果消息列表中根本没有设置“同步分割栏”的话，那么“普通Message”和“异步Message”的处理就没什么大的不同了。</p><p>将普通消息变成异步消息，只需要调用一个方法就可以啦：</p><blockquote><p>android.os.Message#setAsynchronous</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAsynchronous</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        flags |= FLAG_ASYNCHRONOUS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        flags &amp;= ~FLAG_ASYNCHRONOUS;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/post/5c87c0ad6fb9a049f571fe3f">带你真正攻克Handler</a></p><p><a href="https://my.oschina.net/youranhongcha/blog/492591">聊一聊Android的消息机制</a></p><p><a href="https://blog.51cto.com/yaocoder/888374">我读过的最好的epoll讲解–转自”知乎“</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0030-队列的链式储存结构以及实现</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0030-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0030-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>上一篇说了循环队列，但是由于是基于数组的，所以它还是会有溢出问题，为了改善这个问题，所以了解一下它的链式储存还是有必要的。</p><p>虽然我们常用的 ArrayList 一看就知道是使用的数组，但是它实现了扩容，所以解决了溢出问题。而且我们一般只使用 add 方法，很少使用 remove 方法，所以元素的移动也很少。</p><p>看一下链式储存的结构图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-13-1.png?raw=true"></p><p>链式结构前面已经说了很多了，这里就直接给出插入与删除的算法吧，其实也很简单。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>队列为空时，front 肯定与 rear 是相等的，刚开始他们都指向头节点。</p><p>队列插入比单链表的插入还要简单，因为是在队列尾部插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (full()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node n = <span class="hljs-keyword">new</span> Node();<br>    n.value = e;<br>    n.next = <span class="hljs-keyword">null</span>;<br>    rear.next = n;<br>    rear = n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除元素是从队列（链表）头部移除一个元素，这里要注意，因为使用了头节点，所以移除元素需要注意。</p><p>当队列只有一个元素的时候，还需要更新 rear 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (empty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    Node t = front.next;<br>    front.next = t.next;<br>    <br>    <span class="hljs-keyword">if</span> (rear == t) &#123;<br>        rear = front;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> t.value;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0033-树的一些术语</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0033-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0033-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="树的一些定义"><a href="#树的一些定义" class="headerlink" title="树的一些定义"></a>树的一些定义</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1575439850916&di=d7db249fd9d203479984343358eaa4b1&imgtype=jpg&src=http://img3.imgtn.bdimg.com/it/u=3726455203,3907981261&fm=214&gp=0.jpg"></p><p>在学习树的过程中会不断地出现一些术语，所以，这里先列出一些常见的。</p><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><p>节点拥有的<strong>子树数量</strong>为度。</p><p>度为0的节点成为叶子节点。</p><p>树的度，是各个节点的度的最大值。</p><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p><img src="https://upload-images.jianshu.io/upload_images/7043118-2c735a2733887dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/502/format/webp"></p><p>节点 B 与 C 是 A 的<strong>孩子节点</strong>。</p><p>B 与 C 是<strong>兄弟</strong>。</p><p>A 是 B 与 C 的<strong>双亲节点</strong>。</p><p>有点像族谱。</p><h3 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h3><p>树的深度（高度），就是计算这个树有多少层（这个家族有传承了多少代）。</p><p>树还分有序树（子节点有顺序）与无序树。</p><p>森林是多个树（不想交）的集合。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0034-树的储存结构</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0034-%E6%A0%91%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0034-%E6%A0%91%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>我们想要在程序中使用树，就先得将它用数据结构表示出来。下面说几种常见的表示方法。</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>这个表示法很容易理解，每个节点只可能有一个父节点。所以我们可以定义出下面的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>    T data;<br>    Node parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类用来表示一个节点的信息。整个树就可以用一个 Node[] 来表示。</p><p>这个数据结构很简单，但是限制也很多，比如，我想知道某个节点有哪些孩子节点，那么就不得不遍历整个数组。当然你也可以给Node节点加入更多的信息，从而避免遍历数组。</p><p>无论我们如何修改、增强这个Node类，最终都是为了解决我们的需求问题，如果这个Node刚好满足我们的需求，那么这个数据结构就是最好的。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>既然有双亲表示法，那么有孩子表示法也是可以理解的，😁。</p><p>孩子表示法，就是说某一个节点它有哪些孩子。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>    T data;<br>    Node[] children;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种表示方式像一种树形链表。</p><p>孩子表示法除了这种树状外，还有另外一种写法。这种写法类似与 HashMap 的数据结构，可以先想象一下。</p><p> <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d34138468c025aafc73f76999a84c001/14ce36d3d539b60038a17131e750352ac75cb7cc.jpg" alt="img"> </p><p>我们先将所有节点都放入数组中。对于有孩子的节点，那么用一个链表来储存它所有的孩子，对于没有孩子的节点，用空链表表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    T data;<br>    Node childList;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>    Node[] nodes;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="兄弟表示法"><a href="#兄弟表示法" class="headerlink" title="兄弟表示法"></a>兄弟表示法</h3><p>有父母，有孩子，有兄弟，全家齐活。</p><p>这种表示法有点奇特，它最大的特点就是将一个树转化成了二叉树。</p><p>对于任意一个节点来说，它的左孩子是唯一的，它的右兄弟也是唯一的。我们可以利用这个特性，来定义数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    T data;<br>    Node leftChild;<br>    Node rightSib;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于下图的树：</p><p><img src="http://data.biancheng.net/uploads/allimg/190101/2-1Z10112303S92.gif"></p><p>使用兄弟表示法：</p><p><img src="http://data.biancheng.net/uploads/allimg/190101/2-1Z101123113227.gif"></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0035-二叉树的介绍</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0035-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0035-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h3><ul><li><p>每个节点最多只能有两个孩子节点。</p></li><li><p>二叉树是有顺序的。</p></li><li><p>需要区分左子树还是右子树。</p></li></ul><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h4><p>所有的节点都只有左子树——左斜树。</p><p>所有的节点都只有右子树——右斜树。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树可以理解为完美的二叉树，除了叶子节点外，所有的节点都有两个子树。</p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树有些不好理解，可以想象一下，满二叉树是一颗果树，每个节点是果实，你要从这个树上摘水果来吃，但是有两个条件，一是只能从叶子节点摘起，而是只能从右往左开始摘。</p><p>经过一段时间之后，树上剩下的果实就组成了一个完全二叉树。</p><p>我觉得这个“完全”两个字起的不好，但是别的词语也不太好描述，毕竟这树只是叶子节点的右边缺了一块。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li><p><strong>在二叉树的第 i 层上，最多有 $2^{i-1}$ 个节点。</strong></p><p>这个好理解，无非是一个指数计算而已。</p></li><li><p><strong>深度为 K 的二叉树至多有 $2^k - 1$ 个节点。</strong></p><p>这个利用第一个性质，就可以证明出来，等比数列相加可得。</p></li><li><p><strong>对任何一颗二叉树 T，如果其终端节点数为 $n_0$，度为 2 的节点数为 $n_2$ ，则，$n_0 = n_2 + 1$ .</strong></p><p>这个可以使用公式推导出来，但是不容易记住。可以另辟蹊径来思考：</p><p>对于一个只有一个节点的树来说，n0 = 1， n2 = 0。</p><p>我们给这个节点增加两个叶子节点，n0 = 2， n2 = 1。可以看到这种情况下，n0 与 n2 的关系并没有变化，都增加了 1。</p><p>我们再给其中一个叶子节点增加一个叶子节点，可以发现，n0 = 2， n2 = 1，这种情况下其实本质上只是替换了一个叶子节点而已。</p><p>所以，无论树长多大，n0 = n2 + 1。</p></li><li><p><strong>具有 n 个节点的完全二叉树的深度为 $log_2n + 1$ 。</strong></p><p>这个把性质2反过来想就好了。</p></li><li><p><strong>如果对一颗有 n 个节点的完全二叉树的节点按层序编号，对任一节点 i （1 &lt;= i &lt;= n）有：</strong></p><p><strong>如果 i = 1，则节点是根。</strong></p><p><strong>如果 i &gt; 1，则其父节点是 i / 2.</strong></p><p><strong>如果 2i &gt; n，则 i 没有左孩子，否则，其左孩子为 2i。</strong></p><p><strong>如果 2i+1 &gt; n，则 i 没有右孩子，否则，其右孩子为 2i + 1.</strong></p><p>这个性质，画个图就了解了。</p></li></ul><h3 id="二叉树的储存"><a href="#二叉树的储存" class="headerlink" title="二叉树的储存"></a>二叉树的储存</h3><ul><li><p>顺序储存</p><p>这种方式是将二叉树储存到数组中。如下图：</p><p> <img src="http://c.biancheng.net/uploads/allimg/190427/0946243158-1.gif" alt="img"> </p><p> <img src="http://c.biancheng.net/uploads/allimg/190427/094624F33-2.png" alt="img"> </p><p>可以看到这里利用了性质5（性质5是从 1 开始，不过这里是从 0 开始）.</p></li><li><p>链式储存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiTreeNode</span></span>&#123;<br>    T data;<br>    BiTreeNode left, right;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0036-二叉树的遍历</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0036-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0036-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>二叉树的遍历分为4种。二叉树的遍历都很简单，使用递归写的，所以就不演示代码了。</p><p><img src="http://c.biancheng.net/uploads/allimg/190427/0946243158-1.gif" alt="img"></p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>先访问根节点，再对左子树使用前序遍历，再对右子树使用前序遍历。</p><p>图中，前序遍历的结果是：1 2 4 5 3 6</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>先中序遍历根节点的左子树，再访问根节点，再中序遍历根节点的右子树。</p><p>图中，中序遍历的结果是：4 2 5 1 6 3</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先后序遍历根节点的左子树，再后序遍历根节点的右子树，再访问根节点。</p><p>图中，后序遍历的结果是：4 5 2 6 3 1</p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>就是按照层次遍历。</p><p>图中，层序遍历的结果是： 1 2 3 4 5 6</p><h3 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h3><p>已知二叉树的前序遍历为 ABCDEF，中序遍历为 CBAEDF，请问这个二叉树的后序遍历结果？</p><p>推导过程：</p><p>由前序遍历可知，A 为根节点。</p><p>由中序遍历可知，左子树为 CB，右子树为 EDF。</p><p>先看左子树 CB。在前序遍历中，B在前，说明 B 连着 A。而在中序遍历中， C 在 B 之前，说明 C 是 B 的左孩子。</p><p>再看 右子树 EDF ，在前序遍历中，D 在前，说明 D 连着 A，在中序遍历中，E 在 D 前，F 在 D 后，说明 E 是 D 的左孩子，F 是D 的右孩子。</p><p>所以，后序遍历为：C B E F D A.</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0037-线索二叉树</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0037-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0037-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>当我们决定使用链表结构来储存二叉树时，会出现比较多的空指针域。</p><p>通过考察各种二叉链表，不管二叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n个结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。</p><p>那么，有人提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。</p><p>假设  Node 是二叉链表中的一个结点，以下是建立线索的规则：</p><p>  （1）如果 Node.lchild 为空，则存放指向中序遍历序列中该结点的前驱结点，这个结点称为ptr的中序前驱；</p><p>  （2）如果 Node.rchild 为空，则存放指向中序遍历序列中该结点的后继结点，这个结点称为ptr的中序后继；</p><p>那么，这里就会出现一个问题，如何才能知道，这个 lchild 到底是指向的左孩子，还是中序前驱结点呢？</p><p>所以为了区别，还需要额外加两个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    T data;<br>    Node lchild;<br>    Node rchild;<br>    <span class="hljs-keyword">boolean</span> isLeftChild; <span class="hljs-comment">// 为 true，表示 lchild 指向左孩子，否则指向中序前驱节点。</span><br>    <span class="hljs-keyword">boolean</span> isRightChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面，我们来看一下，如何将一个二叉树变成线索二叉树：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Node pre;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inTreading</span><span class="hljs-params">(Node n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    inTreading(n.lchild);<br>    <br>processNode(n);<br>    <br>    inTreading(n.rchild);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processNode</span><span class="hljs-params">(Node n)</span> </span>&#123;<br>    <span class="hljs-comment">// pre 是刚访问过的前驱节点</span><br>    <span class="hljs-comment">// 将 pre 复制给 lchild</span><br>    <span class="hljs-keyword">if</span>(n.lchild == <span class="hljs-keyword">null</span>) &#123;<br>        n.isLeftChild = <span class="hljs-keyword">false</span>;<br>        n.lchild = pre;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这里对于后继的判断比较特殊，因为无法知道 n 的后继，所以改变思路</span><br>    <span class="hljs-comment">// 我们对 pre 做判断是一样的效果</span><br>    <span class="hljs-keyword">if</span>(pre.rchild == <span class="hljs-keyword">null</span>) &#123;<br>        pre.isRightChild = <span class="hljs-keyword">false</span>;<br>        pre.rchild = n;<br>    &#125;<br>    <br>    pre = n;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来深入思考一下，这个线索二叉树，左边指向的是左孩子或者前驱，右边指向的是右孩子或者后继，就像一个双向链表一样。</p><p>但是我们在遍历这个链表的时候，还是要注意，因为有的节点指向的是孩子节点，而不是前驱节点，所以需要特殊处理。</p><p>下面，我们看看应该如何遍历这个链表：</p><p>加上线索的二叉树结构是一个双向链表结构，为了便于遍历线索二叉树，我们为其添加一个头结点，头结点左孩子指向原二叉树的根结点，右孩子指针指向中序遍历的最后一个结点。同时，将第一个结点左孩子指针指向头结点，最后一个结点的右孩子指针指向头结点。<br><img src="https://upload-images.jianshu.io/upload_images/7043118-57a8de71fbe70e86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/827/format/webp" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//T指向头结点，头结点的lchild链域指针指向二叉树的根结点  </span><br><span class="hljs-comment">//中序遍历打印二叉线索树T（非递归算法）  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraversePrint</span><span class="hljs-params">(Node n)</span></span>&#123;  <br>    <span class="hljs-comment">//r指向根结点  </span><br>    Node r = n.lchild;<br>      <br>    <span class="hljs-comment">//空树或遍历结束时</span><br>    <span class="hljs-keyword">while</span>(r != n)&#123;<br>        <span class="hljs-comment">//让 r 指向中序遍历序列的第一个结点（最左下的结点）  </span><br>        <span class="hljs-keyword">while</span>(!r.isLeftChild)&#123;  <br>            r = r.lchild;  <br>        &#125;  <br>     <br>        println(r.data);<br> <br>        <span class="hljs-comment">// 当 r 的右孩子是线索时</span><br>        <span class="hljs-keyword">while</span>(r.isRightChild &amp;&amp; r.rchild != n)&#123;  <br>            r = r.rchild;  <br>            println(r.data);<br>        &#125;  <br>        <br>        <span class="hljs-comment">//当p所指结点的rchild指向的是孩子结点而不是线索时，</span><br>        <span class="hljs-comment">//p的后继应该是其右子树的最左下的结点，即遍历其右子树时访问的第一个节点  </span><br>        <span class="hljs-comment">//更新节点，继续循环</span><br>        r = r.rchild;  <br>    &#125;  <br>    println(<span class="hljs-string">&quot;\n&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0038-图的储存结构</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0038-%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0038-%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>图的表示法有点不同于其他。用顺序储存是无法做的到，用链表可以做到，但是会有许多不便。</p><p>所以这里介绍一些常见的储存图的方式。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵的思想，就是将<strong>顶点与边</strong>分开储存。</p><p>顶点用一个一维的数组即可表示，边因为涉及到两个顶点，所以用二维数组表示。</p><p><img src="https://upload-images.jianshu.io/upload_images/11476842-a4405ad3b5377c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" alt="img"></p><p>顶点的一维数组没啥说的，看看边的邻接矩阵。</p><p>想要知道 X 与 Y 是否相连，看 X 与 Y 形成的十字交集是否为 1 即可。另外这个矩阵是一个对称矩阵，当然只有无向图的邻接矩阵才是对称的，有向图不一定。</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>如果顶点多，边数少，那么邻接矩阵就会浪费很多空间。此时，就不能使用二维数组来实现。</p><p><img src="http://www.ahalei.com/data/attachment/forum/201404/08/091650e0f00oqrcjcfnq93.png" alt="img"></p><p><img src="http://www.ahalei.com/data/attachment/forum/201404/08/091650gyll6hbqbjyxls8s.png" alt="img"></p><p>这种表示方法是不是很眼熟，与树的孩子表示法是差不多的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 边表节点，上图中灰色竖线右边的节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeNode</span> </span>&#123;<br>    <span class="hljs-comment">// 该顶点对应的下标</span><br>    <span class="hljs-keyword">int</span> adjvex;<br>    <span class="hljs-comment">// 边的权值</span><br>    <span class="hljs-keyword">int</span> weight;<br>    <span class="hljs-comment">// 下一个边</span><br>    EdgeNode next;<br>&#125;<br><br><span class="hljs-comment">// 顶点节点，上图中灰色竖线左边的</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VertexNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> adjvex;<br>    EdgeNode next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>对于有向图来说，邻接表可以很好的描述出某个顶点“指向了”哪些顶点。如果反过来，我想知道哪些顶点都指向了某个顶点，该怎么做呢？除非遍历整个邻接表，或者使用逆邻接表。但是使用逆邻接表又无法了解“出度”问题。两难啊！那么有没有一种办法将邻接表与逆邻接表结合起来呢？那就是十字链表了。</p><p><img src="http://data.biancheng.net/uploads/allimg/190107/2-1Z10H11122456.gif" alt="åå­é¾è¡¨å­å¨æåå¾ç¤ºæå¾"></p><p>这里的数据结构需要注意一下：</p><p>对于顶点结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VertexNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> adjvex;<br>    EdgeNode in;<br>    EdgeNode out;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于边表结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tailVex;<br>    <span class="hljs-keyword">int</span> headVex;<br>    EdgeNode head; <span class="hljs-comment">// 逆邻接表的边</span><br>    EdgeNode tail; <span class="hljs-comment">// 邻接表的边</span><br>&#125;<br></code></pre></td></tr></table></figure><p>十字链表，就是同时画了邻接表与逆邻接表。</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接多重表(Adjacency Multilist)主要用于存储<strong>无向图</strong>。</p><p>当我们这样的需求时：对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个结点。使用邻接表就会很复杂。</p><p>因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。</p><p>其实，结构与邻接表差不多，但是，我们需要储存更多的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ivex; <span class="hljs-comment">// 这条边的其中一个顶点</span><br>    <span class="hljs-keyword">int</span> jvex; <span class="hljs-comment">// 这条边的另一个顶点</span><br>    EdgeNode iLink;<br>    EdgeNode jLink;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 iLink 与 jLink 的构造过程是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatGraph</span><span class="hljs-params">(Graph *G)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j, k, l;<br>    <span class="hljs-keyword">char</span> s[MAX_INFO];<br>    VertexType va, vb;<br>    EBox *p;<br>    cin &gt;&gt; G.vexnum &gt;&gt; G.edgenum;<br>    <span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; i &lt; G.vexnum; i ++) &#123;<br>        cin &gt;&gt; G.vertices[i].data;<br>        G.vertices[i].firstedge = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(k =<span class="hljs-number">0</span>; k &lt; G.edgenum; k ++)&#123;<br>        cin &gt;&gt; va &gt;&gt; vb;<br>        i = <span class="hljs-built_in">Locate</span>(va, G);<br>        j = <span class="hljs-built_in">Locate</span>(vb, G);<br>        p = <span class="hljs-keyword">new</span> EBox;<br>        p -&gt; ivex = i;<br>        p -&gt; jvex = j;<br>        p -&gt; info = <span class="hljs-literal">NULL</span>;<br>        p -&gt; ifirstedge = G.vertices[i].firstedge;<br>        G.vertices[i].firstedge = p;<br>        p -&gt; jfirstedge = G.vertices[j].firstedge;<br>        G.vertices[j].firstedge = p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，每当输入一条边时，找到这条边对应的两个顶点（i，j）。</p><p>然后对顶点 i，将这条边使用头插法插入到顶点 i 的边链表（iLink）中，对于 j 做同样的操作，话不好理解，如下图：</p><p><img src="graph_1.png"></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0039-图的遍历</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0039-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0039-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>可以想象一个走迷宫的过程，入口是其中一个顶点，沿着边前进，递归则意味着朝着深处前进，循环则意味着对于某个分叉点，把每条路都走一遍。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>对于邻接矩阵的深度优先遍历：</p><p>只需要针对某一行（列）进行遍历即可，这样只是遍历了某一个顶点的各个边，就不是深度优先了。</p><p>所以在遍历的时候，如果值为 1，假设是在矩阵的 （x, y）位置，则应该递归的去遍历第 y 行。</p><p>想象不出来的，找个矩阵，自己连连线就明白了。</p><p>还有一个需要注意的就是，因为图可能是闭合的，所以，需要额外的空间来标记这个边是否走过了。</p><p>时间复杂度为 o(n*n)。</p><p>对于邻接表来说，其实是一样的，只需要遍历到另外的顶点的时候，递归这个顶点就好了。这就是深度优先的套路。时间复杂度为 o(n+e)。</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先就是一个人走迷宫，遇到一个分叉点的时候，不是直接往深处行进，而是先将分叉的路全部都走一遍，做上记号，最后在选第一条，深入。</p><p>比如，对于 A 点来说，有两条道路，一条到 B，一条到 C，那么我先把 AB，AC 这两条路走了，顺便将 B，C 做个记号，再选 AB 这条路，到 B 点，继续深入，重复这个过程。</p><p>在代码中，做记号这个过程，就是用队列实现的，因为它是先进先出。也需要额外的空间来标记这个边是否走过了。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0040-最小生成树之Prim算法</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0040-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BPrim%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0040-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BPrim%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h2><p>算法思想：</p><p>新建一个空的集合V，新建一个空的集合E。</p><p>在无向图中随便取一个顶点作为起点，加入V，然后遍历包含这个顶点的所有边，找到最短的边，加入E，将这条边的另一个顶点也加入V，这样我们就有了两个顶点。</p><p>再对V中的每一个元素，重复做上面的操作，这个集合就会不断的增长，直到包含所有顶点为止。这样 E 的集合就是最小生成树。</p><p>下面对算法的图例描述：</p><table><thead><tr><th>图例</th><th>说明</th><th>不可选</th><th>可选</th><th>已选（Vnew）</th></tr></thead><tbody><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015154494.png" alt="img"></td><td>此为原始的加权连通图。每条边一侧的数字代表其权值。</td><td>-</td><td>-</td><td>-</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073015175038.png" alt="img"></td><td>顶点<strong>D</strong>被任意选为起始点。顶点<strong>A</strong>、<strong>B</strong>、<strong>E</strong>和<strong>F</strong>通过单条边与<strong>D</strong>相连。<strong>A</strong>是距离<strong>D</strong>最近的顶点，因此将<strong>A</strong>及对应边<strong>AD</strong>以高亮表示。</td><td>C, G</td><td>A, B, E, F</td><td>D</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016090032.png" alt="img"></td><td>下一个顶点为距离<strong>D</strong>或<strong>A</strong>最近的顶点。<strong>B</strong>距<strong>D</strong>为9，距<strong>A</strong>为7，<strong>E</strong>为15，<strong>F</strong>为6。因此，<strong>F</strong>距<strong>D</strong>或<strong>A</strong>最近，因此将顶点<strong>F</strong>与相应边<strong>DF</strong>以高亮表示。</td><td>C, G</td><td>B, E, F</td><td>A, D</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016130394.png" alt="img"></td><td>算法继续重复上面的步骤。距离<strong>A</strong>为7的顶点<strong>B</strong>被高亮表示。</td><td>C</td><td>B, E, G</td><td>A, D, F</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016143177.png" alt="img"></td><td>在当前情况下，可以在<strong>C</strong>、<strong>E</strong>与<strong>G</strong>间进行选择。<strong>C</strong>距<strong>B</strong>为8，<strong>E</strong>距<strong>B</strong>为7，<strong>G</strong>距<strong>F</strong>为11。<strong>E</strong>最近，因此将顶点<strong>E</strong>与相应边<strong>BE</strong>高亮表示。</td><td>无</td><td>C, E, G</td><td>A, D, F, B</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016154616.png" alt="img"></td><td>这里，可供选择的顶点只有<strong>C</strong>和<strong>G</strong>。<strong>C</strong>距<strong>E</strong>为5，<strong>G</strong>距<strong>E</strong>为9，故选取<strong>C</strong>，并与边<strong>EC</strong>一同高亮表示。</td><td>无</td><td>C, G</td><td>A, D, F, B, E</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016114494.png" alt="img"></td><td>顶点<strong>G</strong>是唯一剩下的顶点，它距<strong>F</strong>为11，距<strong>E</strong>为9，<strong>E</strong>最近，故高亮表示<strong>G</strong>及相应边<strong>EG</strong>。</td><td>无</td><td>G</td><td>A, D, F, B, E, C</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2012/426620/2012073016100874.png" alt="img"></td><td>现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。</td><td>无</td><td>无</td><td>A, D, F, B, E, C, G</td></tr></tbody></table><p>我们举一个走迷宫的例子，来比喻一下这个过程：</p><p>首先，有一个小人进入迷宫起点。</p><p>假设这个点有x个岔路，那么我们让这个小人将每条岔路都走一遍，用一个小本本将每条路的长短记录下来。</p><p>选取最短的路（将这条路圈起来），沿着这条路走到终点。</p><p>在假设这个点有y个岔路，那么我们让这个小人将每条岔路都走一遍，但是这次，我们只记录最短的一条到小本本上，然后选取小本本中记录的最短的（除去圈起来的），沿着这条路走到终点。</p><p>就这样不断的重复，直到所有点都走完。</p><p>要实现这个算法，我们需要一个<strong>邻接矩阵</strong>。</p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Prim算法生成最小生成树</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MiniSpanTree_prim</span><span class="hljs-params">(MGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> min, i, j, k;<br>    <span class="hljs-keyword">int</span> adjvex[MAXVEX];<br>    <span class="hljs-keyword">int</span> lowcost[MAXVEX];<br>    lowcost[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    adjvex[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 我们先让lowcost[i]表示各个顶点i与第0个顶点之间的权值</span><br>    <span class="hljs-comment">// 邻接矩阵中，没有相连的两个点，我们记为最大值</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes;i++)<br>    &#123;<br>        lowcost[i] = G.arc[<span class="hljs-number">0</span>][i];<br>        adjvex[i] = <span class="hljs-number">0</span>; <br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; G.numVertexes;i++)<br>    &#123;<br>        min = INFINITY;<br>        j = <span class="hljs-number">1</span>;<br>        k = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 找到 lowcost 中的最小值，即为与已有集合中的某个点相距最近的点</span><br>        <span class="hljs-comment">// 我们以第一次循环举例，那么，这个就寻找的是距离顶点 0 最近的顶点 k</span><br>        <span class="hljs-keyword">while</span> (j&lt;G.numVertexes)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (lowcost[j]!=<span class="hljs-number">0</span>&amp;&amp;lowcost[j]&lt;min)<br>            &#123;<br>                min = lowcost[j];<br>                <span class="hljs-comment">// 将这个点记录下来</span><br>                k = j;<br>            &#125;<br>            j++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// adjvex[k] 的意义，下面有讲解</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)&quot;</span>, adjvex[k], k);<br>        lowcost[k] = <span class="hljs-number">0</span>;<br><br><br>        <span class="hljs-comment">// 寻找距离顶点k最近的点</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; G.numVertexes;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; G.arc[k][j]&lt;lowcost[j])    <br>            &#123;<br>                <span class="hljs-comment">// 找到之后，更新 lowcost[j]</span><br>                <span class="hljs-comment">// 这样 lowcost 就包含了距离集合V中所有顶点最近的顶点</span><br>                lowcost[j] = G.arc[k][j];<br>                <span class="hljs-comment">// 更新 adjvex[j] ，adjvex[j] 表示距离j最近的是顶点k</span><br>                adjvex[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>显然，该算法的时间复杂度为 O(n*n)。</p><p>参考文档：</p><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html</a></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0041-最小生成树之Kruskal算法</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0041-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BKruskal%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0041-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BKruskal%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h2><p>前面的 Prim 算法是以顶点为主要思考方向，使用的是邻接矩阵。</p><p>而 Kruskal 算法是以边为主要思考方向，它使用的是边集数组。</p><p>Kruskal 算法，比较好描述：</p><ol><li>将边按权值升序排序；</li><li>选出权值最小的边，记录下这条边的两个顶点，如果这两个顶点与集合中已有的顶点没有构成闭合回路，则将则两个顶点添加到集合中，否则排除这条边；</li><li>重复步骤2，直到所有顶点都加入最小生成树中；</li></ol><p>用小人走迷宫举例就是：</p><blockquote><p>让小人将迷宫所有的路都跑一遍，按每条路的长度排个序。</p><p>首先选取最短的路，将这条路画到小本本上。</p><p>然后再选取第二短的路，判断这条路是否与小本本上的路产生了闭合回路，如果没有，则画到小本本上，如果有，则排除这条路，这样不断地循环所有的路。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190509001625839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtMjAxNzA4NjcyMzg=,size_16,color_FFFFFF,t_70" alt="img"></p><p>将图的边按权值排序，每个顶点放在单独的集合里：</p><ul><li><p>选出权值最小的边（0，2）加入到最小生成树中，顶点0和2不在同一集合，没产生回路。合并顶点0和2所在的集合。</p></li><li><p>选出权值最小的边（3，5）加入到最小生成树中，顶点3和5不在同一集合，没产生回路。合并顶点3和5所在的集合。</p></li><li><p>选出权值最小的边（1，4）加入到最小生成树中，顶点1和4不在同一集合，没产生回路。合并顶点1和4所在的集合。</p></li><li><p>选出权值最小的边（2，5）加入到最小生成树中，顶点2和5不在同一集合，没产生回路。合并顶点2和5所在的集合。</p></li><li><p>选出权值最小的边（0，3）加入到最小生成树中，顶点0和3在同一集合中，产生回路，故放弃这条边。再选出权值最小的边（1，2）加入到最小生成树中，顶点1和2不在同一集合，没产生回路。合并顶点1和2所在的集合。</p></li></ul><p>至此所有顶点都在同一个集合中，一颗最小生成树就构造完成。</p><p>算法中的难点，就是如何判断顶点，是否产生了回路！！！</p><p>可以这样做：</p><p>我们定义一个数组 parent[]，x = parent[y]，我们记作 x -&gt; y。</p><p>当有一条边 [i - j] 到来时，我们让 i = parent[j]。</p><p>当下一条边 [i - n] 到来时，我们让 i = parent[n]。</p><p>我们就有了这样的关系图：n -&gt; i &lt;- j。</p><p>n 与 j 的 parent 都是 i。这样如果以后有一条边包含了 n 与 j，我们就知道，这条边肯定形成闭合回路了。</p><p>说了这么多，其实就是给这些边都加一个方向，从边两个顶点出发，都走到了同一个终点，那么就是形成回路了。</p><p>从某个顶点出发，走到最终点的代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] parent, <span class="hljs-keyword">int</span> f)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (parent[f] &gt;<span class="hljs-number">0</span>) &#123;<br>        f = parent[f];<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0042-最短路径之Dijkstra算法</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0042-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BDijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0042-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BDijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="最短路径之Dijkstra算法"><a href="#最短路径之Dijkstra算法" class="headerlink" title="最短路径之Dijkstra算法"></a>最短路径之Dijkstra算法</h2><p>看一个动图：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e4/DijkstraDemo.gif/220px-DijkstraDemo.gif" alt="img"></p><p><strong>算法原理</strong>：</p><p><strong>1)</strong> 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 </p><p><strong>(2)</strong> 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 </p><p><strong>(3)</strong> 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 </p><p><strong>(4)</strong> 重复步骤(2)和(3)，直到遍历完所有顶点。 </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Dijkstra最短路径。</span><br><span class="hljs-comment"> * 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参数说明：</span><br><span class="hljs-comment"> *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。</span><br><span class="hljs-comment"> *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。</span><br><span class="hljs-comment"> *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MatrixUDG::dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vs, <span class="hljs-keyword">int</span> prev[], <span class="hljs-keyword">int</span> dist[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,k;<br>    <span class="hljs-keyword">int</span> min;<br>    <span class="hljs-keyword">int</span> tmp;<br>    <span class="hljs-keyword">int</span> flag[MAX];<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)<br>    &#123;<br>        flag[i] = <span class="hljs-number">0</span>;<br>        prev[i] = <span class="hljs-number">0</span>;<br>        dist[i] = mMatrix[vs][i];<br>    &#125;<br><br>    <span class="hljs-comment">// vs 是起点</span><br>    flag[vs] = <span class="hljs-number">1</span>;<br>    dist[vs] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; mVexNum; i++)<br>    &#123;<br>        <span class="hljs-comment">// dist[] 储存的是各个顶点距离起点的距离</span><br>        <span class="hljs-comment">// 寻找里面的最小值</span><br>        min = INF;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; mVexNum; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (flag[j]==<span class="hljs-number">0</span> &amp;&amp; dist[j]&lt;min)<br>            &#123;<br>                min = dist[j];<br>                k = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 认为 k 是离起点最近的，那么 k 之后就不再参与遍历</span><br>        flag[k] = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 利用 k 作为中转点，更新其他点到起点的距离</span><br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; mVexNum; j++)<br>        &#123;<br>            tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));<br>            <span class="hljs-keyword">if</span> (flag[j] == <span class="hljs-number">0</span> &amp;&amp; (tmp  &lt; dist[j]) )<br>            &#123;<br>                <span class="hljs-comment">// 发现j点经过k点到起点更短</span><br>                <span class="hljs-comment">// 将新的最短路径更新到 dist 中</span><br>                dist[j] = tmp;<br>                <span class="hljs-comment">// prev 是记录的最短路径</span><br>                prev[j] = k;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印dijkstra最短路径的结果</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;dijkstra(&quot;</span> &lt;&lt; mVexs[vs] &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; mVexNum; i++)<br>        cout &lt;&lt; <span class="hljs-string">&quot;  shortest(&quot;</span> &lt;&lt; mVexs[vs] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; mVexs[i] &lt;&lt; <span class="hljs-string">&quot;)=&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>dist[i] 储存的是 i 到起点的最短路径值，没有记录详细的路径节点，前驱节点在 prev[i] 中储存着。</p><p>dist 会不断借助中转点进行更新。</p><p>不看算法，只看算法思想，需要用到邻接矩阵，所以复杂度为 O(n * n)；</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.cnblogs.com/msymm/p/9769915.html">https://www.cnblogs.com/msymm/p/9769915.html</a></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0043-最短路径之Floya算法</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0043-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BFloyd%E7%AE%97%E6%B3%95/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0043-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BFloyd%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Flyod算法"><a href="#Flyod算法" class="headerlink" title="Flyod算法"></a>Flyod算法</h2><p>Flyod是个非常牛逼的人，拥有一个开挂的人生。</p><p>人物简介在此：<a href="https://baike.baidu.com/item/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/4903135?fr=aladdin">罗伯特·弗洛伊德</a> 。</p><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>Flyod算法是一个非常优美的算法，因为它就只有几行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>;k&lt;n;k++)<br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>       <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>           A[i][j]=min(A[i][j],A[i][k]+A[k][j]);<br></code></pre></td></tr></table></figure><p>关于这个算法，它还有一个笑话：</p><blockquote><p>为什么 Dijkstra 不能提出 floyd 算法？因为他的名字是 ijk 而不是 kij。</p></blockquote><p>要理解这个笑话，你需要认真读一下这个算法，在这个算法的3层循环中，三个变量是有一定顺序的：k 必须要在 i 与 j 的外面，i 与 j 没有顺序。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>我们下面来说一下这个算法的由来。Floyd 算法是基于<strong>动态规划</strong>而来的，不了解动态规划的可以先去补一下相关知识。</p><p>我们假设，<img src="https://www.zhihu.com/equation?tex=d%5Ek(i,j)" alt="[公式]">为 i, j之间的最短路，它使用 <img src="https://www.zhihu.com/equation?tex=%5C%7B1,2,%5Ccdots,k%5C%7D" alt="[公式]">作为中间节点，那么根据动态规划方程，可以知道:</p><p><img src="https://www.zhihu.com/equation?tex=d%5Ek(i,j)+=+min(d%5E%7Bk-1%7D(i,+j),+d%5E%7Bk-1%7D(i,+k)+++d%5E%7Bk+-+1%7D(k,+j))" alt="[公式]">。</p><p>本来，是有四种情况的，如下：</p><p><img src="https://www.zhihu.com/equation?tex=d%5E%7Bk%7D(i,+j)+=+min(d%5E%7Bk+-+1%7D(i,+j),+d%5E%7Bk+-+1%7D(i,+k)+++d%5E%7Bk+-+1%7D(k,+j))+" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=d%5E%7Bk%7D(i,+j)+=+min(d%5E%7Bk+-+1%7D(i,+j),+d%5E%7Bk+-+1%7D(i,+k)+++d%5E%7Bk%7D(k,+j))+" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=d%5E%7Bk%7D(i,+j)+=+min(d%5E%7Bk+-+1%7D(i,+j),+d%5E%7Bk%7D(i,+j)+++d%5E%7Bk+-+1%7D(k,+j))" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=d%5E%7Bk%7D(i,+j)+=+min(d%5E%7Bk+-+1%7D(i,+j),+d%5E%7Bk%7D(i,+j)+++d%5E%7Bk%7D(k,+j))" alt="[公式]"></p><p>但是只有第一种形式是正确的，其余3中都是错误的，为啥呢？因为 k 不可能是<img src="https://www.zhihu.com/equation?tex=d%5Ek(i,k)" alt="[公式]">或者<img src="https://www.zhihu.com/equation?tex=d%5Ek(k,j)" alt="[公式]">的中间节点。我们拿 <img src="https://www.zhihu.com/equation?tex=d%5Ek(i,k)" alt="[公式]">举例，如果 k 是  <img src="https://www.zhihu.com/equation?tex=d%5Ek(i,k)" alt="[公式]">  的中间节点。那就说明从 i 到 k 的最短路径包含了 k，那岂不是 k 经过了两次，说明形成了环，而环是不可能作为最短路径的。</p><h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p>好，动态规划的公式，我们写出来了，接下来，我们再来理解一下这个公式的真正意义。</p><p>由公式可知，我们可以根据 K-1 的关系式得出 K 得关系式。这就意味着，<strong>只要我们慢慢的加入顶点，就可以得出最小路径。</strong></p><p>这句话的意思是这样的：</p><p>想象一下，我们已经有了一个已求得各点最短路径的图。这个时候，我们往图里面添加一个顶点 X，我们就只需要求出各点经过 X 的路径，然后与原来的路径做比较即可。</p><p>那么，现在，应该就能理解 k 为什么在最外层了！</p><p>如果 k 在最里层，那么在遍历 k 之前，<strong>没有保证各个点之间已经是最小路径</strong>，自然，经过 k 点时，也不是最短路径。</p><p>这个算法，最神奇的地方在于：先求出各个点经过 V0 点的最短路径之后，再求出各个点经过 V1 点的最短路径时，这个最小距离已经包含了经过 V0 的最小距离。</p><p>所以，外层循环每遍历一次，都相当于更新了一次各个点之间的最短路径。也许，本来最短路径只经过 V0 点，现在变成了 V1 点，或者 V0 + V1 点。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0044-拓扑排序</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0044-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0044-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>拓扑排序是对一个有向无环图进行排序。这么说可能很多人都不太理解，如果你常玩游戏，那我可以举一个例子。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1576404765696&di=926d4fc3afb2b3cffcc7351514625644&imgtype=0&src=http://i0.hdslb.com/bfs/article/3ca47d4461b1294e8a0fb12d84b18c8b25a13821.jpg" alt="img"></p><p>看上面图中的技能树，假设每个技能树点亮都需要花费一个技能点，我们有足够的技能点。</p><p>那么，你告诉我，将技能树全部点亮，有多少种方式？？？</p><p>肯定会不止一种，因为每次点亮都有多个选择。但是你也不能一开始就直接点亮最后面的技能。</p><p>当然这个问题，比较蛋疼，我们其实一般不关心有多少种，只需要一种方式就够了。这每一种方式都是一个拓扑排序。</p><p>好了，理解了拓扑排序，接下来，我们说一下该如何实现这个算法。</p><p>以技能树的方式来看，或许你会感觉这个算法应该很简单，确实如此，但是一个好的算法，还需要一个好的数据结构来辅助。</p><p>比如，我们如何知道，某个技能点亮了，某个技能可以被点亮，某个技能无法被点亮。</p><p>在我们前面学习的图的几种储存结构中，只有邻接表是最合适的，因为用链表储存了与他相邻的所有点。我们只需要加一个 “入度” 字段即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> vex;<br>    <span class="hljs-keyword">int</span> weight;<br>    EdgeNode next;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VexNode</span> </span>&#123;<br>    <span class="hljs-comment">// 入度</span><br>    <span class="hljs-keyword">int</span> in;<br>    T data;<br>    EdgeNode edge;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先，遍历所有顶点，总有几个顶点是没有顶点指向它的（对应技能树的最初几个技能），不然的话，就有环了。</p><p>我们使用一个栈（队列也可以）来储存所有 入度 为 0 的所有顶点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">stack = <span class="hljs-keyword">new</span> Stack();<br>stack.push(node);<br></code></pre></td></tr></table></figure><p>然后将弹出其中一个元素，遍历这个元素的 next 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">VexNode vexNode;<br>EdgeNode edgeNode = vexNode.edge;<br><span class="hljs-keyword">while</span>(edgeNode != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 获取这个边的另一边的顶点</span><br>    <span class="hljs-keyword">int</span> k = edgeNode.vex;<br>    <span class="hljs-comment">// 拿到这个顶点</span><br>    VexNode tempNode = getVexNodeWith(k);<br>    <span class="hljs-comment">// 比如，顶点 1 与顶点 2 相邻</span><br>    <span class="hljs-comment">// 这里就是将 1-2 这条边删除了</span><br>    tempNode.in--;<br>    <br>    <span class="hljs-keyword">if</span> (tempNode.in == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果将边删除之后，发现，这个顶点也成了没有顶点指向的顶点，则将它加入栈中</span><br>        stack.push(tempNode);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 继续循环</span><br>    node = node.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样循环，直到栈为空。</p><p>这个算法不难，理解起来也简单。与广度优先遍历有相同的地方。</p><p>好奇，拓扑排序的作用，可以看下这个：</p><p><a href="https://www.zhihu.com/question/39748146">https://www.zhihu.com/question/39748146</a></p><p>它也可以用来判断一个有向图是否有环，因为如果存在环，<strong>环上的顶点的入度不可能为 0</strong>。遍历完之后，会发现有几个顶点没有遍历到。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0045-关键路径</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0045-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0045-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>关键路径是拓扑排序的一种进阶使用。</p><p>当我们将一个工程的各个流程转换为一张有向图时，我们可以使用拓扑排序来判断工程是否能够顺利完成（有没有环）。</p><p>但是如果我们想知道这个工程能够顺利完成，那么就需要知道这个有向图的<strong>关键路径</strong>了。</p><p>什么是关键路径呢？就是在一个有向图中，从起点到终点，肯定会有不止一条路，关键路径就是<strong>最长的那条路</strong>。</p><h3 id="如何计算关键路径"><a href="#如何计算关键路径" class="headerlink" title="如何计算关键路径"></a>如何计算关键路径</h3><p>我们先来看一个非常简单的图：</p><p><img src="critical_path1.png"></p><p>显然，图中的关键路径是 A -&gt; B -&gt; D。</p><p>这个对人类的大脑来说，非常简单就能计算出来，但是如果图变得复杂，我们就无法一眼看出来了。</p><p>这个关键路径有3个点，我们将这个图压扁，如下：</p><p><img src="critical_path2.png"></p><p>我们假设图上边的权重，代表的是时间（单位为小时）。</p><p>对于 A -&gt; C -&gt; D 这条<strong>不关键</strong>的路径，它由两条边构成：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">A</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">C</span><br><span class="hljs-built_in">C</span> <span class="hljs-operator">-&gt;</span> <span class="hljs-built_in">D</span><br></code></pre></td></tr></table></figure><p>如果我们一开始就进行 A -&gt; C 的工作，花 5 个小时完成。</p><p>然后继续进行 C -&gt; D 的工作，花 9 个小时完成。</p><p>这个时候，工程仍然处于未完成状态，因为 B -&gt; D 这条线还处于进行状态。</p><p>所以，我们也可以这样，我们一开始不做 A -&gt; C 的工作，我们等 （3 + 27 - 9 - 5） 个小时，在开始 A -&gt; C 的工作。</p><p>你就会发现，<strong>不关键的路径的执行时间是可以浮动的</strong>。</p><p>对于上面的例子，A -&gt; C 的浮动范围为 (0, 16)， C -&gt; D 的浮动范围为 (5, 21)。</p><blockquote><p>就不要太在意边界条件了</p></blockquote><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先来四个定义：</p><blockquote><p> 前两个针对顶点，后两个针对边</p></blockquote><p><strong>事件最早开始时间</strong>：顶点Vi最早发生的时间。</p><p><strong>事件最晚开始时间</strong>：顶点Vi最晚发生的时间，超出则会延误整个工期。</p><p><strong>活动的最早开始时间</strong>：边Eg最早发生时间。</p><p><strong>活动的最晚开始时间</strong>：边Eg最晚发生时间。不推迟工期的最晚开工时间。</p><p>我们很难直接计算出边的最早最晚开始时间，但是对于每个顶点来说，可以比较简单的计算出。</p><p>有了每个顶点的最早最晚发生时间，我们就可以计算出边的最早最晚发生时间，从而得出关键路径。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>首先，我们仍然使用 拓扑排序 计算出一个顶点序列，不过，我们在做拓扑排序的时候，还可以顺便做一件事情，就是计算出每个定点的最早发生时间。</p><p>计算公式如下：</p><p>etv[k] = max{etv[i] + len(vi, vk)}</p><p>这个公式的意思：</p><blockquote><p>顶点 k 的最早发生时间 = 顶点 i 的最早发生时间 +  i -&gt; k 这条边的值。</p><p>i 为与 k 相连的所有顶点。</p><p>顶点 i 为弧头，k 是弧尾。</p></blockquote><p>我们得到了 拓扑序列 与 所有顶点的最早发生时间，然后就可以获取所有顶点的最晚发生时间了。</p><p>我们将<strong>拓扑序列倒序遍历</strong>，做如下计算：</p><p>ltv[k] = min{ltv[j] - len(vk, vj)}</p><p>这个表达式，与上面的差不多，意思也差不多，不过这里是做减法。</p><p>还有一个需要注意的地方，就是 顶点 k 是弧头，顶点 j 是弧尾，与上面是相反的。</p><p>这样，我们就求的了各个顶点的最晚发生时间。</p><p>知道了最早最晚发生时间，就可以求边的最早最晚发生时间，从而得到关键路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;g.numVextexs;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (g.adjList[i].fitstedge)<br>    &#123;<br>        e = g.adjList[i].fitstedge;<br>        <span class="hljs-keyword">while</span>(e)<br>        &#123;<br>            <span class="hljs-keyword">int</span> eIdx = e-&gt;idx;<br>            <span class="hljs-comment">//活动（i-&gt;eIdx）最早开始时间：事件（顶点） i最早开始时间</span><br>            ete = g_etv[i];<br>            <span class="hljs-comment">//活动（i-&gt;eIdx）最迟开始时间：事件（顶点） eIdx 最迟开始时间 减去 活动持续时间</span><br>            lte = g_ltv[eIdx] - e-&gt;weigh; <br>            <span class="hljs-keyword">if</span> (ete == lte)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%c - %c)-&gt;&quot;</span>,g_init_vexs[i],g_init_vexs[eIdx]);<br>            &#125;<br>            e= e-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个的循环，就是遍历每个顶点的邻接边，求各个边的最早最晚发生时间。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0046-二叉树的查找</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0046-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0046-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h2><p>二叉树的查找与二分查找很像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">serachBinaryTree</span><span class="hljs-params">(BinaryTree bt, <span class="hljs-keyword">int</span> key, BinaryTree parent)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (bt == <span class="hljs-keyword">null</span> || bt.data == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 树节点不存在，返回</span><br>        parentNode = parent;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == bt.data) &#123; <span class="hljs-comment">// 查找成功</span><br>        parentNode = bt;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; bt.data) &#123; <span class="hljs-comment">// 关键字小于根节点查找左子树</span><br>        <span class="hljs-keyword">return</span> serachBinaryTree(bt.lchild, key, bt);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 关键字大于根节点查找右子树</span><br>        <span class="hljs-keyword">return</span> serachBinaryTree(bt.rchild, key, parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看一下二分查找法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 递归实现二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> minIndex, <span class="hljs-keyword">int</span> maxIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> midIndex = (minIndex &amp; maxIndex) + ((minIndex ^ maxIndex) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (data &lt; arr[minIndex] || data &gt; arr[maxIndex] || minIndex &gt; maxIndex) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (data &gt; arr[midIndex]) &#123;<br>        <span class="hljs-keyword">return</span> binarySearch(data, arr, midIndex + <span class="hljs-number">1</span>, maxIndex);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; arr[midIndex]) &#123;<br>        <span class="hljs-keyword">return</span> binarySearch(data, arr, minIndex, midIndex - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的都是递归的写法，理解起来应该也很简单。</p><p>当然也有循环的写法，就不介绍了。</p><p>递归转循环，<strong>无非就是在循环里面改变需要改变的值罢了</strong>。</p><p>上面的二分查找，每次递归，都是改变了  minIndex maxIndex 的值，其他的没有改变，那么我们将更改这两个值的代码，放到循环中就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (minIndex &lt;= maxIndex) &#123;<br>    midIndex = (minIndex &amp; maxIndex) + ((minIndex ^ maxIndex) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (data &gt; arr[midIndex]) &#123;<br>        minIndex = midIndex + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &lt; arr[midIndex]) &#123;<br>        maxIndex = midIndex - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0047-二叉树的插入</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0047-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0047-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h2><p>二叉树的插入需要借助二叉树的查找。</p><p>思考这样的一个问题，<strong>当我们在二叉树中寻找一个节点时，如果这个节点不存在，最后遍历的那个节点与要寻找的节点有什么关系？</strong>？？</p><p>在脑子里过一下查找的过程，发现，没找到的情况下，肯定是在树中找到了<strong>与目标节点最接近的那个节点</strong>。</p><p>知道了这个条件，我们就可以很容易的插入了。</p><p>我们将最后遍历的那个节点叫做 L，目标节点叫做 T。</p><p>如果 L.data &gt; T.data 则，T 可以做为 L 的右节点。反之作为左节点。</p><p>还有一个需要注意的地方，要特殊处理。如果树是空树，则 T 需要作为根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!find(key)) &#123;<br>    Node temp = <span class="hljs-keyword">new</span> Node();<br>    temp.data = key;<br>    <span class="hljs-keyword">if</span> (isEmptyTree()) &#123;<br>        doSomeThing();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last.data &gt; temp.data) &#123;<br>        last.left = temp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        last.right = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了二叉树的插入，构建一个二叉树就非常的简单了。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0048-二叉树的删除</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0048-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0048-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h2><p>二叉树的删除是一个相对复杂一点的操作，因为它需要分情况考虑。</p><p><strong>情况一：</strong>如果待删除的节点是<strong>叶子节点</strong>，这个自然好说，直接删除就好了。</p><p><strong>情况二：</strong>如果待删除的节点<strong>只有左子树或者只有右子树</strong>，这个也简单，让它的左子树或者右子树的根节点来顶自己的位置就好了。</p><p><strong>情况三：</strong>如果待删除的节点既有左子树，又有右子树，该怎么办呢？我们举个例子，如果要删除的是根节点，该让谁来顶根节点的位置？？？</p><p><img src="https://img-blog.csdn.net/20130506102041907" alt="img"></p><p>按照二叉树的尿性，<strong>根节点一般是偏居中的一个值</strong>。所以有两种顶位的方案：让左子树最大的来顶或者让右子树最小的来顶。</p><p>我们仔细想一下这两种方案，会发现一件有趣的事情。</p><p>如果我们让左子树的最大值来顶，那么我们分3步：</p><ul><li>将最大值复制一份</li><li>替换根的值</li><li>删除最大值节点</li></ul><p>前两步简单，第三步看上去又回到了<strong>删除节点问题</strong>上，但是稍微思考一下就会发现因为它已经是最大值了，所以它没有右子树，即这个删除情况与第二种情况一样。</p><p>所以，<strong>最终我们是将情况三转换成了情况二</strong>，同样的，删除右子树的最小是也是同样的道理。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// deleteBST 主要是找到要删除的节点</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteBST</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (key == root.data) &#123;<br>            <span class="hljs-keyword">return</span> delete(root);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root.data) &#123;<br>            <span class="hljs-keyword">return</span> deleteBST(root.left, key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> deleteBST(root.right, key);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Node p)</span> </span>&#123;<br>Node q,s;<br>    <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 左子树为空</span><br>        p = p.right;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 右子树为空</span><br>        p = p.left;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 左右子树都不为空</span><br>        q = p;<br>        s = p.left;<br>        <span class="hljs-comment">// 找左子树的最大值</span><br>        <span class="hljs-keyword">while</span> (s.right != <span class="hljs-keyword">null</span>) &#123;<br>            q = s;<br>            s = s.right;<br>        &#125;<br>        <span class="hljs-comment">// while 之后，s 指向最大值，q是s的父节点</span><br>        <span class="hljs-comment">// 交换值</span><br>        p.data = s.data;<br>        <span class="hljs-comment">// 这里其实也可以直接递归调用 delete(s)</span><br>        <span class="hljs-keyword">if</span>(q != p) &#123;<br>            q.right = s.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.left = s.left;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0049-平衡二叉树</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0049-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0049-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树也是一种二叉排序树，只不过它比较平衡。</p><p>什么叫平衡呢？平衡就是指这个树的<strong>左右两个子树的高度差的绝对值不超过1</strong>。而且，它的左右子树也是平衡二叉树。（禁止套娃）</p><p>在我们构造一个平衡二叉树的时候，肯定不会像构造排序二叉树那么简单，我们需要动态的调整这棵树的平衡性，每当插入一个节点时，导致了树不平衡了，就立刻调整这棵树。</p><p>我们会遇到四种需要调整的情况：</p><h3 id="LL型调整"><a href="#LL型调整" class="headerlink" title="LL型调整"></a>LL型调整</h3><p><img src="https://img-blog.csdn.net/20150818212028853" alt="img"></p><p><img src="https://img-blog.csdn.net/20150818221513880" alt="img"></p><p>比如，我们按照 4，2，1 的顺序构造一个平衡二叉树，就会出现上图的情况。</p><p>这个LL型调整，也有人称为“右旋”，下面给个图来形象的解释一下啥叫“右旋”。</p><p><img src="avl_1.png"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">llRotate</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    Node newRoot = root.left;<br>    <span class="hljs-comment">// 开始碰撞</span><br>    root.left = newRoot.right;<br>    <span class="hljs-comment">// 碰撞完成</span><br>    newRoot.right = root;<br>    <br>    <span class="hljs-keyword">return</span> newRoot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RR型调整"><a href="#RR型调整" class="headerlink" title="RR型调整"></a>RR型调整</h3><p><img src="https://img-blog.csdn.net/20150818215441436" alt="img"></p><p><img src="https://img-blog.csdn.net/20150818220942825" alt="img"></p><p>这个与LL刚好是相反的，理解了LL，这个也就理解了。只需要将 A 节点降下来就好了。</p><h4 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">rrRotate</span><span class="hljs-params">(Node root)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node newRoot = root.right;<br>    root.right = newRoot.left;<br>    newRoot.left = root;<br> <br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LR型调整"><a href="#LR型调整" class="headerlink" title="LR型调整"></a>LR型调整</h3><p><img src="https://img-blog.csdn.net/20150818222514855" alt="img"></p><p><img src="https://img-blog.csdn.net/20150818224419149" alt="img"></p><p>这个调整就比较难理解了。其实这里有一个技巧：我们会发现上图中节点A 与节点B 的平衡因子的符号不一样。</p><p>节点 A 的平衡因子为 2，节点 B 的平衡因子为 -1。这种情况下，我们不能直接旋转树，就算你旋转了也没啥屌用，还是不平衡的，那么应该怎么做呢？</p><p>我们先<strong>将节点 A 的左子树左旋</strong>，会得到如下图：</p><p><img src="avl_2.png"></p><p><strong>然后，我们再右旋以A为根的树</strong>，就可以得到上面图中右边的树了。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">lrRotate</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-comment">// 先旋转A的左子树，旋转完之后，让它接回来</span><br>    root.left = rrRotate(root.left);<br>    <span class="hljs-comment">// 再旋转A</span><br>    llRotate(root);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RL型调整"><a href="#RL型调整" class="headerlink" title="RL型调整"></a>RL型调整</h3><p><img src="https://img-blog.csdn.net/20150818224940731" alt="img"></p><p><img src="https://img-blog.csdn.net/20150818230041580" alt="img"></p><p>这个与LR就是相反的，也就好理解了。</p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">rlRotate</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    root.right = llRotate(root.right);<br>    rrRotate(root);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整算法实现"><a href="#完整算法实现" class="headerlink" title="完整算法实现"></a>完整算法实现</h3><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Node <span class="hljs-title">insert</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-comment">// 空树</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        Node node = <span class="hljs-keyword">new</span> Node();<br>        node.key = key;<br>        <span class="hljs-comment">// 节点的高度</span><br>        node.height = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 递归的寻找节点</span><br>    <span class="hljs-keyword">if</span> (key &lt; node.key) &#123;<br>        node.left = insert(node.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &gt; node.key) &#123;<br>        node.right = insert(node.right, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    node.height = <span class="hljs-number">1</span> + max(height(node.left), height(node.right));<br>    <br>    <span class="hljs-keyword">int</span> balance = getBalance(node);<br>    <br>    <span class="hljs-comment">// 在A的左孩子(L)的左子树(L)上插入新结点</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &lt; node.left.key) &#123;<br>        <span class="hljs-keyword">return</span> llRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在A的右孩子(R)的右子树(R)上插入新结点</span><br>    <span class="hljs-keyword">if</span> (balance &lt; -<span class="hljs-number">1</span> &amp;&amp; key &gt; node.right.key) &#123;<br>        <span class="hljs-keyword">return</span> rrRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在A的左孩子(L)的右子树(R)上插入新结点</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; key &gt; node.left.key) &#123;<br>        node.left = rrRotate(node.left);<br>        <span class="hljs-keyword">return</span> llRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在A的右孩子(R)的左子树(L)上插入新结点</span><br>    <span class="hljs-keyword">if</span> (balence &lt; -<span class="hljs-number">1</span> &amp;&amp; key &lt; node.right.key) &#123;<br>        node.right = llRotate(node.right);<br>        <span class="hljs-keyword">return</span> rrRotate(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">llRotate</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    Node newRoot = node.left;<br>    node.left = newRoot.right;<br>    newRoot.right = node;<br>    <br>    node.height = max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;<br>    newRoot.height = max(height(newRoot.left), height(newRoot.right)) + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">return</span> newRoot;<br>&#125;<br><br><span class="hljs-function">Node <span class="hljs-title">rrRotate</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    Node newRoot = node.right;<br>    node.right = newRoot.left;<br>    newRoot.left = node;<br>    <br>    node.height = max(height(node.left), height(node.right)) + <span class="hljs-number">1</span>;<br>    newRoot.height = max(height(newRoot.left), height(newRoot.right)) + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">return</span> newRoot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(Node node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> node.height;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(Node node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> height(node.left) - height(node.right);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0050-B树</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0050-B%E6%A0%91/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0050-B%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树一般写作“B树”或者“B-树”。“B-树”就是“B树”，中间的横线并不是减号。</p><p>B树用于大数据的储存，为什么呢？二叉树难道不行吗？</p><p>其实，从算法逻辑上来讲，二叉查找树的查找速度和比较次数都是最小的。但是有一个现实的问题拦在了我们前面，磁盘IO问题。</p><p>对于大数据的储存，必定要放入磁盘中，所以处理数据必定会涉及到磁盘IO。</p><p>看下面一个例子：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1abfdfc89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1abfdfc89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>这里我们让树的节点对应磁盘页。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1ade5fc24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>二叉查找树的结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1b26bf2e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第1次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1bc8f309b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第2次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1c828bb63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第3次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1cd0ac5f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第4次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1cdc4983f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1cf06b36f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1d2bbfb75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>IO是非常耗时的，<strong>所以为了减少IO次数，我们就将树变矮变胖</strong>，就是B树了。</p><p>下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：</p><p>1.根结点至少有两个子女。</p><p>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</p><p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p><p>4.所有的叶子结点都位于同一层。</p><p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p><p>上面的概念看着很蛋疼，还是来看一个例子吧：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1eab1116e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1eb401c01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1ec199d2f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b1f3d365da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2001c6b90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b203a7f6f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第1次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2028426a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在内存中定位（和9比较）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b20712252c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第2次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b21ab39190?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在内存中定位（和2，6比较）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b21f1f6280?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>第3次磁盘IO：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2210be1d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在内存中定位（和3，5比较）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2268e1ef2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b222b71c31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b23783a7ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b22b83bd29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b24568925a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b23cfbaff3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b255827ba3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是<strong>拆分</strong>节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b26e7b69d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b27634916b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b27df23411?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b27eddceca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>自顶向下查找元素11的节点位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b28771232f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的<strong>中位数</strong>13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为<strong>左旋</strong>）</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b28e96f94d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b295c46fe3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b299dbe7d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2aa8e105f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2ae791779?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/6/168232b2b25747e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。我们对B树进行调整，使B树的阶数与硬盘储存的页面大小相匹配。比如说一棵B树的阶为1000，高度为3，它可以储存超过10亿（1000x1000x1000）个关键字。</p><p>我们只需要让根节点持久地保留在内存中，那么在这棵树上，寻找某一个关键字，至多需要两次硬盘的读取。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.im/post/5c31f64c6fb9a049ac794ffc">https://juejin.im/post/5c31f64c6fb9a049ac794ffc</a></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0051-B+树</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0051-B+%E6%A0%91/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0051-B+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.mp.sohu.com/upload/20170713/17a0c4f672b34e668a0cd2eb214c117d_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/c56155c2131e45b0bf69f9ae6cba056e_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/164ce3d2504c4d63945e134ca6752a2c_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/891ad19fb4294e9293fdca83e8e34616_th.png" alt="img"></p><p>一个m阶的B树具有如下几个特征：</p><p>1.根结点至少有两个子女。</p><p>2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</p><p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p><p>4.所有的叶子结点都位于同一层。</p><p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p><p><img src="http://img.mp.sohu.com/upload/20170713/eb790f08a02a4bcbbc7cf3f3f8a95d4d_th.png" alt="img"></p><p>一个m阶的B+树具有如下几个特征：</p><p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p><p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p><p><img src="http://img.mp.sohu.com/upload/20170713/ff571cfd72ab4a068ce0867b0e450de8_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/d4430eb5e5ef42008b1facec51636dbb_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/034a86d6e1d94c798e63ab144955c0f6_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/86f732dd90b74be3bf9494859fa78d66_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/0611ff5a5103461e843ab627f8821419_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/adada4999fdd48d4937f5f14c0eb7792_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/afffda21578b4d8a90cbdea4976fb5b6_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/29583d49358e41fa9c2fbc5169fb7d14_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/04eb120cd1e04d3a94c2482abc7deb96_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/3ce28ba0a2bd426ebebac9603f728603_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/3bd2b4220a0f4d1887e2943a729c40a1_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/664e36a4da0f45fcaf6e18b68d36a0b4_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/514d587fa73746978200aca252837a44_th.png" alt="img"></p><p>B-树中的卫星数据（Satellite Information）：</p><p><img src="http://img.mp.sohu.com/upload/20170713/36efa69561dc4043a17d550133e13a6c_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/c3a519a9a9e8456d9be41e69709bafaf_th.png" alt="img"></p><p>B+树中的卫星数据（Satellite Information）：</p><p><img src="http://img.mp.sohu.com/upload/20170713/d8ae1b14e9bf4b1890146eb803ee9795_th.png" alt="img"></p><p>需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p><p><img src="http://img.mp.sohu.com/upload/20170713/7a52624e7add4033bb49c3aa5632a681_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/0ae1d08ece1e4daeac37361e86b3d6a6_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/32ad0e6237624d718bb9a5346e37792e_th.png" alt="img"></p><p>第一次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/6808907785b84be09d8c6b7c8acb5d2a_th.png" alt="img"></p><p>第二次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/0193eedf3a5b47129340e2b6c654ef72_th.png" alt="img"></p><p>第三次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/68553d369a304d798116f432247c6e3f_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/3830300c15bf41f8a2c8fdf8d163fa5b_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/baaed98d8fca4fb9806400651953f92d_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/99d5067451ec486dbccc37611ff3747c_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/7522d2811b5340a7a9b222bc14ba7276_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/169def080e8e47a68fc4fdce3451337a_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/8db1bc52ab2c418eb9a92fbb1189db98_th.png" alt="img"></p><p>B-树的范围查找过程</p><p>自顶向下，查找到范围的下限（3）：</p><p><img src="http://img.mp.sohu.com/upload/20170713/bb40b700247c425f9b9d358c726d5e65_th.png" alt="img"></p><p>中序遍历到元素6：</p><p><img src="http://img.mp.sohu.com/upload/20170713/244ea6eaee4a4e1d87a33967ff6ef5ff_th.png" alt="img"></p><p>中序遍历到元素8：</p><p><img src="http://img.mp.sohu.com/upload/20170713/61f472a56f7840e78de23901cb5e85b2_th.png" alt="img"></p><p>中序遍历到元素9：</p><p><img src="http://img.mp.sohu.com/upload/20170713/a7881e1683a8486fa3956d585a97bd6d_th.png" alt="img"></p><p>中序遍历到元素11，遍历结束：</p><p><img src="http://img.mp.sohu.com/upload/20170713/c3fc3c097cf94d439c5d6962d2fb8d4e_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/1a3c8f93be3249d28b0813f9d0d5e998_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/80eff1a11cf24458a5cf80b821d365cd_th.png" alt="img"></p><p>B+树的范围查找过程</p><p>自顶向下，查找到范围的下限（3）：</p><p><img src="http://img.mp.sohu.com/upload/20170713/c0ef4d22cedf43cc8d21732d27f9be3e_th.png" alt="img"></p><p>通过链表指针，遍历到元素6, 8：</p><p><img src="http://img.mp.sohu.com/upload/20170713/005777d81ab247c281f8a1b4bc6b3461_th.png" alt="img"></p><p>通过链表指针，遍历到元素9, 11，遍历结束：</p><p><img src="http://img.mp.sohu.com/upload/20170713/e972e47b2c554f789e02e90b26a8b543_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/fb9ce5eba2f845c7b378da1921029511_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/0ba5c259843a4d0e8ef5d318362f097f_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/44cd141ed5094c09a1870d0449f9aab7_th.png" alt="img"></p><p><img src="http://img.mp.sohu.com/upload/20170713/9b5530015b324841a570505798c937f4_th.png" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="简要地介绍B-树："><a href="#简要地介绍B-树：" class="headerlink" title="简要地介绍B+树："></a>简要地介绍B+树：</h3><p>​    B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</p><h3 id="B-树的特征："><a href="#B-树的特征：" class="headerlink" title="B+树的特征："></a>B+树的特征：</h3><p>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素<strong>不保存数据，只用来索引</strong>，所有数据都保存在叶子节点。</p><p>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。（链表）</p><p>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p><h3 id="B-树的优势："><a href="#B-树的优势：" class="headerlink" title="B+树的优势："></a>B+树的优势：</h3><p>1.单一节点存储更多的元素（因为不需要储存卫星数据，所以可以存放更多的关键字），使得查询的IO次数更少。</p><p>2.所有查询都要查找到叶子节点，查询性能稳定。</p><p>3.所有叶子节点形成有序链表，便于范围查询。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0052-几种排序算法</title>
    <link href="/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/09/22/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574071390673&di=ba2aabca513398477433f20938c0e1cc&imgtype=jpg&src=http://img.mp.itc.cn/upload/20170709/75b2287703174baa856f13ff062ad0f3_th.jpg"></p><p>假设我们不是对序列进行排序，而是对角斗士进行武力排名，那么该怎么设立一个规则呢？</p><p>我们给角斗士每人分配一个令牌，令牌的编号对应着排名，从 1 到 n，刚开始肯定是随机分配一个令牌。</p><p>然后角斗士可以发起挑战，但是只能挑战排名比自己高1位的对手，比如编号为 14的，只能挑战编号为13的对手，如果挑战成功之后，互换令牌。</p><p>这样，经过一段时间之后，角斗士手里的令牌不再变化了，那么手里令牌为1的，就是武力最高的了。</p><p>这就是一个冒泡排序了，能力更出众的，总是会往上冒。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序虽然也可以用角斗士的例子，但是这样不免重复，会导致记忆混乱。</p><p>选择排序着重于选择，每一次的选择结果都会导致序列变化。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574073009920&di=7eb6589c7d79ca4edaee46a995c83d11&imgtype=0&src=http://pic.962.net/up/2018-9/15366576267342512.jpg"></p><p>假设你是一个农村里的孩子，一天你砍了很多竹子用来喂竹鼠，但是在喂之前你突然想给竹子按长度排一个序，然后再砍了喂竹鼠。那么该怎么排呢？</p><p>可以这样，先扫一眼所有的竹子，找到最长的，放到第一位，这样最长的就找到了，将这个最长的拿到一边。</p><p>重复上面的步骤，就排好序了。</p><p>所谓选择，就是每次都选择一个自己需要的。</p><p>选择排序比起冒泡排序少了很多交换动作，所以要稍微快点。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574073480251&di=cfa51463944838874a03a931d7f4e25a&imgtype=0&src=http://a4.att.hudong.com/64/93/19300001024098134717935829117.jpg"></p><p>插入排序有一个最形象的例子了，每个人都玩过，就是扑克牌。</p><p>回想一下，你斗地主的时候，一张一张的起牌的时候，是不是每次都是插入一张牌到手里的牌里面。</p><p>比如，你的手里有一张 3，一张 5，这个时候来了一张 4，你肯定是将 4 插入到 3 与 5 中间。</p><p>因为你手里的牌本来就是有序的，所以插入也非常快。</p><p>插入排序不稳定，如果本来是有序的，最快可以为 o(n)，最慢为 o(n*n)。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574075185473&di=e0ee7af3c73da1adb0132ea852e1313f&imgtype=0&src=http://i0.hdslb.com/bfs/article/fc43c32d0d7b7f9e17bb562f09de8edecc37f80b.jpg" alt="img"> </p><p>前面说过，插入排序在序列有序的情况下，速度非常快，那么可不可以先让序列变为基本有序，然后再排序呢？</p><p>说明一下，啥叫基本有序，基本有序就是小的基本在前面，大的基本在后面，不大不小的基本在中间。</p><p>比如一个序列，{9， 1， 5， 8， 3， 7， 4， 6 ，2}，它是一个无序序列。</p><p>想一下，怎么将它变成一个基本有序序列？</p><p>我们将这个序列，按照镂空的方式分为3段，如下：</p><p>第一段：{o，x，x，o，x，x，o，x ，x}，得到 {9，8，4}</p><p>第二段：{x，o，x，x，o，x， x，o ，x}，得到 {1，3，6}</p><p>第三段：{x，x，o， x，x，o，x， x ，o}，得到 {5，7，2}</p><p>为啥要这样分呢？因为这样分了之后，每一段都保留了整个序列的部分特征，对这些子序列进行排序之后，整个序列就会基本有序。</p><p>比如，我们使用插入排序，将上面的3个子序列排序后：</p><p>{4，8，9}</p><p>{1，3，6}</p><p>{2，5，7}</p><p>合并之后，就会得到{4，1，2，8，3，5，9，6，7}，虽然还不是有序的，但是比起原来的序列，已经算得上的基本有序的，然后我们重复上面的步骤，再次将整个序列分解，但是间隔要慢慢变小，直到为0。</p><p>为 0 时，就是最后一次比较，就是对整个序列进行一次插入排序，比较完之后，序列就是有序的了。</p><p>希尔排序的时间复杂度在 ${o(n^{\frac{3}2})}$，虽然它的代码里面有3个循环。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574075256315&di=7523894d6b6d242d9e8f4bd360f5aa1a&imgtype=0&src=http://img.juimg.com/tuku/yulantu/140812/330709-140Q211040899.jpg"></p><p>堆是一个完全二叉树。</p><p>在排序算法中，我们使用数组来表示这个完全二叉树，如下：</p><p><img src="https://images2017.cnblogs.com/blog/1120165/201801/1120165-20180110173213144-507404208.png"></p><p>上图是一个大顶堆，大顶堆就是最大的在根上。对应的还有小顶堆。</p><p>看图中每个节点的索引关系：</p><blockquote><p>一个节点的索引为 i，其左孩子节点的索引为 2*i + 1，右孩子节点的索引为 2* i + 2.</p><p>当然这个关系不是固定的，如果不在0位置储存元素，那么关系就不一样了。</p></blockquote><p>对于一个无序序列，刚开始的堆肯定是不满足条件的，需要调整这个堆，如何调整呢？很简单，只需要对非叶子节点，做如下处理就好了：</p><blockquote><p>比较它的左右孩子，找到更大的孩子，然后与自己比较，如果孩子大，则交换。</p></blockquote><p>注意，要对每个非叶子节点处理，遍历的时候，要从索引值由大到小开始，不然的话，小的（就是最上面的）先换了也没用。好的，我们使用内在化来强化记忆一下这个过程：</p><p><img src="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/heapSort.gif?raw=true"></p><p>这里有一个动图，只看它的前半部分。</p><p>我们将每个节点当作一个角斗士，对于最下面一层的角斗士，他们下面已经没有人了，所以没必要决斗。对于其他角斗士，则需要从3个角斗士中选一个，让最厉害的角斗士站在顶端。如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/heap.png?raw=true"></p><p>对每个非最底层的角斗士（从下往上）都这样来一遍，这样处于最顶端的就是最厉害的角斗士了。这个和我们常见的两两对战不一样，而是三三对战。</p><p>如此，我们的大顶堆就构建好了。构建好了然后呢，这个玩意怎么帮助我们排序呢？</p><p>假设，国王让你选出10个最厉害的角斗士，你按照上面的三三对战方式选出了最厉害的一个，然后该怎么办？将最厉害的择出来，然后按照同样的方式再一次选一个吗？这样也可以，但是就浪费了第一次比较的结果（时间复杂度为o(n*n)的都是这样，没有好好利用前一次比较的结果）。</p><p>那么应该如何利用前一次的比较结果呢？只需要找到完全二叉树里面，叶子节点最右边的一个（索引值最大的一个），将它与根节点交换，然后让根节点不断的下沉就好了。</p><p>所以，我们让序号最大的角斗士与序号最小的角斗士交换位置，再将最后一个位置去掉（它已经是最厉害的了）。</p><p>交换之后，让序号最小的角斗士与他下面的两人比较，谁最厉害就与谁交换位置。这里假设交换的左边的孩子位置，那么它应该下沉到左边孩子位置。</p><p>下沉之后，再让他与两个孩子比较，不断的重复这个过程，直到位置不再改变，这样，根上的就是第二厉害的角斗士了，而且依然是一个大顶堆。</p><p>堆排序的时间复杂度为 O(n*logn)，因为二叉树的高度为 logn，空间复杂度 o(1)，只需要一个用来储存临时数据的交换单元，还是非常不错的。</p><p>堆排序是一个不稳定的算法，因为交换不是相邻交换，而是跳跃式交换。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="https://a.zdmimg.com/201909/27/5d8d6d7b953bb6313.jpg_fo742.jpg"></p><p>归并排序使用了分治的思想。</p><p>假如你是皇帝，你要选出全国最美的十个少女，那么应该怎么做呢？</p><p>你需要将命令传递到丞相，丞相将命令下发到各个州，各个州再传递到各个郡，各个郡再传递到各个县。</p><p>然后由县令统计出当地的少女并排好名次，再交给所属的太守，太守负责汇总所管辖的各个县，然后排出所有名次，再上传给刺史。然后刺史汇总所有管辖的郡，排好名次，上传给丞相，丞相汇总各个州的名词，在交给皇帝，就搞定了。</p><p>先看看归并排序的动图吧：</p><p><img src="https://img2018.cnblogs.com/blog/1258817/201903/1258817-20190326201207440-689679432.gif"></p><p>这个很容易理解：</p><p>就是将一个 n 长的序列，分解为n个1长度序列，然后两两比较，合成 n/2 个 2 长度的序列，再两两合并，直到序列只有一个。</p><p>归并排序是相邻的比较，所以是稳定的排序。它的时间复杂度为 O(n*logn)，但是空间负责度为 O(n)。将两个数组合并成一个数组的时候需要额外的储存空间。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574163780407&di=220f5a174e686c27c818a2fd5f03e0e1&imgtype=0&src=http://imgqn.koudaitong.com/upload_files/2015/02/05/Fl6VuwWfHxhPtmRW54B2r_YElPEc.jpg%2521730x0.jpg"></p><p>比如，你在逛一个超市，买了各种零食与家用品，全部放在了堆在了背包里面。</p><p>回家后，你想按照价值给它们排个序，你准备如何做呢？</p><p>可以这样做，随便从包里选一个出来作为参照物，然后将比这个参照物价值小的放到左边，将比这个参照物价值大的放到右边。这样，参照物的位置就固定了，然后再堆左右两边做同样的操作，直到左右两边不可分隔。这样就排好序了。</p><p>这个就是快速排序。</p><p>看个图加深一下印象：</p><p> <img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" alt="img"> </p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm">JS-Sorting-Algorithm</a></p><p><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg">十大经典排序算法动画与解析，看我就够了！（配代码完全版）</a></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2019/09/22/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/TCP/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2019/09/22/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/TCP/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>滑动窗口是用于控制网络传输的流量的，说白了就是TCP在进行数据传输的时候，会有两个端，一个发送端，一个接收端。但是发送端与接收端它们是处于不同环境（应用、系统、硬件）的，所以它们的发送能力与接受能力肯定是不一样的，那么就很可能出现这样的问题：如果发送的速度过快，而接收端处理的较慢，就会出现接收端数据溢出的问题！！！</p><p>那么滑动窗口就是处理<strong>这些</strong>问题的，上面只是举了一个例子，实际上会有更多的问题，这里就不细说了，直接看看滑动窗口是如何工作的吧。</p><h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><ol><li><p>首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。 </p><p><img src="https://c1.staticflickr.com/1/955/42138740462_ed4ce64c1b_b.jpg" alt="img"></p></li><li><p>接收端没有收到A，所以不回复ACK包。发送端重传A,B,C,D四个包，这次全都到达了。</p><p><img src="https://c1.staticflickr.com/1/949/42138740402_dbbbf52c8c_b.jpg" alt="img"></p></li><li><p>接收端先获得A，发ACK包A，但是中途丢失；根据<strong>累计确认</strong>的原则，发D的ACK包，然后窗口滑动。</p><p><img src="https://c1.staticflickr.com/1/904/27313728687_a5673da755_b.jpg" alt="img"></p><p>这里解释一下，什么是累计确认！！！</p><p>累计确认可以理解为发送端与接收端做的一个<strong>特殊约定</strong>。当接收端成功收到了 A-D的所有包后，那么可以直接发一个D的确认包就OK了，然后发送端收到了D的确认包之后，就明白A-D已经全被接受了。</p><p>根据上面的解释，我们可以推断出这样的一种情景：</p><p>发送端发送了 A-D 包，但是 D 先到达了，那么接收端是不能发送 D 的确认包的！！！接收端只能按照顺序来发送确认包。</p></li><li><p>发送端收到D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。</p><p><img src="https://c1.staticflickr.com/1/951/27313728577_04e0867716_b.jpg" alt="img"></p></li><li><p>接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是<strong>发F的ACK包</strong>；收到H，还是<strong>发F的ACK包</strong>。不幸的是，三个ACK包全都丢失。 </p><p><img src="https://c1.staticflickr.com/1/952/27313728427_a5b7d4b107_b.jpg" alt="img"></p></li><li><p>发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失。 </p><p><img src="https://c1.staticflickr.com/1/944/27313728297_65698014e9_b.jpg" alt="img"></p></li><li><p>接收端获得I，因为没有G，只好回复F的ACK包。之后又相继收到G,H包。 </p><p><img src="https://c1.staticflickr.com/1/973/28312507728_96c5813bee_b.jpg" alt="img"></p></li><li><p>接收端根据累计确认，发I包，其中H对应的丢失。窗口向右滑动。 </p><p><img src="https://c1.staticflickr.com/1/824/41284211495_31f906941b_b.jpg" alt="img"></p></li></ol><p>后面的就不详细说了，原来的动画在 <a href="http://www.exa.unicen.edu.ar/catedras/comdat1/material/Filminas3_Practico3.swf">这个地址</a>， 下载一个 adobe player 就可以自己设置参数运行了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0029-循环队列</title>
    <link href="/2019/09/20/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0029-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2019/09/20/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0029-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>顺序结构的储存方式的最大不足就是：对头的元素移除的时候，需要将队列中的每一个元素向前移动一格。为了避免每次移动，所以想出了循环队列的结构。</p><p>我们按照下面的方式来定义循环队列：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-12-4.png?raw=true"></p><p>上面的这个图表示空的循环队列，front 指向队头，rear指向队尾。front 与 rear 相等表示队列为空。</p><p>那么我们需要思考一个问题。当队列满了的时候，front 与 rear 的关系是什么样的？看下面的这个图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-12-7.png?raw=true"></p><p>可以看到在这种情况下，a1 与 a3 被从队头移除，又添加了 a6 与 a7，front 与 rear 也是相等的，那么就分不清了队列到底是满还是空的了。我们可以额外加一个辅助条件来帮助我们判断队列是满还是空，但是这里我们介绍另外一种方式：我们最多只存放 SIZE-1 个元素，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-12-8.png?raw=true"></p><p>front 与 rear 之间始终隔了一个，这样我们认为队列满了，虽然这样浪费了一个格子，但是使用起来却非常的方便，因为 front 与 rear 始终满足这样的一个关系：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(rear + 1)</span> <span class="hljs-meta">%</span> SIZE = fro<span class="hljs-symbol">nt</span><br></code></pre></td></tr></table></figure><p>下面，我们来使用代码来实现它。</p><h2 id="队列大小"><a href="#队列大小" class="headerlink" title="队列大小"></a>队列大小</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (rear - front + SIZE) % SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 rear 可能比 front 小，所以需要先加上 SIZE，然后再取余。</p><p>因为空了一个格子，所以 size 的计算很简单。</p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>插入只需要在 rear 指向的位置放入一个元素就好了，rear 往后移动一格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inQueue</span><span class="hljs-params">(T e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(isFull()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    table[rear] = e;<br>    rear = (rear + <span class="hljs-number">1</span>) % SIZE<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>删除元素只需要将 front 指针往后移动一格就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!inRange(i)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    T result = table[front];<br>    front = (front + <span class="hljs-number">1</span>) % SIZE;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除与插入都很简单，因为是数组所以需要考虑的东西不多。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0028-队列</title>
    <link href="/2019/09/19/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0028-%E9%98%9F%E5%88%97/"/>
    <url>/2019/09/19/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0028-%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>队列在生活中很常见了，几乎做什么都要排列，食堂打饭，取票厅取票，地铁进站等等。</p><p>想象一下我们排队的时候是如何行动的，在队伍的尾部开始排队，然后慢慢向前移动，最后到了队伍的头部，搞完事情之后就可以走了。</p><p>每次排特别长的队伍总是很烦躁的，因为很浪费时间，而且限制了自由，这相当于是一种顺序储存方式。那么既然有顺序储存方式也就有链式储存，再想一下，当我们在银行或者医院排队的时候，是不是需要先取号，然后就不用排队了，只需要找个位置坐下来，然后等着叫号就行了，这其实就是一种链式储存方式，每个排队的人可以随意的坐在任何位置，当队伍最前面的事情被处理完之后，排队的人也不需要移动。</p><p>下面，我们分别来说明顺序储存与链式储存，由于顺序储存与链表的顺序储存基本是一样的，所以这里就不再介绍了。我们说一个比较特殊的队列——循环队列。下篇见。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003-View的层次</title>
    <link href="/2019/09/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0003-View%E7%9A%84%E5%B1%82%E6%AC%A1/"/>
    <url>/2019/09/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0003-View%E7%9A%84%E5%B1%82%E6%AC%A1/</url>
    
    <content type="html"><![CDATA[<p>前面我们说到，RecyclerView 的 view 不是在一个层次的。比如 FixView 就显示在最顶层。需要理解的是，这里的 layer 与 canvas 的 layer 比较类似，虽然分了层次，但是实际上是一个先绘制一个后绘制导致的，后绘制的 view 会盖在先绘制的 view 的上面。</p><p>比如，我们写一个 FrameLayout，它又两个 child：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;FrameLayout<br>    xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:background=<span class="hljs-string">&quot;@drawable/border_bg&quot;</span>&gt;<br><br>    &lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/title&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:background=<span class="hljs-string">&quot;@drawable/item_background&quot;</span><br>        android:gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#999999&quot;</span><br>        android:textSize=<span class="hljs-string">&quot;22sp&quot;</span><br>        android:textStyle=<span class="hljs-string">&quot;bold&quot;</span>/&gt;<br><br>    &lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/title2&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:background=<span class="hljs-string">&quot;@drawable/item_background&quot;</span><br>        android:gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#999999&quot;</span><br>        android:textSize=<span class="hljs-string">&quot;22sp&quot;</span><br>        android:textStyle=<span class="hljs-string">&quot;bold&quot;</span>/&gt;<br>&lt;/FrameLayout&gt;<br></code></pre></td></tr></table></figure><p>在显示这个布局的时候，显然下面的 TextView 会覆盖在上面的 TextView 上，这个是因为 ViewGroup 使用数组保存了所有的 child。</p><blockquote><p>android.view.ViewGroup</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Child views of this ViewGroup</span><br><span class="hljs-keyword">private</span> View[] mChildren;<br></code></pre></td></tr></table></figure><p>在绘制 child 的时候，是遍历的各个 child：</p><blockquote><p>android.view.ViewGroup#dispatchDraw</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childrenCount; i++) &#123;<br>    drawChild(canvas, child, drawingTime);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于都是在同一个画布上作画，先绘制的自然看起来是在下面，所以就有了一个层次效果。</p><p>同时，有一个需要特别注意的地方，就是要想 child 在最上面，显然在 addView 的时候，需要传递 index 为 -1，这样就会添加到最后面（当然不传递也是默认为 -1）。</p><p>好的，了解了这个我们再来看 <code>com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView</code> 这个方法做了什么：</p><blockquote><p>com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFixedView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>    showView(view);<br>    addView(view, -<span class="hljs-number">1</span>);<br>    hideView(view);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的不是原来的代码，但是与原来的代码是等价的，看起来会更容易理解一点。</p><p>showView 方法，我们已经说过了，是使用 ChildHelper 设置了一个标识。</p><p>addView 方法，这里可以理解为向 RecyclerView 中添加了一个 view。</p><p>hideView 方法，使用 ChildHelper 设置了一个标识，标识这个 view 无法被找到。</p><p>hideView 这个方法的作用并不是说对我们隐藏了这个 view，而是对 LayoutManager 来说，隐藏了这个 view。这是什么意思呢？具体可以看这两篇文章（是一个在 Android Framework 组工作的大佬写的）：</p><ol><li><a href="http://www.birbit.com/recyclerview-animations-part-1-how-animations-work">http://www.birbit.com/recyclerview-animations-part-1-how-animations-work</a></li><li><a href="http://www.birbit.com/recyclerview-animations-part-2-behind-the-scenes">http://www.birbit.com/recyclerview-animations-part-2-behind-the-scenes</a></li></ol><p>我说一下我自己的理解，可能理解的不准确。</p><p>我们的列表上有 A B D E 四个元素，这个时候在 B D 之间准备添加一个 C，当我们添加了数据，调用 notifyxxx 之后，Adapter 中的数据就立刻是最新的了，但是这个时候 LayoutManager 中的数据仍然是没有发生变化的，为什么呢？这个是因为 RecyclerView 的动画导致的。因为 RecyclerView 要显示一个添加动画，而这个动画需要两个布局才能完成，一个添加之前的布局（pre-layout），一个添加之后的布局(post-layout)，将这个两个布局进行对比，才有可能执行正确的动画。</p><p>当 pre-layout 完成之后，Adapter 中数据的变化才会反应到 LayoutManager 中，然后 post-layout，接着再执行动画。</p><p>实际上，LayoutManager 工作的方式是这样的：</p><ul><li><p>LayoutManger 保存了可见与不可见的 child，可以认为它与 Adatper 的变化是同步的。</p></li><li><p>但是它有两套 API，一套用于获取可见的 view，一套用于获取所有的 view。即 pre-layout 获取的是所有的view，post-layout 获取的是可见的 view。</p></li></ul><p>这里所说的可见与不可见都是针对 LayoutManager 的，showView 与  hideView 也是。</p><p>如果我们将 hideView 注释掉，就会发现当我们滚动的时候，所有的 child 都会显示出来，界面会变得很卡，这是因为 LayoutManager 知晓了所有的 child，并且每次滚动都会触发 addFixView 方法，所以 LayoutManager 管理的 child 越来越多（都是重复的），自然就会很卡。</p><p>如果我们将 showView 注释掉，当我们滚动的时候，会发现 FixView 跑到背景后面去了（VLayoutActivity），至于为什么下面说。</p><p>最后再说，addView，这个方法并没有重复添加 view，看下面的逻辑：</p><blockquote><p>android.support.v7.widget.RecyclerView.LayoutManager#addViewInt</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ensure in correct position</span><br><span class="hljs-keyword">int</span> currentIndex = mChildHelper.indexOfChild(child);<br><span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) &#123;<br>    index = mChildHelper.getChildCount();<br>&#125;<br><span class="hljs-keyword">if</span> (currentIndex == -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Added View has RecyclerView as parent but&quot;</span><br>                                    + <span class="hljs-string">&quot; view is not a real child. Unfiltered index:&quot;</span><br>                                    + mRecyclerView.indexOfChild(child));<br>&#125;<br><span class="hljs-keyword">if</span> (currentIndex != index) &#123;<br>    mRecyclerView.mLayout.moveView(currentIndex, index);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到其实只是将 view 重新移动了最后的位置。但是如果我们没有调用 showView 的话，LayoutManager 是不知道有这个 view 的，会导致 currentIndex 为 -1，则抛出异常，从而导致 view 的位置没有移动，则被后面添加的 view 给覆盖了。</p><p>啊，终于比较能够说服自己了，解决了心头之恨，当初看了一天，看的几乎快要怀疑自己了。</p><p>嗯，再额外说一个东西，就是它的每个 Card 的背景是如何实现的。</p><p>先看如何设置背景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">LinearLayoutHelper layoutHelper1 = <span class="hljs-keyword">new</span> LinearLayoutHelper();<br>layoutHelper1.setBgColor(Color.YELLOW);<br></code></pre></td></tr></table></figure><p>这样设置之后，LinearLayoutHelper 对应的 Adapter 管理的所有 View 就都会在同一个背景上，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/device3.png?raw=true" alt="device3.png"></p><p>这个背景其实是一个 View 实现的，具体看代码吧。</p><blockquote><p>com.alibaba.android.vlayout.layout.BaseLayoutHelper#requireLayoutView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requireLayoutView</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mBgColor != <span class="hljs-number">0</span> || mLayoutViewBindListener != <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>像追踪这样的效果的源码，最好的方法就是直接看哪里用到了相关的变量，这里我们从  bgColor 入手。</p><blockquote><p>com.alibaba.android.vlayout.layout.BaseLayoutHelper#afterLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mLayoutView == <span class="hljs-keyword">null</span>) &#123;<br>    mLayoutView = helper.generateLayoutView();<br>    helper.addOffFlowView(mLayoutView, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 afterLayout 中，这里创建了一个 LayoutView，然后将这个 view 添加到最前头（head 的值为 true）。</p><p>这样 LayoutView 就是一个背景了。需要注意的是 LayoutView 的 LayoutParams 必须是对应 LayoutMangager 的 LayoutParams，否则会被替换掉。</p><blockquote><p>com.alibaba.android.vlayout.VirtualLayoutManager#generateLayoutView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">generateLayoutView</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mRecyclerView == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    View layoutView = mLayoutViewFatory.generateLayoutView(mRecyclerView.getContext());<br>    LayoutParams params = <span class="hljs-keyword">new</span> LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);<br>    attachViewHolder(params, <span class="hljs-keyword">new</span> LayoutViewHolder(layoutView));<br><br>    layoutView.setLayoutParams(params);<br>    <span class="hljs-keyword">return</span> layoutView;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里设置的 LayoutParams 是 VirtualLayoutManager.LayoutParams，然后还将 layoutParams 的 mViewHolder 变量赋值了，这个也很重要，否则会报空指针异常，因为这个 view 也添加到了 RecyclerView 中，由 LayoutManager 来管理，需要满足一定的条件。</p><p>这里需要理解的是，这个 view 是我们自行添加的，而不是通过 adapter 的流程添加的。</p><p>我们再看，如果不使用这个 LayoutParams 会怎样：</p><blockquote><p>android.support.v7.widget.RecyclerView.Recycler#bindViewToPosition</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();<br><span class="hljs-keyword">final</span> LayoutParams rvLayoutParams;<br><span class="hljs-keyword">if</span> (lp == <span class="hljs-keyword">null</span>) &#123;<br>    rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();<br>    holder.itemView.setLayoutParams(rvLayoutParams);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!checkLayoutParams(lp)) &#123;<br>    rvLayoutParams = (LayoutParams) generateLayoutParams(lp);<br>    holder.itemView.setLayoutParams(rvLayoutParams);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    rvLayoutParams = (LayoutParams) lp;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它会检测 LayoutParams 是否会满足要求，不满足就自己生成了一个，而生成的 LayoutParams 的 mViewHolder 是 null，所以会报空指针异常。</p><p>这个问题，我在研究 view 的 generateLayoutParams 的时候就遇到过，知识点串联起来的感觉还是挺爽的。</p><p>我自己的测试代码，我想在 FixView 上额外添加一个 Button，见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFixedView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>    <span class="hljs-comment">//removeChildView(view);</span><br>    <span class="hljs-comment">//mFixedContainer.addView(view);</span><br>    addOffFlowView(view, <span class="hljs-keyword">false</span>);<br>    <br>    <span class="hljs-keyword">if</span> (!t.contains(view)) &#123;<br>        Button button = <span class="hljs-keyword">new</span> Button(view.getContext());<br>        VirtualLayoutManager.LayoutParams layoutParams = <span class="hljs-keyword">new</span> VirtualLayoutManager.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,<br>                ViewGroup.LayoutParams.WRAP_CONTENT);<br>        attachViewHolder(layoutParams, <span class="hljs-keyword">new</span> LayoutViewHolder(button));<br>        button.setLayoutParams(layoutParams);<br>        button.measure(View.MeasureSpec.makeMeasureSpec(<span class="hljs-number">100</span>, View.MeasureSpec.EXACTLY),<br>                View.MeasureSpec.makeMeasureSpec(<span class="hljs-number">100</span>, View.MeasureSpec.EXACTLY));<br>        button.layout(view.getLeft(), view.getTop(), view.getLeft() + <span class="hljs-number">100</span>, view.getTop() + <span class="hljs-number">100</span>);<br>        button.setText(<span class="hljs-string">&quot;Test&quot;</span>);<br>        showView(button);<br>        addView(button, -<span class="hljs-number">1</span>);<br>        hideView(button);<br>        t.add(view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个 button 就显示出来了。</p><p>刚开始，我使用了 RecyclerView.LayoutParams，报了空指针异常，提示 mViewHolder 为null，立刻就想到是 LayoutParams 被替换了，然后改了一下就好了。</p>]]></content>
    
    
    <categories>
      
      <category>vLayout</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码分析-vLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-自定义LayoutHelper</title>
    <link href="/2019/09/17/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0002-%E8%87%AA%E5%AE%9A%E4%B9%89LayoutHelper/"/>
    <url>/2019/09/17/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0002-%E8%87%AA%E5%AE%9A%E4%B9%89LayoutHelper/</url>
    
    <content type="html"><![CDATA[<p>在实现自己的 LayoutHelper 之前，我们先看看官方是如何实现的。如果你之前了解过自定义 LayoutManager，那么这个就是小意思了。</p><p>我们先来看一个比较简单的 <code>com.alibaba.android.vlayout.layout.FixLayoutHelper</code>。</p><blockquote><p>com.alibaba.android.vlayout.layout.FixLayoutHelper</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItemCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> itemCount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (itemCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">super</span>.setItemCount(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">super</span>.setItemCount(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，固定的 item 只管理单个 view，就算我们设置了多个，也只取第一个。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">FixLayoutHelper layoutHelper = <span class="hljs-keyword">new</span> FixLayoutHelper(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// itemCount 设置为 0，不显示，LayoutHelper 认为没有 view 需要排列</span><br>adapters.add(<span class="hljs-keyword">new</span> SubAdapter(<span class="hljs-keyword">this</span>, layoutHelper, <span class="hljs-number">0</span>));<br><br>layoutHelper = <span class="hljs-keyword">new</span> FixLayoutHelper(FixLayoutHelper.TOP_RIGHT, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 这里即使将 itemCount 设置为 10，效果也是一样的</span><br>adapters.add(<span class="hljs-keyword">new</span> SubAdapter(<span class="hljs-keyword">this</span>, layoutHelper, <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(MainViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onBindViewHolder(holder, position);<br>        LayoutParams layoutParams = <span class="hljs-keyword">new</span> LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class="hljs-number">200</span>);<br>        holder.itemView.setLayoutParams(layoutParams);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>看看别的方法，有三个比较重要，我们先看第一个：</p><blockquote><p>com.alibaba.android.vlayout.layout.FixLayoutHelper#layoutViews</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layoutViews</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span><br><span class="hljs-params"><span class="hljs-function">        VirtualLayoutManager.LayoutStateWrapper layoutState, LayoutChunkResult result,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">final</span> LayoutManagerHelper helper)</span> </span>&#123;<br>    <span class="hljs-comment">// reach the end of this layout</span><br>    <span class="hljs-keyword">if</span> (isOutOfRange(layoutState.getCurrentPosition())) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!mShouldDrawn) &#123;<br>        layoutState.skipCurrentPosition();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// find view in currentPosition</span><br>    View view = mFixView;<br>    <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;<br>        view = layoutState.next(recycler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        layoutState.skipCurrentPosition();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;<br>        result.mFinished = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    mDoNormalHandle = state.isPreLayout();<br><br>    <span class="hljs-keyword">if</span> (mDoNormalHandle) &#123;<br>        <span class="hljs-comment">// in PreLayout do normal layout</span><br>        helper.addChildView(layoutState, view);<br>    &#125;<br><br>    mFixView = view;<br><br>    doMeasureAndLayout(view, helper);<br><br>    result.mConsumed = <span class="hljs-number">0</span>;<br>    result.mIgnoreConsumed = <span class="hljs-keyword">true</span>;<br><br>    handleStateOnResult(result, view);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们看第 16-21 行的代码，这是很重要的一个部分，这里就是获取是否有可以复用的 view。往下看，到 37 行，这里就是处理了 view 的测量与布局。里面的逻辑还是很简单的，这里截取两段看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = helper.getChildMeasureSpec(xxx);<br>heightSpec = helper.getChildMeasureSpec(xxx);<br><br><span class="hljs-comment">// do measurement</span><br>helper.measureChildWithMargins(view, widthSpec, heightSpec);<br></code></pre></td></tr></table></figure><p>测量都是一样的，先创建 MeasureSpec，然后调用 measureChildWithMargins 方法，view 的大小就测量好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">top = helper.getPaddingTop() + mY + mAdjuster.top;<br>right = helper.getContentWidth() - helper.getPaddingRight() - mX - mAdjuster.right;<br>left = right - params.leftMargin - params.rightMargin - view.getMeasuredWidth();<br>bottom = top + params.topMargin + params.bottomMargin + view.getMeasuredHeight();<br></code></pre></td></tr></table></figure><p>布局就更简单了，因为是固定位置，所以只需要算一下绝对位置就好了，没啥好说的。</p><p>我们再看另外两个方法：</p><blockquote><p>com.alibaba.android.vlayout.layout.FixLayoutHelper#beforeLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeLayout</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span><br><span class="hljs-params"><span class="hljs-function">                         LayoutManagerHelper helper)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.beforeLayout(recycler, state, helper);<br><br>    <span class="hljs-keyword">if</span> (mFixView != <span class="hljs-keyword">null</span> &amp;&amp; helper.isViewHolderUpdated(mFixView)) &#123;<br>        <span class="hljs-comment">// recycle view for later usage</span><br>        helper.removeChildView(mFixView);<br>        recycler.recycleView(mFixView);<br>        mFixView = <span class="hljs-keyword">null</span>;<br>        isAddFixViewImmediately = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    mDoNormalHandle = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的作用，是在 layout 之前做一些事情，这里做的事情是如果检测到 viewHolder 变化了，就将 view 放入复用池中，便于接下来layout时复用。</p><blockquote><p>com.alibaba.android.vlayout.layout.FixLayoutHelper#afterLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterLayout</span><span class="hljs-params">(<span class="hljs-keyword">final</span> RecyclerView.Recycler recycler, RecyclerView.State state,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">int</span> startPosition, <span class="hljs-keyword">int</span> endPosition, <span class="hljs-keyword">int</span> scrolled,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-keyword">final</span> LayoutManagerHelper helper)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.afterLayout(recycler, state, startPosition, endPosition, scrolled, helper);<br><br>    <span class="hljs-comment">// disabled if mPos is negative number</span><br>    <span class="hljs-keyword">if</span> (mPos &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mDoNormalHandle &amp;&amp; state.isPreLayout()) &#123;<br>        <span class="hljs-keyword">if</span> (mFixView != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//                Log.d(TAG, &quot;after layout doNormal removeView&quot;);</span><br>            helper.removeChildView(mFixView);<br>            recycler.recycleView(mFixView);<br>            isAddFixViewImmediately = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        mFixView = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Not in normal flow</span><br>    <span class="hljs-keyword">if</span> (shouldBeDraw(helper, startPosition, endPosition, scrolled)) &#123;<br>        mShouldDrawn = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (mFixView != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// already capture in layoutViews phase</span><br>            <span class="hljs-comment">// if it&#x27;s not shown on screen</span><br>            <span class="hljs-keyword">if</span> (mFixView.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                addFixViewWithAnimator(helper, mFixView);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// helper.removeChildView(mFixView);</span><br>                helper.addFixedView(mFixView);<br>                isRemoveFixViewImmediately = <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Runnable action = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    mFixView = recycler.getViewForPosition(mPos);<br>                    doMeasureAndLayout(mFixView, helper);<br>                    <span class="hljs-keyword">if</span> (isAddFixViewImmediately) &#123;<br>                        helper.addFixedView(mFixView);<br>                        isRemoveFixViewImmediately = <span class="hljs-keyword">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        addFixViewWithAnimator(helper, mFixView);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            <span class="hljs-keyword">if</span> (mFixViewDisappearAnimatorListener.isAnimating()) &#123;<br>                mFixViewDisappearAnimatorListener.withEndAction(action);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                action.run();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mShouldDrawn = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (mFixView != <span class="hljs-keyword">null</span>) &#123;<br>            removeFixViewWithAnimator(recycler, helper, mFixView);<br>            mFixView = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的作用，是在 layout 之后做一些事情。不知道你看到这里时有没有产生疑问：我们 RecyclerView 时从上往下，或者从下往上布局的，那么如果我们的屏幕上只能显示 10 个 item，而在第 100 个位置有一个 FixView，那么问题就来了，为什么我们一打开这个界面 FixView 就能立即显示出来，而不是滑动到了第 100 个位置才显示出来？</p><p>我们先看该方法时在什么时候被调用的？</p><blockquote><p>com.alibaba.android.vlayout.VirtualLayoutManager#runPostLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runPostLayout</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state, <span class="hljs-keyword">int</span> scrolled)</span> </span>&#123;<br>    mNested--;<br>    <span class="hljs-keyword">if</span> (mNested &lt;= <span class="hljs-number">0</span>) &#123;<br>        mNested = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> startPosition = findFirstVisibleItemPosition();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> endPosition = findLastVisibleItemPosition();<br>        List&lt;LayoutHelper&gt; layoutHelpers = mHelperFinder.getLayoutHelpers();<br>        Iterator&lt;LayoutHelper&gt; iterator = layoutHelpers.iterator();<br>        LayoutHelper layoutHelper = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            layoutHelper = iterator.next();<br>            <span class="hljs-keyword">try</span> &#123;<br>                layoutHelper.afterLayout(recycler, state, startPosition, endPosition, scrolled, <span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (VirtualLayoutManager.sDebuggable) &#123;<br>                    <span class="hljs-keyword">throw</span> e;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mViewLifeCycleHelper) &#123;<br>            mViewLifeCycleHelper.checkViewStatusInScreen();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法在 <code>com.alibaba.android.vlayout.VirtualLayoutManager#onLayoutChildren</code> 里面被调用，而 onLayoutChildren 几乎是不断的在被调用，RecyclerView 刚显示时，滚动时都需要调用该方法，所以 runPostLayout 也是不断的会被调用。</p><p>看 runPostLayout 的内部逻辑，可以发现它调用了所有的 LayoutHelper 的 afterLayout 方法。即，与 layoutViews 不一样，layoutViews 只会在滚动到相应位置才会调用，afterLayout 与 beforeLayout 都会不断的被调用。</p><p>所以，FixView 一开始就可以显示，显然是在 afterLayout 中做了什么。</p><p>说实话，这段逻辑我没看懂，写这个代码的人太喜欢用bool变量来控制逻辑了，所以只好使出断点调试大法。界面（VLayoutActivity）刚展示的时候，只会走 afterLayout 与 beforeLayout，beforeLayout 没什么影响，afterLayout 走到了第 47 行：</p><blockquote><p>com.alibaba.android.vlayout.layout.FixLayoutHelper#addFixViewWithAnimator</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFixViewWithAnimator</span><span class="hljs-params">(LayoutManagerHelper layoutManagerHelper, View fixView)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mFixViewAnimatorHelper != <span class="hljs-keyword">null</span>) &#123;<br>        ViewPropertyAnimator animator = mFixViewAnimatorHelper<br>                .onGetFixViewAppearAnimator(fixView);<br>        <span class="hljs-keyword">if</span> (animator != <span class="hljs-keyword">null</span>) &#123;<br>            fixView.setVisibility(View.INVISIBLE);<br>            layoutManagerHelper.addFixedView(fixView);<br>            mFixViewAppearAnimatorListener.bindAction(layoutManagerHelper, fixView);<br>            animator.setListener(mFixViewAppearAnimatorListener).start();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            layoutManagerHelper.addFixedView(fixView);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        layoutManagerHelper.addFixedView(fixView);<br>    &#125;<br>    isRemoveFixViewImmediately = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用了第 14 行，所以，是 addFixedView 方法起了作用。该方法是将 FixView add 到了 LayoutManager 里面。这里需要 add 是因为本来 fixView 不应该在 LayoutManager 管理的集合里面，但是它又需要显示出来，所以需要 add。</p><p>addFixedView 这个方法里面的逻辑也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFixedView</span><span class="hljs-params">(View view)</span> </span>&#123;<br>    addOffFlowView(view, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOffFlowView</span><span class="hljs-params">(View view, <span class="hljs-keyword">boolean</span> head)</span> </span>&#123;<br>    showView(view);<br>    addHiddenView(view, head);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHiddenView</span><span class="hljs-params">(View view, <span class="hljs-keyword">boolean</span> head)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> index = head ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>    addView(view, index);<br>    mChildHelperWrapper.hide(view);<br>&#125;<br></code></pre></td></tr></table></figure><p>showView 是调用了 mChildHelperWrapper 的 show 方法，最终会调用到 <code>android.support.v7.widget.ChildHelper.Bucket#clear</code> 里面。这个类具体可以看看这篇文章：<a href="https://blog.csdn.net/fyfcauc/article/details/54175072">https://blog.csdn.net/fyfcauc/article/details/54175072</a> ，它的内部逻辑就是将该 view 标记为可见。</p><p>我刚开始以为这个 showView 方法没啥作用，因为后面不是又重新隐藏了么，直到我将这行代码注掉之后，发现刚开始是正常的吗，但是上下滑动之后， FixView 的层次变化了，但是没找到原因。</p><p>查看 LayoutManagerHelper 的注释与 layer 有点关系，下篇再讲。</p>]]></content>
    
    
    <categories>
      
      <category>vLayout</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码分析-vLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-设计思想</title>
    <link href="/2019/09/16/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0001-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2019/09/16/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/0001-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>一般的情况下，我们使用 RecyclerView 都是用来实现同一种类型的列表。</p><p>实现多种类型的列表的话，也有解决方案，就是通过 <code>android.support.v7.widget.RecyclerView.Adapter#getItemViewType</code> 来区分不同的 item 类型，来加载不同的布局。但是这种解决方法有局限性，想要做出一个类似淘宝首页的界面，基本上是不可能的。</p><p>我们先来看一下淘宝的首页长什么样，然后再思考该如何去做。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/device.png?raw=true" alt="device.png"></p><p>这是一个比较复杂的界面，对于一个复杂的问题，我们需要将问题简化，或者将这个问题分解为多个相对简单的小问题，所以我们将这个界面分隔为多个部分：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/device2.png?raw=true" alt="device.png"></p><p>我们将首页分为了几个部分，每个部分的结构都比较简单，那么这个时候就遇到了第一个需要解决的问题：</p><p>我们知道 RecyclerView  之所以能够流畅滑动，是因为它的复用机制，那么我们将首页分为了好几个部分之后，它的复用粒度应该是什么样的呢？是每个黑框框起来的作为一个复用粒度，还是说将黑框里面的每一个布局作为一个复用粒度呢？显然复用粒度越小滑动起来就越流畅，但是我们需要实现如何才能复用更小的粒度。</p><p>我们知道，RecyclerView 的五虎上将中，LayoutManager 是用来排列item的布局的，我们现有的 LayoutManager 都无法满足要求，那么应该怎么办呢？只能自定义 LayoutManager 了。通过自定义 LayoutManager 我们可以解决 item 的排列问题，但是这里我们又遇到了第二个问题：</p><p>首页的 item 排列并不是固定的，就算我们实现了一个 LayoutManager 将 item 排列成图上的模样，但是如果 UI 改了 item 的位置，那岂不是又要重新写一个 LayoutManager？这也太惨了。这个问题要怎么解决呢？这个就不是纯技术的问题了。如果 UI 随心所欲的改 item 样式，如果我们怎么写都是徒劳的，这个时候就需要与 UI 达成一致，给 UI 一定的创作空间，但是需要在某个范围内。这个创作空间就在 <code>com.alibaba.android.vlayout.layout</code> 下，什么意思呢？这个包下面的各种 Helper 其实本质上都是一个 LayoutManager。当然如果你实在杠不过UI，你也可以自定义 LayoutHelper 来实现特殊效果。</p><p>就算我们定义了各种 LayoutManager，那又能怎么样呢？</p><p>我们回想一下 RecyclerView 的工作原理，首先，RecyclerView 从 Adapter 获取 View，然后 LayoutManager 将 View 按实现排列，这样我们的列表就出来了。</p><p>上面，我们将首页分为了多段，那么我们可不可以使用多个 Aadapter 与 LayoutManager 呢？每一段分别对应不同的 Adapter 与 LayoutManager，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/vlayout2.png?raw=true"></p><p>那么，对于屏幕上的每一个位置，我们可以这样做：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/vLayout/vlayout.png?raw=true"></p><p>当然，我们需要先将 LayoutHelper 给设置进去，也就是说，我们需要先知道每个位置的 item 是什么类型的（或者知道每个类型有多少个 item）。LayoutHelper 搞定了，同理，Adapter 也是一样的，具体的实现在 <code>com.alibaba.android.vlayout.DelegateAdapter</code> 里面。</p>]]></content>
    
    
    <categories>
      
      <category>vLayout</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码分析-vLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0011-梳理（一）</title>
    <link href="/2019/09/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0011-%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/09/12/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0011-%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>再回顾一下，Tangram 是如何将一个 Json 文件变成一个个的 View，显示到页面上的？</p><p>首先，我们发起网络请求，从服务器请求下来 json 数据，使用解析器将 json 数据解析成 Card 对象，这一步是由 <code>com.tmall.wireless.tangram.dataparser.concrete.PojoDataParser</code> 类完成的。</p><p>获取到了 Card 之后，Card 里面还有 Cell 数据需要解析，这一步是由 <code>com.tmall.wireless.tangram.dataparser.concrete.Card</code> 类完成的。</p><p>这样我们就将 Json 数据转成了 Tangram 可以理解的东西。</p><p>然后，我们需要对 RecyclerView 与 Adapter 有比较深入的了解。</p><p>我们一般是这样写 Adapter 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAdapter</span>(<span class="hljs-title">private</span> <span class="hljs-title">var</span> <span class="hljs-title">count</span>: <span class="hljs-title">Int</span>) : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">StackViewHolder</span>&gt;() </span>&#123;<br><br>    <span class="hljs-function">fun <span class="hljs-title">addItem</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyItemInserted(++count)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>= <span class="hljs-function">count</span><br><span class="hljs-function"></span><br><span class="hljs-function">    override fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: StackViewHolder, position: Int)</span> </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;tetg&quot;</span>, <span class="hljs-string">&quot;onBindViewHolder + $position&quot;</span>)<br>        holder.bind(position)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: StackViewHolder </span>&#123;<br>        Log.e(<span class="hljs-string">&quot;tetg&quot;</span>, <span class="hljs-string">&quot;onCreateViewHolder&quot;</span>)<br>        val root = LayoutInflater.from(parent.context)<br>            .inflate(R.layout.item_stack, parent, <span class="hljs-keyword">false</span>)<br>        <span class="hljs-keyword">return</span> StackViewHolder(root)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackViewHolder</span>(<span class="hljs-title">itemView</span>: <span class="hljs-title">View</span>) : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>(<span class="hljs-title">itemView</span>) </span>&#123;<br><br>    <span class="hljs-keyword">private</span> val text: TextView = itemView.findViewById(R.id.text)<br>    <span class="hljs-keyword">private</span> val root: View = itemView.findViewById(R.id.root)<br><br>    <span class="hljs-function">fun <span class="hljs-title">bind</span><span class="hljs-params">(position: Int)</span> </span>&#123;<br>        text.text = <span class="hljs-string">&quot;$position&quot;</span><br>        val rnd = Random()<br>        val color = Color.argb(<span class="hljs-number">255</span>, rnd.nextInt(<span class="hljs-number">256</span>), rnd.nextInt(<span class="hljs-number">256</span>), rnd.nextInt(<span class="hljs-number">256</span>))<br>        root.setBackgroundColor(color)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仔细看一下，想要做出不同样式的item，主要将 onBindViewHolder 与 onCreateViewHolder 的逻辑分别封装到 Cell 里面，这样就简单很多。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCell</span> </span>&#123;<br>    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: StackViewHolder, position: Int)</span> </span>&#123;&#125;<br>    <span class="hljs-function">fun <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: StackViewHolder </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们在将 Adapter 的数据源改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;MyCell&gt; datas;<br></code></pre></td></tr></table></figure><p>Adapter 的逻辑就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span>(<span class="hljs-title">private</span> <span class="hljs-title">var</span> <span class="hljs-title">count</span>: <span class="hljs-title">Int</span>) : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">ViewHolder</span>&gt;() </span>&#123;<br><br>    <span class="hljs-function">fun <span class="hljs-title">addItem</span><span class="hljs-params">()</span> </span>&#123;<br>        notifyItemInserted(++count)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>= <span class="hljs-function">count</span><br><span class="hljs-function"></span><br><span class="hljs-function">    override fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>&#123;<br>        datas.get(position).onBindViewHolder(holder, position)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: ViewGroup, viewType: Int)</span>: StackViewHolder </span>&#123;<br>        <span class="hljs-comment">// 这里需要根据 viewType 来创建不同的 ViewHolder</span><br>        <span class="hljs-comment">// 一种很直接的解决方法就是用一个map，将 viewType 与 viewHolder 对应起来</span><br>        <span class="hljs-keyword">return</span> map.get(viewType).createViewHolder()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要处理好，viewHolder 就行了。当然 Tangram 里面的逻辑不可能这么简单，但是只要你理解了这个，再看 Tangram 应该会好理解很多。</p><p>有了数据，又有了所有的 viewHolder，就只差自定义的 layoutManager 了。</p><p>vlayout 做了自定义 layoutManager  的部分，一个类型的 Card 都对应一个 layoutManager，根据不同的 Card 获取不同的 layoutManager，然后将 Card 里面的 Cell 排列好，这样页面就显示出来了。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0008-事件总线</title>
    <link href="/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0008-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <url>/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0008-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>事件总线(TangramBus)用于组件和组件、组件和卡片、组件和页面之间的通信。它也是默认被注册到 Tangram 的 serviceManager 里，在组件和 TangramEngine 里都可以获取到。</p><p>BusSupport 与 TimerSupport 一样，都是内置在 TangramEngine 里面了的，不需要我们手动注册：</p><blockquote><p>com.tmall.wireless.tangram.TangramBuilder.InnerBuilder#build</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tangramEngine.register(TimerSupport.class, <span class="hljs-keyword">new</span> TimerSupport());<br>tangramEngine.register(BusSupport.class, <span class="hljs-keyword">new</span> BusSupport());<br></code></pre></td></tr></table></figure><p>我们在其他地方就可以获取注册进去的这个对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BusSupport busSupport = serviceManager.getService(BusSupport.class);<br></code></pre></td></tr></table></figure><p>获取到 BusSupport 之后，我们就可以使用这个对象来发送一个事件对象了，就像 EventBus 一样。</p><blockquote><p>com.tmall.wireless.tangram.eventbus.BusSupport#post(com.tmall.wireless.tangram.eventbus.Event)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mDispatcher.enqueue(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>在深入分析之前，我们来先看看 Event 相关的东西。</p><p>Event 这个类相当简单，可以当作一个 bean 来看待。我们可以直接创建这个对象，但是比较好的做法是复用该对象，为此 Tangram 提供了一个 EventPool 来帮助我们复用 Event 对象，如下：</p><blockquote><p>com.tmall.wireless.tangram.eventbus.BusSupport#obtainEvent(java.lang.String, java.lang.String, android.support.v4.util.ArrayMap&lt;java.lang.String,java.lang.String&gt;, com.tmall.wireless.tangram.eventbus.EventContext)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Event <span class="hljs-title">obtainEvent</span><span class="hljs-params">(String type, String sourceId,</span></span><br><span class="hljs-params"><span class="hljs-function">        ArrayMap&lt;String, String&gt; args, EventContext eventContext)</span> </span>&#123;<br>    Event event = EventPool.sharedInstance().acquire();<br>    event.type = type;<br>    event.sourceId = sourceId;<br>    event.args = args;<br>    event.eventContext = eventContext;<br>    <span class="hljs-keyword">return</span> event;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们使用了 BusSupport 封装的方法来获取到一个 Event 对象，并对其字段赋值。</p><p>事件对象创建好了之后，使用 post 方法发送出去，那么如果去接收这个对象呢？上面我们分析到，post 方法内部是调用了 Dispatcher.enqueue 方法：</p><blockquote><p>com.tmall.wireless.tangram.eventbus.Dispatcher#enqueue(com.tmall.wireless.tangram.eventbus.Event)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Event event)</span> </span>&#123;<br>    Message msg = obtainMessage();<br>    msg.obj = event;<br>    <span class="hljs-keyword">return</span> sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Dispatcher 是继承了 Handler 的，所以这里是将 Event 封装成了一个 Message，然后发送出去了。那么哪里可以接收到这个消息呢，看 Dispatcher 的构造方法：</p><blockquote><p>com.tmall.wireless.tangram.eventbus.Dispatcher#Dispatcher</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dispatcher</span><span class="hljs-params">(IDispatcherDelegate dispatcherDelegate)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(Looper.getMainLooper());<br>    <span class="hljs-keyword">this</span>.mDispatcherDelegate = dispatcherDelegate;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到 Looper 是主线程的 Looper 对象，所以发送出去的消息在主线程可以接收到。又因为 Hander 在发送 Message 的时候，会将接收者（target）设置为自己，所以 Dispatcher 想要处理接收到的消息的话，肯定需要重写 handleMessage 方法。</p><blockquote><p>com.tmall.wireless.tangram.eventbus.Dispatcher#handleMessage</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.handleMessage(msg);<br>    <span class="hljs-keyword">if</span> (mDispatcherDelegate != <span class="hljs-keyword">null</span>) &#123;<br>        mDispatcherDelegate.dispatch((Event) msg.obj);<br>    &#125;<br>    EventPool.sharedInstance().release((Event) msg.obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里做了两件事：</p><ul><li>将接收到的消息分发出去</li><li>将事件对象回收</li></ul><p>我们继续跟踪下去，发现 BusSupport 实现了 IDispatcherDelegate 接口：</p><blockquote><p>com.tmall.wireless.tangram.eventbus.BusSupport#dispatch</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Event event)</span> </span>&#123;<br>    String type = event.type;<br>    List&lt;EventHandlerWrapper&gt; eventHandlers = subscribers.get(type);<br>    <span class="hljs-keyword">if</span> (eventHandlers != <span class="hljs-keyword">null</span>) &#123;<br>        EventHandlerWrapper handler = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = eventHandlers.size(); i &lt; size; i++) &#123;<br>            handler = eventHandlers.get(i);<br>            <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(handler.producer) &amp;&amp; handler.producer.equals(event.sourceId)) &#123;<br>                handler.handleEvent(event);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TextUtils.isEmpty(handler.producer)) &#123;<br>                handler.handleEvent(event);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了一个新类：EventHandlerWrapper，看类名就知道它是来处理事件的。</p><p>有个地方需要注意，如果我们在创建 EventHandlerWrapper 对象的时候指定了 producer，那么需要在创建 Event 的时候，也指定相应的值，否则匹配不上哦。</p><p>首先，我们获取到事件的类型，然后根据这个类型，获取到该类型对应的所有观察者，然后一个一个的将事件回调过去，很是很简单的。</p><p>了解了 BusSupport 的工作流程，我们就知道如果我们想要接收一个事件，需要定义一个事件类型，然后向 BusSupport 注册该类型的观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> EventHandlerWrapper mSetMeta = BusSupport.wrapEventHandler(<span class="hljs-string">&quot;setMeta&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;parseMeta&quot;</span>);<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAdded</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onAdded();<br>    BusSupport busSupport = serviceManager.getService(BusSupport.class);<br>    <span class="hljs-keyword">if</span> (busSupport != <span class="hljs-keyword">null</span>) &#123;<br>        busSupport.register(mSetMeta);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRemoved</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onRemoved();<br>    BusSupport busSupport = serviceManager.getService(BusSupport.class);<br>    <span class="hljs-keyword">if</span> (busSupport != <span class="hljs-keyword">null</span>) &#123;<br>        busSupport.unregister(mSetMeta);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Keep</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseMeta</span><span class="hljs-params">(Event event)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (mTotalPageCount != Integer.MAX_VALUE) &#123;<br>            storeCache();<br>        &#125;<br>        mIndex = Integer.parseInt(event.args.get(KEY_INDEX));<br>        mTotalPageCount = Integer.parseInt(event.args.get(KEY_PAGE_COUNT));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 EventHandlerWrapper 内部是使用了反射来获取回调的方法，所以这里需要写一个 parseMeta 方法，而且为了防止代码压缩的时候被删除，需要 keep 一下。</p><p>好长时间不画图了，画个图吧，感觉这个图没有说清楚，觉得没有帮助的话当作没看见吧：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/BusSupport.png?raw=true"></p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0009-使用布局</title>
    <link href="/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0009-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0009-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>对于布局来说，内置布局一般满足大部分场景，如果有特殊需求，可自定义实现。需要实现<code>Card</code>和<code>LayoutHelper</code>。<code>Card</code>是自定义布局的 model，<code>LayoutHelper</code>是自定义布局的实现，基于<a href="https://github.com/alibaba/vlayout"><code>vlayout</code></a>框架。</p><p>这部分的东西也在 vlayout 里面，所以不分析了，可以先看看<a href="http://tangram.pingguohe.net/docs/android/use-card">官方文档</a>介绍。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0010-与 RxJava 配合使用</title>
    <link href="/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0010-%E4%B8%8E-RxJava-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/09/11/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0010-%E4%B8%8E-RxJava-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>想要使用 RxJava，需要先开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">engine.setSupportRx(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>然后还要提供依赖包，具体可以参考<a href="http://tangram.pingguohe.net/docs/android/reactive-tangram">官方文档</a>.</p><h2 id="响应式流中数据结构的定义"><a href="#响应式流中数据结构的定义" class="headerlink" title="响应式流中数据结构的定义"></a>响应式流中数据结构的定义</h2><p>在响应式流中，传递的都是数据单个对象，而传统的命令式接口里，一个操作往往有多个类型的参数，JAVA 里没有像元组那样的结构用来组合一系列对象，用 <code>Object[]</code> 类型的对象也难以理解维护，因此，针对这种情况，Tangram 将相关接口的参数封装成一系列 <code>TangramOp1</code>、<code>TangramOp2</code>、<code>TangramOp3</code> 对象，分别包含一个、两个、三个参数，用来在响应式流中传递信息，也方便原有接口的对接。具体的定义在包 <code>com.tmall.wireless.tangram.op</code> 下，包含了插入、更新、异步加载等接口的操作定义。下文中碰到的接口里包含的 <code>ClickExposureCellOp</code>、<code>LoadGroupOp</code> 等都是在这个背景下定义的结构。</p><p>这一段还是应该好好阅读几遍的，在我刚开始接触 Rx 的时候，就不太明白为啥会设计出这样的接口：</p><blockquote><p>io.reactivex.functions</p></blockquote><p>在 functions 包下，还有 Function3，Function4 这样的东西。有了上面这段话，初学者应该就会比较好理解一些。</p><p>关于 Rx 的配合使用，官方文档也说的差不多了，再深入就是 Rx 相关的东西，这里就不说了。这里只说一下 demo 的 RxTangramActivity 显示的效果会是一个一个卡片加载出来的。想要做出依次加载的效果，有哪些思路呢？</p><ul><li>每次add一个，控制好add时机</li><li>使用动画</li></ul><p>使用动画的话，会有一个问题，就是上下滑出滑入的时候都会执行动画，不好搞。看看 Tangram 是如何做的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java">Disposable dsp8 = Observable.create(<span class="hljs-keyword">new</span> ObservableOnSubscribe&lt;JSONArray&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(ObservableEmitter&lt;JSONArray&gt; emitter)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String json = <span class="hljs-keyword">new</span> String(getAssertsFile(getApplicationContext(), <span class="hljs-string">&quot;data.json&quot;</span>));<br>        JSONArray data = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            data = <span class="hljs-keyword">new</span> JSONArray(json);<br>        &#125; <span class="hljs-keyword">catch</span> (JSONException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        emitter.onNext(data);<br>        emitter.onComplete();<br>    &#125;<br>&#125;).flatMap(<span class="hljs-keyword">new</span> Function&lt;JSONArray, ObservableSource&lt;JSONObject&gt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;JSONObject&gt; <span class="hljs-title">apply</span><span class="hljs-params">(JSONArray jsonArray)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> JSONArrayObservable.fromJsonArray(jsonArray);<br>    &#125;<br>&#125;).map(<span class="hljs-keyword">new</span> Function&lt;JSONObject, ParseSingleGroupOp&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ParseSingleGroupOp <span class="hljs-title">apply</span><span class="hljs-params">(JSONObject jsonObject)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ParseSingleGroupOp(jsonObject, engine);<br>    &#125;<br>&#125;).compose(engine.getSingleGroupTransformer())<br>.filter(<span class="hljs-keyword">new</span> Predicate&lt;Card&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Card card)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> card.isValid();<br>    &#125;<br>&#125;).map(<span class="hljs-keyword">new</span> Function&lt;Card, AppendGroupOp&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AppendGroupOp <span class="hljs-title">apply</span><span class="hljs-params">(Card card)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Thread.sleep(<span class="hljs-number">300</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AppendGroupOp(card);<br>    &#125;<br>&#125;).subscribeOn(Schedulers.io())<br>.observeOn(AndroidSchedulers.mainThread())<br>.subscribe(engine.asAppendGroupConsumer(), <span class="hljs-keyword">new</span> Consumer&lt;Throwable&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Throwable throwable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        throwable.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>里面的逻辑还是挺清晰的：</p><ul><li><p>先从 json 模拟数据文件里面读取出数据，将数据转成 JSONArray</p></li><li><p>将 JsonArray 转成 Observerable&lt;JSONObject&gt;，具体做法就是将 JSONArray 拆成一个一个的 JSONObject 数组，然后发送出去</p><blockquote><p>com.alibaba.android.rx.JSONArrayObservable.FromJsonArrayDisposable#run</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    JSONArray a = array;<br>    <span class="hljs-keyword">int</span> n = a.length();<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;<br>        T value = (T) a.opt(i);<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>            actual.onError(<span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;The &quot;</span> + i + <span class="hljs-string">&quot;th element is null&quot;</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        actual.onNext(value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isDisposed()) &#123;<br>        actual.onComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下游接收到 JSONObject 后解析成 Card</p></li><li><p>校验 Card 是否有效</p></li><li><p>将 Card 封装成一个 AppendGroupOp 对象</p></li><li><p>线程切换</p></li><li><p>下游拿到 AppendGroupOp 对象，执行添加 Card 操作</p></li></ul><p>这样就完成了，那么现在，我们应该就知道了，将 json 数据解析成了 Card 需要耗时一定的时间，所以就有了一个间隔效果，而且调用 notifyItemRangeInserted 还会有有一个自带的动画效果。要是不相信的话，可以自己去写个 demo 跑一下。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Annotation Processor</title>
    <link href="/2019/09/10/blog_bak/Blog/Java/Annotation%20Processor/"/>
    <url>/2019/09/10/blog_bak/Blog/Java/Annotation%20Processor/</url>
    
    <content type="html"><![CDATA[<p>注解处理在 Java 1.5 的时候就已经发布了，虽然它很老了，但是却是最强大的 API 之一。下面我们会先讨论注解处理，代码自动生成以及使用到这些技术的开源库。</p><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>实际上，我们应该都知道什么是注解。我们经常使用到的：<code>@Override</code>，<code>@Singleton</code>，<code>@StringRes</code> 等等，这些就是注解。</p><p>注解是一种可以添加到Java源代码的语法元数据。 我们可以注释类，接口，方法，变量，参数等。 可以从源文件中读取Java注解。 Java注解也可以嵌入和读取编译器生成的类文件。 <strong>Java VM可以在运行时保留注解，并通过反射进行读取</strong>。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个注解需要两部分信息： <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html">Retention</a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html">Target</a> 。</p><p> <a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/annotation/RetentionPolicy.html">RetentionPolicy</a> 指定了注解应该保留到程序生命周期的什么时候。举个例子：注解可以保留到程序的编译时期或者运行时期。</p><p> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html">ElementType</a>s 指定了注解应该作用于程序的哪一个部分。有3个取值：</p><ul><li>SOURCE —— 编译时期，不会储存</li><li>CLASS —— 储存在 class 文件中，但是不会保留到运行时期</li><li>RUNTIME —— 储存在 class 文件中，运行时期可以访问（通过反射）</li></ul><p>拿 <code>BindView</code> 注解来说，<code>RetentionPolicy.SOURCE</code> 表示注解只需要在编译时期保存，之后就不需要了。<code>ElementType.FIELD</code> 表示该注解只能修饰字段。</p><h3 id="注解处理器介绍"><a href="#注解处理器介绍" class="headerlink" title="注解处理器介绍"></a>注解处理器介绍</h3><h4 id="编译时期"><a href="#编译时期" class="headerlink" title="编译时期"></a>编译时期</h4><p>Annotation Processor 实际上是 javac 编译器的一部分，所以注解处理时<strong>发生在编译时期</strong>，这有许多好处，其中之一就是“在编译其实发生错误比运行时期发生错误要好的多”。</p><h4 id="无反射"><a href="#无反射" class="headerlink" title="无反射"></a>无反射</h4><p>Java 的反射 API 会在运行时抛出许多错误，这实在是有点蛋疼。但是 Annotation Processor 就不一样了，它会直接给我们一个程序的语义结构，我们使用这个语义结构就可以分析注解所处的上下文场景，然后做处理。</p><h4 id="生成样板代码"><a href="#生成样板代码" class="headerlink" title="生成样板代码"></a>生成样板代码</h4><p>Annotation Processor 最大的用处就是用来生成样板代码了，比如著名的 ButterKnife 等开源库。</p><p>注意：<strong>注解处理器只能生成新的文件，无法更改已经存在的文件</strong>。</p><h3 id="注解处理器是如何工作的"><a href="#注解处理器是如何工作的" class="headerlink" title="注解处理器是如何工作的"></a>注解处理器是如何工作的</h3><p>注解处理会执行很多轮。编译器首先会读取java源文件，然后查看文件中是否有使用注解，如果有使用，则调用其对应的注释处理器，这个注解处理器（可能会）生成新的带有注解的java源文件。这些新注解将再次调用其相应的注释处理器，然后再次生成更多的java源文件。就这样一直循环，直到没有新的文件生成。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/Annotation%20Processor/1.png?raw=true"></p><h3 id="注册注解处理器"><a href="#注册注解处理器" class="headerlink" title="注册注解处理器"></a>注册注解处理器</h3><p>java 编译器需要知道所有的注解处理器，所以如果我们想要自定义一个处理器，我们必须要让 java 编译器知道我们创建了一个。</p><p>有两种方法来注册一个处理器：</p><ul><li><p>老方法：</p><p>创建一个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;your-annotation-processor-module&gt;/src/main/resources/META-INF/services<br></code></pre></td></tr></table></figure><p>然后在services文件夹里面，创建一个名字叫做<code>javax.annotation.processing.Processor</code>的文件。在这个文件中声明你的处理器的权限定名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;your-package&gt;.YourProcessor<br></code></pre></td></tr></table></figure></li><li><p>新方法：</p><p>使用谷歌的  <a href="https://github.com/google/auto/tree/master/service">AutoService</a> 库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> foo.bar;<br><span class="hljs-keyword">import</span> javax.annotation.processing.Processor;<br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Processor</span> </span>&#123;<br>  <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意在 gradle 文件中引入依赖。</p></li></ul><h3 id="创建一个注解处理器"><a href="#创建一个注解处理器" class="headerlink" title="创建一个注解处理器"></a>创建一个注解处理器</h3><p>首先，我们需要继承一个父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Processor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(processingEnvironment);<br>        <span class="hljs-comment">// initialize helper/utility classes...</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment)</span> </span>&#123;<br>        <span class="hljs-comment">// do processing...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>init()</code> 提供帮助和工具类，如：Filer（生成文件），Messager（用于记录错误，警告等），Elements（用于操作程序元素的工具方法），类型（用于操作类型的工具方法）等。 我们可以使用processingEnvironment 这个变量来获取这些类。</p><p><code>process()</code> 这个方法就是所有处理器处理注解的地方。这里你可以获取到被注解修饰的元素的所有信息。然后你就可以生成新的文件了。</p><p><code>getSupportedAnnotationTypes()</code> 这里返回自定义的注解就好了。它的返回值是 process() 方法的第一个参数。</p><p><code>getSupportedSourceVersion()</code> 返回最新的 java 版本就好了。</p><h4 id="新建两个module"><a href="#新建两个module" class="headerlink" title="新建两个module"></a>新建两个module</h4><p>一个用于创建注解，一个用于创建注解处理器。</p><p>为啥需要新建两个module呢？</p><p>因为 processor 需要 annatation 的引用，所以 annotation 需要提出来作为一个 module。</p><p>那么可不可以将所有代码都放到 app 里面呢？是可以的，但是由于我们不需要 processor 的代码，只需要它在编译的时候处理我们的代码然后生成新的文件就好了，更不就不需要将  processor 的代码打包到 apk 里面，所以新建 module 是最好的选择。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/Annotation%20Processor/2.png?raw=true"></p><p>piri-pricessor 的 build.gradle 需要配置一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation project(<span class="hljs-string">&#x27;:piri-annatation&#x27;</span>)<br></code></pre></td></tr></table></figure><p>app 的 build.gradle 需要配置一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation project(<span class="hljs-string">&#x27;:piri-annatation&#x27;</span>)<br>annotationProcessor project(<span class="hljs-string">&#x27;:piri-processor&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> NewIntent &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>ElementType.TYPE 表示这个注解可以修饰 类，接口，枚举 等等。</p><h4 id="创建注解处理器"><a href="#创建注解处理器" class="headerlink" title="创建注解处理器"></a>创建注解处理器</h4><p>自定义的注解处理器需要继承至一个指定的父类（<code>AbstractProcessor </code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewIntentProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv)</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开始处理注解"><a href="#开始处理注解" class="headerlink" title="开始处理注解"></a>开始处理注解</h4><h5 id="首先找到所有的被指定注解修饰元素"><a href="#首先找到所有的被指定注解修饰元素" class="headerlink" title="首先找到所有的被指定注解修饰元素"></a>首先找到所有的被指定注解修饰元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Element element : roundEnvironment.getElementsAnnotatedWith(NewIntent.class)) &#123;<br><br>    <span class="hljs-keyword">if</span> (element.getKind() != ElementKind.CLASS) &#123;<br>        messager.printMessage(Diagnostic.Kind.ERROR, <span class="hljs-string">&quot;Can be applied to class.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    TypeElement typeElement = (TypeElement) element;<br>    activitiesWithPackage.put(<br>        typeElement.getSimpleName().toString(),<br>        elements.getPackageOf(typeElement).getQualifiedName().toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用 <code>roundEnvironment.getElementsAnnotatedWith()</code> 这个方法就可以找出所以被指定注解修饰的元素，这个方法返回了一个集合，集合类型是 Element，Element 是所有元素的一个父接口。</p><p>然后我们判断一下，注解是否被正确使用了，因为我们在创建注解的时候就指定了该注解只能修饰类，接口，枚举…</p><p>如果注解被错误使用了，我们可以使用 message 打印错误信息，反之，被正确使用了，那么我们就可以将它强制转换为 TypeElement。关于这个 TypeElement ，它是 Element 的一个子接口。它通常可以用于类和方法参数。还有一些其他类型的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<span class="hljs-comment">// PackageElement</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<span class="hljs-comment">// TypeElement</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<span class="hljs-comment">// VariableElement</span><br><span class="hljs-keyword">private</span> Foo other; <span class="hljs-comment">// VariableElement</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Foo</span> <span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// ExecuteableElement</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span> <span class="hljs-params">( // ExecuteableElement</span></span><br><span class="hljs-params"><span class="hljs-function">                 <span class="hljs-keyword">int</span> newA// TypeElement</span></span><br><span class="hljs-params"><span class="hljs-function">                 )</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之所以要强制转换成 TypeElement，是因为转换之后，我们可以获取到更多的信息。</p><h5 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">TypeSpec.Builder navigatorClass = TypeSpec<br>                    .classBuilder(<span class="hljs-string">&quot;Navigator&quot;</span>)<br>    .addModifiers(Modifier.PUBLIC, Modifier.FINAL);<br><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; element : activitiesWithPackage.entrySet()) &#123;<br>    String activityName = element.getKey();<br>    String packageName = element.getValue();<br>    ClassName activityClass = ClassName.get(packageName, activityName);<br>    MethodSpec intentMethod = MethodSpec<br>        .methodBuilder(METHOD_PREFIX + activityName)<br>        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)<br>        .returns(classIntent)<br>        .addParameter(classContext, <span class="hljs-string">&quot;context&quot;</span>)<br>        .addStatement(<span class="hljs-string">&quot;return new $T($L, $L)&quot;</span>, classIntent, <span class="hljs-string">&quot;context&quot;</span>, activityClass + <span class="hljs-string">&quot;.class&quot;</span>)<br>        .build();<br>    navigatorClass.addMethod(intentMethod);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是 JavaPoet 的使用方法，就不多说了，可以查看<a href="https://github.com/square/javapoet"> 文档</a> 。</p><h5 id="最后，将代码写入文件"><a href="#最后，将代码写入文件" class="headerlink" title="最后，将代码写入文件"></a>最后，将代码写入文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFile.builder(<span class="hljs-string">&quot;com.annotationsample&quot;</span>, navigatorClass.build())<br>  .build()<br>  .writeTo(filer);<br></code></pre></td></tr></table></figure><p>生成的文件大概内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Navigator</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Intent <span class="hljs-title">startMainActivity</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Intent(context, com.annotationsample.MainActivity.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们就可以在代码中使用生成的代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NewIntent</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;&#125;<br><br>----------------------------------------------------------------------------------------<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SplashActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_splash);<br>        Navigator.startMainActivity(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//generated class, method</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例工程"><a href="#实例工程" class="headerlink" title="实例工程"></a>实例工程</h4><p><a href="https://github.com/aprz512/AnnotationProcessorDemo">AnnotationProcessorDemo</a></p><p>遇到的坑：</p><ul><li>新建module的时候要选择 java module，否则找不到 AbstractProcessor 类</li><li>我的 AS 一直保持着最新的 gradle 版本，在我写示例项目的时候，是引用的 gradle 版本是 <code>https\://services.gradle.org/distributions/gradle-5.1.1-all.zip</code>，于是我就踩了一个深坑，那就是发现 processor 工程打包除了问题，导致 app 项目引用了无法生成文件。找了一个下午的问题最后发现是 gradle 版本的问题，改成 <code>https\://services.gradle.org/distributions/gradle-4.6-all.zip</code> 就好了。我特么想骂人。</li></ul><p><strong>上面的版本问题，已经找到答案</strong>，添加一行代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gr">annotationProcessor &#x27;com.google.auto.service:auto-service:1.0-rc5&#x27;<br></code></pre></td></tr></table></figure><p>我当时看别人的博客的时候，就很奇怪，为啥不用加 annotationProcessor。</p><h3 id="倒推一下-ButterKnife-是怎么做的"><a href="#倒推一下-ButterKnife-是怎么做的" class="headerlink" title="倒推一下 ButterKnife 是怎么做的"></a>倒推一下 ButterKnife 是怎么做的</h3><p>首先我们先来回忆一下我们是怎么使用 ButterKnife 的。</p><p>给控件加上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindView(R.id.title)</span> <br>TextView title;<br></code></pre></td></tr></table></figure><p>在 Activity 的 setContentView 后，添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ButterKnife.bind(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>经过这两步，title 就会被自动赋值，然后我们就可以使用了。</p><p>这里我们可以猜想一下，ButterKnife 的注解处理器做了什么。</p><p>第一步，肯定也是先要获取到被注解修饰的元素。然后接下来该做什么呢？我们转换一下思维，如果我们没有使用 ButterKnife 的话，我们会做什么——我们会在 setContentView 方法后面写一个 initView 方法，然后给变量赋值。这个时候你就应该反应过来了，ButterKnife.bind(this); 这句代码就做了类似的功能。那么它是如何实现的呢？</p><p>我们从这行代码中可以看出，ButterKnife 会持有当前 Activity 的引用，那么我们可不可以利用这个引用，拿到 title 呢？答案是可以的，因为 title 不是私有的，所以我们只需要生成一个类，将这个类放入当前 Activity 所在的 package 中即可。</p><p>由于注解的参数就是这个控件的 id，所以我们也可以找到这个控件，调用 findViewById，将这个值赋值给 title。大概是这样：</p><blockquote><p>自动生成的代码 xxx</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">activity.title = Utils.findViewById(root, id);<br>这样就完成了赋值。当然实际不可能这么简单，还有很多细节需要处理，这里只是一个倒推，具体的细节还请执行查阅源代码。<br></code></pre></td></tr></table></figure><p><strong>后记</strong></p><p>文章中已经说过，Annotaion Processor 只能生成新的文件，无法对已有的文件进行修改。如果我们有这方便的需求，那么应该怎么做呢？比如，我们想给某些类（比如Activity 或者 Fragement ）添加 log，手动添加的话，就很蛋疼了，这个时候，如果可以批量处理的话就会轻松很多。那么有什么可以办到呢，就是 Transform API 了，下一篇就写这个东西。</p><h3 id="added"><a href="#added" class="headerlink" title="added"></a>added</h3><p>注解处理器有这么一个蛋疼的地方：它会为每个使用注解的工程生成一个文件，那么问题就来了，有多个module以依赖的形式被app引用，那么就会生成多个相同的类，打包的时候肯定会报错，怎么解决呢？Arouter是生成不同的文件（以模块命名）。</p><p>想做一个<strong>收集被指定注解修饰的类</strong>的功能，但是遇到了很多问题：</p><p>首先生成的多个文件只能在module中访问，无法整合成一个类。</p><p>就算想别的方法再搞一个类整合这些生成的类，也需要知道这些生成的类的类名，还要能够访问的到这些类（除非你使用反射）。注解处理器的工作方式是每个module分开处理，没法知道别的module生成类的名字（除非像deeplink一样，手动添加）。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>注解处理器可能会有多次处理过程。<br>一个简单的例子：第一轮处理调用了注解处理器的process()方法，我们生成了对应的文件。由于生成了新文件，它可能会有注解，所以会走下一轮注解处理，然后重复生成文件。<br>就会报错：Attempt to recreate a file for type xxxx<br>解决办法是需要在 process 中将保存的集合清空，在集合为空时，不生成文件。</p>]]></content>
    
    
    <categories>
      
      <category>AnnotationProcessor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-AnnotationProcessor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0005-使用定时器</title>
    <link href="/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0005-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0005-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>组件的业务逻辑里难免有涉及到定数触发的逻辑，比如倒计时、定时滚动。Tangram 内置了定时器模块，可以全局复用，防止重复开发。以在组件里使用定时器为例： 在 bindView 或者 postBindView 方法里注册定时器。</p><p>在自定义的 View 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postBindView</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cell.serviceManager != <span class="hljs-keyword">null</span>) &#123;<br>        TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class);<br>        <span class="hljs-keyword">if</span> (timerSupport != <span class="hljs-keyword">null</span> &amp;&amp; !timerSupport.isRegistered(<span class="hljs-keyword">this</span>)) &#123;<br>            <span class="hljs-comment">//第一个参数4是单位秒，第二个参数是接口回调，第三个参数是立即执行</span><br>            timerSupport.register(<span class="hljs-number">4</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 TimerSupport 的获取方式有点类似 Android 的 getSystemService。我们看看是怎么做的。</p><blockquote><p>com.tmall.wireless.tangram.BaseTangramEngine</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt; mServices = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;S&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;S&gt; type, <span class="hljs-meta">@NonNull</span> S service)</span> </span>&#123;<br>    Preconditions.checkArgument(type != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;type is null&quot;</span>);<br>    mServices.put(type, type.cast(service));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;S&gt; <span class="hljs-function">S <span class="hljs-title">getService</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Class&lt;S&gt; type)</span> </span>&#123;<br>    Object service = mServices.get(type);<br>    <span class="hljs-keyword">if</span> (service == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> type.cast(service);<br>&#125;<br></code></pre></td></tr></table></figure><p>BaseTangramEngine 这个类里面有一个 map，里面储存了各种 service 的实例。我们只需要调用 register 方法将一个实例注册进去，以后就可以通过 getService 方法获取了。而 BaseCell 的 serviceManager 字段又是指向同一个对象，所以这就像是一个单利用来储存与获取数据。</p><p>获取到 TimerSupport 之后，就是使用观察者模式来注册监听与解绑监听。</p><blockquote><p>com.tmall.wireless.tangram.support.TimerSupport#register(int, com.tmall.wireless.tangram.support.TimerSupport.OnTickListener, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interval, <span class="hljs-meta">@NonNull</span> OnTickListener onTickListener, <span class="hljs-keyword">boolean</span> intermediate)</span> </span>&#123;<br>    mDefaultTimer.register(interval, onTickListener, intermediate);<br>&#125;<br></code></pre></td></tr></table></figure><p>监听器的实现是 <code>com.tmall.wireless.tangram.support.HandlerTimer</code>类，这个类很简单，一般只要做过倒计时功能的都看的懂，里面是使用 Handler 做了一个循环实现的，所以我就不分析这个类了。</p><p>在注册完监听之后，还需要考虑的是，什么时候启动这个循环，什么时候终止这个循环，因为 TimerSupport 是统一管理所有的定时器。比如：当一个观察者解除监听的时候，不能直接停止整个定时器，因为可能还有别的观察者需要使用整个定时器。我们来看看，Tangram 是如何处理的：</p><blockquote><p>com.tmall.wireless.tangram.support.HandlerTimer#register</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">int</span> interval, OnTickListener onTickListener, <span class="hljs-keyword">boolean</span> intermediate)</span> </span>&#123;<br>    mListeners.put(onTickListener, <span class="hljs-keyword">new</span> IntervalTickListener(interval, onTickListener, intermediate));<br>    start(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在注册监听的时候，就会启动这个全局定时器。</p><blockquote><p>com.tmall.wireless.tangram.support.HandlerTimer#runTask</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTask</span><span class="hljs-params">()</span> </span>&#123;<br>    mCopyListeners.clear();<br>    mCopyListeners.addAll(mListeners.values());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = mCopyListeners.size(); i &lt; size; i++) &#123;<br>        IntervalTickListener listener = mCopyListeners.get(i);<br>        listener.onTick();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mListeners.isEmpty()) &#123;<br>        stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在通知所有观察者的时候会判断，如果没有了观察者，会停止这个全局定时器。</p><p>关于定时器的处理，TimerSupport 就是用来统一管理一个全局的定时器的，免得每个 Cell 都开启一个自己的。TimerSupport 里面还有其他的一些方法，可以去看看。</p><p>在自定义 View 中实现接口：</p><blockquote><p>com.tmall.wireless.tangram.support.TimerSupport.OnTickListener</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//处理业务逻辑        </span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 unbindView 或者 postUnbindView 的方法里要记得注销定时器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (cell.serviceManager != <span class="hljs-keyword">null</span>) &#123;<br>    TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class);<br>    <span class="hljs-keyword">if</span> (timerSupport != <span class="hljs-keyword">null</span>) &#123;<br>        timerSupport.unregister(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0006-使用组件辅助模块</title>
    <link href="/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0006-%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/"/>
    <url>/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0006-%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>每个组件里可能会有一些重复逻辑，特别是采用通用 model 开发组件的时候，组件的 View 之间一般没有继承体系，为了解决这种问题，建议业务也像<code>SimpleClickSupport</code>或者<code>ExposureSupport</code>一样将逻辑模块化，通过 serviceManager 注册到框里提供给组件使用。此外框架里还提供了一个<code>CellSupport</code>，暴露了一些基本接口，业务方需要继承它并注册到 Tangram 里。</p><p>假设我们的页面上有一些 Cell 需要做一些比较特殊且复杂的 log 操作，我们将 log 操作封装了起来以方便调用。</p><p>现在就有两种方式来使用封装好了的工具，第一种是在自定义 View 的时候，创建这个工具类出来，这显然不太好，或许我们可以将这个工具方法改为静态的，没法改的话，将工具类改为单利。</p><p>第二种方法就对该工具类没啥要求，只需要我们写好这个类之后，然后注册到 ServiceManager 里面，然后每个 cell 都可以获取到这个工具类了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexLogUtil</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(View v)</span></span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">engine.register(ComplexLogUtil.class, <span class="hljs-keyword">new</span> ComplexLogUtil());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cellInited</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cell.serviceManager != <span class="hljs-keyword">null</span>) &#123;<br>        ComplexLogUtil complexLogUtil = cell.serviceManager.getService(ComplexLogUtil.class);<br>        <span class="hljs-keyword">if</span> (timerSupport != <span class="hljs-keyword">null</span> ) &#123;<br>            complexLogUtil.log(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ServiceManager 就是一个纽带，让每个 Cell 都可以共享同一个东西。</p><p>再说 CellSupport，源码里面是这样使用这个类的：</p><blockquote><p>com.tmall.wireless.tangram.MVHelper#mountView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (cell.serviceManager != <span class="hljs-keyword">null</span>) &#123;<br>    CellSupport cellSupport = cell.serviceManager.getService(CellSupport.class);<br>    <span class="hljs-keyword">if</span> (cellSupport != <span class="hljs-keyword">null</span>) &#123;<br>        cellSupport.postBindView(cell, view);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就说明了，当我们注册的时候，我们只能使用 <code>CellSupport.class</code> 来注册。比如我们有一个类 MyCellSupport 实现了这个接口，我们注册的时候如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">engine.register(CellSupport.class, <span class="hljs-keyword">new</span> MyCellSupport());<br></code></pre></td></tr></table></figure><p>这个玩意就比较像一个切面了，比如我们想对每一个 cell 在 bindView 或者 unBindView 做一些通用的操作，就可以实现这个接口。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0007-使用布局辅助模块</title>
    <link href="/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0007-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/"/>
    <url>/2019/09/10/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0007-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><code>CardSupport</code>，布局辅助模块，主要处里布局背景加载的回调，让业务方有能力去控制相关逻辑，业务方需要继承它并注册到 Tangram 里。由于这里面的逻辑涉及到 vLayout，而 vLayout 系列准备另起一个系列，所以这里就不说咯。</p><p>这个类还是挺简单的，里面就几个空方法，Java 8 可以改成接口，用默认实现。</p><p>方法的意义也很明了，就是用来处理布局背景的，其他的没有。</p><p>还有一个方法是用来设置固定的 view 的出现与消失动画的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardSupport</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> FixAreaLayoutHelper.<span class="hljs-function">FixViewAnimatorHelper <span class="hljs-title">onGetFixViewAppearAnimator</span><span class="hljs-params">(Card card)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnbindBackgroundView</span><span class="hljs-params">(View layoutView, Card card)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindBackgroundView</span><span class="hljs-params">(View layoutView, Card card)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003-处理点击与曝光</title>
    <link href="/2019/09/09/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0003-%E5%A4%84%E7%90%86%E7%82%B9%E5%87%BB%E4%B8%8E%E6%9B%9D%E5%85%89/"/>
    <url>/2019/09/09/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0003-%E5%A4%84%E7%90%86%E7%82%B9%E5%87%BB%E4%B8%8E%E6%9B%9D%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>在上一篇，我们在自定义的 View 中的 cellInited 方法里面做了一些初始化的操作，其中就有添加点击事件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cellInited</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    setOnClickListener(cell);<br>    <span class="hljs-keyword">this</span>.cell = cell;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，setOnClickListener 方法的参数是 BaseCell，说明它肯定实现了点击事件的接口：</p><blockquote><p>com.tmall.wireless.tangram.structure.BaseCell#onClick</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (serviceManager != <span class="hljs-keyword">null</span>) &#123;<br>        SimpleClickSupport service = serviceManager.getService(SimpleClickSupport.class);<br>        <span class="hljs-keyword">if</span> (service != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">int</span> eventType = <span class="hljs-keyword">this</span>.pos;<br>            <span class="hljs-keyword">if</span> (innerClickMap.containsKey(v.hashCode())) &#123;<br>                eventType = innerClickMap.get(v.hashCode()).intValue();<br>            &#125;<br>            service.onClick(v, <span class="hljs-keyword">this</span>, eventType);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看第 10 行代码，这行代码最终会调用到 <code>com.tmall.wireless.tangram.support.SimpleClickSupport#defaultClick</code> 里面。</p><p>SimpleClickSupport 的子类应该要处理这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleClickSupport</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleClickSupport</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleClickSupport</span><span class="hljs-params">()</span> </span>&#123;<br>        setOptimizedMode(<span class="hljs-keyword">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultClick</span><span class="hljs-params">(View targetView, BaseCell cell, <span class="hljs-keyword">int</span> eventType)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.defaultClick(targetView, cell, eventType);<br>        Toast.makeText(targetView.getContext(), <span class="hljs-string">&quot; 您点击了组件  type:&quot;</span>+cell.type, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出来，SimpleClickSupport 是用来统一处理点击事件的。说一下 defaultClick 的 3 个参数：</p><ul><li>targetView 是 Cell 对应的 View，可能是一个 View，也可能是一个  ViewGroup</li><li>cell 是View 对应的 cell （感觉有点废话）</li><li>eventType 是注册点击事件时，传入的 type，如果没有传入该值默认为在 Card 中的位置。</li></ul><p>我们可以在自定义 View 中传入 type：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cellInited</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    cell.setOnClickListener(<span class="hljs-keyword">this</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">this</span>.cell = cell;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，点击该 cell，eventType 就是 4 了。</p><p>使用<code>SimpleClickSupport</code>的时候需要注意：</p><ul><li>建议开启优化模式</li></ul><p>在路由点击事件的时候，会判断如果开启了优化，会调用到 defaultClick 方法，否则的话会触发反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View targetView, BaseCell cell, <span class="hljs-keyword">int</span> eventType, Map&lt;String, Object&gt; params)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (optimizedMode) &#123;<br>        defaultClick(targetView, cell, eventType);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>            <span class="hljs-comment">// 使用反射寻找方法</span><br>            <span class="hljs-comment">// 方法需要以 onClickXXX 或者 onXXXClick 命名</span><br>            <span class="hljs-comment">// 并且参数列表是View targetView, BaseCell cell, int type或者View targetView, BaseCell cell, int type, Map&lt;String, Object&gt; params</span><br>            ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="处理曝光"><a href="#处理曝光" class="headerlink" title="处理曝光"></a>处理曝光</h2><p>Tangram 认为组件曝光的时机就是被 RecyclerView 的 Adapter 绑定数据的那个时候，也就是即将滑动到屏幕范围内。在这个时候业务上可能需要有一些处理，因此提供了接口定义并整合到框架里 —— <code>ExposureSupport</code>。它定义了3个层面的曝光接口，一是曝光布局，二是曝光组件整体区域，三是曝光组件局部区域。业务方实现子类，并针对三个层面的曝光做分别的实现。</p><p>文档开头说的还是很清晰的，但是却没有仔细说这 3 个接口是哪 3 个，真的是蛋疼。</p><p>布局的整体曝光（<strong>这是从文档copy出来的，不知道是布局的曝光还是组件整体的曝光</strong>）回调接口是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExposure</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Card card, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> position)</span></span>;<br></code></pre></td></tr></table></figure><p>这个方法在<code>com.tmall.wireless.tangram.dataparser.concrete.PojoGroupBasicAdapter#onBindViewHolder</code>中调用。</p><p>组件的局部区域曝光接口是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultTrace</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View targetView, <span class="hljs-meta">@NonNull</span> BaseCell cell, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是我却没找到哪里调用了这个方法！！！</p><p>还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultExposureCell</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View targetView, <span class="hljs-meta">@NonNull</span> BaseCell cell, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法在 <code>com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder</code> 中调用。</p><p>可以看到，onExposure 与 defaultExposureCell 执行的时机<strong>差不多在同一时刻</strong>，因为 PojoGroupBasicAdapter 是 GroupBasicAdapter 的子类。差别就只有参数了。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0004-异步加载数据</title>
    <link href="/2019/09/09/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0004-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/"/>
    <url>/2019/09/09/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0004-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>Tangram 的页面的数据无法一次性返回，有些区块布局内的数据需要异步加载、甚至分页加载。Tangram 里内置了封装了异步加载的逻辑，需要各个层面配合完成。</p><h2 id="数据设置"><a href="#数据设置" class="headerlink" title="数据设置"></a>数据设置</h2><p>想要实现异步加载，服务器返回的数据需要做如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;Shop&quot;</span>,<br><span class="hljs-attr">&quot;load&quot;</span>: <span class="hljs-string">&quot;queryShop&quot;</span>,<br><span class="hljs-attr">&quot;loadType&quot;</span>: <span class="hljs-string">&quot;-1&quot;</span>,<br><span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;container-oneColumn&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>load 是接口名称，表示这个布局需要执行异步加载的接口。</li><li>loadType 是异步加载的方式，-1表示需要异步加载，1表示需要异步加载且有分页。</li><li>hasMore 与 loadType 配合，当 loadType = 1 的时候表示分页是否结束。</li><li>loadParams 是异步加载接口的常规参数字典，需要在调用接口时透传。</li></ul><p>既然规定了 load 是接口名称，我们直接搜一下哪里用到了 “load”这个字符串，果然 Card 里面有一个字段：</p><blockquote><p>com.tmall.wireless.tangram.dataparser.concrete.Card#KEY_API_LOAD</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_API_LOAD = <span class="hljs-string">&quot;load&quot;</span>;<br></code></pre></td></tr></table></figure><p>继续看用这个字符串搞了啥：</p><blockquote><p>com.tmall.wireless.tangram.dataparser.concrete.Card#parseWith(org.json.JSONObject, com.tmall.wireless.tangram.MVHelper, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseWith</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> JSONObject data, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> MVHelper resolver, <span class="hljs-keyword">boolean</span> isParseCell)</span> </span>&#123;<br>    ...<br>    load = data.optString(KEY_API_LOAD, <span class="hljs-keyword">null</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>从 json 数据里面解析出来接口名字，这个在意料之中。</p><p>解析出来之后，框架里面并没有去发起请求，而是使用了接口的方式让外部去做请求，这里<strong>只是将接口的一些信息解析出来保存起来</strong>。</p><h2 id="CardLoadSupport与AsyncLoader，AsyncPageLoader"><a href="#CardLoadSupport与AsyncLoader，AsyncPageLoader" class="headerlink" title="CardLoadSupport与AsyncLoader，AsyncPageLoader"></a>CardLoadSupport与AsyncLoader，AsyncPageLoader</h2><p>上面说了，请求的处理还是暴露给了外部去处理，那么应该怎么做呢？只需要做一件事，提供一个自定义的 <code>CardLoadSupport</code> 就好了。</p><p>这个  <code>CardLoadSupport</code> 需要传入两个参数进去，<code>AsyncLoader</code>和<code>AsyncPageLoader</code>。所以归根结底，还是要自定义两个对象，<code>AsyncLoader</code> 和 <code>AsyncPageLoader</code>。</p><p>自定义这两个对象不难，我们看一个例子就明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> AsyncLoader() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(Card card, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> LoadedCallback callback)</span> </span>&#123;<br>        Log.w(<span class="hljs-string">&quot;Load Card&quot;</span>, card.load);<br>        ...<br>        <span class="hljs-comment">// callback.fail(false);</span><br>        callback.finish(engine.parseComponent(cells));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>card 参数里面有接口的所有信息了，所以可以发起请求，请求之后可以根据结果来设置相应的回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> AsyncPageLoader() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> page, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Card card, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> LoadedCallback callback)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">// cells 是请求回来的数据</span><br>        List&lt;BaseCell&gt; cs = engine.parseComponent(cells);<br><br>        <span class="hljs-keyword">if</span> (card.page == <span class="hljs-number">1</span>) &#123;<br>            GroupBasicAdapter&lt;Card, ?&gt; adapter = engine.getGroupBasicAdapter();<br><br>            card.setCells(cs);<br>            adapter.refreshWithoutNotify();<br>            Range&lt;Integer&gt; range = adapter.getCardRange(card);<br><br>            adapter.notifyItemRemoved(range.getLower());<br>            adapter.notifyItemRangeInserted(range.getLower(), cs.size());<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            card.addCells(cs);<br>        &#125;<br><br>        <span class="hljs-comment">//mock load 6 pages</span><br>        callback.finish(card.page != <span class="hljs-number">6</span>);<br>        card.notifyDataChange();<br>    &#125;<br>&#125;));<br></code></pre></td></tr></table></figure><p>这里是分页请求的处理，与我们平时分页的逻辑并无多大区别。</p><p>下面我们来看看源码里面，这两个 loader 做了什么，我们以 AsyncPageLoader 为例。</p><blockquote><p>com.tmall.wireless.tangram.TangramEngine#onScrolled</p></blockquote><p>在 RecyclerView 滚动的时候，就会调用这个方法，当然这方法需要我们主动的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">recyclerView.addOnScrollListener(<span class="hljs-keyword">new</span> RecyclerView.OnScrollListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onScrolled(recyclerView, dx, dy);<br>        engine.onScrolled();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>下面，我们分析 onScrolled 方法里面的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// position 是当前屏幕上最后一个 cell 的位置</span><br><span class="hljs-comment">// lastCardIndex 是表示的第几种 type 类型，从 0 开始</span><br><span class="hljs-comment">// 所以 current 是屏幕上最后一个 card</span><br><span class="hljs-comment">// 这里是对屏幕上最后一个卡片进行预加载更多</span><br><span class="hljs-keyword">if</span> (pair != <span class="hljs-keyword">null</span> &amp;&amp; position &gt;= pair.first.getUpper() - mPreLoadNumber) &#123;<br>    <span class="hljs-comment">// async load</span><br>    <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(current.load) &amp;&amp; current.loaded) &#123;<br>        <span class="hljs-comment">// page load</span><br>        <span class="hljs-keyword">if</span> (current.loadMore) &#123;<br>            loadSupport.loadMore(current);<br>            loadSupport.reactiveDoLoadMore(current);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">boolean</span> loadedMore = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-comment">// 这里是处理当前屏幕上的 card</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = firstCardIndex; i &lt; Math.min(lastCardIndex + mPreLoadNumber, cards.size()); i++) &#123;<br>    Card c = cards.get(i);<br>    <span class="hljs-comment">// async load</span><br>    <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(c.load) &amp;&amp; !c.loaded) &#123;<br>        <span class="hljs-comment">// page load</span><br>        <span class="hljs-keyword">if</span> (c.loadMore &amp;&amp; !loadedMore) &#123;<br>            <span class="hljs-comment">// only load one load more card</span><br>            loadSupport.loadMore(c);<br>            loadSupport.reactiveDoLoadMore(c);<br>            loadedMore = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            loadSupport.doLoad(c);<br>            loadSupport.reactiveDoLoad(c);<br>        &#125;<br>        c.loaded = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这里是处理数据源里的最后一个 card</span><br><span class="hljs-keyword">if</span> (mEnableAutoLoadMore &amp;&amp; mGroupBasicAdapter.getItemCount() - position &lt; mPreLoadNumber) &#123;<br>    loadMoreCard();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的主要逻辑分为 3 段，但是很蛋疼的是，这 3 段逻辑又有重复的地方。我们拿数学区间举例：假设第一段区间是 [0, 3]，第二段是 [2, 4]，第三段是 [3, 5]。可以看出区间里面有重复的地方法，就如同上面代码的 3 段逻辑。我们举一个例子来说明逻辑重复导致的影响：</p><p>Tangram 提供了一个禁止加载更多的方法：</p><blockquote><p>com.tmall.wireless.tangram.TangramEngine#enableAutoLoadMore</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enableAutoLoadMore</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enableAutoLoadMore)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.mEnableAutoLoadMore = enableAutoLoadMore;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个字段只用在了第 3 段逻辑里面，按照道理来说，设置了这个之后，我们就不会自动加载更多了，但是实际上上面的两段逻辑也包含加载更多的逻辑，所以即使也将这个字段设置为了 false，你再运行官方demo也没啥区别。</p><p>这里我懒得搞清楚它为啥要这样写了，说实话这个框架的是值得一看的，但是代码真的很乱，阅读起来你搞不清楚写的人在想啥。</p><p>我们继续我们的分析，从上面的代码中我们可以看到它调用了 CardLoadSupport 的 doLoad 与 loadMore 方法。</p><h2 id="CardLoadSupport-doLoad"><a href="#CardLoadSupport-doLoad" class="headerlink" title="CardLoadSupport#doLoad"></a>CardLoadSupport#doLoad</h2><p>这个方法是用来加载 Card 中的数据的。</p><blockquote><p>com.tmall.wireless.tangram.support.async.CardLoadSupport#doLoad</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doLoad</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Card card)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mAsyncLoader == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!card.loading &amp;&amp; !card.loaded) &#123;<br>        card.loading = <span class="hljs-keyword">true</span>;<br>        mAsyncLoader.loadData(card, <span class="hljs-keyword">new</span> AsyncLoader.LoadedCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">()</span> </span>&#123;<br>                card.loading = <span class="hljs-keyword">false</span>;<br>                card.loaded = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(List&lt;BaseCell&gt; cells)</span> </span>&#123;<br>                finish();<br>                card.addCells(cells);<br>                card.notifyDataChange();<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loaded)</span> </span>&#123;<br>                card.loading = <span class="hljs-keyword">false</span>;<br>                card.loaded = loaded;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法中，我们可以看到实际上是使用了 <code>com.tmall.wireless.tangram.support.async.AsyncLoader#loadData</code> 这个方法，而这个方法是我们在创建 AsyncLoader 的时候，需要实现的方法。这样加载 Card 数据的逻辑就串起来了：</p><ul><li><p>监听 RecyclerView 的滚动，在滚动的时候就触发加载加载逻辑。</p></li><li><p>如果数据没有加载的话，就调用外部实现的 <code>AsyncLoader#loadData</code> 方法来加载数据。</p></li></ul><h2 id="CardLoadSupport-loadMore"><a href="#CardLoadSupport-loadMore" class="headerlink" title="CardLoadSupport#loadMore"></a>CardLoadSupport#loadMore</h2><p>这个方法是用来处理分页加载的。</p><blockquote><p>com.tmall.wireless.tangram.support.async.CardLoadSupport#loadMore</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadMore</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Card card)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mAsyncPageLoader == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!card.loading &amp;&amp; card.loadMore &amp;&amp; card.hasMore) &#123;<br>        card.loading = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (!card.loaded) &#123;<br>            card.page = sInitialPage;<br>        &#125;<br><br><br>        mAsyncPageLoader.loadData(card.page, card, <span class="hljs-keyword">new</span> AsyncPageLoader.LoadedCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasMore)</span> </span>&#123;<br>                card.loaded = <span class="hljs-keyword">true</span>;<br>                card.loading = <span class="hljs-keyword">false</span>;<br>                card.page++;<br>                card.hasMore = hasMore;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(List&lt;BaseCell&gt; cells, <span class="hljs-keyword">boolean</span> hasMore)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (card.page == sInitialPage) &#123;<br>                    card.setCells(cells);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    card.addCells(cells);<br>                &#125;<br><br>                finish(hasMore);<br>                card.notifyDataChange();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fail</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> retry)</span> </span>&#123;<br>                card.loaded = <span class="hljs-keyword">true</span>;<br>                card.loading = <span class="hljs-keyword">false</span>;<br>                card.hasMore = retry;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑也很简单，与 doLoad 方法是一样的。我们在实现 <code>AsyncPageLoader.loadData</code> 方法的时候，一定要注意正确的调用 finish 与 fail 方法。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-前言</title>
    <link href="/2019/09/07/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0001-%E5%89%8D%E8%A8%80/"/>
    <url>/2019/09/07/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0001-%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>直接看官方文档比较好吧：</p><ul><li><a href="http://tangram.pingguohe.net/docs/basic-concept/history">了解Tangram</a></li><li><a href="http://tangram.pingguohe.net/docs/basic-concept/concept">基本概念</a></li><li><a href="http://tangram.pingguohe.net/docs/basic-concept/structure">基础架构</a></li><li><a href="http://tangram.pingguohe.net/docs/basic-concept/principle">设计原则</a></li></ul><p>后面的文章，都是照着下面链接的目录来的：</p><p><a href="http://tangram.pingguohe.net/docs/android/access-tangram">http://tangram.pingguohe.net/docs/android/access-tangram</a></p><p>主要是记录在看文档的过程中，对相应部分源码的分析与自己的理解。</p><p>Tangram 的接入与核心方法这两部分可讲的东西不多，所以我们直接跳过。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-组件开发</title>
    <link href="/2019/09/07/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0002-%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2019/09/07/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Tangram/0002-%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>在 Tangram 的领域里，我们将一个普通的列表页面结构化成树状结构：分别是页面 - 布局 - 组件。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">页面<br>|<span class="hljs-string"></span><br><span class="hljs-string">- 布局1</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件11</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件12</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件13</span><br><span class="hljs-string"></span>|<br>- 布局2<br>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件21</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件22</span><br><span class="hljs-string"></span>|<br>- 布局3<br>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件31</span><br><span class="hljs-string"></span>|<span class="hljs-string"></span>|<br>|<span class="hljs-string">- 组件32</span><br><span class="hljs-string"></span>|<br>- 组件4<br>...<br>|<span class="hljs-string"></span><br><span class="hljs-string"></span>|<br>|<span class="hljs-string"></span><br><span class="hljs-string">- 布局n</span><br><span class="hljs-string"></span>|<br>- 组件n1<br></code></pre></td></tr></table></figure><p>组件分为两层：model 和 View。Tangram 里提供了通用 model 类型 <code>BaseCell</code>，因此开发组件有两个选择：</p><ol><li>采用通用 model，开发自定义 View。</li><li>采用自定义 model 和自定义 View</li></ol><p>BaseCell 里面储存了组件的数据信息，又需要的都可以在里面获取到，可以看一下结构树来了解一下里面的方法都有什么，这里就不展开说了，方法名很明了。</p><h2 id="通用-Model-开发自定义-View"><a href="#通用-Model-开发自定义-View" class="headerlink" title="通用 Model 开发自定义 View"></a>通用 Model 开发自定义 View</h2><p>文档提供了两种开发方式，一种是需要实现 <code>ITangramViewLifeCycle</code> 接口，一种是使用注解加反射的方式。</p><p>我们先来看第一种，实现结构的方式，以官方的demo为例：</p><blockquote><p>com.tmall.wireless.tangram.example.data.SingleImageView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITangramViewLifeCycle</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>自定义的 View 需要实现接口，这个没啥说的。</p><p>该接口有 3 个方法需要实现：</p><blockquote><p>com.tmall.wireless.tangram.structure.view.ITangramViewLifeCycle</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITangramViewLifeCycle</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cellInited</span><span class="hljs-params">(BaseCell cell)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postBindView</span><span class="hljs-params">(BaseCell cell)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postUnBindView</span><span class="hljs-params">(BaseCell cell)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一个方法，就是用来做一些初始化工作的，cell 表示是这个组件的一些信息。上面说过，页面由布局与组件组成，对应的就是 Card 与 Cell。</p><p>我们追踪一下，看这个方法在哪里被调用：</p><blockquote><p>com.tmall.wireless.tangram.MVHelper#initView</p></blockquote><blockquote><p>com.tmall.wireless.tangram.MVHelper#mountView</p></blockquote><blockquote><p>com.tmall.wireless.tangram.core.adapter.BinderViewHolder#bind</p></blockquote><blockquote><p>com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder</p></blockquote><p>可以看到，最后到了 GroupBasicAdapter 的 onBindViewHolder方法里面。Tangram 的布局是基于 RecyclerView 的，我们将 GroupBasicAdapter 当作一个超级强的 Adapter 的实现就好了，所以 Cell 的初始化是在 onBindViewHolder 中执行的。</p><p>再看接口中的第二个方法，看名字就应该知道也是在 onBindViewHolder 的时候执行的，不过有一个 post 前缀，我们追踪一下就会发现，其实就是比 cellInited 方法晚一点调用而已。</p><blockquote><p>com.tmall.wireless.tangram.MVHelper#mountView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&#125; <span class="hljs-keyword">else</span> &#123;<br>    loadMethod(cell, view);<br>    initView(cell, view);<br>    renderView(cell, view);<br>    renderStyle(cell, view);<br>&#125;<br><span class="hljs-keyword">if</span> (mvResolver.isCompatibleType(cell.stringType)) &#123;<br>    mvResolver.getCellClass(cell.stringType).cast(cell).bindView(view);<br>&#125;<br>postMountView(cell, view);<br></code></pre></td></tr></table></figure><p>第 3 行与第 10 行，第 3 行会触发 cellInited 的调用，第 10 行触发了 postBindView。</p><p>再看接口中的第三个方法，我们可以思考一下，应该在什么时候触发 postUnBindView 方法？最显然的应该是在滑出屏幕的时候，但是如果对 RecyclerView 的回收机制有一定了解的应该知道，一个 item 滑出屏幕的时候，还没有进入 pool 里面，而是进入到了 cache 里面，是为了防止用户滑出又滑入的情况。所以我们应该在 item 进入 pool 的时候再触发 postUnBindView，而且只有进入了 pool 中的 item 才会重新走 onBindViewHolder，这刚好与 postBindView 是对称的。</p><p>我们追踪一下代码，看看它是什么时候调用的：</p><blockquote><p>com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onViewRecycled</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(BinderViewHolder&lt;C, ? extends View&gt; holder)</span> </span>&#123;<br>    ...<br>    holder.unbind();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>与我们思考的一样，是当 item 被回收的时候，触发的。</p><p>现在，我们知道了这 3 个方法调用的时机，就知道我们可以在这 3 个方法里面做什么了，下面是一个例子：</p><blockquote><p>com.tmall.wireless.tangram.example.data.TestView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cellInited</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    setOnClickListener(cell);<br>    <span class="hljs-keyword">this</span>.cell = cell;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里处理了点击事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postBindView</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pos = cell.pos;<br>    String parent = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (cell.parent != <span class="hljs-keyword">null</span>) &#123;<br>        parent = cell.parent.getClass().getSimpleName();<br>    &#125;<br>    textView.setText(<br>            cell.id + <span class="hljs-string">&quot; pos: &quot;</span> + pos + <span class="hljs-string">&quot; &quot;</span> + parent + <span class="hljs-string">&quot; &quot;</span> + cell<br>                    .optParam(<span class="hljs-string">&quot;msg&quot;</span>));<br><br>    <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">57</span>) &#123;<br>        textView.setBackgroundColor(<span class="hljs-number">0x66cccf00</span> + (pos - <span class="hljs-number">50</span>) * <span class="hljs-number">128</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pos % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        textView.setBackgroundColor(<span class="hljs-number">0xaaaaff55</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        textView.setBackgroundColor(<span class="hljs-number">0xcceeeeee</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法里，就是设置组件了。</p><p>postBindView 与 cellInited 的区别在于，postBindView 调用的时候，view 与 style 的渲染准备工作都完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postUnBindView</span><span class="hljs-params">(BaseCell cell)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，这个方法都不用做什么，除非你有什么需要取消的，比如网络请求，定时器。</p><p>自定义 View 还支持注解加反射的方式，原理是一样的，不过一个是直接调用，一个是使用反射来调用，我不太喜欢这种方式，就不介绍了。</p><h2 id="自定义-Model-开发组件"><a href="#自定义-Model-开发组件" class="headerlink" title="自定义 Model 开发组件"></a>自定义 Model 开发组件</h2><p>采用通用的 model 开发组件，只需要写 View 就可以了，然而需要在<strong>每次绑定数据的时候都要取原始 json 里解析一下字段</strong>。有时候一个业务方会<strong>有一些通用的业务字段定义</strong>，每个组件里<strong>重复解析会让代码显得冗余</strong>，因此也提供了注册自定义 model 的兼容模式开发组件。这个时候就需要写自定义 model 和自定义 View 两部分了。</p><p>自定义 Model 需要继承 BaseCell，可以实现下面的几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 解析数据业务数据，可以将解析值缓存到成员变量里 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseWith</span><span class="hljs-params">(JSONObject data)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/** 解析数据样式数据，可以将解析值缓存到成员变量里 */</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseStyle</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> JSONObject data)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/** 绑定数据到自定义 View */</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> V view)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/** 绑定数据到 View 之后，可选实现 */</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postBindView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> V view)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">/** 校验原始数据，检查组件的合法性 */</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>其中两个 parse 方法可以理解，但是两个 bind 方法感觉没啥作用啊，有啥通用的 bind 与 unbind 逻辑可以写在这里吗？当成一个切面好理解些。</p><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><p>想一下，Tangram 复用的粒度是 Card 还是 Cell？Card的作用是用来排列 Cell 的，所以它只是起了一个布局的作用，是一个虚拟的概念，在实际的绘制中根本不存在 Card 。所以粒度是 Cell。</p>]]></content>
    
    
    <categories>
      
      <category>Tangram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android源码解析-Tangram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0005-绑定数据</title>
    <link href="/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0005-%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE/"/>
    <url>/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0005-%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>前面一篇文章，对于 preview 方法，我们分析完了第一行代码，现在，我们继续分析设置数据的方法，做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">IContainer iContainer = (IContainer) mContainer;<br><span class="hljs-keyword">if</span> (jsonData != <span class="hljs-keyword">null</span>) &#123;<br>    iContainer.getVirtualView().setVData(jsonData);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的东西都看懂了的话，就知道这里的 mContainer 实际上是一个 Container 的实例，<code> iContainer.getVirtualView()</code>的值就是 VHLayout。这里设置了 json 数据。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setVData(java.lang.Object, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVData</span><span class="hljs-params">(Object data, <span class="hljs-keyword">boolean</span> isAppend)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= <span class="hljs-number">18</span>) &#123;<br>        Trace.beginSection(<span class="hljs-string">&quot;ViewBase.setVData&quot;</span>);<br>    &#125;<br>    mViewCache.setComponentData(data);<br>    <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> JSONObject) &#123;<br>        <span class="hljs-keyword">boolean</span> invalidate = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (((JSONObject) data).optBoolean(FLAG_INVALIDATE)) &#123;<br>            invalidate = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView();<br>        <span class="hljs-keyword">if</span> (cacheView != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cacheView.size(); i &lt; size; i++) &#123;<br>                ViewBase viewBase = cacheView.get(i);<br>                List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != items) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, length = items.size(); j &lt; length; j++) &#123;<br>                        Item item = items.get(j);<br>                        <span class="hljs-keyword">if</span> (invalidate) &#123;<br>                            item.invalidate(data.hashCode());<br>                        &#125;<br>                        item.bind(data, isAppend);<br>                    &#125;<br>                    viewBase.onParseValueFinished();<br>                    <span class="hljs-keyword">if</span> (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123;<br>                        mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure,<br>                                EventData<br>                                        .obtainData(mContext, viewBase));<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        ((JSONObject) data).remove(FLAG_INVALIDATE);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> com.alibaba.fastjson.JSONObject) &#123;<br>        <span class="hljs-keyword">boolean</span> invalidate = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (((com.alibaba.fastjson.JSONObject) data).getBooleanValue(FLAG_INVALIDATE)) &#123;<br>            invalidate = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView();<br>        <span class="hljs-keyword">if</span> (cacheView != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cacheView.size(); i &lt; size; i++) &#123;<br>                ViewBase viewBase = cacheView.get(i);<br>                List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != items) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, length = items.size(); j &lt; length; j++) &#123;<br>                        Item item = items.get(j);<br>                        <span class="hljs-keyword">if</span> (invalidate) &#123;<br>                            item.invalidate(data.hashCode());<br>                        &#125;<br>                        item.bind(data, isAppend);<br>                    &#125;<br>                    viewBase.onParseValueFinished();<br>                    <span class="hljs-keyword">if</span> (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123;<br>                        mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure,<br>                                EventData<br>                                        .obtainData(mContext, viewBase));<br>                    &#125;<br><br>                &#125;<br>            &#125;<br>        &#125;<br>        ((com.alibaba.fastjson.JSONObject) data).remove(FLAG_INVALIDATE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (VERSION.SDK_INT &gt;= <span class="hljs-number">18</span>) &#123;<br>        Trace.endSection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码稍微有点长，再仔细看一下，里面有两段逻辑，是差不多的，一段是针对 Android 自带的 JSONObject 处理的，一段是针对 <code>com.alibaba.fastjson.JSONObject</code> 处理的，为啥没有 Gson。</p><p>我们只分析其中一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView();<br><span class="hljs-keyword">if</span> (cacheView != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = cacheView.size(); i &lt; size; i++) &#123;<br>        ViewBase viewBase = cacheView.get(i);<br>        List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != items) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>, length = items.size(); j &lt; length; j++) &#123;<br>                Item item = items.get(j);<br>                <span class="hljs-keyword">if</span> (invalidate) &#123;<br>                    item.invalidate(data.hashCode());<br>                &#125;<br>                item.bind(data, isAppend);<br>            &#125;<br>            viewBase.onParseValueFinished();<br>            <span class="hljs-keyword">if</span> (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123;<br>                mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure,<br>                        EventData<br>                                .obtainData(mContext, viewBase));<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取缓存中的所有 ViewBase，然后对每一个 ViewBase 的 Item （也就是封装的属性类），都调用它的 bind 方法。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewCache.Item#bind</p><p>这个方法有点长，截取一段分析</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">case TYPE_INT:<br>    <span class="hljs-keyword">if</span> (value instanceof Number) &#123;<br>        Integer integer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Integer(<span class="hljs-params">value</span>)</span>;<br>        <span class="hljs-keyword">if</span> (integer != null) &#123;<br>            mView.set<span class="hljs-constructor">Attribute(<span class="hljs-params">mKey</span>, <span class="hljs-params">integer</span>.<span class="hljs-params">intValue</span>()</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>value 的值，是 Parser 解析出来的，里面就是从 json 里面取对应的字段值，懒得看了。拿到值之后，设置给 view。</p><p>这样，数据绑定就搞定了。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0006-事件处理</title>
    <link href="/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0006-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <url>/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0006-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>组件默认是不会响应事件的。想要组件响应事件，需要做如下类似设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">flag=&quot;flag_exposure|flag_clickable&quot;<br></code></pre></td></tr></table></figure><p>flag_exposure 表示组件曝光事件，源码中 <code>com.tmall.wireless.vaf.virtualview.event.EventManager#TYPE_Exposure</code> 表示曝光事件，看了调用的位置，一般都在 setData 的时候，有点奇怪。</p><p>flag_clickable 就是点击事件了。</p><p>当用户触摸了某个位置的时候，会触发下面的代码：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#click</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> isLong)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> clickRoute(mId, isLong);<br>&#125;<br></code></pre></td></tr></table></figure><p>或者下面的 layout 的方法：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.Layout#click</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">click</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">boolean</span> isLong)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> deal = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mSubViews.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        ViewBase v = mSubViews.get(i);<br>        <span class="hljs-keyword">int</span> l = v.getAbsoluteDrawLeft();<br>        <span class="hljs-keyword">int</span> t = v.getAbsoluteDrawTop();<br>        <span class="hljs-keyword">int</span> w = v.getComMeasuredWidth();<br>        <span class="hljs-keyword">int</span> h = v.getComMeasuredHeight();<br>        <span class="hljs-keyword">if</span> (x &gt;= l &amp;&amp; x &lt; (l + w) &amp;&amp; y &gt;= t &amp;&amp; y &lt;= t + h) &#123;<br>            deal = v.click(x, y, isLong);<br>            <span class="hljs-keyword">if</span> (deal) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!deal) &#123;<br>        deal = <span class="hljs-keyword">super</span>.click(x, y, isLong);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> deal;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，对于 layout 来说，如果 child 没有处理 click 事件的话，会自己处理。类比一下 View 与  ViewGroup 还是很容易理解的。</p><p>下面的分析流程走 ViewBase 的  click 方法。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#clickRoute</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">clickRoute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">boolean</span> isLong)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret;<br>    <span class="hljs-keyword">if</span> (isLong) &#123;<br>        ret = onLongClick(id);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ret = onClick(id);<br>    &#125;<br>    <span class="hljs-comment">//if (!ret &amp;&amp; null != mParent) &#123;</span><br>    <span class="hljs-comment">//    ret = mParent.clickRoute(mParent.mId, isLong);</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>以 onClick 为例：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#onClick</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onClick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mBean) &#123;<br>        mBean.click(id, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mClickCode) &#123;<br>        ExprEngine engine = mContext.getExprEngine();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != engine) &#123;<br>            engine.getEngineContext().getDataManager().replaceData(<br>                    getViewCache().getComponentData());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != engine &amp;&amp; engine.execute(<span class="hljs-keyword">this</span>, mClickCode)) &#123;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;onClick execute failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// isClickable 会判断是否设置了 flag_clickable 标志位</span><br>    <span class="hljs-keyword">if</span> (isClickable() &amp;&amp; isVisible()) &#123;<br>        ret = mContext.getEventManager().emitEvent(EventManager.TYPE_Click, EventData.obtainData(mContext, <span class="hljs-keyword">this</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里发送了一个消息。</p><p>点击事件的注册如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">sVafContext.getEventManager().register(EventManager.TYPE_Click, <span class="hljs-keyword">new</span> IEventProcessor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(EventData data)</span> </span>&#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;TYPE_Click data view:&quot;</span> + data.mView);<br>        Log.d(TAG, <span class="hljs-string">&quot;TYPE_Click view name:&quot;</span> + data.mVB.getTag(<span class="hljs-string">&quot;name&quot;</span>));<br>        Log.d(TAG, <span class="hljs-string">&quot;TYPE_Click view traceId:&quot;</span> + data.mVB.getTag(<span class="hljs-string">&quot;activityTraceId&quot;</span>));<br>        Toast.makeText(PreviewActivity.<span class="hljs-keyword">this</span>,<br>                <span class="hljs-string">&quot;TYPE_Click view name:&quot;</span> + data.mVB.getTag(<span class="hljs-string">&quot;name&quot;</span>)<br>                        + <span class="hljs-string">&quot;\n traceId:&quot;</span> + data.mVB.getTag(<span class="hljs-string">&quot;activityTraceId&quot;</span>), Toast.LENGTH_SHORT).show();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>可以看到，这里处理了消息， 只能统一处理。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0007-控件</title>
    <link href="/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0007-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2019/09/06/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0007-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>虚拟控件到底是如何工作的？它是如何直接绘制在 canvas 上的？</p><p>Tangram 提供的控件分为两类，一类以 Native 开头，表示实际上是基于原生控件实现的。一类以 Virtual 开头，表示这不是一个实际的控件。</p><p>这里分析两个控件，来加深对虚拟控件的理解。</p><h2 id="NativeText"><a href="#NativeText" class="headerlink" title="NativeText"></a>NativeText</h2><p>看它的构造函数，它里面封装了一个原生的控件：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.view.text.NativeText</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextBase</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> NativeTextImp mNative;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NativeText</span><span class="hljs-params">(VafContext context, ViewCache viewCache)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, viewCache);<br><br>        mNative = <span class="hljs-keyword">new</span> NativeTextImp(context.forViewConstruction());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 NativeTextImp 就是继承至 TextView 的。</p><p>Tangram 的控件都是继承至 ViewBase 的，而不是继承至 View。它们没有 view 的 onMeasure，onLayout，onDraw 等方法，而是有自己的一套方法：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.IView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onComMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onComLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>这两个方法就是自己的一套测量与布局逻辑，对于 Native 开头的控件来说，肯定是直接调用了封装的原生控件的方法：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.view.text.NativeText</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    mNative.onComMeasure(widthMeasureSpec, heightMeasureSpec);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    mNative.onComLayout(changed, l, t, r, b);<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于 Virtual 开头的控件来说，它里面没有封装原生控件，所以只能自己实现了，不过我们不用太担心，ViewBase 里有一个内部类 <code>com.tmall.wireless.vaf.virtualview.core.ViewBase.VirtualViewImp</code>，它实现了一些通用的逻辑，一般情况下，我们只需要使用它的方法就好了，看看 VirtualText 是如何做的：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.view.text.VirtualText</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextBase</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> VirtualViewImp mImp = <span class="hljs-keyword">new</span> VirtualViewImp();<br>    <br>        <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>        mImp.onComMeasure(widthMeasureSpec, heightMeasureSpec);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，用起来还是很方便的，VirtualText 没有子组件，所以不用实现 onComLayout 方法。</p><p>上面说了测量与布局，没有说绘制，是因为绘制有点特殊。还记得在容器添加组件的时候，是怎么做的么？</p><blockquote><p>com.tmall.wireless.vaf.virtualview.container.Container#attachViews(com.tmall.wireless.vaf.virtualview.core.ViewBase, android.view.View)</p><p>之前我们没有深入分析这个方法，只是简单的带过了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachViews</span><span class="hljs-params">(ViewBase view, View displayViewHolder)</span> </span>&#123;<br>    view.setDisplayViewContainer(displayViewHolder);<br>    <span class="hljs-keyword">if</span> (view <span class="hljs-keyword">instanceof</span> Layout) &#123;<br>        View v = view.getNativeView();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != v) &#123;<br>            <span class="hljs-keyword">if</span> (v.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                LayoutParams layoutParams = <span class="hljs-keyword">new</span> LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight);<br>                addView(v, layoutParams);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LayoutParams layoutParams = v.getLayoutParams();<br>                layoutParams.width = view.getComLayoutParams().mLayoutWidth;<br>                layoutParams.height = view.getComLayoutParams().mLayoutHeight;<br>                v.setLayoutParams(layoutParams);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> INativeLayoutImpl) &#123;<br>                Layout layout = (Layout) view;<br>                List&lt;ViewBase&gt; subViews = layout.getSubViews();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != subViews) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = subViews.size(); i &lt; size; i++) &#123;<br>                        ViewBase com = subViews.get(i);<br>                        ((INativeLayoutImpl) v).attachViews(com, v);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Layout layout = (Layout) view;<br>            List&lt;ViewBase&gt; subViews = layout.getSubViews();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != subViews) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = subViews.size(); i &lt; size; i++) &#123;<br>                    ViewBase com = subViews.get(i);<br>                    attachViews(com, displayViewHolder);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        View v = view.getNativeView();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != v) &#123;<br>            <span class="hljs-keyword">if</span> (v.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                LayoutParams layoutParams = <span class="hljs-keyword">new</span> LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight);<br>                addView(v, layoutParams);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LayoutParams layoutParams = v.getLayoutParams();<br>                layoutParams.width = view.getComLayoutParams().mLayoutWidth;<br>                layoutParams.height = view.getComLayoutParams().mLayoutHeight;<br>                v.setLayoutParams(layoutParams);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法看起来很长，但是表达的意思非常的简单：</p><ul><li>如果这个组件是以 Native 开头，这将这个组件封装的原生控件添加到容器里面</li><li>而对于不是以 Native 开头的，没有添加到容器里面，因为它根本就不是一个 view</li></ul><p>这里说的 Native 开头不太准确，但是比较好理解，应该说成是里面封装了一个原生控件的组件。</p><p>对于以 Native 开头的，既然添加到了容器里面，那么它的绘制，就都交给 ViewRootImpl 去处理了，不用我们关心。那么这里有一个问题，既然它会被添加到容器里面，我们可不可以不用去实现其测量与布局逻辑呢？反正都是由系统处理。这个肯定是不行的，因为虽然添加到容器中后，走的是系统的布局，但是<strong>它与容器中其他虚拟控件的相互位置等等</strong>，走的是自定义的那一套逻辑，所以还是要实现自定义的测量与布局。</p><h2 id="VirtualText"><a href="#VirtualText" class="headerlink" title="VirtualText"></a>VirtualText</h2><p>而对于非 Native 开头的，它没有被添加到容器里面，那么它是怎么显示出来的呢？其实就是直接画在容器上的 canvas 上的啦。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.container.Container#onDraw</p><p>如果有虚拟控件，需要调用 setWillNotDraw(false);，该方法才会执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mView &amp;&amp; mView.shouldDraw()) &#123;<br>        mView.comDraw(canvas);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 mView 就是模板文件的根 ViewBase 了。它调用了自己 comDraw 方法，参数是自己的 canvas，我们拿 VHLayout 举例：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.Layout#comDraw</p><p>VHLayout  继承 Layout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.comDraw(canvas);<br><br>    <span class="hljs-comment">//FIXME let layout clip virtual children</span><br>    <span class="hljs-comment">//canvas.save();</span><br>    <span class="hljs-comment">//VirtualViewUtils.clipCanvas(canvas, mMeasuredWidth, mMeasuredHeight, mBorderWidth,</span><br>    <span class="hljs-comment">//    mBorderTopLeftRadius, mBorderTopRightRadius, mBorderBottomLeftRadius, mBorderBottomRightRadius);</span><br>    <span class="hljs-comment">// draw children</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, size = mSubViews.size(); i &lt; size; i++) &#123;<br>        ViewBase v = mSubViews.get(i);<br>        <span class="hljs-keyword">if</span> (v.shouldDraw()) &#123;<br>            v.comDraw(canvas);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//canvas.restore();</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它调用了每个子组件的 comDraw 方法。这样一层一层绘制下去，我们拿 VirtualText 举例：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.view.text.VirtualText#onComDraw</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onComDraw(canvas);<br><br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == mContentRect) &#123;<br>           makeContentRect();<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mContentRect) &#123;<br>...<br><br>           canvas.save();<br>           canvas.clipRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mMeasuredWidth, mMeasuredHeight);<br>           canvas.drawText(mDrawText, left, top - mDescent, mPaint);<br>           canvas.restore();<br>      ...<br><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           Log.w(TAG, <span class="hljs-string">&quot;skip draw text&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这样 Text 就绘制出来了。</p><p>不过在绘制的时候，还有一个需要注意的地方：</p><p>子组件的画布需要变化一下，需要将绘制的位置，变换到布局的位置。</p><p>看看它是如何做的：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#comLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    mDrawLeft = l;<br>    mDrawTop = t;<br><br>    onComLayout(<span class="hljs-keyword">true</span>, l, t, r, b);<br>&#125;<br></code></pre></td></tr></table></figure><p>在子组件布局完成之后，保存了左上角的位置。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#comDraw</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">comDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    canvas.save();<br>    canvas.translate(mDrawLeft, mDrawTop);<br>    onComDraw(canvas);<br>    canvas.restore();<br>    mIsDrawed = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在绘制的时候，将画布平移了，这样一来，就不用子组件来操心了。</p><p>总结：</p><p>虚拟控件就是将测量，布局，绘制的逻辑封装在了一个普通的类X中，在依托容器显示的时候，容器中组件的测量，布局，绘制的逻辑，都走X类中的测量，布局，绘制的逻辑。</p><p>测量，布局逻辑是为了确定子组件在容器中画布的位置。</p><p>其实，把它想象成一个自定义控件就很好理解了。</p><p>当我们自定义一个比较复杂的控件时，通常会将这个控件分为好几部分。比如我们要绘制一个日历控件：</p><ul><li>我们可以将将年分当作容器，它可以用 RecyclerView 或者 ViewPager 来实现</li><li>将月份封装成一个类，它只需要确定当前月有多少天，以及每天的信息应该绘制在哪个位置 （这个玩意就相当于一个布局方法了），以及绘制边框</li><li>将天封装成一个类，它绘制每一天的信息</li></ul><p>对于月份来说，它不是一个 View，却相当于一个 ViewGroup，用于确定每一天的位置，然后平移画布。</p><p>对于天来说，它不是一个 View，却相当于一个 View，用于绘制某天的信息。</p><p>我们项目中的日历就是这么实现的，扩展性也不错。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-前言</title>
    <link href="/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0001-%E5%89%8D%E8%A8%80/"/>
    <url>/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0001-%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>本来按照顺序是应该先写 VLayout，再写 Tangram，最后才是 Virtualview。这是一个循序渐进的过程。由于我本身对 VLayout 有了一定的了解，所以我就直接看了 Tangram，发现源码阅读起来不算太难，就是写代码的风格看着有点蛋疼（我们装了阿里的 Java 规约插件，然后发现源码里全是警告线，这特么自己开发的内部都不用的吗）。当我根据文档一点一点的阅读完源码之后，本来以为就要结束的时候，才发现里面说的“虚拟控件”才是比较值得咀嚼的。</p><p>于是我又花了3天左右来啃这个东西，其中的艰辛…，唉，我太难了。</p><p>根据官方文档，对照源码，阅读完里面的核心内容之后，发现虚拟控件并没有那么的神奇，而且它有一些不足。</p><p>本系列就是将我在阅读的过程中，理解的，记录的，思考的东西整理出来。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-数据模板</title>
    <link href="/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0002-%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF/"/>
    <url>/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0002-%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>这一段本来应该是介绍 Tangram 才说的，但是为了说明模板的作用，这里还是需要简要的说明一下 Tangram 是做什么的。</p><p>首先，作为一个商城类应用，其首页的变动是非常频繁的，特别是在一些特殊的节日。按照一般的开发逻辑，在节日之前肯定是要发新版的，而且节日过了之后，又需要将界面改回来。如果一直发新版本的话，就效率太低了，更新频繁的话也很容易找骂。</p><p>一种解决方案就是使用 H5，但是性能会有问题。下面的片段来源于文档：</p><blockquote><p>最初我们看重动态性，在HTML框架和发布工具上做了大量的文章。我们可以快速开发出一张HTML页面，并推送到端上，而且通过Hybrid接口还能与Native进行交互。然而在大规模（双11）应用的过程中我们很快发现了问题——性能。当时我们认为WebView的性能是HTML页面的瓶颈，现在还不是大规模推广HTML的时候，我们需要一套替代方案。</p></blockquote><p>H5 暂时不可行，那么还是只能在原生页面上想办法了（下面的内容，还是来源于文档，建议去看官方文档）。</p><p>从业务的角度来说，带界面的业务基本分三种：</p><ol><li>临时性业务——比如活动，几张页面生命周期可能2周，1周，甚至一两天。数量多，需求频繁，有可沉淀的东西，但变化更多。对极致性能不敏感。</li><li>常规业务——比如频道，生命周期长，需要长期维护。数量有限，需求稳定，沉淀性好。对极致性能相当敏感。</li><li>基础业务——跟常规业务相比需求稳定性更高，对性能和稳定性有极高的要求。</li></ol><p>对于第<strong>1</strong>型，我们认为未来一定属于HTML，随着WebView性能的提升和Mobile开发框架与开发技能日趋成熟，现阶段HTML体现出的劣势终将荡然无存。</p><p>而第<strong>2</strong>型和第<strong>3</strong>型是值得我们去思考的，结合我们团队所负责的业务形态，我们结合多年在业务上的经验制定了以<strong>粗粒度组件化+灵活布局容器</strong>为基本理念的界面解决方案。</p><p><strong>以 Tangram View 作为根节点，具备滚动能力；页面的子节点为布局容器，每行一个容器，向下单行排列；布局容器中按照各自的布局规则，在其内对任意组件进行排列。</strong></p><p>这里说的比较抽象，我举一个例子：</p><p>我们写一个 MainActivity，其布局长这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/container&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看出，这里布局里面其实什么都没有，那么这个时候，我想要让界面显示出东西出来，怎么办呢？有两种方法：</p><ul><li>动态的创建控件</li><li>动态的加载布局</li></ul><p>动态的创建控件显然难度太高了，特别是复杂的布局，很是蛋疼。动态的加载布局，是可以的，但是解析 XML 太慢了，可以优化一下不？这里参照了 Google 的思路，Android Studio 在打包 APK 的时候，会将 XML 文件编译为二进制文件，它不仅仅减小了体积，而且在解析文件的时候，会更加快速。</p><p>这样思考的话，一个可以动态更改布局的方法就有了雏形：将布局文件编译为二进制文件，上传到服务器，客户端下载，界面启动的时候，动态加载最新版本的布局。</p><p>理解了上面的话，我们再来看看 Tangram 的模板是什么东西。</p><h2 id="模板是什么"><a href="#模板是什么" class="headerlink" title="模板是什么"></a>模板是什么</h2><p>模板其实就是上面说说的二进制布局文件，不过这个二进制文件不是 Android Studio 编译 xml 文件之后生成的，而是 alibaba 有自己的一套工具，用来生成二进制文件。</p><p>这个二进制文件有自己的格式，具体可以参考官方文档，这里只贴一个图，后面的源码部分会经常用到这个图：</p><p><img src="https://gw.alicdn.com/tfs/TB1H9.tg8fH8KJjy1XbXXbLdXXa-1270-300.jpg"></p><h2 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h2><p>我们刚开始接触 Android 的时候，也需要学习如何编写一个界面，需要熟悉每个控件是做什么的。对于 Tangram 也是如此，它有一套自己的控件（虽然也是使用的原生控件实现的），所以我们也需要先熟悉一下这些控件，控件的介绍在：</p><ul><li><a href="http://tangram.pingguohe.net/docs/virtualview/atom-elements">http://tangram.pingguohe.net/docs/virtualview/atom-elements</a></li><li><a href="http://tangram.pingguohe.net/docs/virtualview/container-elements">http://tangram.pingguohe.net/docs/virtualview/container-elements</a></li></ul><p>这里举一个简单的例子：</p><blockquote><p>TextTest.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">VHLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">orientation</span>=<span class="hljs-string">&quot;V&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;#008899&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;$&#123;height&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Title: text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textColor</span>=<span class="hljs-string">&quot;#333333&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textSize</span>=<span class="hljs-string">&quot;12&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">VHLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看出来，与 Android XML 布局的差别不大，还很简洁。其中使用到的属性的意思也很明了，有不清楚的可以参考文档：</p><ul><li><a href="http://tangram.pingguohe.net/docs/virtualview/elements">http://tangram.pingguohe.net/docs/virtualview/elements</a></li></ul><h2 id="模板编译工具的使用"><a href="#模板编译工具的使用" class="headerlink" title="模板编译工具的使用"></a>模板编译工具的使用</h2><p>模板写好了之后，我们就可以编译该模板文件为二进制文件了。</p><p>首先需要下载编译工具，工具下载地址在：<a href="https://github.com/alibaba/virtualview_tools">https://github.com/alibaba/virtualview_tools</a></p><p>使用 git clone 下来之后：</p><ul><li><p>切到 <code>virtualview_tools\compiler-tools\TemplateWorkSpace</code> 目录下</p></li><li><p>在 template 目录下，创建 TextTest.xml 模板文件</p></li><li><p>打开 templatelist.properties，增加一行  TextTest=Test,1</p><p>说一下格式</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">格式 <span class="hljs-attr">xmlFileName=</span>outFileName,<span class="hljs-keyword">Version</span>[,platform]<br><br>xmlFileName 标识 template 目录下需要编译的 <span class="hljs-keyword">xml</span> <span class="hljs-title">文件名建议不带 .xml</span> 后缀，目前做了兼容<br><br>outFileName 输出到 build 目录下的 .out 文件名，这个 outFileName 会编译到二进制文件中，需要是唯一的，可以理解为模板的 ID<br><br><span class="hljs-keyword">Version</span> 表示 <span class="hljs-keyword">xml</span> <span class="hljs-title">编译后的版本号，看上面的模板文件结构图，模板文件可以有主版本号，次版本号，修订版本号，经过测试这个版本号表示 的是修订版本号，从源码上来看主版本号与次版本号似乎是固定的</span><br><span class="hljs-title"></span><br><span class="hljs-title">platform</span> 同时兼容 iOS 和 android 时不写，可填的值为 android 和iphone<br></code></pre></td></tr></table></figure></li><li><p>打开 git bash，执行 <code>sh buildTemplate.sh</code> 命令</p></li><li><p>就会在 build 目录下生成相应的文件了</p></li></ul><p>项目地址里面有中文文档，虽然不是非常的详细，但是也大致看的懂。</p><p>编译工具还提供了实时预览的效果，由于我只是想看源码，所以并没有尝试这个效果，有兴趣的可以自己试试实时预览，写复杂的布局肯定需要用到。</p><p>查看说明文档，还会发现，编译器支持增加自定义属性，我没试过就不说了，但是我大致知道它是如何工作的，我们后面会说源码，所以如果你都能看懂，这个自定义属性也就自然懂了 。</p><p>执行完 buildTemplate 命令之后，我们进入 build 目录，里面有几个目录需要关注：</p><ul><li>out目录：XML 模板编译成二进制数据的文件，其他内容都是以此为基础生成，上传到 cdn，通过模板管理后台下发的也是这里的文件；</li><li>java目录：XML 模板编译成二进制数据之后的 Java 字节数组形式，可以直接拷贝到 Android 开发工程里使用，作为打底数据；</li><li>sign目录：out 格式文件的 md5 码，供模板管理平台下发模板给客户端校验使用；</li><li>txt目录：XML 模板编译成二进制数据之后的十六进制字符串形式，转换成二进制数据就是 java 目录下的字节数组</li></ul><p>我们打开 build\java 目录，找到生成的 TEST.java 文件，打开后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TEST</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] BIN = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[] &#123;<br><span class="hljs-number">65</span>, <span class="hljs-number">76</span>, <span class="hljs-number">73</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">47</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">122</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">87</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">51</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">47</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">84</span>, <span class="hljs-number">101</span>, <span class="hljs-number">115</span>, <span class="hljs-number">116</span>, <span class="hljs-number">0</span>, <span class="hljs-number">110</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">86</span>, <span class="hljs-number">50</span>, -<span class="hljs-number">11</span>, -<span class="hljs-number">48</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">47</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">108</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">48</span>, <span class="hljs-number">92</span>, -<span class="hljs-number">43</span>, -<span class="hljs-number">16</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">119</span>, <span class="hljs-number">112</span>, -<span class="hljs-number">84</span>, -<span class="hljs-number">68</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">60</span>, <span class="hljs-number">45</span>, <span class="hljs-number">58</span>, -<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">47</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">108</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">48</span>, -<span class="hljs-number">80</span>, -<span class="hljs-number">104</span>, <span class="hljs-number">85</span>, <span class="hljs-number">46</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">120</span>, -<span class="hljs-number">103</span>, <span class="hljs-number">119</span>, <span class="hljs-number">112</span>, -<span class="hljs-number">84</span>, -<span class="hljs-number">68</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">64</span>, -<span class="hljs-number">101</span>, <span class="hljs-number">46</span>, <span class="hljs-number">54</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">51</span>, <span class="hljs-number">51</span>, <span class="hljs-number">51</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">92</span>, -<span class="hljs-number">43</span>, -<span class="hljs-number">16</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">87</span>, -<span class="hljs-number">65</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">54</span>, <span class="hljs-number">69</span>, <span class="hljs-number">45</span>, <span class="hljs-number">82</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">117</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">82</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">15</span>, -<span class="hljs-number">117</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">84</span>, <span class="hljs-number">105</span>, <span class="hljs-number">116</span>, <span class="hljs-number">108</span>, <span class="hljs-number">101</span>, <span class="hljs-number">58</span>, <span class="hljs-number">32</span>, <span class="hljs-number">116</span>, <span class="hljs-number">101</span>, <span class="hljs-number">120</span>, <span class="hljs-number">116</span>, -<span class="hljs-number">14</span>, -<span class="hljs-number">87</span>, -<span class="hljs-number">65</span>, <span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">36</span>, <span class="hljs-number">123</span>, <span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">105</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">116</span>, <span class="hljs-number">125</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面就只有一个 byte 数组，里面个每个数都表示一个字节。</p><p>我们再打开 build\out 目录，找到生成的 TEST.out 文件，用十六进制编辑器查看，如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/1.png?raw=true"></p><p>看前面5个字节，表示的就是 ALIVV，这个就是模板文件结构表的固定开头。将图中的十六进制换成数字，就是与 TEST.java 文件中的字节数组是一一对应的。</p><p>看了这些东西，总结出一句话，那就是<strong>这个二进制数组就表示的是一个布局</strong>，所以这个文件叫做模板文件。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003-模板编译与解析</title>
    <link href="/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0003-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E6%9E%90/"/>
    <url>/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0003-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>PS： 为了方便记录，将编译与解析合并</p></blockquote><p>官方文档的这一篇叫做“组件编译”，我看了文档，发现这里的组件的意思应该是“控件”。为了阅读的流畅性，所以这里我就改名为模板编译，其实最终还是编译的一个一个的布局控件。</p><p>既然要将一个xml文件编译成二进制文件，最后还要能够解析出来，那么我们需要解决一些问题，还是拿之前的 xml 文件来说：</p><blockquote><p>TextTest.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">VHLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">orientation</span>=<span class="hljs-string">&quot;V&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;#008899&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;$&#123;height&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Title: text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textColor</span>=<span class="hljs-string">&quot;#333333&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textSize</span>=<span class="hljs-string">&quot;12&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">VHLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先，VHLayout 这些控件的名字怎么储存？</p><p>然后属性名怎么储存？</p><p>属性值怎么储存？</p><blockquote><p>属性值分为多种，一般的颜色、数值子类的简单，可以字节作为整数存起来，但是像 text 属性，一般是一个字符串，该怎么储存呢？</p><p>还有像 layoutWidth 这样的，可以写 200 这样的数值，也可以写 match_parent，这个又该如何处理？</p></blockquote><p>模板还支持逻辑表达式，这个表达式又该怎么储存？</p><p>我们先来看官方文档的说明，然后一个一个来对照源码进行解析。</p><ul><li>颜色：转换成4字节整型颜色值，格式 AARRGGBB；</li><li>枚举：按照预定义的整数转换，比如 gravity 的类型，orientation 的类型…</li><li>基础组件的类型：按照预定义的整数转换，内置基础组件的类型从 1 开始分配，自定义组件建议从 1000 开始分配，后续可能语义化成字符串类型定义，对用户隐藏这些细节；</li><li>字符串：以 hashCode 值作为它的序列化后整数，并在字符串资源区建立以 hashCode 为索引的列表，在解析的时候从中获取原始的字符串值；</li><li>逻辑表达式：与字符串的处理类似；</li></ul><p>上面说，对于颜色值，是字节储存的，因为颜色值也是 4 个字节组成的，转成二进制都不用改的。在上面的例子种，我们设置的颜色值是 <code>#008899</code>，前面的“#”，我们不需要，只需要后面的“008899”，直接放入二进制文件中。为了验证猜想，我们查看二进制文件，看看有没有 <code>00 88 99</code> 3个直接是挨着的。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/2.png?raw=true"></p><p>肯定是有的。</p><p>我们再来看源码，是如何解析这个值的。</p><h2 id="加载模板文件"><a href="#加载模板文件" class="headerlink" title="加载模板文件"></a>加载模板文件</h2><p>一个模板编译好了之后，我们可以直接使用，也可以让服务器下发。这里介绍直接使用的方式。按照官方文档的实例，是在 Application 中加载的模板文件，应该也是可以在别的地方加载的。代码如下：</p><blockquote><p>com.aprz.virtualviewdemo.MyApp#onCreate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sViewManager.loadBinBufferSync(TEST.BIN);<br></code></pre></td></tr></table></figure><p>这里传入的参数，就是模板文件的二进制数据数组了。既然加载了数组，肯定需要解析出来使用，我们可以顺着这里路径点击去，最后就到了下面的代码：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean)</p><p>这坨方法，还是非常长的，但是不难，我们一点一点分析啊。</p><p>如果你能对着模板文件结构图来看这段代码，简直不要太简单了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadFromBuffer</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] buf, <span class="hljs-keyword">boolean</span> override)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != buf) &#123;<br>        mDepPageIds = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">if</span> (buf.length &gt; <span class="hljs-number">27</span>) &#123;<br>            <span class="hljs-comment">// check tag</span><br>            <span class="hljs-keyword">byte</span>[] tagArray = Arrays.copyOfRange(buf, <span class="hljs-number">0</span>, Common.TAG.length());<br>            <span class="hljs-keyword">if</span> (Arrays.equals(Common.TAG.getBytes(), tagArray)) &#123;<br>                ...<br></code></pre></td></tr></table></figure><p>Common.TAG 就是 “ALIVV”，这个固定标识是用来验证是否是模板文件的。总不能随便给一个二进制文件，就开始解析吧。最后的 if 判断就是用来判断前 5 个字节是否为 “ALIVV”表示的字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">CodeReader reader = <span class="hljs-keyword">new</span> CodeReader();<br><br>reader.setCode(buf);<br>reader.seekBy(Common.TAG.length());<br><br><span class="hljs-comment">// check version</span><br><span class="hljs-keyword">int</span> majorVersion = reader.readShort();<br><span class="hljs-keyword">int</span> minorVersion = reader.readShort();<br><span class="hljs-keyword">int</span> patchVersion = reader.readShort();<br>reader.setPatchVersion(patchVersion);<br></code></pre></td></tr></table></figure><p>这一段，逻辑也很清晰，跳过固定标识，依次读取 主版本号，次版本号，修订版本号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((Common.MAJOR_VERSION == majorVersion) &amp;&amp; (Common.MINOR_VERSION == minorVersion)) &#123;<br>    <span class="hljs-keyword">int</span> uiStartPos = reader.readInt();<br>    reader.seekBy(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">int</span> strStartPos = reader.readInt();<br>    reader.seekBy(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">int</span> exprCodeStartPos = reader.readInt();<br>    reader.seekBy(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">int</span> extraStartPos = reader.readInt();<br>    reader.seekBy(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>当主版本号为1，并且次版本号为0的时候，才会走里面的逻辑。这里就可以看出来，主版本号与次版本号不是我们可以更改的，应该是编译的时候生成的固定值。我们只能设置修订版本号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> pageId = reader.readShort();<br><br><span class="hljs-keyword">int</span> depPageCount = reader.readShort();<br><span class="hljs-keyword">if</span> (depPageCount &gt; <span class="hljs-number">0</span>) &#123;<br>    mDepPageIds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[depPageCount];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; depPageCount; ++i) &#123;<br>        mDepPageIds[i] = reader.readShort();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是记录该模板的依赖，没搞懂，而且源码里面标记为过时了，查看源码也没有用到的地方，就当做没有这几行代码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (reader.seek(uiStartPos)) &#123;<br>    <span class="hljs-comment">// parse ui codes</span><br>    <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (!override) &#123;<br>        result = mUiCodeLoader.loadFromBuffer(reader, pageId, patchVersion);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = mUiCodeLoader.forceLoadFromBuffer(reader, pageId, patchVersion);<br>    &#125;<br></code></pre></td></tr></table></figure><p>定位到组件区的起始位置（不明白的回去查看模板文件二进制格式图）。然后就可以开始读取组件（控件）信息了。UiCodeLoader 里面的逻辑咱们不深入了，留到下面说，这里先把外面的逻辑走完，有个大致的理解。可以猜想一下，UiCodeLoader  肯定是解析控件信息了，将解析控件的代码封装为了一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// parse string</span><br><span class="hljs-keyword">if</span> (reader.getPos() == strStartPos) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mStringLoader) &#123;<br>        result = mStringLoader.loadFromBuffer(reader, pageId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;mStringManager is null&quot;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;string pos error:&quot;</span> + strStartPos + <span class="hljs-string">&quot;  read pos:&quot;</span> + reader.getPos());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据模板文件二进制格式图可以看出来，组件解析完了之后，就是字符串区了，这里就是解析字符串了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// parse expr</span><br><span class="hljs-keyword">if</span> (reader.getPos() == exprCodeStartPos) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mExprCodeLoader) &#123;<br>        result = mExprCodeLoader.loadFromBuffer(reader, pageId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;mExprCodeStore is null&quot;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;expr pos error:&quot;</span> + exprCodeStartPos + <span class="hljs-string">&quot;  read pos:&quot;</span> + reader.getPos());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// load extra data</span><br><span class="hljs-keyword">if</span> (reader.getPos() == extraStartPos) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (BuildConfig.DEBUG) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;extra pos error:&quot;</span> + extraStartPos + <span class="hljs-string">&quot;  read pos:&quot;</span> + reader.getPos());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析表达式，与解析额外数据，但是这里没有对额外数据做处理，也没有提供可覆盖的方法，有点奇怪。</p><p>总结一下，<code>com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean)</code>这个方法就是照着模板二进制文件解析出来了里面的所有详细，为实例化出控件做准备。</p><h2 id="UiCodeLoader"><a href="#UiCodeLoader" class="headerlink" title="UiCodeLoader"></a>UiCodeLoader</h2><p>前面，我们没有深入控件解析的逻辑，这里就仔细说说。上面我们分析到了：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBuffer</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">loadFromBuffer</span><span class="hljs-params">(CodeReader reader, <span class="hljs-keyword">int</span> pageId, <span class="hljs-keyword">int</span> patchVersion)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">int</span> count = reader.readInt();<br>    <span class="hljs-comment">//count should be 1</span><br>    <span class="hljs-keyword">short</span> nameSize = reader.readShort();<br>    String name = <span class="hljs-keyword">new</span> String(reader.getCode(), reader.getPos(), nameSize, Charset.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    CodeReader oldCodeReader = mTypeToCodeReader.get(name);<br>    <span class="hljs-keyword">if</span> (oldCodeReader != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">int</span> oldPatchVersion = oldCodeReader.getPatchVersion();<br>        <span class="hljs-keyword">if</span> (patchVersion &lt;= oldPatchVersion) &#123;<br>            <span class="hljs-comment">//avoid loading code repeat</span><br>            Log.w(TAG, <span class="hljs-string">&quot;load view name &quot;</span> + name + <span class="hljs-string">&quot; should not override from &quot;</span> + patchVersion + <span class="hljs-string">&quot; to &quot;</span><br>                + patchVersion);<br>            ret = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>    ret = loadFromBufferInternally(reader, nameSize, name);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>说一下，只要是 loader 里面的逻辑，基本都是在解析二进制文件，搞各种 readInt ，readShort 之类的，所以一定要对着二进制结构图看。</p><p>它先读取了一个 count，但是它没有用到这个值，额，牛逼，只是加了一句注释，count应该为1 。我们看结构图，发现这个count值表示的是组件的个数，也就是说这个组件个数应该为1 。那么应该代表的是根布局，如果我写两个会怎么样呢？比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">VHLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">orientation</span>=<span class="hljs-string">&quot;V&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;#008899&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;$&#123;height&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Title: text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textColor</span>=<span class="hljs-string">&quot;#333333&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textSize</span>=<span class="hljs-string">&quot;12&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">VHLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">VHLayout</span></span><br><span class="hljs-tag"><span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">orientation</span>=<span class="hljs-string">&quot;V&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;#002299&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;flag_exposure|flag_clickable&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutHeight</span>=<span class="hljs-string">&quot;$&#123;height&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layoutWidth</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;Title: text-------------------------&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textColor</span>=<span class="hljs-string">&quot;#333333&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">textSize</span>=<span class="hljs-string">&quot;12&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">VHLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实际上，还是只显示了第一个 VHLayout，而且编译之后的二进制文件里面 count 依然是 1 。猜想是编译器只处理了第一个根节点。</p><p>继续往下分析，读取了模板的 name，就是我们在 templatelist.properties 里面设置的值。以我们的例子来说，这个 name 就是 “TEST”。</p><p>再接着就是判断补丁值，根据逻辑可以知道，修订版本值不能降低，否则就会忽略。继续深入代码调用：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBufferInternally</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">loadFromBufferInternally</span><span class="hljs-params">(CodeReader reader, <span class="hljs-keyword">short</span> nameSize, String name)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br>    mTypeToCodeReader.put(name, reader);<br>    reader.seekBy(nameSize);<br><br>    <span class="hljs-keyword">short</span> uiCodeSize = reader.readShort();<br>    mTypeToPos.put(name, reader.getPos());<br>    <span class="hljs-keyword">if</span> (!reader.seekBy(uiCodeSize) ) &#123;<br>        ret = <span class="hljs-keyword">false</span>;<br>        Log.e(TAG, <span class="hljs-string">&quot;seekBy error:&quot;</span> + uiCodeSize);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 name 与 reader 对应着储存起来，以后需要的时候可以直接获取，避免重复创建。将 name 与 pos 对应着储存起来，这个表示 reader 读取到了什么位置。这个 pos 非常的重要，这个 pos 表示的是组件区的<strong>组件数据</strong>开始的位置，<strong>组件数据里面都是储存的组件的属性值</strong>。</p><p>就没有其他的逻辑了，总结一下，UiCodeLoader 做了这些事情：</p><blockquote><p>读取了每个模板的 name，为每个模板都保存了对应的 CodeReader 实例（根据 name 获取），还记录了 CodeReader 读取到了哪个位置。</p></blockquote><h2 id="StringLoader"><a href="#StringLoader" class="headerlink" title="StringLoader"></a>StringLoader</h2><p>上面处理完了组件区，接着就该字符串区了。看如下代码：</p><blockquote><p>com.tmall.wireless.vaf.virtualview.loader.StringLoader#loadFromBuffer</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">loadFromBuffer</span><span class="hljs-params">(CodeReader reader, <span class="hljs-keyword">int</span> pageId)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">// pageId 是页面编码</span><br>    mCurPage = pageId;<br><br>    <span class="hljs-keyword">int</span> totalSize = reader.getMaxSize();<br>    <span class="hljs-comment">// 字符串的个数</span><br>    <span class="hljs-keyword">int</span> count = reader.readInt();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br>        <span class="hljs-comment">// 字符串索引</span><br>        <span class="hljs-keyword">int</span> id = reader.readInt();<br>        <span class="hljs-comment">// 字符串长度</span><br>        <span class="hljs-keyword">int</span> len = reader.readShort();<br>        <span class="hljs-keyword">int</span> pos = reader.getPos();<br>        <span class="hljs-keyword">if</span> (pos + len &lt;= totalSize) &#123;<br>            <span class="hljs-comment">// 解析出字符串</span><br>            String str = <span class="hljs-keyword">new</span> String(reader.getCode(), reader.getPos(), len);<br>            <span class="hljs-comment">// 与id对应储存起来，可以根据id拿到string，也可以根据string拿到id</span><br>            mIndex2String.put(id, str);<br>            mString2Index.put(str, id);<br>            reader.seekBy(len);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;read string over&quot;</span>);<br>            ret = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的代码里面，其逻辑注释说的很详细了。</p><p>需要注意的是，id 表示字符串的唯一标识，这个唯一标识，很重要，应该是编译的时候自动生成的一个数，先记住这个唯一标识。</p><p>上面我们说过，像 title=“Hello”这样的属性值，“Hello”就是作为字符串储存的，所以这里就可以将“Hello”给提取出来，id 就是 3556653。</p><p>总结一下：</p><blockquote><p>StringLoader 就是将字符串区的字符串读取出来了，然后储存了id与string。</p></blockquote><h2 id="ExprCodeLoader"><a href="#ExprCodeLoader" class="headerlink" title="ExprCodeLoader"></a>ExprCodeLoader</h2><p>这个 loader，我还没深入的去看，暂时就不说了。</p><p>说一个我发现的东西，例子中，我们使用了数据绑定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">layoutHeight=&quot;$&#123;height&#125;&quot;<br></code></pre></td></tr></table></figure><p>这个 “${height}” 是储存在字符串区的。</p><p>说了这么多 loader，其实最核心的东西还没有涉及到，不是不愿意讲，而是这部分代码的逻辑在实例化控件的位置，我们下篇再讲。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0027-栈的应用之四则表达式</title>
    <link href="/2019/09/04/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0027-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%9B%9B%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2019/09/04/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0027-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%9B%9B%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>四则表达式大家应该都知道如何取计算，有个口诀：</p><blockquote><p>先乘除，后加减，从左算到右，先括号内再括号外。</p></blockquote><p>看下面的这个表达式：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">9 </span>+ (<span class="hljs-number">3</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">3</span> + <span class="hljs-number">10</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>这个表达式，让我们来算，非常的简单。但是让计算机来计算呢，就比较麻烦了。因为计算机不会口诀，它不知道应该先计算括号里面的。</p><p>那么如何才能让计算机计算四则表达式呢？在 20 世纪 50 年代，一个波兰逻辑学家（名字太长，就不打了）发明了一种后缀表达式（逆波兰表达式）。这种后缀表达式是一种全新的显示方式，非常巧妙的解决了程序实现四则运算的问题。</p><p>对于上面的那个四则表达式，它的后缀表达式如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">四则表达式<br>9 + (3 - 1) *<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 10 </span>/ 2<br>后缀表达式：<br>9<span class="hljs-number"> 3 </span>1 -<span class="hljs-number"> 3 </span>* +<span class="hljs-number"> 10 </span>2 / +<br></code></pre></td></tr></table></figure><p>之所以叫后缀表达式，是因为符号在要运算数字的后面出现。</p><h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><p>有了后缀表达式，我们需要理解它是如何工作的，先来说一段规则：</p><blockquote><p>从左到右遍历表达式的每个数字与符号，遇到数字就进栈，遇到符号，就出栈两个数字，然后进行运算，将运算的结果进栈，一直遍历完毕，最后栈内的就是计算结果。</p></blockquote><p>看下面的这个例子：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">后缀表达式：<br>9<span class="hljs-number"> 3 </span>1 -<span class="hljs-number"> 3 </span>* +<span class="hljs-number"> 10 </span>2 / +<br></code></pre></td></tr></table></figure><ol><li><p>创建一个空栈，遍历表达式，前3个都是数字，直接进栈：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-1.png?raw=true"></p></li><li><p>接下来遇到了 “-”，从栈里面取两个运算数字，第一个是减数，第二个是被减数，即（3 - 1），然后将结果 2 进栈:</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-2.png?raw=true"></p></li><li><p>接着是数字 3 进栈</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-3.png?raw=true"></p></li><li><p>接着是遇到了 “*”，同样从栈里面取出两个数字，计算（2 * 3），将结果 6 放入栈中，然后，又遇到了 “+”，从栈里面取出两个数字，计算（9 + 6），将结果 15 放入栈中：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-4.png?raw=true"></p></li><li><p>接着是，10 与 2 进栈，然后是遇到 “/”，计算（10 / 2），将 5 进栈。最后遇到 “+”，计算 （15 + 5），将 20 进栈。20 就是计算结果。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-5.png?raw=true"></p></li></ol><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>前面我们说了，后缀表达式对于程序来说，很好描述，但是如果没有一个方法很容易的将中缀表达式转成后缀表达式的话，后缀表达式毫无意义。</p><p>所以这里介绍中缀表达式转后缀表达式的规则：</p><ul><li>从左到右遍历中缀表达式</li><li>遇到数字直接输出</li><li>遇到左括号进栈</li><li>遇到右括号，需要将栈内元素出栈，直到左括号出栈</li><li>遇到符号需要对于栈顶元素<ul><li>如果栈为空，进栈</li><li>如果栈顶为左括号，进栈</li><li>将栈顶元素依次出栈，直到遇到比该符号的优先级低的符号。</li></ul></li></ul><p>还是上面的例子【9 + (3 - 1) * 3 + 10 / 2】，用图来描述一遍：</p><ol><li><p>初始化一个空栈，开始遍历，第一个是数字 9 ，直接输出，然后是符号 “+”，进栈</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-6.png?raw=true"></p><p>此时表达式为：9</p></li><li><p>左括号未配对，直接进栈，3直接输出，“-”进栈，1直接输出，遇到右括号需要将栈里面的元素输出，直到左括号出栈</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-7.png?raw=true"></p><p>此时表达式为：9 3 1 - </p></li><li><p>遇到 “*” 号，比栈顶元素的优先级高，进栈，输出 3</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-8.png?raw=true"></p><p>此时表达式为：9 3 1 - 3</p></li><li><p>遇到 “+”号，将 “*”出栈，将“+”出栈，将这个“+”号进栈，输出表达式为 ：，然后是输出 10，将“/”进栈，</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-9.png?raw=true"></p><p>此时表达式为：9 3 1 - 3 * + 10</p></li><li><p>输出 “2”，将 “/”，“+” 出栈</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-9-10.png?raw=true"></p><p>此时表达式为：9 3 1 - 3 * + 10 2 / +</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>先定义操作符数据结构，因为涉及到优先级比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Operator</span> </span>&#123;<br><br>    PLUS(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-number">1</span>), MINUS(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">1</span>), MUl(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-number">2</span>), DIV(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>), LEFT_BRACKET(<span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-number">3</span>), RIGHT_BRACKET(<span class="hljs-string">&quot;)&quot;</span>, <span class="hljs-number">3</span>);<br><br>    String symbol;<br>    <span class="hljs-keyword">int</span> priority;<br><br>    Operator(String s, <span class="hljs-keyword">int</span> priority) &#123;<br>        <span class="hljs-keyword">this</span>.symbol = s;<br>        <span class="hljs-keyword">this</span>.priority = priority;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lessOrEqual</span><span class="hljs-params">(Operator operator)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.priority &lt;= operator.priority;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operator <span class="hljs-title">get</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        Operator[] values = Operator.values();<br>        <span class="hljs-keyword">for</span> (Operator operator : values) &#123;<br>            <span class="hljs-keyword">if</span> (operator.symbol.equals(s)) &#123;<br>                <span class="hljs-keyword">return</span> operator;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后开始想法子计算表达式，分为几个步骤。</p><ol><li><p>将字符串表达式分解开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] splitExpr(String expr) &#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    expr = expr.replaceAll(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>   <br>    <span class="hljs-keyword">int</span> length = expr.length();<br>   <br>    <span class="hljs-comment">// 用来储存数字</span><br>    StringBuilder builder = <span class="hljs-keyword">null</span>;<br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>   <br>        String c = expr.substring(i, i + <span class="hljs-number">1</span>);<br>   <br>        <span class="hljs-comment">// 遇到符号，需要先判断将 builder 里面储存的数字添加到集合，然后将符号添加到集合</span><br>        <span class="hljs-keyword">if</span> (isSymbol(c)) &#123;<br>            <span class="hljs-keyword">if</span> (builder != <span class="hljs-keyword">null</span>) &#123;<br>                result.add(builder.toString());<br>                builder = <span class="hljs-keyword">null</span>;<br>            &#125;<br>            result.add(c);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNumber(c)) &#123;<br>            <span class="hljs-comment">// 遇到数字就将数字添加到 builder，避免多位数字问题</span><br>            <span class="hljs-keyword">if</span> (builder == <span class="hljs-keyword">null</span>) &#123;<br>                builder = <span class="hljs-keyword">new</span> StringBuilder();<br>            &#125;<br>            builder.append(c);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;表达式有问题&quot;</span>);<br>        &#125;<br>   <br>    &#125;<br>   <br>    <span class="hljs-keyword">if</span> (builder != <span class="hljs-keyword">null</span>) &#123;<br>        result.add(builder.toString());<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将表达式分解之后，可以执行中缀转后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String[] midToEnd(String expr) &#123;<br>   <br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>   <br>    <span class="hljs-comment">// 先将表达式分解出来</span><br>    String[] array = splitExpr(expr);<br>    Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>   <br>    String pop;<br>   <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        String s = array[i];<br>        <span class="hljs-keyword">if</span> (isNumber(s)) &#123;<br>            <span class="hljs-comment">// 数字直接输出</span><br>            result.add(s);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOperator(s)) &#123;<br>            <span class="hljs-comment">// 符号将栈顶优先级高于或等于的依次出栈</span><br>            Operator operator;<br>            Operator top;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; isOperator(stack.peek())) &#123;<br>                operator = Operator.get(s);<br>                top = Operator.get(stack.peek());<br>                <span class="hljs-keyword">if</span> (operator.lessOrEqual(top)) &#123;<br>                    result.add(stack.pop());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将自己进栈</span><br>            stack.push(s);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.equals(Operator.LEFT_BRACKET.symbol)) &#123;<br>            <span class="hljs-comment">// 左括号进栈</span><br>            stack.push(s);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.equals(Operator.RIGHT_BRACKET.symbol)) &#123;<br>            <span class="hljs-comment">// 右括号需要匹配左括号</span><br>            <span class="hljs-keyword">while</span> (!stack.empty()) &#123;<br>                pop = stack.pop();<br>                <span class="hljs-keyword">if</span> (pop.equals(Operator.LEFT_BRACKET.symbol)) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                result.add(pop);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;表达式有问题&quot;</span>);<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        result.add(stack.pop());<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后计算后缀表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cal</span><span class="hljs-params">(String expr)</span> </span>&#123;<br>    String[] temp = midToEnd(expr);<br>    Stack&lt;Double&gt; number = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String s : temp) &#123;<br>        <span class="hljs-keyword">if</span> (isNumber(s)) &#123;<br>            <span class="hljs-comment">// 数字直接进栈</span><br>            number.push(Double.parseDouble(s));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOperator(s)) &#123;<br>            <span class="hljs-comment">// 运算符则弹出两个数字，计算结果，将结果进栈</span><br>            <span class="hljs-keyword">if</span> (number.size() &gt;= <span class="hljs-number">2</span>) &#123;<br>                Double opr = number.pop();<br>                Double opl = number.pop();<br>                number.push(func(opl, opr, s));<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;表达式有问题&quot;</span>);<br>        &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> number.pop();<br>   <br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Double <span class="hljs-title">func</span><span class="hljs-params">(Double opl, Double opr, String op)</span> </span>&#123;<br>   <br>    <span class="hljs-keyword">if</span> (Operator.PLUS.symbol.equals(op)) &#123;<br>        <span class="hljs-keyword">return</span> opl + opr;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Operator.MINUS.symbol.equals(op)) &#123;<br>        <span class="hljs-keyword">return</span> opl - opr;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Operator.MUl.symbol.equals(op)) &#123;<br>        <span class="hljs-keyword">return</span> opl * opr;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Operator.DIV.symbol.equals(op)) &#123;<br>        <span class="hljs-keyword">return</span> opl / opr;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;表达式有问题&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里我为了简单，只处理了运算数为整形的情况，分解表达式字符串用的是正则，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String numberRegex = <span class="hljs-string">&quot;\\d+&quot;</span>;<br>    <span class="hljs-keyword">return</span> s.matches(numberRegex);<br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymbol</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String regex = <span class="hljs-string">&quot;[\\+\\-\\*\\/()]&quot;</span>;<br>    <span class="hljs-keyword">return</span> s.matches(regex);<br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String regex = <span class="hljs-string">&quot;[\\+\\-\\*\\/]&quot;</span>;<br>    <span class="hljs-keyword">return</span> s.matches(regex);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0004-组件的创建</title>
    <link href="/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0004-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2019/09/04/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Virtualview/0004-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>前面我们说了，想要加载一个模板文件，需要调用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sViewManager.loadBinBufferSync(TEST.BIN);<br></code></pre></td></tr></table></figure><p>那么，模板加载进来了之后，该怎么使用呢？用法还算是简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preview</span><span class="hljs-params">(String templateName, com.alibaba.fastjson.JSONObject jsonData)</span> </span>&#123;<br>    mContainer = sVafContext.getContainerService().getContainer(templateName, <span class="hljs-keyword">true</span>);<br>    IContainer iContainer = (IContainer) mContainer;<br>    <span class="hljs-keyword">if</span> (jsonData != <span class="hljs-keyword">null</span>) &#123;<br>        iContainer.getVirtualView().setVData(jsonData);<br>    &#125;<br><br>    Layout.Params p = iContainer.getVirtualView().getComLayoutParams();<br>    LinearLayout.LayoutParams marginLayoutParams = <span class="hljs-keyword">new</span> LinearLayout.LayoutParams(p.mLayoutWidth, p.mLayoutHeight);<br>    marginLayoutParams.leftMargin = p.mLayoutMarginLeft;<br>    marginLayoutParams.topMargin = p.mLayoutMarginTop;<br>    marginLayoutParams.rightMargin = p.mLayoutMarginRight;<br>    marginLayoutParams.bottomMargin = p.mLayoutMarginBottom;<br><br>    mLinearLayout.removeAllViews();<br>    mLinearLayout.addView(mContainer, marginLayoutParams);<br>&#125;<br></code></pre></td></tr></table></figure><p>templateName 就是我们模板的名字，不是模板文件的名字，是模板的名字，以我们的例子来说，就是“TEST”。</p><p>jsonData 就是模板需要展示的数据，一个例子如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;style&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;text-style&quot;</span> : <span class="hljs-string">&quot;bold|italic&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;height&quot;</span>: <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 style 可以看作是一个对象，它里面有一个 text-style 属性，我们可以这样使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">textStyle=<span class="hljs-string">&quot;$&#123;style.text-style&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>我们的例子中没有用到 style 这个东西。</p><h2 id="ContainerService"><a href="#ContainerService" class="headerlink" title="ContainerService"></a>ContainerService</h2><p>参数介绍完之后，我们来看看里面的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mContainer = sVafContext.getContainerService().getContainer(templateName, <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>这行代码就是核心内容了，里面就有实例化模板文件中的 view 的所有逻辑。我们点进去看一下：</p><blockquote><p>com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getContainer</span><span class="hljs-params">(String viewType, <span class="hljs-keyword">boolean</span> createParam)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> type = mComContainerTypeMap.getContainerMap(viewType);<br>    <span class="hljs-keyword">if</span> (type &lt;= -<span class="hljs-number">1</span>) &#123;<br>        type = CONTAINER_TYPE_NORMAL;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getContainer(viewType, type, createParam);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 Tangram 是支持自定义组件与组件容器的，所以如果你有自定义的组件容器的话，需要注册进去，注册的时候需要传递一个 type 值。由于我们没有自定义的 type 所以这里会返回 -1（也就是说对于自带的容器都是返回 -1），所以我们的 type 值会默认是 CONTAINER_TYPE_NORMAL。</p><blockquote><p>com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, int, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getContainer</span><span class="hljs-params">(String viewType, <span class="hljs-keyword">int</span> containerType, <span class="hljs-keyword">boolean</span> createParam)</span> </span>&#123;<br>    IContainer container = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// 实例化组件是这行代码做的</span><br>    ViewBase vb = mVM.getView(viewType);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == vb) &#123;<br>        vb = mVM.getDefaultImage();<br>        vb.setViewType(viewType);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果模板的根布局是 container，不用做什么额外的操作</span><br>    <span class="hljs-comment">// 如果模板的根布局不是 container，需要添加一层 container 在外面，container 为 com.tmall.wireless.vaf.virtualview.container.Container 对象</span><br>    <span class="hljs-keyword">if</span> (vb.isContainer()) &#123;<br>        container = (IContainer) vb.getNativeView();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ContainerMrg cm = mContainerMrg.get(containerType);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != cm) &#123;<br>            container = cm.getContainer(mAppContext);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;getContainer type invalidate:&quot;</span> + containerType);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 有了容器之后，设置 layoutParams 就完事了</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != container) &#123;<br>        container.setVirtualView(vb);<br>        <span class="hljs-keyword">if</span> (createParam) &#123;<br>            Layout.Params p = vb.getComLayoutParams();<br>            MarginLayoutParams marginLayoutParams = <span class="hljs-keyword">new</span> MarginLayoutParams(p.mLayoutWidth, p.mLayoutHeight);<br>            marginLayoutParams.leftMargin = p.mLayoutMarginLeft;<br>            marginLayoutParams.topMargin = p.mLayoutMarginTop;<br>            marginLayoutParams.rightMargin = p.mLayoutMarginRight;<br>            marginLayoutParams.bottomMargin = p.mLayoutMarginBottom;<br>            ((View)container).setLayoutParams(marginLayoutParams);<br>        &#125;<br><br>        <span class="hljs-comment">// 这里就是将 layout 里面的控件都拿出来，add到容器里里面</span><br>        container.attachViews();<br>    &#125;<br>    <span class="hljs-keyword">return</span> (View)container;<br>&#125;<br></code></pre></td></tr></table></figure><p>文档里面说过，因为虚拟控件只是绘制在 canvas 上，所以它依托一个原生容器控件作为宿主容器，必须要有容器才会显示。</p><p>我们例子中用的 VHLayout，看起来像一个容器，但是它不是，它里面有自己的测量，布局，绘制逻辑，但是它不是 ViewGroup，也不是 View。它也需要依托在一个容器里面，因为容器是继承了 ViewGroup 的，所以容器才能显示出来。</p><p>比如：VHLayout里面竖向排列了3个 NText，我们只拿布局逻辑来说。竖向排列的逻辑放在了 VHLayout 里面，但是容器会将 3个 NText 都拿出来，add 到自己的布局里面，那么这个时候，容器在布局的时候，就需要调用 VHLayout 里面的布局逻辑，来排列 3 个 NText。</p><p>这里先有个大致的了解，后面会单独讲解虚拟控件到底是个什么东西。</p><h2 id="ViewManager"><a href="#ViewManager" class="headerlink" title="ViewManager"></a>ViewManager</h2><p>回到代码逻辑，我们深入下去：</p><blockquote><p>com.tmall.wireless.vaf.framework.ViewManager#getView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewBase <span class="hljs-title">getView</span><span class="hljs-params">(String type)</span> </span>&#123;<br>    ViewBase v;<br>    List&lt;ViewBase&gt; vList = mViewCache.get(type);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == vList || <span class="hljs-number">0</span> == vList.size()) &#123;<br>        v = mViewFactory.newView(type, mUuidContainers);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != v) &#123;<br>            <span class="hljs-keyword">if</span> (v.supportDynamic()) &#123;<br>                mAppContext.getNativeObjectManager().addView(v);<br>            &#125;<br>            v.setViewType(type);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.e(TAG, <span class="hljs-string">&quot;new view failed type:&quot;</span> + type);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        v = vList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法就很简单了，只有第5行是核心代码，就是调用了 ViewFactory 的方法。其他的逻辑都是与缓存相关，因为最终都是基于RecyclerView的，有兴趣的可以自己研究。</p><h2 id="ViewFactory"><a href="#ViewFactory" class="headerlink" title="ViewFactory"></a>ViewFactory</h2><blockquote><p>com.tmall.wireless.vaf.virtualview.ViewFactory#newView(java.lang.String, android.util.SparseArray&lt;com.tmall.wireless.vaf.virtualview.core.ViewBase&gt;)</p></blockquote><p>这个方法很长，我们一段一段的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewBase <span class="hljs-title">newView</span><span class="hljs-params">(String type, SparseArray&lt;ViewBase&gt; uuidContainers)</span> </span>&#123;<br>    ViewBase ret = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mLoader) &#123;<br>        CodeReader cr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>            cr = mUiCodeLoader.getCode(type);<br>            <span class="hljs-keyword">if</span> (cr == <span class="hljs-keyword">null</span>) &#123;<br>                Log.d(TAG, <span class="hljs-string">&quot;load &quot;</span> + type + <span class="hljs-string">&quot; start when createView &quot;</span>);<br>                mTmplWorker.executeTask(type);<br>                cr = mUiCodeLoader.getCode(type);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>mUiCodeLoader 是老朋友了，我们可以根据 type 获取到对应的 CodeReader，CodeReader 里面储存的是模板的二进制数据。</p><p>mTmplWorker 是用来做异步加载处理的，因为有可能我们启动了异步加载，在实例化模板的时候，模板文件还没有读取完成，所以这里就需要先去加载模板文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != cr) &#123;<br>    mComArr.clear();<br>    ViewBase curView = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">int</span> tag = cr.readByte();<br>    <span class="hljs-keyword">int</span> state = STATE_continue;<br>    ViewCache viewCache = <span class="hljs-keyword">new</span> ViewCache();<br></code></pre></td></tr></table></figure><p>mComArr 是一个栈，是用来帮助读取模板的结构的，因为栈的特性很适合处理嵌套的控件层次。</p><p>tag 有两个字，一个是表示开始，一个表示结束，其实就是组件的开始与结束标识符，对应着xml 里面的 “&lt;” 与  “/&gt;”。这个没有实际证据，我猜的。</p><p>state 是用来表示是否需要跳出循环的，下面是一个死循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (tag) &#123;<br>        <span class="hljs-keyword">case</span> Common.CODE_START_TAG:<br>            <span class="hljs-keyword">short</span> comID = cr.readShort();<br>            <span class="hljs-comment">// 这里就是实例化 viewBase 了，暂时不深入</span><br>            ViewBase view = createView(mAppContext, comID, viewCache);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != view) &#123;<br>                Layout.Params p;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != curView) &#123;<br>                    p = ((Layout) curView).generateParams();<br>                    mComArr.push(curView);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    p = <span class="hljs-keyword">new</span> Layout.Params();<br>                &#125;<br>                view.setComLayoutParams(p);<br>                curView = view;<br>                <br>                ...<br>        <span class="hljs-keyword">case</span> Common.CODE_END_TAG:<br>            <span class="hljs-keyword">if</span> (mComArr.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                ViewBase c = mComArr.pop();<br>                <span class="hljs-keyword">if</span> (c <span class="hljs-keyword">instanceof</span> Layout) &#123;<br>                    ((Layout) c).addView(curView);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    state = STATE_failed;<br>                    Log.e(TAG, <span class="hljs-string">&quot;com can not contain subcomponent&quot;</span>);<br>                &#125;<br>                curView = c;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// can break;</span><br>                state = STATE_successful;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>主要说一下 mComArr 的作用：</p><ul><li><p>第一次遇到起始标志，将该 view 赋值给 curView。</p></li><li><p>再遇到起始标志的时候，就说明遇到了 view 嵌套的情况，这个时候将 curView 放入栈内。</p></li><li><p>遇到结束标识的时候，将栈顶元素取出来，add 到 curView 中。</p></li></ul><p>这样就搞定了 view 树的解析，还是比较容易理解的，实在绕不清楚的可以回去看看四则运算的中缀转后缀。</p><p>接下来，我们看看上面代码中省略的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// int</span><br>    <span class="hljs-keyword">byte</span> attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">int</span> value = cr.readInt();<br>        view.setValue(key, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// int RP</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">int</span> value = cr.readInt();<br>        view.setRPValue(key, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// float</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">float</span> value = Float.intBitsToFloat(cr.readInt());<br>        view.setValue(key, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// float RP</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">float</span> value = Float.intBitsToFloat(cr.readInt());<br>        view.setRPValue(key, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// string code</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">int</span> value = cr.readInt();<br>        view.setStrValue(key, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// expr code</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> key = cr.readInt();<br>        <span class="hljs-keyword">int</span> value = cr.readInt();<br>        view.setValue(key, mExprCodeLoader.get(value));<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-comment">// user var</span><br>    attrCount = cr.readByte();<br>    <span class="hljs-keyword">while</span> (attrCount &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> varType = cr.readByte();<br>        <span class="hljs-keyword">int</span> nameId = cr.readInt();<br>        <span class="hljs-keyword">int</span> value = cr.readInt();<br>        view.addUserVar(varType, nameId, value);<br>        --attrCount;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> uuid = view.getUuid();<br>    <span class="hljs-keyword">if</span> (uuid &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">null</span> != uuidContainers) &#123;<br>        uuidContainers.put(uuid, view);<br>    &#125;<br>    List&lt;Item&gt; pendingItems = viewCache.getCacheItem(view);<br>    <span class="hljs-keyword">if</span> (pendingItems == <span class="hljs-keyword">null</span> || pendingItems.isEmpty()) &#123;<br>        view.onParseValueFinished();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    state = STATE_failed;<br>    Log.e(TAG, <span class="hljs-string">&quot;can not find view id:&quot;</span> + comID);<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>这里的大部分代码都是在读取二进制文件中储存的属性键值对。</p><p>属性的 key 是一个 int 值，在 <code>com.libra.virtualview.common.StringBase</code> 中。</p><p>属性的 value 分为好几类：</p><ul><li>int</li><li>int RP</li><li>float</li><li>flot RP</li><li>string</li><li>expr</li><li>user var</li></ul><p>int 是整数，int RP 是什么呢？RP 表示的是百分比。不是说我们要写 20%w 这样的东西，而是说，如果UI妹妹给我们的切图是 720 * 1080 的，其中有个 button 的宽度为 100px，那么我们不用换算成dp，可以直接使用 100，然后调用 <code>com.libra.Utils#setUedScreenWidth</code> 设置一下就好了，在创建 view 的时候，会自动帮我们按百分比换算的。</p><p>我们拿我们的 xml 来说，有一个属性键值对是 <code>textSize=&quot;12&quot;</code>，那么 key 就是 <code>final public static int STR_ID_textSize = -1003668786;</code>，value 就是 12。这些属性键值对都是在组件区的组件数里面。</p><h2 id="ViewBase"><a href="#ViewBase" class="headerlink" title="ViewBase"></a>ViewBase</h2><p>当我们解析出来了组件的属性键值对之后，就可以设置给实例化出来的 view 了。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setValue(int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">// set self value</span><br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">this</span>.setAttribute(key, value);<br><br>    <span class="hljs-comment">// set layout param value</span><br>    <span class="hljs-keyword">if</span> (!ret &amp;&amp; <span class="hljs-keyword">null</span> != mParams) &#123;<br>        ret = mParams.setAttribute(key, value);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">switch</span> (key) &#123;<br>        <span class="hljs-keyword">case</span> StringBase.STR_ID_paddingLeft:<br>            mPaddingLeft = Utils.dp2px(value);<br>            isPaddingLeftSet = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.core.Layout.Params#setAttribute(int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">switch</span> (key) &#123;<br>        <span class="hljs-keyword">case</span> StringBase.STR_ID_layoutWidth:<br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) &#123;<br>                mLayoutWidth = Utils.dp2px(value);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mLayoutWidth = value;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>setValue 的思路还是很清楚的，先看 ViewBase 能不能处理这个属性，不能就给 Params 处理。看里面的逻辑都是<strong>将属性值给储存起来了</strong>，随后在测量，布局，绘制的时候就会用到这些属性值。</p><p>上面是对 int 类型的处理，对 String 类型的处理有点不一样。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrValue</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setStrValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">this</span>.setStrAttribute(key, value);<br><br>    <span class="hljs-keyword">if</span> (!ret &amp;&amp; <span class="hljs-keyword">null</span> != mParams) &#123;<br>        ret = mParams.setStrAttribute(key, value);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrAttribute</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setStrAttribute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    StringLoader sm = mContext.getStringLoader();<br>    <span class="hljs-comment">// 注意这里</span><br>    String stringValue = sm.getString(value);<br>    <span class="hljs-keyword">boolean</span> ret = setAttribute(key, stringValue);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, java.lang.String)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, String stringValue)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> ret = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">switch</span> (key) &#123;<br>        <span class="hljs-keyword">case</span> StringBase.STR_ID_layoutWidth:<br>            mViewCache.put(<span class="hljs-keyword">this</span>, StringBase.STR_ID_layoutWidth, stringValue, Item.TYPE_FLOAT);<br>            <span class="hljs-keyword">this</span>.mParams.mLayoutWidth = LayoutCommon.WRAP_CONTENT;<br>            <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.core.Layout.Params#setStrAttribute</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setStrAttribute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">//TODO</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ViewBase 的 setStrAttribute 方法，需要注意的是 value 并不是属性值。还记得我们前面讲 StringLoader 的时候，会给字符串生成一个唯一的 id 么？这里的 value 就是生成的id。根据这个 id， 我们可以获取到对应的字符串值。</p><p>在设置字符串属性值的时候，需要特殊处理，因为如果是按照 <code>layoutHeight=&quot;$&#123;height&#125;&quot; </code>这样的使用方式，我们这个时候是拿不到对应的值的，我们只能将 “${height}”给储存起来，等到设置了 json 数据的时候，在从里面取对应的值，然后再设置属性。</p><p>具体的方式就是：将属性键值对封装成一个类。</p><blockquote><p>com.tmall.wireless.vaf.virtualview.core.ViewCache.Item</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Item</span><span class="hljs-params">(ViewBase v, <span class="hljs-keyword">int</span> key, String attrEL, <span class="hljs-keyword">int</span> valueType)</span> </span>&#123;<br>    mView = v;<br>    mKey = key;<br>    mAttrEL = attrEL;<br>    mValueType = valueType;<br>&#125;<br></code></pre></td></tr></table></figure><p>v 就是属性所属的 view，key 就是属性的 id，attrEl 就是属性字符串值，valueType 是属性值的类型。attrEl 可能还需要进行解析才能使用，比如将 “${height}”解析为 “height”，具体看 <code>com.tmall.wireless.vaf.virtualview.core.ViewCache.Parser</code> 源码。</p><p>然后，等到设置了数据之后，就可以调用 item.bind 方法，给 view 设置属性了，后面细说。</p><p>其他的属性解析都是类似的，就不说了。再回到 view 实例化的代码处，具体说一下实例化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewBase view = createView(mAppContext, comID, viewCache);<br></code></pre></td></tr></table></figure><blockquote><p>com.tmall.wireless.vaf.virtualview.ViewFactory#createView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ViewBase <span class="hljs-title">createView</span><span class="hljs-params">(VafContext context, <span class="hljs-keyword">int</span> comID, ViewCache viewCache)</span> </span>&#123;<br>    ViewBase.IBuilder builder = mBuilders.get(comID);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != builder) &#123;<br>        <span class="hljs-keyword">return</span> builder.build(context, viewCache);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上就是调用了 build 方法。mBuilders 集合是在构造方法里<code>com.tmall.wireless.vaf.virtualview.ViewFactory#ViewFactory</code>初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>mBuilders.put(Common.VIEW_ID_FrameLayout, <span class="hljs-keyword">new</span> FrameLayout.Builder());<br>mBuilders.put(Common.VIEW_ID_GridLayout, <span class="hljs-keyword">new</span> GridLayout.Builder());<br>mBuilders.put(Common.VIEW_ID_VHLayout, <span class="hljs-keyword">new</span> VHLayout.Builder());<br>...<br></code></pre></td></tr></table></figure><p>可以看出来，每个控件都需要提供一个 Builder 类，用来实例化该控件。可以看一下 VHLayout 的 Builder 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewBase</span>.<span class="hljs-title">IBuilder</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewBase <span class="hljs-title">build</span><span class="hljs-params">(VafContext context, ViewCache viewCache)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VHLayout(context, viewCache);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，整个模板的实例化逻辑就理清楚了。</p><p><strong>总结</strong>：</p><p>从模板里面解析出 view 树。</p><p>解析 view 树的时候，使用 builder 创建 view，然后给 view 设置对应的属性。</p><p>如果是 <code>@&#123;height&#125;</code>这样的属性值的话，不能直接给属性赋值，需要储存起来，等到设置数据的时候在设置值。</p>]]></content>
    
    
    <categories>
      
      <category>Virtualview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-Virtualview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0021-栈的定义</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0021-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0021-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>在我们的软件应用中，栈的应用是非常普通的。</p><p>拿一个文本编辑器来举例，我们经常使用 <code>Ctrl + Z</code> 的快捷键来回退到上一步，这个动作就用到了栈。</p><p>栈是一种只能够在一端进行插入与删除的数据结构，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-2-2.png?raw=true"></p><p>栈的插入操作叫做入栈，删除操作叫做出栈。</p><p>我们玩的游戏《汉诺塔》，就是一种典型的入栈出栈操作。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0022-进栈出栈变化形式</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0022-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0022-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>思考一个问题：有 [1, 2, 3, 4, … ，n] 一共 n 个整数，他们按顺序入栈，问一共有多少种出栈顺序（提示：1 入栈之后可以立即出栈）？</p><p>首先，我们设f(n)代表序列个数为n的出栈序列种数。同时，<strong>我们假定第一个出栈的序数是k</strong>。</p><p>第一个出栈的序数k将1~ n的序列分成两个序列：</p><ul><li>其中一个是1~ k-1，序列个数为k-1；</li><li>另外一个是k+1~n，序列个数是n-k。 </li></ul><p>那么对于一个给定的值 k 来说，f(k) 就表示前 k 个数的出栈顺序，f(n-k) 就表示后 n-k 个数的出栈顺序。</p><p>f(n)的问题就等价于<strong>序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数</strong>，即选择k这个序数的出栈组合为f(k-1)×f(n-k)，又因为第一个出栈的数可以是 1 ~ n 中的任意一个数，所以 k 可以取值 1 ~ n。</p><p>所以：f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">f</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果，我们知道卡特兰数，那么这个公式可以转换为 $C^n_{2n}-C^{n+1}_{2n}$  。</p><p>可以看出最后转换成了排列组合公式，那么下面我们从排列组合的角度来思考一下这个问题。</p><p>我们先不管数的顺序是怎么样的，对于每一个数来说，总是要先入栈一次，然后再出栈一次。这里就假设入栈记为1，出栈记为0，那么就会产生一个 2n 个数的序列。这个序列由 n 个 1 与 n 个 0 组成。</p><p>使用排列组合的思想，在 2n 个位置里面选 n 个位置放入 1，其余的位置放入 0，一共有 $C^n_{2n}$ 种可能。</p><p>然后再思考一下，按照上面的排列方式，有一些序列是不符合要求的，比如 <code>0001...</code> 这种序列，因为 0 表示出栈，前面都没有入栈，哪里来的出栈呢？</p><p>所以我们需要找出在某个位置上，它前面的0的个数大于1的个数的所有序列。</p><p>我们假设在某个位置上（只能是奇数位置，不可能是偶数位置），0的个数刚好比1的个数<strong>多一个</strong>，设这个位置为 2m+1。</p><p>那么，这个位置前就有 m+1 个 0 和 m 个 1。后面有 n-m-1 个 0， n -m 个 1。</p><p>这里我们要做一个骚操作：</p><p>将  2m+1 位置后面的 0 与 1 互换，则该位置后面就变成了 n-m-1 个 1， n -m 个 0。所以整个序列变成了由 n+1 个 0， n-1 个 1 组成的序列。</p><p>我们将所有不符合要求的集合记作 B。</p><p>将由 n+1 个 0， n-1 个 1 组成的序列集合记作 A，A 的个数为 $C^{n+1}_{2n}%$。</p><p>B 集合中的每一个元素都对应着 A 中的一个元素。</p><p>则 A 集合包含 B 集合。</p><p>再反过来思考，任何一个由 n+1 个 0 和 n-1 个 1 组成的 2n 个数的序列，由于 0 的个数比 1 的个数多 2 个，2n为偶数，故必在某一个奇数位上 0 的个数刚好比 1 的个数多一个。同样在后面部分0和1互换，就成为了由 n 个 0 和 n 个 1 组成的 2n 个数的序列，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。</p><p>同样的，转换为集合来思考，即集合 B 包含集合 A。</p><p>最终，我们得到，集合A = 集合B。</p><p>所以，不符合要求的集合数为 $C^{n+1}_{2n}$。</p><p>最后得到  $C^n_{2n}-C^{n+1}_{2n}$  。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0023-栈的顺序储存结构及实现</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0023-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0023-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>本篇我们使用数组来实现栈。在之前我们需要思考一个简单的问题，因为栈只能从一端进行删除，那么我们使用数组的哪一端来进行插入与删除呢？</p><p>根据出栈与入栈的特性，我们知道栈底一般是不变的，显然用数组的下标为 0 的一段作为栈底比较好。接下来我们还要使用一个变量来记录栈顶元素的位置，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-4-2.png?raw=true"></p><p>当入栈与出栈的时候，只需要改变top的值就好了。当 top = 0 的时候，表示栈内只有一个值，所以我们规定 top = -1 的时候，栈为空。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> Object[] table = <span class="hljs-keyword">new</span> Object[SIZE];<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><p>将一个元素压入栈中，分为两步：</p><ul><li>将 top 的值加一</li><li>将元素赋值给 top 指向的位置</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isFull()) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    table[++top] = value;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，非常的简单，没啥说的，返回值 -1 表示失败， 0 表示成功。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-4-3.png?raw=true"></p><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><p>将一个元素删除，分为三步：</p><ul><li><p>返回 top 指向的元素</p></li><li><p>将 top 减一</p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    T result = (T) table[top];<br>    top--;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 pop 返回了出栈的值，这里的返回值还是经常会用到的。图的话，将入栈的图反过来看就好了。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0024-两个栈共享空间</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0024-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0024-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>首先需要说的是，两个栈共享空间的意思是一个数组里面有两个栈。</p><p>那么什么情况下会设计出这么奇怪的数据结构呢？有时候我们需要两个栈，而且这两个栈的变化是相反的，当一个栈的元素增加的时候，另一个栈的元素就应该减少，这个时候就可以使用两个栈共享空间了。</p><p>之所以要让两个栈共享空间而不是直接写两个栈，主要是在顺序储存的情况下，太浪费空间了，因为我们只能预估一个大概的最大值作为栈的储存空间。当两个栈共享空间的话，就可以节约一部分内存了。</p><p>看下面的这个设计图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-5-1.png?raw=true"></p><p>我们让两个栈的栈底分别在数组的两端，两个栈的栈顶是对着的（就像两个饮料瓶的瓶口相互对着一样，假设瓶口是栈顶）。当我们像栈内放入元素的时候，两个栈顶就会相互靠拢，直到两个栈顶挨着了，这个时候就说明，两个栈都满了。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack2</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-keyword">private</span> Object[] table = <span class="hljs-keyword">new</span> Object[SIZE];<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top2 = SIZE;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>top 表示栈1 的栈顶，栈1 没有元素的时候 top = -1，top2 表示栈2 的栈顶，栈2 没有元素的时候 top = SIZE。</p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>插入元素的时候需要指定插入哪一个栈，就没啥其他的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(T value, <span class="hljs-keyword">int</span> which)</span> </span>&#123;<br>    <span class="hljs-comment">// 栈满了</span><br>    <span class="hljs-keyword">if</span> (top + <span class="hljs-number">1</span> == top2) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (which == <span class="hljs-number">1</span>) &#123;<br>        table[++top] = value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        table[--top2] = value;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> which)</span> </span>&#123;<br>    T result;<br><br>    <span class="hljs-keyword">if</span> (which == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        result = (T) table[top--];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (top2 == SIZE) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        result = (T) table[top2++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入与删除就是分为两个栈来处理，与单个栈的插入与删除是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0025-栈的链式储存结构及实现</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0025-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0025-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>使用数组来实现线性表总是有很大的局限性，因为大小无法决定，如果增加扩容功能的话，赋值元素也很浪费性能，所以下面我们用链式储存来实现栈。</p><p>使用链式储存结构，必然要增加一个指向下一个元素的指针，所以这里相比顺序储存增加了使用空间。</p><p>思考一下，使用链式存储的时候，头指针应该指向哪里，是指向栈底还是栈顶比较好？</p><p>因为我们经常需要对栈顶进行操作，所以头指针指向栈顶比较合适，不然每次操作都要从栈底遍历一下。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-6-1.png?raw=true"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    T value;<br>    Node next;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    Node head;<br>    <span class="hljs-keyword">int</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="入栈操作"><a href="#入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">push</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count == SIZE) &#123;<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    Node node = <span class="hljs-keyword">new</span> Node();<br>    node.value = value;<br>    node.next = head;<br>    head = node;<br>    count++;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-6-2.png?raw=true"></p><h2 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    T result = head.value;<br>    Node p = head;<br>    head = head.next;<br>    free(p);<br>    count--;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-6-3.png?raw=true"></p><p>如果前面的链表都理解的话，这些入栈出栈的代码还是很简单的。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0026-栈的应用之递归</title>
    <link href="/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0026-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <url>/2019/09/01/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0026-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>递归是个啥就不说了，是非常基础的东西了。将两面镜子对着，你就明白啥是递归了。</p><p>下面我们讲一个数列：斐波那契数列。用这个数列来讲解递归。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><blockquote><p>如果兔子在出生的第二个月，就有了繁殖能力，一对兔子每个月可以生一对兔子。问一年后有多少对兔子？</p></blockquote><p>这里我们假设第 x 个月，兔子有 f(x) 对，则 第 x-1 个月，有 f(x-1) 对，第 x-2 个月，有 f(x-2) 对。这看起来像是废话，但是仔细想一想，因为兔子在出生的第2个月才有繁殖能力。所以在 x-1 个月的时候，只有 f(x-2) 对兔子才有繁殖能力，有因为每一对兔子可以生一对兔子，所以 :</p><p>f(x) = f(x-1) + f(x-2)</p><p>其中，f(x-1) 表示第 x-1 个月的兔子数，f(x-2) 表示所有兔子中可以繁殖的兔子数。</p><p>所以这个数列为：1，1，2，3，5，8，13，21，34，55，89，144。即一年后有 144 对兔子。</p><h2 id="循环实现"><a href="#循环实现" class="headerlink" title="循环实现"></a>循环实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        q = p + c;<br>        p = c;<br>        c = q;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> q;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>明显可以看出，递归的逻辑更加清晰。但是需要注意的是，函数的每次调用都将其变量，返回值，参数值都放入了调用栈之中，如果递归的层次太深，会报栈溢出的错误，因为栈的容量是有大小限制的，不会无穷大。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0020-双向链表</title>
    <link href="/2019/08/28/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0020-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2019/08/28/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0020-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>双向链表很好理解，就是既可以往后遍历也可以往前遍历。就好比你做地铁，工作人员告诉你只能从 A 到 B，无法从 B 到 A，那你肯定觉得这个人有病。</p><p>单向链表与循环链表虽然都很有用，但是有各自的局限性，有局限就会有可以完善的地方，双向链表就是来补充他们的不足的。</p><p>前面的例子中，我们的节点类都是这样设计的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    T t;<br>    Node&lt;T&gt; next;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>双向链表的话，就还需要加一个东西，加一个指向前面节点的指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    T t;<br>    Node&lt;T&gt; next;<br>    Node&lt;T&gt; pre;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>next 指针就是用来向后遍历的，pre 指针是用来向前遍历的。</p><p>头节点就应该是这样（不要搞错了头指针与头节点）：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-14-3.png?raw=true"></p><p>一开始让他们都指向自己就好了。</p><p>一个有数据的双向链表长这样：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-14-4.png?raw=true"></p><h2 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h2><p>这里就不写完成的代码了，只说一下核心逻辑，其他的与单项链表差不多。</p><p>先理清思路：</p><ul><li>找到要插入的位置，拿到该位置的前后两个节点（P, N）</li><li>用两个变量保存起来</li><li>再执行单链表的插入操作（执行两次）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Node p, e;<br>Node insert;<br><br>p.next = insert;<br>insert.next = e;<br>e.pre = insert;<br>insert.pre = p;<br></code></pre></td></tr></table></figure><p>这样写就不用记顺序，如果只使用两个变量，也可以做出来，但是有点蛋疼。</p><p>如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-14-5.png?raw=true"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">s.pre = p;<br>s.next = p.next;<br>p.next.pre = s<br>p.next = s;<br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>这个还是比较简单的：就是将单链表的删除操作，执行两次。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-14-6.png?raw=true"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">p.pre.next = p.next;<br>p.next.pre = p.pre;<br></code></pre></td></tr></table></figure><p>这两个语句顺序没啥关系，因为将链表反过来，再删除的话，也是一样的。</p><p>双向链表相对于单链表来说，更加复杂一点，但是在操作某个节点的前后节点的时候会更加方便。这就是一个典型的使用空间换时间的操作。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0019-循环链表</title>
    <link href="/2019/08/27/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0019-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <url>/2019/08/27/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0019-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>前面我们说的链表都是单链表，因为链表中的节点只储存了指向后一个节点的指针，所以我们无法向前遍历，只能向后遍历。</p><p>如果我们想要遍历前面的节点，那么该怎么做呢？原来的单链表结构是无法做到了，所以需要改进一下。</p><p>第一中改进方案就是这一章需要讲的，循环链表。</p><p>顾名思义，就是将链表的头和尾连起来，串成一个圆环，就是循环链表了。</p><p>同样是只能向后遍历，因为头和尾连起来了，所以最后总能遍历到前面的节点。有点不撞南墙不回头的意思。</p><p>虽然只是将头与尾连起来了，但是在使用这个数据结构的时候，还是有几个需要注意的地方。</p><h2 id="循环链表的初始化"><a href="#循环链表的初始化" class="headerlink" title="循环链表的初始化"></a>循环链表的初始化</h2><p>为了与单链表保持一致，循环链表也有一个头节点，但是在初始化这个头节点的时候，需要注意一下，因为刚开始的链表是没有数据的，所以这个时候头节点需要指向自己，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-3.png?raw=true"></p><p>当有数据的时候，循环链表如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-4.png?raw=true"></p><p>可以看出，其实这种循环链表与单链表的差别不大，只不过循环链表的遍历条件变成了：<code>node.next != headNode</code>。</p><p>我们想访问一个节点的时候，时间复杂度仍然为 O(n).</p><p>有些时候，我们需要访问到链表的最后一个元素，按照上面的循环链表的结构，我们需要 O(n) 的时间，那么有没有快捷一点的方法呢？</p><p>显然是有点，比如说我们加一个尾指针，指向最后一个节点，这样就可以以 O(1) 的时间访问尾节点了。再仔细想一下，有了尾指针，头指针还需要吗？</p><p>因为是循环链表，所以尾指针指向的就是头节点，所以可以不需要头指针了。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-5.png?raw=true"></p><p>举一个尾指针的用处，合并两个链表，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-13-6.png?raw=true"></p><p>要想将它们合并，还是很简单的，先理清思路：</p><ul><li>将 A 链表的头尾节点引用断开（由于断开后就找不到了，所以需要保存一下头节点的引用）</li><li>将 A 链表的尾指针指向 B 链表的第一个节点</li><li>将 B 链表的尾指针指向 A 链表的第一个节点</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Node temp = rearA.next;<br>rearA.next = rearB.next.next;<br><span class="hljs-comment">// 因为 java 会自动释放节点，所以就没写</span><br><span class="hljs-comment">// 可以加上</span><br><span class="hljs-comment">// Node headB = rearB.next;</span><br><span class="hljs-comment">// free(headB);</span><br>rearB.next = temp;<br></code></pre></td></tr></table></figure><p>有了尾节点之后，代码会简单很多，<strong>因为合并链表涉及到头与尾两个节点</strong>，所以使用尾节点比较方便。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0025-非阻塞算法</title>
    <link href="/2019/08/26/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0025-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/26/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0025-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章，真的是很有意思，讲的都是概念性的东西，但是越读越有味道，最好多读几遍。</p></blockquote><p>在并发上下文中，<strong>非阻塞算法是一种不阻塞访问共享状态（或以其他方式协作或通信）的线程的算法</strong>。更一般地说，如果一个线程的挂起不会导致算法中涉及的其他线程的挂起，则这个算法是非阻塞的。</p><p>为了更好的理解阻塞算法和非阻塞算法之间的区别，我会先讲解阻塞算法然后再讲解非阻塞算法。</p><h2 id="阻塞算法"><a href="#阻塞算法" class="headerlink" title="阻塞算法"></a>阻塞算法</h2><p>很多算法和并发数据结构都是阻塞的。例如，<code>java.util.concurrent.BlockingQueue</code>的不同实现都是阻塞数据结构。如果一个线程要往一个阻塞队列中插入一个元素，队列中没有足够的空间，执行插入操作的线程就会阻塞直到队列中有了可以存放插入元素的空间。</p><p>下图演示了一个阻塞算法是如何保证一个共享数据结构的行为的：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-1.png"></p><p>线程 A 执行请求的操作</p><p>线程 B 会一直阻塞直到可以安全地执行操作（线程A的操作执行完）</p><h2 id="非阻塞算法"><a href="#非阻塞算法" class="headerlink" title="非阻塞算法"></a>非阻塞算法</h2><p>Java也包含几个非阻塞数据结构。<code>AtomicBoolean</code>, <code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>都是非阻塞数据结构的例子。</p><p>下图演示了一个非阻塞算法保证一个共享数据结构的行为：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-2.png"></p><p>线程 B 执行请求的操作</p><p>线程 A 访问的时候，发现无法访问会直接返回，可以去做一些别的操作。</p><h2 id="非阻塞算法-vs-阻塞算法"><a href="#非阻塞算法-vs-阻塞算法" class="headerlink" title="非阻塞算法 vs 阻塞算法"></a>非阻塞算法 vs 阻塞算法</h2><p>阻塞算法和非阻塞算法的主要不同在于当请求操作不能够执行时阻塞算法和非阻塞算法会怎么做。</p><p>阻塞算法会阻塞线程直到请求操作可以被执行。非阻塞算法会通知请求线程操作不能够被执行，并返回。</p><p>阻塞算法的问题：如果一个线程 T1 往一个已经满了的阻塞队列里插入一个元素，这个线程就会阻塞，直到其他线程从这个阻塞队列中取走了一些元素。如果由于某些原因，从阻塞队列中取元素的线程 T2 被阻塞在了程序的某处，那么，T1 要么一直阻塞下去，要么直到 T2 从阻塞队列中取走了一个元素。</p><h2 id="并发数据结构"><a href="#并发数据结构" class="headerlink" title="并发数据结构"></a>并发数据结构</h2><p>在一个多线程系统中，线程间通常通过一些数据结构“交流”。可以是任何的数据结构，从变量到更加高级的数据结构（队列，栈等）。为了便于多线程对数据结构的正确并发访问，必须通过某些并发算法来保护数据结构。这些并发算法让这些数据结构成为<strong>并发数据结构</strong>。</p><p>如果某个算法确保一个并发数据结构是阻塞的，它就被称为是一个<strong>阻塞算法</strong>。这个数据结构也被称为是一个<strong>阻塞，并发数据结构</strong>。</p><p>如果某个算法确保一个并发数据结构是非阻塞的，它就被称为是一个<strong>非阻塞算法</strong>。这个数据结构也被称为是一个<strong>非阻塞，并发数据结构</strong>。</p><h2 id="单个写线程的情景"><a href="#单个写线程的情景" class="headerlink" title="单个写线程的情景"></a>单个写线程的情景</h2><p>在一些场景下，你仅有唯一的一个线程在向一个共享变量写，多个线程在读这个变量。当仅有一个线程在更新一个变量，不管有多少个线程在读这个变量，都不会发生竞态条件。因此，无论时候当仅有一个线程在写一个共享变量时，你可以把这个变量声明为<code>volatile</code>。</p><p>当多个线程在一个共享变量上执行一个 read-update-write 的顺序操作时才会发生竞态条件。如果你只有一个线程在执行一个 raed-update-write 的顺序操作，其他线程都在执行读操作，将不会发生竞态条件。</p><p>下面是一个单个写线程的例子，它没有采取同步手段但任然是多线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleWriterCounter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Only one thread may ever call this method,</span><br><span class="hljs-comment">     * or it will lead to race conditions.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count++;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Many reading threads may call this method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，多个线程时可以访问 SingleWriterCounter 的同一个实例的，只要只有一个线程调用 inc() 方法（不是指某一时刻一个线程，而是只有一个线程）。<code>count()</code>方法可以被多个线程调用。这样的场景将不会发生任何竞态条件。</p><p>下图，说明了线程是如何访问<code>count</code>这个volatile变量的。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-3.png"></p><h2 id="基于volatile变量的更高级的数据结构"><a href="#基于volatile变量的更高级的数据结构" class="headerlink" title="基于volatile变量的更高级的数据结构"></a>基于volatile变量的更高级的数据结构</h2><p>使用多个<code>volatile</code>变量去创建数据结构是可以的，构建出的数据结构中每一个<code>volatile</code>变量仅被一个单个的线程写，被多个线程读。每个<code>volatile</code>变量可能被一个不同的线程写（但仅有一个）。使用像这样的数据结构多个线程可以使用这些<code>volatile</code>变量以一个非阻塞的方法彼此发送信息。</p><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleWriterCounter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> countA = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> countB = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Only one (and the same from thereon) thread may ever call this method,</span><br><span class="hljs-comment">     * or it will lead to race conditions.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>.countA++;  &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Only one (and the same from thereon) thread may ever call this method,</span><br><span class="hljs-comment">     * or it will lead to race conditions.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">incB</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>.countB++;  &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Many reading threads may call this method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">countA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.countA; &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Many reading threads may call this method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">countB</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.countB; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有一个线程调用 <code>incA()</code>，也只有一个线程调用 <code>incB()</code>，<code>countA()</code>和<code>countB()</code>可以被多个线程调用。这个例子实际上是两个 SingleWriterCounter 合在一起了。</p><p>下图，展示了两个线程通过类似于上面的一个数据结构进行通信的：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-4.png"></p><h2 id="CAS-与乐观锁"><a href="#CAS-与乐观锁" class="headerlink" title="CAS 与乐观锁"></a>CAS 与乐观锁</h2><p>如果你确实需要多个线程写同一个共享变量，使用volatile变量是不合适的。你需要独占对这个变量的访问权限（排他）。下面代码演示了Java中的同步块是如何进行排他访问的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedCounter</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>inc() 与 count() 都有一个同步块，而同步块与 wait() - notify() 却是我们想避免的。</p><p>我们可以使用原子变量来代替这两个同步块。在这个例子中是<code>AtomicLong</code>。下面是SynchronizedCounter类的AtomicLong实现版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicCounter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> updated = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">while</span>(!updated)&#123;<br>            <span class="hljs-keyword">long</span> prevCount = <span class="hljs-keyword">this</span>.count.get();<br>            updated = <span class="hljs-keyword">this</span>.count.compareAndSet(prevCount, prevCount + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.count.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本是上一个版本的线程安全版本。在这一版中，我们感兴趣的是inc()方法的实现。inc()方法中不再含有一个同步块。而是被下面这些代码替代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> updated = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">while</span>(!updated)&#123;<br>    <span class="hljs-keyword">long</span> prevCount = <span class="hljs-keyword">this</span>.count.get();<br>    updated = <span class="hljs-keyword">this</span>.count.compareAndSet(prevCount, prevCount + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这些代码并不是一个原子操作。也就是说，可能会有两个不同的线程调用 inc() 方法。但是这里却没有包含竟态条件。</p><p>秘密就在于<code>while</code>循环里的第二行代码。<code>compareAndSet()</code>方法调用是一个原子操作。它用一个期望值和AtomicLong 内部的值去比较，如果这两个值相等，就把AtomicLong内部值替换为一个新值。<code>compareAndSet()</code>通常被CPU中的<code>compare-and-swap</code>指令直接支持。因此，不需要去同步，也不需要去挂起线程。</p><p>假设，这个<code>AtomicLong</code>的内部值是20。然后，两个线程去读这个值，都尝试调用<code>compareAndSet(20, 20 + 1)</code>。尽管<code>compareAndSet()</code>是一个原子操作，这个方法也会被这两个线程相继执行（<strong>某一个时刻只有一个</strong>）。</p><p>第一个线程会使用期望值20（这个计数器的上一个值）与AtomicLong的内部值进行比较。由于两个值是相等的，AtomicLong会更新它的内部值至21（20 + 1 ）。变量<code>updated</code>被修改为true，while循环结束。</p><p>现在，第二个线程调用<code>compareAndSet(20, 20 + 1)</code>。由于AtomicLong的内部值不再是20，这个调用将不会成功。AtomicLong的值不会再被修改为21。变量，<code>updated</code>被修改为false，线程将会再次在while循环外自旋。这段时间，它会读到值21并企图把值更新为22。如果在此期间没有其它线程调用<code>inc()</code>。第二次迭代将会成功更新AtomicLong的内部值到22。</p><p>上一部分展现的代码被称为<strong>乐观锁</strong>（optimistic locking）。乐观锁区别于传统的锁（有时也被称为<strong>悲观锁</strong>）。传统的锁会使用同步块或其他类型的锁阻塞对临界区域的访问。一个同步块或锁可能会导致线程挂起。</p><p>乐观锁允许所有的线程在不发生阻塞的情况下创建一份共享内存的拷贝。这些线程接下来可能会对它们的拷贝进行修改，并企图把它们修改后的版本写回到共享内存中。如果没有其它线程对共享内存做任何修改， CAS操作就允许线程将它的变化写回到共享内存中去。如果，另一个线程已经修改了共享内存，这个线程将不得不再次获得一个新的拷贝，在新的拷贝上做出修改，并尝试再次把它们写回到共享内存中去。</p><p>称之为“乐观锁”的原因就是：<strong>线程会乐观的认为，其他线程在此期间（线程获得了他们想要更改的数据的副本并应用他们的更改）不会对共享内存进行更改</strong>。当这个乐观假设成立时，这个线程仅仅在无锁的情况下完成共享内存的更新。当这个假设不成立时，线程所做的工作就会被丢弃，但仍然不使用锁。</p><p><strong>乐观锁适用于共享内存竞用不是非常高的情况。</strong>如果共享内存上的内容非常多，仅仅因为更新共享内存失败，就用浪费大量的CPU周期用在拷贝和修改上。</p><h2 id="不可替换的数据结构"><a href="#不可替换的数据结构" class="headerlink" title="不可替换的数据结构"></a>不可替换的数据结构</h2><p>一般的，在数据结构不是很复杂的情况下，我们可以使用 CAS 来更新一个数据结构：将数据拷贝一份，做出修改，然后将旧的替换为新的引用。</p><p>然而，一个大的数据结构可能会需要大量的内存和CPU周期来复制。这会使你的程序占用大量的内存和浪费大量的时间在拷贝操作上，导致你的程序的性能降低，特别是在这个数据结构的竞争非常高情况下。</p><p>一个线程花费在拷贝和修改这个数据结构上的时间越长，其它线程在此期间修改这个数据结构的可能性就越大。如果一个线程修改了这个数据结构，其它所有的线程都不等不再次执行 拷贝-修改 操作。这将会增大性能影响和内存浪费。</p><p>接下来的部分将会讲解一种实现非阻塞数据结构的方法，这种数据结构可以被并发修改，而不仅仅是拷贝和修改。</p><h2 id="共同修改"><a href="#共同修改" class="headerlink" title="共同修改"></a>共同修改</h2><p>我们可以不用每次复制原来的数据结构，而是让多个线程同时修改这个数据结构。这里的多线程同时修改并不是真正意义上的同时修改，而是说某一个线程提交自己的修改时，别的线程依然无法访问，但是如果该线程在提交自己的修改之后阻塞了，别的线程可以继续完成该线程提交的修改操作。</p><p>大致的过程如下：</p><ul><li><strong>检查另一个线程是否已经对这个数据结构提交了修改</strong></li><li><strong>如果没有其他线程提交了修改，创建一个修改对象，然后向这个数据结构提交这次修改</strong></li><li><strong>执行对共享数据结构的修改</strong></li><li><strong>移除对这个修改的引用，向其它线程发送信号，告诉它们这个修改已经被执行</strong></li></ul><p>第二步可以阻塞其他线程提交一个修改。因此，第二步实际的工作是作为这个数据结构的一个锁。如果一个线程已经成功提交了一个修改，其他线程就不可以再提交一个修改直到第一个修改执行完毕。</p><p>如果一个线程提交了一个修改，然后做一些其它的工作时发生阻塞，这时候，这个共享数据结构实际上是被锁住的。其它线程检测到它们不能够提交修改，这个时候我们就休要做一些特殊的操作（<strong>为了避免一个已经提交的修改锁住共享数据结构，这个修改对象必须包含足够的信息让其他线程来完成这次修改</strong>），我们让别的线程来帮助完成这次修改。</p><p>下面是一个蓝图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/non-blocking-algorithms-5.png"></p><p>可以看到，上面的图中有两次检查。</p><p><strong>第一次检查</strong>，是某个线程 T1 想要对数据结构提交一个修改，发现已经有别的线程 T0 提交过修改了，但是 T0 却没有完成自己提交的修改，所以 T1 需要先帮 T0 完成它提交的修改，然后再复制数据结构，创建自己的修改。</p><p>等到 T1 创建完自己的修改之后，由于不可抗力，T1 也阻塞了，这个时候 T2 又来了，所以 T2 也需要再次完成未完成的修改。<strong>这里就是第二次检查的作用了</strong>。</p><h2 id="一个非阻塞算法的模板"><a href="#一个非阻塞算法的模板" class="headerlink" title="一个非阻塞算法的模板"></a>一个非阻塞算法的模板</h2><p>在非阻塞算法方面，我（博客原作者 Jakob Jenkov ）并不是一位专家，所以，下面的模板可能错误。不要基于我提供的模板实现自己的非阻塞算法。这个模板意在告诉你一个关于非阻塞算法大致是什么样子的。如果，你想实现自己的非阻塞算法，首先学习一些实际的工业水平的非阻塞算法，然后在实践中学习更多关于非阻塞算法实现的知识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonblockingTemplate</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntendedModification</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> AtomicBoolean completed = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> AtomicStampedReference&lt;IntendedModification&gt; ongoingMod =<br>        <span class="hljs-keyword">new</span> AtomicStampedReference&lt;IntendedModification&gt;(<span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//declare the state of the data structure here.</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(!attemptModifyASR());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">attemptModifyASR</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;<br><br>        IntendedModification currentlyOngoingMod = ongoingMod.getReference();<br>        <span class="hljs-keyword">int</span> stamp = ongoingMod.getStamp();<br><br>        <span class="hljs-keyword">if</span>(currentlyOngoingMod == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//copy data structure state - for use</span><br>            <span class="hljs-comment">//in intended modification</span><br><br>            <span class="hljs-comment">//prepare intended modification</span><br>            IntendedModification newMod = <span class="hljs-keyword">new</span> IntendedModification();<br><br>            <span class="hljs-keyword">boolean</span> modSubmitted =  ongoingMod.compareAndSet(<span class="hljs-keyword">null</span>, newMod, stamp, stamp + <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span>(modSubmitted)&#123;<br><br>                <span class="hljs-comment">//complete modification via a series of compare-and-swap operations.</span><br>                <span class="hljs-comment">//note: other threads may assist in completing the compare-and-swap</span><br>                <span class="hljs-comment">// operations, so some CAS may fail</span><br><br>                modified = <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//attempt to complete ongoing modification, so the data structure is freed up</span><br>            <span class="hljs-comment">//to allow access from this thread.</span><br><br>            modified = <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> modified;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说实话，这里有个地方我有点疑问（上面代码中的 45-50行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//attempt to complete ongoing modification, so the data structure is freed up</span><br>    <span class="hljs-comment">//to allow access from this thread.</span><br><br>    modified = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里别的线程帮助完成提交的修改的时，应该怎么做才能不导致阻塞？</p><p>如果使用 CAS，那岂不是还是要走 copy 数据结构的套路？那就还是回到了原来的问题啊，copy 复杂的数据结构可能会导致更激烈的竞争。</p><p>或者将两个修改合并？？但是虽然这样不会 copy 数据，但是合并的操作怎么保证不阻塞？合并的时候完全使用 CAS 操作，这样就只 copy 了提交对象。</p><h2 id="非阻塞算法是不容易实现的"><a href="#非阻塞算法是不容易实现的" class="headerlink" title="非阻塞算法是不容易实现的"></a>非阻塞算法是不容易实现的</h2><p>正确的设计和实现非阻塞算法是不容易的。在尝试设计你的非阻塞算法之前，看一看是否已经有人设计了一种非阻塞算法正满足你的需求。</p><p>Java已经提供了一些非阻塞实现（比如 ConcurrentLinkedQueue），相信在Java未来的版本中会带来更多的非阻塞算法的实现。</p><p>除了Java内置非阻塞数据结构还有很多开源的非阻塞数据结构可以使用。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>非阻塞算法的第一个好处是，给了线程一个选择，当它们请求的动作不能够被执行时做些什么。不再是被阻塞在那。在这种情况下，它可以选择阻塞或自我等待，像这样把CPU的使用权让给其它的任务。</p><h3 id="没有死锁"><a href="#没有死锁" class="headerlink" title="没有死锁"></a>没有死锁</h3><p>非阻塞算法的第二个好处是，一个线程的挂起不会导致其它线程挂起。这也意味着不会发生死锁。非阻塞算法任然可能产生活锁（live lock），两个线程一直请求一些动作，但一直被告知不能够被执行（由于相互影响）。</p><h3 id="没有线程挂起"><a href="#没有线程挂起" class="headerlink" title="没有线程挂起"></a>没有线程挂起</h3><p>挂起和恢复一个线程的代价是昂贵的。</p><p>无论什么时候，一个线程阻塞，就会被挂起。由于使用非阻塞算法线程不会被挂起，这种过载就不会发生。这就意味着CPU有可能花更多时间在执行实际的业务逻辑上而不是上下文切换。</p><h3 id="降低线程延迟"><a href="#降低线程延迟" class="headerlink" title="降低线程延迟"></a>降低线程延迟</h3><p>在这里我们提到的延迟指的是一个请求产生到线程实际的执行它之间的时间。因为在非阻塞算法中线程不会被挂起，它们就没有线程切换成本。这就意味着当一个请求执行时可以得到更快的响应，减少它们的响应延迟。</p><p>非阻塞算法通常<strong>忙等待</strong>直到请求动作可以被执行来降低延迟。当然，在一个非阻塞数据数据结构有着很高的线程争用的系统中，CPU可能在它们忙等待期间消耗大量的CPU周期。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0021-阻塞队列</title>
    <link href="/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0021-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <url>/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0021-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>阻塞队列与普通队列的区别在于：</p><p>当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。</p><p>试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来（如从队列中移除一个或者多个元素，或者完全清空队列）。</p><p>下图展示了如何通过阻塞队列来合作：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency-utils/blocking-queue.png"></p><p>线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素</p><p>从5.0开始，JDK在java.util.concurrent包里提供了阻塞队列的官方实现。尽管JDK中已经包含了阻塞队列的官方实现，但是熟悉其背后的原理还是很有帮助的。</p><h2 id="阻塞队列的简单实现"><a href="#阻塞队列的简单实现" class="headerlink" title="阻塞队列的简单实现"></a>阻塞队列的简单实现</h2><p>阻塞队列的实现类似于带上限的Semaphore的实现。下面是阻塞队列的一个简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlockingQueue</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List queue = <span class="hljs-keyword">new</span> LinkedList();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>  limit = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.limit = limit;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Object item)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException  </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.queue.size() == <span class="hljs-keyword">this</span>.limit) &#123;<br>            wait();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.queue.size() == <span class="hljs-number">0</span>) &#123;<br>            notifyAll();<br>        &#125;<br>        <span class="hljs-keyword">this</span>.queue.add(item);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">dequeue</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.queue.size() == <span class="hljs-number">0</span>)&#123;<br>            wait();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.queue.size() == <span class="hljs-keyword">this</span>.limit)&#123;<br>            notifyAll();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue.remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到这个例子与上一篇的带上界的信号量很像，不过就是多了一步操作（往 list 里面添加或删除元素）。</p><p>每当 list 满的时候，enqueue 线程就会进入 wait 方法，然后阻塞。当 list 从满变为非满的时候，阻塞的线程就会被唤醒。</p><p>当 list 为空的时候，dequeue 线程会进入 wait 方法，然后阻塞。当 list 从空变为非空的时候，阻塞的线程就会被唤醒。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0022-线程池</title>
    <link href="/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0022-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0022-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>线程池（Thread Pool）对于限制应用程序中同一时刻运行的线程数很有用。因为每启动一个新线程都会有相应的性能开销，每个线程都需要给栈分配一些内存等等。</p><p>我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。只要池里有空闲的线程，任务就会分配给一个线程执行。在线程池的内部，任务被插入一个阻塞队列，线程池里的线程会去取这个队列里的任务。当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它。</p><p>Java 5 在 <code>java.util.concurrent</code> 包中自带了内置的线程池，所以你不用非得实现自己的线程池。不过无论如何，知道一点关于线程池实现的知识总是有用的。</p><p>下面我们来实现一个简易版的线程池。</p><p>一个线程池需要存放两部分的东西：线程、任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BlockingQueue taskQueue = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> List&lt;PoolThread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;PoolThread&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isStopped = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> noOfThreads, <span class="hljs-keyword">int</span> maxNoOfTasks)</span> </span>&#123;<br>        taskQueue = <span class="hljs-keyword">new</span> BlockingQueue(maxNoOfTasks);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;noOfThreads; i++) &#123;<br>            threads.add(<span class="hljs-keyword">new</span> PoolThread(taskQueue));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (PoolThread thread : threads) &#123;<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isStopped) <span class="hljs-keyword">throw</span><br>            <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;ThreadPool is stopped&quot;</span>);<br><br>        <span class="hljs-keyword">this</span>.taskQueue.enqueue(task);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isStopped = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span> (PoolThread thread : threads) &#123;<br>            thread.toStop();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在构造函数中，一开始就创建出多个线程，并启动它们，以供后面的任务使用，当然这里是为了简化，完全可以做到任务到来了之后再去创建线程。</p><p>execute 方法就很简单了，我们啥都不用做，将任务放入队列即可（就像银行排队一样，就算前面没有人，你也要先取号）。</p><p>stop 方法就是用来停止线程池里面所有线程的。</p><p>我们再来看 PoolThread 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>       isStopped = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PoolThread</span><span class="hljs-params">(BlockingQueue&lt;Runnable&gt; queue)</span> </span>&#123;<br>        taskQueue = queue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!isStopped()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Runnable runnable =taskQueue.take();<br>                runnable.run();<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                <span class="hljs-comment">// 写日志或者报告异常,</span><br>                <span class="hljs-comment">// 但保持线程池运行.</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toStop</span><span class="hljs-params">()</span> </span>&#123;<br>        isStopped = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.interrupt(); <span class="hljs-comment">// 打断池中线程的 dequeue() 调用.</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStopped</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isStopped;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是一个增强版，线程执行 run 方法的时候，只能去队列里面取。队列没有东西，就阻塞着。处理异常一定要捕获。<strong>如果线程有中断标识按需退出，例子中没有处理</strong>，官方包中线程池也是不会中断，一定会执行完当前任务。</p><p>然后一个隐藏的点：子线程会在完成当前执行的任务后阻塞。注意 <code>PoolThread.stop()</code> 方法中调用了 <code>this.interrupt()</code>。它确保阻塞在 <code>taskQueue.dequeue()</code> 里的 <code>wait()</code> 调用的线程能够跳出 <code>wait() 调用（因为执行了中断interrupt，它能够打断这个调用）</code>，并且抛出一个 <code>InterruptedException</code> 异常离开 <code>dequeue()</code> 方法。这个异常在 <code>PoolThread.run()</code> 方法中被截获、报告，然后再检查 <code>isStopped</code> 变量。由于 <code>isStopped</code> 的值是 true, 因此 <code>PoolThread.run()</code> 方法退出，子线程终止。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0023-CAS</title>
    <link href="/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0023-CAS/"/>
    <url>/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0023-CAS/</url>
    
    <content type="html"><![CDATA[<p>在说 CAS 之前先说一下乐观锁的定义：</p><blockquote><p><strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</p></blockquote><p>CAS是乐观锁的一种实现，说起来很抽象，其实还是很简单的，因为实际上它都不算是锁，更像是一种策略。</p><p>CAS（Compare and swap），是设计并发算法时用到的一种技术。简单来说，CAS 是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术。</p><p>在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> locked = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!locked) &#123;<br>            locked = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码，如果用在多线程的程序会出现很多错误。</p><p>为了在一个多线程程序中良好的工作，“check then act” 操作必须是原子的。原子就是说“check”操作和“act”被当做一个原子代码块执行。不存在多个线程同时执行原子块。</p><p>下面是一个代码示例，把之前的lock()方法用synchronized关键字重构成一个原子块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> locked = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!locked) &#123;<br>            locked = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在lock()方法是同步的，所以，在某一时刻只能有一个线程在同一个 MyLock 实例上执行它。</p><p><strong>原子的lock方法实际上是一个“compare and swap”的例子</strong>。</p><p>现在的 CPU 自身就支持 CAS 操作。Java 5 中，我们可以使用 <code>java.util.concurrent.atomic</code> 包中的原子类来使用CPU中的这些功能。</p><p>下面是一个使用AtomicBoolean类实现lock()方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicBoolean locked = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> locked.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。<br>如果值被替换了，compareAndSet()返回true，否则，返回false。</p><p>使用 <code>Java5+</code> 提供的CAS特性而不是使用自己实现的的好处是 <code>Java5+</code> 中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性。这会使代码运行更快。</p><p>在使用 CAS 的时候，还需要注意 ABA 问题。</p><p>ABA 问题就是：如果某个线程将变量的值改变了，然后又改回原来的值，所以 CAS 仍然会认为值没有别的线程改变过。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0024-剖析同步器</title>
    <link href="/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0024-%E5%89%96%E6%9E%90%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <url>/2019/08/23/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0024-%E5%89%96%E6%9E%90%E5%90%8C%E6%AD%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>前面，我们设计了简易版的信号量、锁等，它们虽然功能不一样，但是内部的差距却差不多。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。</p><p>大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能：</p><ul><li>状态</li><li>访问条件</li><li>状态变化</li><li>通知策略</li><li>Test-and-Set 方法</li><li>Set 方法</li></ul><p>并不是所有同步器都包含上述部分，也有些并不完全遵照上面的内容。但通常你会看到一或多个类似的功能。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p><strong>同步器中的状态是用来确定某个线程是否有访问权限。</strong></p><p>下面是Lock和BoundedSemaphore中的两个代码片段。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class Lock&#123;<br><span class="hljs-addition">+   //state is kept here</span><br><span class="hljs-addition">+   private boolean isLocked = false; </span><br>    public synchronized void lock()<br>        throws InterruptedException&#123;<br>        while(isLocked)&#123;<br>            wait();<br>        &#125;<br>        isLocked = true;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class BoundedSemaphore &#123;<br><span class="hljs-addition">+    //state is kept here</span><br><span class="hljs-addition">+    private int signals = 0;</span><br>    private int bound   = 0;<br><br>    public BoundedSemaphore(int upperBound)&#123;<br>        this.bound = upperBound;<br>    &#125;<br>    public synchronized void take() throws InterruptedException&#123;<br>        while(this.signals == bound) wait();<br>        this.signal++;<br>        this.notify();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="访问条件"><a href="#访问条件" class="headerlink" title="访问条件"></a>访问条件</h2><p>访问条件决定调用<code>test-and-set</code>方法（下文会说到）的线程是否可以对状态进行设置。访问条件一般是基于同步器<a href="http://ifeve.com/anatomy-of-a-synchronizer/#state">状态</a>的。通常是放在一个while循环里，以避免<a href="http://ifeve.com/thread-signaling/#spurious_wakeups">虚假唤醒</a>问题。访问条件的计算结果要么是true要么是false。</p><p>这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class Lock&#123;<br>    private boolean isLocked = false;<br>    public synchronized void lock()<br>        throws InterruptedException&#123;<br><span class="hljs-addition">+        //access condition</span><br><span class="hljs-addition">+        while(isLocked)&#123;</span><br>            wait();<br>        &#125;<br>        isLocked = true;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h2><p><strong>一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。</strong>换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果。</p><p>这里有两个状态变化的代码片段：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class Lock&#123;<br><br>    private boolean isLocked = false;<br><br>    public synchronized void lock()<br>        throws InterruptedException&#123;<br>        while(isLocked)&#123;<br>            wait();<br>        &#125;<br><span class="hljs-addition">+        //state change</span><br><span class="hljs-addition">+        isLocked = true;</span><br>    &#125;<br><br>    public synchronized void unlock()&#123;<br><span class="hljs-addition">+        //state change</span><br><span class="hljs-addition">+        isLocked = false;</span><br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class BoundedSemaphore &#123;<br>    private int signals = 0;<br>    private int bound   = 0;<br><br>    public BoundedSemaphore(int upperBound)&#123;<br>        this.bound = upperBound;<br>    &#125;<br><br>    public synchronized void take() throws InterruptedException&#123;<br>        while(this.signals == bound) wait();<br><span class="hljs-addition">+        //state change</span><br><span class="hljs-addition">+        this.signals++;</span><br>        this.notify();<br>    &#125;<br><br>    public synchronized void release() throws InterruptedException&#123;<br>        while(this.signals == 0) wait();<br><span class="hljs-addition">+        //state change</span><br><span class="hljs-addition">+        this.signals--;</span><br>        this.notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通知策略"><a href="#通知策略" class="headerlink" title="通知策略"></a>通知策略</h2><p>一旦某个线程改变了同步器的状态，可能需要通知其它等待的线程状态已经变了。因为也许这个状态的变化会让其它线程的访问条件变为true。</p><p>通知策略通常分为三种：</p><ol><li><p>通知所有等待的线程</p><p>通知所有等待的线程非常简单。所有等待的线程都调用的同一个对象上的wait()方法，某个线程想要通知它们只需在这个对象上调用notifyAll()方法。</p></li><li><p>通知N个等待线程中的任意一个</p><p>通知等待线程中的任意一个也很简单，只需将notifyAll()调用换成notify()即可。调用notify方法没办法确定唤醒的是哪一个线程，也就是“等待线程中的任意一个”。</p></li><li><p>通知N个等待线程中的某个指定的线程</p><p>有时候可能需要通知指定的线程而非任意一个等待的线程。例如，如果你想保证线程被通知的顺序与它们进入同步块的顺序一致，或按某种优先级的顺序来通知。想要实现这种需求，每个等待的线程必须在其自有的对象上调用wait()。当通知线程想要通知某个特定的等待线程时，调用该线程自有对象的notify()方法即可。</p></li></ol><p>下面是通知策略的一个例子（通知任意一个等待线程）：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff">public class Lock&#123;<br><br>    private boolean isLocked = false;<br><br>    public synchronized void lock()<br>        throws InterruptedException&#123;<br>        while(isLocked)&#123;<br>            //wait strategy - related to notification strategy<br>            wait();<br>        &#125;<br>        isLocked = true;<br>    &#125;<br><br>    public synchronized void unlock()&#123;<br>        isLocked = false;<br><span class="hljs-addition">+        notify(); //notification strategy</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Test-and-Set方法"><a href="#Test-and-Set方法" class="headerlink" title="Test-and-Set方法"></a>Test-and-Set方法</h2><p><code>test-and-set</code>其实就是包括了访问条件与状态变化。</p><p>同步器中最常见的有两种类型的方法，test-and-set是第一种（set是另一种）。Test-and-set的意思是，调用这个方法的线程检查访问条件，如若满足，该线程设置同步器的内部状态来表示它已经获得了访问权限。</p><p>状态的改变通常使其它试图获取访问权限的线程计算条件状态时得到false的结果，但并不一定总是如此。例如，在<a href="http://ifeve.com/read-write-locks/">读写锁</a>中，获取读锁的线程会更新读写锁的状态来表示它获取到了读锁，但是，只要没有线程请求写锁，其它请求读锁的线程也能成功。</p><p>test-and-set很有必要是原子的，也就是说在某个线程检查和设置状态期间，不允许有其它线程在test-and-set方法中执行。</p><p>test-and-set方法的程序流通常遵照下面的顺序：</p><ol><li>如有必要，在检查前先设置状态</li><li>检查访问条件</li><li>如果访问条件不满足，则等待</li><li>如果访问条件满足，设置状态，如有必要还要通知等待线程</li></ol><p>下面的<a href="http://ifeve.com/read-write-locks/">ReadWriteLock</a>类的lockWrite()方法展示了test-and-set方法。调用lockWrite()的线程在检查之前先设置状态(writeRequests++)。然后检查canGrantWriteAccess()中的访问条件，如果检查通过，在退出方法之前再次设置内部状态。这个方法中没有去通知等待线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLock</span></span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Thread, Integer&gt; readingThreads =<br>        <span class="hljs-keyword">new</span> HashMap&lt;Thread, Integer&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> writeAccesses    = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> writeRequests    = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> Thread writingThread = <span class="hljs-keyword">null</span>;<br>  <br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockWrite</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        writeRequests++;<br>        Thread callingThread = Thread.currentThread();<br>        <span class="hljs-keyword">while</span>(! canGrantWriteAccess(callingThread))&#123;<br>            wait();<br>        &#125;<br>        writeRequests--;<br>        writeAccesses++;<br>        writingThread = callingThread;<br>    &#125; <br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><p>set方法是同步器中常见的第二种方法。set方法仅是设置同步器的内部状态，而不先做检查。set方法的一个典型例子是Lock类中的unlock()方法。持有锁的某个线程总是能够成功解锁，而不需要检查该锁是否处于解锁状态。</p><p>set方法的程序流通常如下：</p><ol><li>设置内部状态</li><li>通知等待的线程</li></ol><p>这里是unlock()方法的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        isLocked = <span class="hljs-keyword">false</span>;<br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0017-嵌套监视器锁死</title>
    <link href="/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0017-%E5%B5%8C%E5%A5%97%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%E5%AE%9A/"/>
    <url>/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0017-%E5%B5%8C%E5%A5%97%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>前面我们说到过死锁产生的4个条件，其中前3个是可以说是由于锁的特性导致的，一般我们不可改变，只有第4个原因是人为导致的，即<strong>获取锁的顺序不一致导致的</strong>。</p><p>但是在某些情况下，即使获取锁的顺序一致，也有<strong>可能会导致类似死锁的情况，相互等待</strong>。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//lock implementation with nested monitor lockout problem</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> MonitorObject monitorObject = <span class="hljs-keyword">new</span> MonitorObject();<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>(isLocked)&#123;<br>                <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.monitorObject)&#123;<br>                    <span class="hljs-keyword">this</span>.monitorObject.wait();<br>                &#125;<br>            &#125;<br>            isLocked = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">this</span>.isLocked = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.monitorObject)&#123;<br>                <span class="hljs-keyword">this</span>.monitorObject.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看上面的代码，lock 与 unlock 方法都顺序获取两个锁，一个是 lock 对象本身，一个是 monitorObject 对象。</p><p>看上去没什么问题，但是注意一下，monitorObject 同步块下面的代码是一个相互唤醒的代码，这会导致下面的情况发生：</p><p>某一时刻，isLocked 为 true，这个时候，T1 获取到了 lock 对象的锁，然后接下来获取到了 monitorObjet 的锁，但是由于该 lock 锁已经被别人使用了，所以会进入 wait 方法，释放 monitorObject 锁。所以 T1 只持有 lock 对象的锁，然后等待别的线程唤醒。</p><p>然后切换到另一个线程 T2，这个线程是获取了 lock 锁（将 isLocked 置为 true）的线程，它执行完自己的代码之后，需要调用 unLock 方法了，然后发现 lock 对象被 T1 持有了，它无法进入 synchronized 里面，唤醒 T1 线程。</p><p>这样，T1 等待 T2 唤醒，但是 T2 又无法唤醒 T1（T1 持有 T2 需要的锁），这就与死锁比较类似，不过死锁都是阻塞在获取锁这里，而嵌套监视器锁定是一个线程阻塞在获取锁这里，另一个线程一直在 wait。</p><p>最后，由于 lock 锁被 T1 持有了，而后所有调用 lock 与 unlock 方法的线程都会被阻塞。另外，从这里也可以看出来，wait 只会释放对象上的锁。</p><p>看完上面的解释后，你可能会想，确实会有这样的情况，但是本公子天纵奇才，怎么可能会写这么搓的代码。那我们接下来看个不那么简化的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Fair Lock implementation with nested monitor lockout problem</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Thread lockingThread = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> List waitingThreads = <span class="hljs-keyword">new</span> ArrayList();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        QueueObject queueObject = <span class="hljs-keyword">new</span> QueueObject();<br><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            waitingThreads.add(queueObject);<br><br>            <span class="hljs-keyword">while</span>(isLocked ||<br>                  waitingThreads.get(<span class="hljs-number">0</span>) != queueObject)&#123;<br><br>                <span class="hljs-keyword">synchronized</span>(queueObject)&#123;<br>                    <span class="hljs-keyword">try</span>&#123;<br>                        queueObject.wait();<br>                    &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                        waitingThreads.remove(queueObject);<br>                        <span class="hljs-keyword">throw</span> e;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            waitingThreads.remove(queueObject);<br>            isLocked = <span class="hljs-keyword">true</span>;<br>            lockingThread = Thread.currentThread();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lockingThread != Thread.currentThread())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException(<br>                <span class="hljs-string">&quot;Calling thread has not locked this lock&quot;</span>);<br>        &#125;<br>        isLocked = <span class="hljs-keyword">false</span>;<br>        lockingThread = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(waitingThreads.size() &gt; <span class="hljs-number">0</span>)&#123;<br>            QueueObject queueObject = waitingThread.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">synchronized</span>(queueObject)&#123;<br>                queueObject.notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子基本上是与前面“饥饿与公平”的最后一个例子一样。但是不同的地方在于，“饥饿与公平”的例子中，lock 方法的 synchronized 里面没有嵌套 synchronized(queueObject)，而在这个例子中，显然是一个监视器嵌套的情况。</p><p>与之前的例子仅仅又一步之差，但是却引发出一个重大的bug。</p><h2 id="嵌套监视器锁死-VS-死锁"><a href="#嵌套监视器锁死-VS-死锁" class="headerlink" title="嵌套监视器锁死 VS 死锁"></a>嵌套监视器锁死 VS 死锁</h2><p>嵌套监视器锁死与死锁很像：都是线程最后被一直阻塞着互相等待。</p><p>但是两者又不完全相同。在死锁中我们已经对死锁有了个大概的解释，死锁通常是因为两个线程获取锁的顺序不一致造成的，线程1锁住A，等待获取B，线程2已经获取了B，再等待获取A。如死锁避免中所说的，死锁可以通过总是以相同的顺序获取锁来避免。</p><p>发生嵌套管程锁死时锁获取的顺序是一致的。线程1获得A和B，然后释放B，等待线程2的信号。线程2需要同时获得A和B，才能向线程1发送信号。所以，一个线程在等待唤醒，另一个线程在等待想要的锁被释放。</p><p>不同点归纳如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">死锁中，二个线程都在等待对方释放锁。<br><br>嵌套管程锁死中，线程<span class="hljs-number">1</span>持有锁<span class="hljs-selector-tag">A</span>，同时等待从线程<span class="hljs-number">2</span>发来的信号，线程<span class="hljs-number">2</span>需要锁<span class="hljs-selector-tag">A</span>来发信号给线程<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0018-失效的数据</title>
    <link href="/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0018-%E5%A4%B1%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0018-%E5%A4%B1%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>原文叫做 “Slipped Conditions”，这个不太好翻译，所以我就借用一下《Java并发编程实战》的一节的标题了，讲的东西差不多。</p><p>直接看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>(isLocked)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-keyword">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>                    <span class="hljs-comment">//do nothing, keep waiting</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>            isLocked = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        isLocked = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看 lock 方法，里面有两个同步代码块，第一个同步代码块里面使用 isLocked 作为条件判断，却在第二个同步代码块里面更新了 isLocked 这个值。</p><p>这样的写就会很容易产生问题：</p><p>当一个线程 T1 执行完第一个同步代码块之后，可能就失去了CPU时间片执行的机会，然后另外一个线程 T2 就可以若无其事的也进入到 lock 方法里面，并且由于第一个线程 T1 没有更新 isLocke 的值，所以 T2 进入第一个同步代码块之后不会进入 wait 方法，这样就相当于有两个线程同时获取了 lock 锁。</p><p>这个场景就是“slipped conditions”的例子。</p><p>当 T1 进入第一个同步代码块后，从它使用 isLocked 这个值开始，一直到它更新 isLocke 值后，这个期间应该是不允许别的线程访问的，其他线程访问了就是使用了失效的数据。</p><p>所以我们应该让<strong>使用条件</strong>与<strong>更新条件</strong>这两个地方为原子的。也就是说，在第一个线程检查和设置条件期间，不会有其它线程使用这个条件。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0019-锁的可重入性</title>
    <link href="/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0019-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <url>/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0019-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>synchronized 就是可重入的，看下面的实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ++count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span> </span>&#123;<br>        inc();<br>        <span class="hljs-keyword">return</span> --count;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子没什么意义，我们可以不用在意。</p><p>但是注意一下它的 dec 方法，在这个方法里面它又调用了 inc 方法，而 inc 与 dec 方法都有 synchronized 修饰。如果 synchronized 不可重入的话，线程在执行 dec 方法的时候，会阻塞在对 inc 方法的调用上。但是实际情况是没有的，所以 synchronized 肯定是可重入的。</p><p>再回想一下我们前面写的例子，Lock 与 FairLock 这两个锁是可重入的吗？</p><p>先看 Lock 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked      = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">private</span> Thread lockingThread = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(isLocked)&#123;<br>            wait();<br>        &#125;<br><br>        isLocked = <span class="hljs-keyword">true</span>;<br>        lockingThread = Thread.currentThread();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lockingThread != Thread.currentThread())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException(<br>                <span class="hljs-string">&quot;Calling thread has not locked this lock&quot;</span>);<br>        &#125;<br><br>        isLocked = <span class="hljs-keyword">false</span>;<br>        lockingThread = <span class="hljs-keyword">null</span>;<br>        notify();<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>当一个线程 T 进入 lock 方法之后，会将 isLocked 置为 true，如果这个时候，再次调用 lock 方法的话，会发生什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 连续调用调用 lock 方法</span><br>myLock.lock();<br><span class="hljs-comment">// do something</span><br>myLock.lock();<br></code></pre></td></tr></table></figure><p>在第二次调用 lock 方法的时候，由于 isLocked 已经变为 true 了，所以会进入 wait 方法，导致该线程休眠了，这就不是一个可重入的锁，正常情况下它不应该休眠。</p><p>那么应该如何解决这个问题呢？</p><p>我们想想，发现如果是<strong>同一个线程</strong>多次获取锁的话，就不应该进入 wait 方法。所以我们需要特殊处理一下，而且，获取锁多少次还应该释放锁多少次。</p><p>看看改进之后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;<br>    <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br>    Thread  lockedBy = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lockedCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Thread callingThread =<br>            Thread.currentThread();<br>        <span class="hljs-keyword">while</span>(isLocked &amp;&amp; lockedBy != callingThread)&#123;<br>            wait();<br>        &#125;<br>        isLocked = <span class="hljs-keyword">true</span>;<br>        lockedCount++;<br>        lockedBy = callingThread;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Thread.curentThread() ==<br>           <span class="hljs-keyword">this</span>.lockedBy)&#123;<br>            lockedCount--;<br><br>            <span class="hljs-keyword">if</span>(lockedCount == <span class="hljs-number">0</span>)&#123;<br>                isLocked = <span class="hljs-keyword">false</span>;<br>                notify();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看 lock 方法：</p><blockquote><p>在进入 wait 之前，先判断了当前线程是不是获取了锁的线程，如果是则不需要 wait。然后记录了获取锁的次数。</p></blockquote><p>在看 unlock 方法：</p><blockquote><p>首先就判断了当前线程是不是获取了锁的线程，不是的话，就不用走下面的逻辑了，是的话就notify，减少获取锁的次数。</p></blockquote><p>这样，我们就实现了一个可重入锁了，其实还是蛮简单的，就是<strong>记录了一下锁的获取次数以及判断一下当前线程是不是获取了锁的线程</strong>。</p><p>有一个需要注意的地方：<strong>在finally语句中调用unlock()</strong></p><p>如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//do critical section code,</span><br>    <span class="hljs-comment">//which may throw exception</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁</strong>。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。</p><p>FairLock 与 Lock 的核心代码其实是差不多的，所以就不讲了。</p><p>synchronized 不用这样是因为，java文件在被编译为 class 文件的时候就已经做了这些操作。比如，我们查看一个 class 文件的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>: monitorenter  <span class="hljs-comment">//进入同步方法</span><br><span class="hljs-comment">//..........省略其他  </span><br><span class="hljs-number">15</span>: monitorexit   <span class="hljs-comment">//退出同步方法</span><br><span class="hljs-number">16</span>: goto          <span class="hljs-number">24</span><br><span class="hljs-comment">//省略其他.......</span><br><span class="hljs-number">21</span>: monitorexit <span class="hljs-comment">//退出同步方法</span><br></code></pre></td></tr></table></figure><p>发现，有两个 monitorexit，第二个 monitorexit 就是用来处理发生异常的情况的。再看第一个 monitorexit 后面有一个 goto，说明如果不出现异常是不会走第二个 monitorexit 的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0020-信号量</title>
    <link href="/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0020-%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <url>/2019/08/22/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0020-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失，或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理。</p><p>之前就在实现公平锁的时候就实现了一个类似信号量的东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> signal = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.signal = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.signal) wait();<br>        <span class="hljs-keyword">this</span>.signal = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑前面已经解释过多次了，所以这里就不再赘述了。</p><p>唯一需要注意的是，<strong>这里的 take 与 release 的意思与我们理解的意思是相反的</strong>。take 表示产生了一个信号，release 表示消耗了一个信号。在这里例子中显得很反常，但是在本文的最后一个例子中就会发现很合理。</p><p>上面的例子是一个简单的信号量，那么它可以做什么呢？</p><ul><li>可以在两个线程之间通信</li></ul><p>如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore();<br>SendingThread sender = <span class="hljs-keyword">new</span> SendingThread(semaphore)；<br>ReceivingThread receiver = <span class="hljs-keyword">new</span> ReceivingThread(semaphore);<br>receiver.start();<br>sender.start();<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SendingThread</span> </span>&#123;<br><br>    Semaphore semaphore = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SendingThread</span><span class="hljs-params">(Semaphore semaphore)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//do something, then signal</span><br>        <span class="hljs-keyword">this</span>.semaphore.take();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecevingThread</span> </span>&#123;<br><br>    Semaphore semaphore = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReceivingThread</span><span class="hljs-params">(Semaphore semaphore)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.semaphore.release();<br>        <span class="hljs-comment">//receive signal, then do something...</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>SendingThread 线程执行到  this.semaphore.take(); 的时候会阻塞，然后等待 RecevingThread 执行到 this.semaphore.release(); 才会醒过来，继续执行自己的代码。</p><p>信号量可以用在线程需要配合的地方。</p><p>下面我们对信号量进行增强。</p><h2 id="可计数的信号量"><a href="#可计数的信号量" class="headerlink" title="可计数的信号量"></a>可计数的信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSemaphore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> signals = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.signals++;<br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.signals == <span class="hljs-number">0</span>) wait();<br>        <span class="hljs-keyword">this</span>.signals--;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个可计数的也没啥意义，我们再增加一下功能。</p><h2 id="带上界的信号量"><a href="#带上界的信号量" class="headerlink" title="带上界的信号量"></a>带上界的信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedSemaphore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> signals = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bound   = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BoundedSemaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> upperBound)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.bound = upperBound;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.signals == bound)<br>            wait();<br>        <span class="hljs-keyword">this</span>.signals++;<br>        <span class="hljs-comment">// 这里调用 notify，是用来唤醒 release 导致的阻塞的线程</span><br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">this</span>.signals == <span class="hljs-number">0</span>)<br>            wait();<br>        <span class="hljs-keyword">this</span>.signals--;<br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当已经产生的信号数量达到了上限，take方法将阻塞新的信号产生请求，直到某个线程调用release方法后，被阻塞于take方法的线程才能传递自己的信号。</p><p>BoundedSemaphore 其实可以当作锁来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">BoundedSemaphore semaphore = <span class="hljs-keyword">new</span> BoundedSemaphore(<span class="hljs-number">1</span>);<br>...<br>semaphore.take();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//critical section</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    semaphore.release();<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的例子中，Semaphore被用来在多个线程之间传递信号，这种情况下，take和release分别被不同的线程调用。</p><p>但是在锁这个例子中，take和release方法将被同一线程调用，因为只允许一个线程来获取信号（允许进入关键区域的信号），其它调用take方法获取信号的线程将被阻塞，直到第一个调用take方法的线程调用release方法来释放信号。对release方法的调用永远不会被阻塞，这是因为任何一个线程都是先调用take方法，然后再调用release。</p><p>通过有上限的Semaphore可以限制进入某代码块的线程数量。设想一下，在上面的例子中，如果BoundedSemaphore 上限设为5将会发生什么？意味着允许5个线程同时访问关键区域，但是你必须保证，这个5个线程不会互相冲突。否则你的应用程序将不能正常运行。</p><p>必须注意，release方法应当在finally块中被执行。这样可以保在关键区域的代码抛出异常的情况下，信号也一定会被释放。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的滑动处理（三）</title>
    <link href="/2019/08/21/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2019/08/21/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="ViewDragHelper-定义"><a href="#ViewDragHelper-定义" class="headerlink" title="ViewDragHelper 定义"></a>ViewDragHelper 定义</h2><p>Android 官方对 ViewDragHelper 的定义是：</p><ul><li>可以用于自定义 ViewGroup</li><li>可以进行拖拽移动或者重新定位ViewGroup中子视图View</li><li>提供有效操作和状态追踪</li></ul><p>##使用 ViewDragHelper</p><p>下面说说，如何使用 ViewDragHelper（下面简称 VDH） 。</p><p>创建一个 VDH 对象：</p><blockquote><p>androidx.customview.widget.ViewDragHelper#create(android.view.ViewGroup, androidx.customview.widget.ViewDragHelper.Callback)</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> static ViewDragHelper create(<span class="hljs-meta">@NonNull</span> ViewGroup forParent, <span class="hljs-meta">@NonNull</span> Callback cb) &#123;<br>    <span class="hljs-keyword">return</span> new ViewDragHelper(forParent.getContext(), forParent, cb);<br>&#125;<br></code></pre></td></tr></table></figure><p>VDH 构造函数是私有的，但是有多个可供访问的静态方法。使用它就可以创建一个 VDH 对象。</p><p>上面的静态方法中，cb 参数很重要，因为，<strong>ViewDragHelper.Callback是用来连接ViewDragHelper和parent view的</strong>。</p><p>要让VDH能够处理相关的拖动事件就需要<strong>将拖动时触发事件状态传给VDH</strong>，所以我们要针对onInterceptTouchEvent、onTouchEvent 做特别的处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> viewDragHelper.shouldInterceptTouchEvent(ev!!)<br>&#125;<br></code></pre></td></tr></table></figure><p>直接委托给 vdh，让它判断是否需要拦截事件，如果这里有自己的逻辑，也可以添加，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">val</span> myIntercept = someCondition(ev)<br>    <span class="hljs-keyword">return</span> myIntercept and viewDragHelper.shouldInterceptTouchEvent(ev!!)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，就是 onTouchEvent，一般情况下，自定义ViewGroup，而 ViewGroup 默认不会处理事件，所以我们需要在 ACTION_DOWN 的时候，处理这个事件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SuppressLint(<span class="hljs-meta-string">&quot;ClickableViewAccessibility&quot;</span>)</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br><br>    <span class="hljs-comment">// 在这里，将事件传递给 VDH，让它去处理</span><br>    viewDragHelper.processTouchEvent(event!!)<br><br>    <span class="hljs-comment">// 处理下 down 事件按，让后续事件都传过来</span><br>    <span class="hljs-keyword">if</span> (event.action == MotionEvent.ACTION_DOWN) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(event)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面，看看 ViewDragHelper.Callback 中的几个常用方法：</p><blockquote><p>pointerId：区分多点触控时的 id position</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">tryCaptureView</span><span class="hljs-params">(child: <span class="hljs-type">View</span>, pointerId: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-comment">// 限制指定的控件才可以拖动</span><br>    <span class="hljs-keyword">return</span> child.id == R.id.video<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getViewVerticalDragRange</span><span class="hljs-params">(child: <span class="hljs-type">View</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> verticalRange<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法，需要返回一个大于0的数，然后指定的 View 才会在垂直方向移动。我试过，只要大于 0 即可，似乎没有别的要求。暂时没有去探究这个值有什么意义。</p><blockquote><p>top： 表示拖动指定 view 时，view 的 top 值</p><p>dy ：是每次的差值</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clampViewPositionVertical</span><span class="hljs-params">(child: <span class="hljs-type">View</span>, top: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-comment">// 限制竖向拖动的范围为 【0，verticalRange】</span><br>    <span class="hljs-keyword">val</span> min = Math.min(top, verticalRange)<br>    <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">0</span>, min)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，是将 top 的值限制了，避免 view 被拖出指定的范围。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewPositionChanged</span><span class="hljs-params">(changedView: <span class="hljs-type">View</span>, left: <span class="hljs-type">Int</span>, top: <span class="hljs-type">Int</span>, dx: <span class="hljs-type">Int</span>, dy: <span class="hljs-type">Int</span>)</span></span> &#123;<br>            <span class="hljs-keyword">super</span>.onViewPositionChanged(changedView, left, top, dx, dy)<br>            changeVideo(changedView, top)<br>            changeVideoDetail(top)<br>            changeVideoTitle(top)<br>            changePlayButton(top)<br>            changeCloseButton(top)<br>        &#125;<br></code></pre></td></tr></table></figure><p>这个方法表示，当指定的 View 被拖动时，这个方法就会被回调，然后我们就可以在这个方法里面做一些操作，比如改变另外的View 的位置，这样就可以实现一个联动效果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewReleased</span><span class="hljs-params">(releasedChild: <span class="hljs-type">View</span>, xvel: <span class="hljs-type">Float</span>, yvel: <span class="hljs-type">Float</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onViewReleased(releasedChild, xvel, yvel)<br>&#125;<br></code></pre></td></tr></table></figure><p>当指定的View 被释放的时候（手指抬起等），这个方法会被回调。如果我们想要一个回弹效果，在这里处理是一个很好的解决方法。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewReleased</span><span class="hljs-params">(releasedChild: <span class="hljs-type">View</span>, xvel: <span class="hljs-type">Float</span>, yvel: <span class="hljs-type">Float</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onViewReleased(releasedChild, xvel, yvel)<br>    dragHelper.settleCapturedViewAt(mDragOriLeft , mDragOriLeft)<br>    invalidate()<br>&#125;<br></code></pre></td></tr></table></figure><p>settleCapturedViewAt 是 VDH 提供的一个方法，实际上是使用的 scroller，所以调用这个方法，还需要和使用 Scroller 一样，<strong>实现 computeScroll 方法</strong>。</p><p>还有一些判断边缘拖拽的方法就不介绍了，我实现了一些效果，给我的感觉用起来还是挺方便的。</p><p>但是这里有一个问题，就是如果你想实现一些很复杂的效果，其实核心不在拖拽的处理上，而是在一些计算方面，就比如你想要一个回弹效果，直接使用 scroller 可以实现，但是这个回弹效果很普通，UI想要更加炫酷的回弹效果。这个时候考验的不是你对View的理解，<strong>而是你对数学的理解</strong>。就像我刚接触自定义控件的时候，看的aige的系列文章，其中有一个翻书效果，要想实现这个效果，如果你没有空间想象能力，没有一定的数学知识，无论你对View的绘制，对各种工具有多么熟练，你仍然无从下手。</p><p>我实现的一些demo：</p><p><a href="https://github.com/aprz512/NestedScrollingDemos"><strong>NestedScrollingDemos</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0016-饥饿与公平</title>
    <link href="/2019/08/21/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0016-%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/"/>
    <url>/2019/08/21/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0016-%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3/</url>
    
    <content type="html"><![CDATA[<p>在多线程程序中，有可能出现这样的情况：某个线程由于得不到CPU的时间片，导致这个线程永远无法执行。这种情况就叫做“饥饿”。</p><p>解决“饥饿”的方案叫“公平性”，即让每个线程都有机会获得CPU得运行机会。</p><h2 id="“饥饿”的原因"><a href="#“饥饿”的原因" class="headerlink" title="“饥饿”的原因"></a>“饥饿”的原因</h2><p>先来说一下导致“饥饿”得几个原因：</p><ul><li><p>高优先级线程吞噬低优先级线程的CPU时间</p><p>你可以为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台<strong>。对大多数应用来说，你最好是不要改变其优先级值</strong>。</p></li><li><p>线程被一直因为获取不到锁而阻塞，因为 <code>synchronized</code> 是非公平锁，所以有可能线程永远得不到锁。</p><p>Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在<strong>一个试图进入该同步区的线程处于被永久堵塞</strong>的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。</p></li><li><p>线程一直处于 wait 状态，因为 notify 总是随机唤醒一个，所以有可能线程永远不会被唤醒。</p><p>如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p></li></ul><h2 id="实现“公平性”"><a href="#实现“公平性”" class="headerlink" title="实现“公平性”"></a>实现“公平性”</h2><p>文章原文说了这样的一句话：</p><blockquote><p>While it is not possible to implement 100% fairness in Java we can still implement our synchronization constructs to increase fairness between threads.</p></blockquote><p>我也不知道为啥不能100%实现。暂且放过。</p><p>下面，我们来自己实现一个锁，不要方，很简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Synchronizer</span></span>&#123;<br>    Lock lock = <span class="hljs-keyword">new</span> Lock();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSynchronized</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        <span class="hljs-keyword">this</span>.lock.lock();<br>        <span class="hljs-comment">//critical section, do a lot of work which takes a long time</span><br>        <span class="hljs-keyword">this</span>.lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子里面所使用的 Lock 就是我们需要实现的锁了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked      = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">private</span> Thread lockingThread = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br><br>        <span class="hljs-keyword">while</span>(isLocked)&#123;<br>            wait();<br>        &#125;<br><br>        isLocked = <span class="hljs-keyword">true</span>;<br><br>        lockingThread = Thread.currentThread();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lockingThread != Thread.currentThread())&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException(<br>                <span class="hljs-string">&quot;Calling thread has not locked this lock&quot;</span>);<br>        &#125;<br><br>        isLocked = <span class="hljs-keyword">false</span>;<br>        lockingThread = <span class="hljs-keyword">null</span>;<br><br>        notify();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lock 方法</strong>：多个线程访问该方法的时候，只有第一个获得 synchronized 锁的线程才能进入 lock 方法，然后将 isLocked 置为true，其余的线程获得 synchronized 锁之后，只能进入 wait 方法。</p><p><strong>unlock 方法</strong>：该方法重新将 isLocked 置为 false，这样其他线程才能跳出 wait 所在的循环。调用 notify 之后，由于多个线程使用的是同一个锁，所以将随机唤醒一个线程。</p><p>我们仔细想一下，<strong>lock 方法也是一个同步代码块，但是线程基本不会在同步代码块上阻塞（同步代码块很短），而是都阻塞到了 wait 方法上</strong>。</p><p>虽然，notify 唤醒的时候，是随机唤醒一个阻塞在同一个对象上的线程。但是这里就是我们可以优化的点了！！！<strong>因为如果我们让每个线程都阻塞在不同对象的 wait 方法上，这样我们只需要公平的调用这些对象的 notify 方法就可以实现公平性了</strong>。</p><p>为了实现公平性，我们还需要一个队列，用来存储线程到来的顺序，按照到来的顺序来唤醒线程，实现公平性。</p><p>看下面的代码，一个简易的公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isLocked = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">private</span> Thread lockingThread = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> List&lt;QueueObject&gt; waitingThreads = <span class="hljs-keyword">new</span> ArrayList&lt;QueueObject&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        QueueObject queueObject = <span class="hljs-keyword">new</span> QueueObject();<br>        <span class="hljs-keyword">boolean</span> isLockForThisThread = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            waitingThreads.add(queueObject);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (isLockForThisThread) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                isLockForThisThread =<br>                    !isLocked &amp;&amp; waitingThreads.get(<span class="hljs-number">0</span>) == queueObject;<br>                <span class="hljs-keyword">if</span> (isLockForThisThread) &#123;<br>                    isLocked = <span class="hljs-keyword">true</span>;<br>                    waitingThreads.remove(queueObject);<br>                    lockingThread = Thread.currentThread();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                queueObject.doWait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    waitingThreads.remove(queueObject);<br>                &#125;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lockingThread != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException(<br>                <span class="hljs-string">&quot;Calling thread has not locked this lock&quot;</span>);<br>        &#125;<br>        isLocked = <span class="hljs-keyword">false</span>;<br>        lockingThread = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (waitingThreads.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            waitingThreads.get(<span class="hljs-number">0</span>).doNotify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueObject</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isNotified = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">while</span>(!isNotified)&#123;<br>            <span class="hljs-keyword">this</span>.wait();<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.isNotified = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isNotified = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.notify();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == o;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们先说 QueueObject 类，它其实就是一个信号量。doWait 方法里面使用了循环，避免假唤醒。同时也储存了唤醒信号，避免信号丢失。这个类还是很好理解的，就是将 Object 的 wait 与 notify 增强了一下。</p><p>再来看 FairLock 类。别看代码有点复杂，但是逻辑基本没变。比如 lock 方法：</p><p>首先为每个线程都创建一个锁对象，然后放入队列里面。</p><p>接下来仍然是一个 while 循环，只不过这个循环的变量需要注意一下，原先只要判断是否已经有线程把锁拿走了，现在还需要在这个基础上判断，是否当前线程是队列里面的第一个线程（只有第一个有资格运行，这样才公平）。然后仍然是调用 wait 方法。</p><p><strong>再来仔细的对比一下，FairLock 与 Lock 的区别</strong>：</p><p>lock()方法不再声明为synchronized，取而代之的是只对必需同步的代码进行同步。</p><p>调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在<strong>同一时间仅有一个等待线程（头部的）获得唤醒</strong>，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。</p><p><strong>queueObject.doWait()调用放置在synchronized(this)块之外，以避免监视器嵌套锁死的情况（下一篇会讲）</strong>。</p><p>最后，注意到queueObject.doWait()的try – catch块，在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。</p><h2 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h2><p>如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。</p><p>这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。</p><p>究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的滑动处理（二）</title>
    <link href="/2019/08/20/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/08/20/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="CoordinatorLayout-Behavior"><a href="#CoordinatorLayout-Behavior" class="headerlink" title="CoordinatorLayout.Behavior"></a>CoordinatorLayout.Behavior</h2><p>CoordinatorLayout 根据 <a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html">官方文档</a> 的描述，它是一个“<em>超级FrameLayout</em>“，专门用来帮助实现布局中的View相互交互。我们只需要为布局里面的 Views 创建自定义的或者分配现有的 <strong>Behavior</strong> 即可。<strong>Behavior</strong> 是 <em>Material Design</em> 独一无二的核心，例如滑动抽屉和面板，滑动消失元素，和跟随其他空间移动的按钮等等。</p><p>我们先来看看 Behavior 是如何工作的，后面还会配上几个例子便于理解。</p><p>Behavior 用来表示同一个布局中2个或者2个以上的控件之间的交互。通常分为以下几类：</p><h3 id="Layout-Based-Behaviors"><a href="#Layout-Based-Behaviors" class="headerlink" title="Layout-Based Behaviors:"></a>Layout-Based Behaviors:</h3><p>先来看一个效果图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/1_FBOsM15NY4pFSXjhots-IQ.gif?raw=true"> </p><p>当 snackbar 从底部出现的时候，FAB 会立即向上平移一个 SnackBar 的高度。</p><p><strong>Anchoring</strong> 是 <strong>Layout-Based Behaviors</strong> 的一种，比如我们将 FAB <strong>anchored to</strong> AppBarLayout，看下面的效果图（注意观察红色的类似短信图标的按钮）：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/1_fVKOTpH7S2ZlGrpmLcuyZQ.gif?raw=true"></p><p>可以看到 FAB 随着 AppBarLayout 在移动，而且最后还会消失。这种 anchored to 的行为，在 CoordinatorLayout 中对应着一个属性，我们下面会说到。</p><h3 id="Scroll-Based-Behaviors"><a href="#Scroll-Based-Behaviors" class="headerlink" title="Scroll-Based Behaviors"></a>Scroll-Based Behaviors</h3><p>还是看上面的图，这次不看 FAB，而是观察下面的长文本。TextView 本身是不可滚动的，所以它的外面有一层 NestedScrollView 包裹。</p><p>一个 CoordinatorLayout 中有两个可以滚动的控件，一个是 AppBarLayout，一个是 NestedScrollView 。通过效果图，可以看出，他们并没有产生冲突，而是将滑动联动起来了，我们向上滚动 NestedScrollView  的时候，会向将 AppBarLayout 往上推，推到顶部之后，NestedScrollView  才开始滚动，之间没有停顿，无缝衔接。</p><p>之所以能够产生这样的行为，是因为这两个控件都被分配了一个 Behavior。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CoordinatorLayout</span>.DefaultBehavior(AppBarLayout.Behavior.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppBarLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearLayout</span> </span>&#123;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;android.support.v4.widget.NestedScrollView<br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    app:layout_behavior=<span class="hljs-string">&quot;@string/appbar_scrolling_view_behavior&quot;</span><br>    &gt;<br></code></pre></td></tr></table></figure><h3 id="Implementing-the-Behaviors"><a href="#Implementing-the-Behaviors" class="headerlink" title="Implementing the Behaviors"></a>Implementing the Behaviors</h3><p>介绍完了两类 Behaviors，接下来我们看看如何自定义一个 Behavior。</p><p>首先，我们的 Behavior 必须继承至 Coordinator.Behaviors&lt;V&gt;，V 就是需要这个Behavior 的控件的类型。比如我想给 TextView 指定一个 Behavior，那么 V 就是 TextView 类型。</p><p>然后，Coordinator.Behaviors&lt;V&gt; 有一些方法需要覆盖来达到我们想要的效果，其中有3个方法尤其重要（额，还有滚动相关的方法，与第一篇是以一样的就不介绍了）。</p><h4 id="layoutDependsOn-…"><a href="#layoutDependsOn-…" class="headerlink" title="layoutDependsOn(…)"></a>layoutDependsOn(…)</h4><p>这个方法用来决定，当前 View 需要依赖哪个 View。比如你需要根据同一布局中的 ImageView 的位置来决定自己的位置，那么就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(parent: <span class="hljs-type">CoordinatorLayout</span>, child: <span class="hljs-type">View</span>, dependency: <span class="hljs-type">View</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> dependency <span class="hljs-keyword">is</span> ImageView<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的返回值，true 表示当前 View 是有依赖对象的，反之则无。但它返回 false 的时候，onDependentViewChanged 方法不会被调用。</p><p>嗯，有一种情况我还没有搞清楚，当我们新建一个空项目的时候，模板选择第一个，那么我们的MainActivity 的布局是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/cl&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.appbar.AppBarLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/AppTheme.AppBarOverlay&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">androidx.appcompat.widget.Toolbar</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toolbar&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;?attr/actionBarSize&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?attr/colorPrimary&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">app:popupTheme</span>=<span class="hljs-string">&quot;@style/AppTheme.PopupOverlay&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">com.google.android.material.appbar.AppBarLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/content_main&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fab&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom|end&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">&quot;@dimen/fab_margin&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@android:drawable/ic_dialog_email&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.coordinatorlayout.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到最下面有一个 FloatingActionButton。</p><p>MainActivity 的部分代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_main)<br>    setSupportActionBar(toolbar)<br><br>    fab.setOnClickListener &#123; view -&gt;<br>        Log.e(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;h = <span class="hljs-subst">$&#123;cl.measuredHeight&#125;</span>&quot;</span>)<br>        Snackbar.make(view, <span class="hljs-string">&quot;Replace with your own action&quot;</span>, Snackbar.LENGTH_LONG)<br>            .setAction(<span class="hljs-string">&quot;Action&quot;</span>, <span class="hljs-literal">null</span>).show()<br>        Log.e(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;h = <span class="hljs-subst">$&#123;cl.measuredHeight&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们点击 FAB 的时候，发现，随着 Snackbar 的出现， FAB 上移了，而且 <strong>CoordinatorLayout 的高度并没有改变</strong>，也就是说，FAB ”<em>依赖</em>“了 Snackbar ，随着 Snackbar 的上移，FAB 也移动了自己的位置。</p><p>那么，我找了以下 FAB 的 Behavior 源码，发现它的 layoutDependsOn 返回了 false（它根本就没有复写这个方法）。那么它是怎么做到的呢？</p><p>我在源码里面发现了这样的一个字段：</p><blockquote><p>androidx.coordinatorlayout.widget.CoordinatorLayout.LayoutParams</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A &#123;<span class="hljs-doctag">@link</span> Gravity&#125; value describing how this child view dodges any inset child views in</span><br><span class="hljs-comment"> * the CoordinatorLayout. Any views which are inset on the same edge as this view is set to</span><br><span class="hljs-comment"> * dodge will result in this view being moved so that the views do not overlap.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> dodgeInsetEdges = Gravity.NO_GRAVITY;<br></code></pre></td></tr></table></figure><p>然后我在布局里面添加了一个 View，设置了如下属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/test&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom|end&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">&quot;@dimen/fab_margin&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_dodgeInsetEdges</span>=<span class="hljs-string">&quot;bottom&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>运行之后，果然可以跟随 Snackbar 。那么现在可以得出结论，FAB 跟随 Snackbar 是 CoordinatorLayout 自带的功能，与 Behavior 没有关系。</p><p>但是这里还是有一个疑问，CoordinatorLayout  是从哪里获取到 Snackbar  的高度的？？？</p><h4 id="onDependentViewChanged-…"><a href="#onDependentViewChanged-…" class="headerlink" title="onDependentViewChanged(…)"></a>onDependentViewChanged(…)</h4><p>一旦我们确定了依赖关系，那么就可以根据依赖关系来处理交互逻辑了。比如：我想让一个 TextView 跟随 ImageView 的底部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">override fun <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(parent: CoordinatorLayout, child: TextView, dependency: View)</span>: Boolean </span>&#123;<br>    <span class="hljs-comment">// 让 child 跟随 dependency 的底部</span><br>    val bottom = dependency.y.roundToInt() + dependency.height<br>    child.top = bottom<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们让 child （TextView）的 top 值等于 dependency （ImageView）的 bottom 值就可以达到我们想要的效果了。</p><h4 id="onDependentViewRemoved-…"><a href="#onDependentViewRemoved-…" class="headerlink" title="onDependentViewRemoved(…)"></a>onDependentViewRemoved(…)</h4><p>这个方法看名字就很好理解了，就是当依赖的View被删除的时候，会调用这个方法。</p><h3 id="例子项目"><a href="#例子项目" class="headerlink" title="例子项目"></a>例子项目</h3><p><a href="https://github.com/aprz512/NestedScrollingDemos"><strong>NestedScrollingDemos</strong></a></p><p>这个项目里面的例子有很详细的注释，可以参考。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0013-ThreadLocal</title>
    <link href="/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0013-ThreadLocal/"/>
    <url>/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0013-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<p>ThreadLocal类创建的变量会给每个线程都分配一份，虽然每个线程都持有的是执行同一个ThreadLocal对象的引用，但是获取的（调用 get 方法）确实不同的对象。</p><h2 id="创建-ThreadLocal-对象"><a href="#创建-ThreadLocal-对象" class="headerlink" title="创建 ThreadLocal 对象"></a>创建 ThreadLocal 对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal myThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal();<br></code></pre></td></tr></table></figure><p>这个好理解，与普通Java类一样使用即可。</p><h2 id="储存值"><a href="#储存值" class="headerlink" title="储存值"></a>储存值</h2><p>当创建好了 ThreadLocal 之后，我们就可以往里面储存值了，就像 ThreadLocal 是一个容器一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadLocal 支持泛型</span><br><span class="hljs-keyword">private</span> ThreadLocal myThreadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal&lt;String&gt;();<br><br><span class="hljs-comment">// 储存一个 string 对象</span><br>myThreadLocal1.set(<span class="hljs-string">&quot;Hello ThreadLocal&quot;</span>);<br>String threadLocalValues = myThreadLocal.get();<br></code></pre></td></tr></table></figure><p>嗯，获取用 String 来当作例子有点不恰当，没法看出它是不是同一个对象，我们稍微改变一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadLocal 支持泛型</span><br><span class="hljs-keyword">private</span> ThreadLocal myThreadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal&lt;Object&gt;();<br><br><span class="hljs-comment">// 储存一个 string 对象</span><br>myThreadLocal1.set(<span class="hljs-keyword">new</span> Object());<br>Object o = myThreadLocal.get();<br>System.out.println(o.hashcode())<br></code></pre></td></tr></table></figure><p>在不同的线程里面执行，打印 hashCode 会发现是不同的值，即不同的线程 set 与 get 获取的都是属于自己的那一份，无法获取别的线程的，别的线程也获取不到自己的。</p><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><p>ThreadLocal 还可以指定一个初始值，即当没有执行 set 方法的时候，get 方法也能取出初始值来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;Object&gt; threadLocal = ThreadLocal.withInitial(Object::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><p>这个<strong>初始值也是每个线程都有一份</strong>，每个线程获取的也是不同的对象，而不是同一个对象。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal =<br>            <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;();<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            threadLocal.set( (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">100D</span>) );<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br><br>            System.out.println(threadLocal.get());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyRunnable sharedRunnableInstance = <span class="hljs-keyword">new</span> MyRunnable();<br><br>        Thread thread1 = <span class="hljs-keyword">new</span> Thread(sharedRunnableInstance);<br>        Thread thread2 = <span class="hljs-keyword">new</span> Thread(sharedRunnableInstance);<br><br>        thread1.start();<br>        thread2.start();<br><br>        thread1.join(); <span class="hljs-comment">//wait for thread 1 to terminate</span><br>        thread2.join(); <span class="hljs-comment">//wait for thread 2 to terminate</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面创建了两个线程共享一个MyRunnable实例。</p><p>每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。</p><p>如果不使用ThreadLocal对象，那么第二个线程将会覆盖第一个线程所设置的值。</p><p>然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>InheritableThreadLocal类是ThreadLocal的子类。</p><p>为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal<strong>允许一个线程创建的所有子线程访问其父线程的值</strong>。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>ThreadLocal 实际上是将要存放的对象放入到了 Thread 的 localValues 变量中。</p><blockquote><p>java.lang.Thread</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Normal thread local values.</span><br><span class="hljs-comment"> */</span><br>ThreadLocal.Values localValues;<br><br></code></pre></td></tr></table></figure><p>使用 set 方法的时候，是将 ThreadLocal 本身的弱引用做为 key，将要储存的对象做为 value。</p><blockquote><p>java.lang.ThreadLocal#set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p> 看起来传递的是 this，其实真正put的时候，使用的是弱引用。如下：</p><blockquote><p>java.lang.ThreadLocal.ThreadLocalMap.Entry</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-keyword">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Entry 是继承至 WeakReference 的，而 Entry 就是要 put 进去的 key 与 value 的封装。</p><p>所以，网上多说，会有内存泄露的可能。是因为如果 ThreadLocal 本身如果没有再使用了，而当前线程迟迟不结束的话，会导致 Thread 的 localValues 变量里存的 key 被回收，values 却无法被回收（引用找不到了，但是却存在于 threa 的成员变量里面）。</p><p>这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会一直存在一条强引用链：<code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code>造成内存泄漏，当然线程结束就好了。</p><p><strong>所以，使用 ThreadLocal 推荐写成 private static 的</strong>。用完也应该 remove。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0014-volatile关键字</title>
    <link href="/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0014-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0014-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>Java 的 volatile 关键字表示修饰的这个变量的 <strong>值储存在主存</strong> 中，这里不要理解错了，并不是说 volatile 修饰的变量就直接在主内存中操作（这是不可能的），而是说：</p><ul><li>修改volatile变量时会强制将修改后的值刷新的主内存中。</li><li>修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，需要重新读取主内存中的值。</li></ul><p>说的通俗一点，就是每次读取 volatile 变量都会从主存中读取，每次写入 volatile 变量都是写入到主存中。</p><p>前面我们说过可见性问题，而 volatile 关键字就是用来保证线程之间变量的可见性。可能还是有点抽象，那就再说一遍。</p><h2 id="volatile-对可见性的保证"><a href="#volatile-对可见性的保证" class="headerlink" title="volatile 对可见性的保证"></a>volatile 对可见性的保证</h2><p>现在的 CPU 为了性能，会将内存中的数据拷贝到 CPU 的高速缓存中。如果有多个 CPU 的话，每个线程会运行在不同的 CPU 上，即每个线程都会拷贝一个数据到高速缓存中。如下图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-1.png"></p><p>对于非 volatile 的变量，在多线程的程序中，就会出现可见性问题，当一个线程更新了值之后，而另一个线程却看不到，就会导致程序错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedObject</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>假设，线程 1 会更新计数器的值， 线程 2 会时时的读取这个计数器的值。由于 counter 不是 volatile 的，所以在线程 1 更新其值之后，不一定会将值刷新到主存中，当线程 2 读取的时候，读取的还是未更新的值：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-volatile-2.png"></p><p>使用 volatile 之后，就不一样了。volatile 就是用来解决这个问题的，我们给 counter 加上关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SharedObject</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当线程1更新 counter 的值后， 线程2就能读到最新值了。</p><p>但是如果 线程1 与 线程2 都更新 counter 的值的话，仅仅加上 volatile 关键字还是不够的，后面会说。</p><h2 id="volatile-对重排序的影响"><a href="#volatile-对重排序的影响" class="headerlink" title="volatile 对重排序的影响"></a>volatile 对重排序的影响</h2><p>volatile 可见性不仅会影响到它优化的变量，还会对重排序有一定影响。看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//x、y为非volatile变量</span><br><span class="hljs-comment">//flag为volatile变量</span><br><br>x = <span class="hljs-number">2</span>;         <span class="hljs-comment">//语句1</span><br>y = <span class="hljs-number">0</span>;         <span class="hljs-comment">//语句2</span><br>flag = <span class="hljs-keyword">true</span>;   <span class="hljs-comment">//语句3</span><br>x = <span class="hljs-number">4</span>;         <span class="hljs-comment">//语句4</span><br>y = -<span class="hljs-number">1</span>;        <span class="hljs-comment">//语句5</span><br></code></pre></td></tr></table></figure><p>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，<strong>不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面</strong>。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>并且 volatile 关键字能保证，<strong>执行到语句3时，语句1和语句2必定是执行完毕</strong>了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><h2 id="volatile-与-Happens-Before"><a href="#volatile-与-Happens-Before" class="headerlink" title="volatile 与 Happens-Before"></a>volatile 与 Happens-Before</h2><p>再来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> years;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> months<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> days;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalDays</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> total = <span class="hljs-keyword">this</span>.days;<br>        total += months * <span class="hljs-number">30</span>;<br>        total += years * <span class="hljs-number">365</span>;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> years, <span class="hljs-keyword">int</span> months, <span class="hljs-keyword">int</span> days)</span></span>&#123;<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">this</span>.years  = years;<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">this</span>.months = months;<br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-keyword">this</span>.days   = days;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>update 方法写了3个变量，只有 days 是 volatile 的。但是实际上在将 days 的值刷入主内存的时候，会将 years 与 months 的值也刷入主内存。</p><p>totalDays 方法读取了3个变量的值，当从主内存读取 days 的值的时候，也会从主内存读取 months 与 years 的值。</p><p>起初，我是无法理解的，于是去  stackOverFlow 上问了一下，很快就有了答案：</p><p>这个是由于 “Happens-Before” 原则引发的：</p><blockquote><p>由于 days 被 volatile 修饰，所以代码 1 2 处 Happens-Before 代码 3，即代码 1 2 的结果对代码 3 是可见的。</p><p>同样，volatile 变量的写 Happens-Before volatile 变量的读。</p><p>在根据 Happens-Before 的传递性，所以某一个线程想要读取 days 的值的时候，months 与  years 的值也是最新的。</p></blockquote><h2 id="volatile-使用注意"><a href="#volatile-使用注意" class="headerlink" title="volatile 使用注意"></a>volatile 使用注意</h2><p>前面，我们说的多个线程更新 counter 的值，尽管 counter 是 volatile 的，但是还是会出问题，现在就来解释一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">counter++;<br></code></pre></td></tr></table></figure><p>就拿这个举例，假设某个时刻，counter 的值为 4。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">线程<span class="hljs-number">1</span>从主内存中读取值为<span class="hljs-number">4</span>，准备执行加一的指令，然后线程<span class="hljs-number">1</span>被阻塞，切换到线程<span class="hljs-number">2</span><br><br>线程<span class="hljs-number">2</span>从主内存中读取值为<span class="hljs-number">4</span>，准备执行加一的指令，然后线程<span class="hljs-number">2</span>被阻塞，切换到线程<span class="hljs-number">1</span><br><br>线程<span class="hljs-number">1</span>执行加一的指令，最后将自增后的值赋值给counter，counter的值成了<span class="hljs-number">5</span>，写入回了主内存。线程<span class="hljs-number">1</span>阻塞，切换到线程<span class="hljs-number">2</span>.<br><br>线程<span class="hljs-number">2</span>执行加一的指令（将<span class="hljs-number">4</span>加一的过程中不需要对counter进行读写，所以自增之后的值还是<span class="hljs-number">5</span>），然后将 <span class="hljs-number">5</span> 赋值给 counter，并写入回了主内存。<br><br>最后，counter 的结果还是 <span class="hljs-number">5</span>.<br></code></pre></td></tr></table></figure><p>看一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/30/ee48b1e38ea8819d6f06df279a819a1d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在读取一个变量与给这个变量赋值之间是有一段间隔的，这段间隔表示它们不是一个原子操作，不是原子操作就会产生竟态条件。两个线程同时读取值之后，一个线程即使更新了值，也不管用了，因为读取操作已经完成了，后面的写操作不需要再次读取该值，也就看不到最新的值。</p><p>所以，volatile 应该用在不需要依赖变量的当前值的地方。反过来说：</p><blockquote><p>运算结果并不依赖变量的当前值（即结果对产生中间结果不依赖），或者能够确保只有单一的线程修改变量的值</p></blockquote><p>比如，用来更新标识变量，直接给标识赋值，<code>flag =  true 或者 flag = false </code>，不需要依赖当前的值，像  flag = !flag 就不行。</p><p>最后，由于 volatile 每次写操作将最新值刷入主存，每次读操作要从主存重新读取，所以效率不高，而且它还禁止了指令优化，所以一定要在确实需要的时候才使用。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0015-死锁</title>
    <link href="/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0015-%E6%AD%BB%E9%94%81/"/>
    <url>/2019/08/20/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0015-%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。</p><h2 id="死锁的产生"><a href="#死锁的产生" class="headerlink" title="死锁的产生"></a>死锁的产生</h2><p>死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p><p>举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">如果线程<span class="hljs-number">1</span>锁住了<span class="hljs-selector-tag">A</span>，然后尝试对<span class="hljs-selector-tag">B</span>进行加锁，同时线程<span class="hljs-number">2</span>已经锁住了<span class="hljs-selector-tag">B</span>，接着尝试对<span class="hljs-selector-tag">A</span>进行加锁，这时死锁就发生了。<br><br>线程<span class="hljs-number">1</span>永远得不到<span class="hljs-selector-tag">B</span>，线程<span class="hljs-number">2</span>也永远得不到<span class="hljs-selector-tag">A</span>，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（<span class="hljs-selector-tag">A</span>和<span class="hljs-selector-tag">B</span>），它们将永远阻塞下去。这种情况就是一个死锁。<br></code></pre></td></tr></table></figure><p>上面的例子可能的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>TreeNode parent   = <span class="hljs-keyword">null</span>;  <br>List children = <span class="hljs-keyword">new</span> ArrayList();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addChild</span><span class="hljs-params">(TreeNode child)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.children.contains(child)) &#123;<br><span class="hljs-keyword">this</span>.children.add(child);<br>child.setParentOnly(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addChildOnly</span><span class="hljs-params">(TreeNode child)</span></span>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.children.contains(child)&#123;<br><span class="hljs-keyword">this</span>.children.add(child);<br>&#125;<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(TreeNode parent)</span></span>&#123;<br><span class="hljs-keyword">this</span>.parent = parent;<br>parent.addChildOnly(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParentOnly</span><span class="hljs-params">(TreeNode parent)</span></span>&#123;<br><span class="hljs-keyword">this</span>.parent = parent;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果线程1调用<code>parent.addChild(child)</code>方法的同时有另外一个线程2调用<code>child.setParent(parent)</code>方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Thread <span class="hljs-number">1</span>: parent.add<span class="hljs-constructor">Child(<span class="hljs-params">child</span>)</span>; <span class="hljs-comment">//locks parent</span><br>          --&gt; child.set<span class="hljs-constructor">ParentOnly(<span class="hljs-params">parent</span>)</span>;<br><br>Thread <span class="hljs-number">2</span>: child.set<span class="hljs-constructor">Parent(<span class="hljs-params">parent</span>)</span>; <span class="hljs-comment">//locks child</span><br>          --&gt; parent.add<span class="hljs-constructor">ChildOnly()</span><br></code></pre></td></tr></table></figure><p>首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。</p><p>然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。</p><p>现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。</p><p>上面的例子说的是比较简单的死锁，还有更加复杂的死锁（死锁可能不止包含2个线程）。下面是4个线程发生死锁的例子：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Thread</span> <span class="hljs-number">1</span>  <span class="hljs-variable">locks</span> <span class="hljs-variable">A</span><span class="hljs-operator">,</span> <span class="hljs-variable">waits</span> <span class="hljs-variable">for</span> <span class="hljs-variable">B</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-number">2</span>  <span class="hljs-variable">locks</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span> <span class="hljs-variable">waits</span> <span class="hljs-variable">for</span> <span class="hljs-built_in">C</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-number">3</span>  <span class="hljs-variable">locks</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span> <span class="hljs-variable">waits</span> <span class="hljs-variable">for</span> <span class="hljs-built_in">D</span><br><span class="hljs-built_in">Thread</span> <span class="hljs-number">4</span>  <span class="hljs-variable">locks</span> <span class="hljs-built_in">D</span><span class="hljs-operator">,</span> <span class="hljs-variable">waits</span> <span class="hljs-variable">for</span> <span class="hljs-variable">A</span><br></code></pre></td></tr></table></figure><p>还有数据库也可能发生死锁（这个与线程的死锁是一样的道理）。</p><p>当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁。</p><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>先来说一下死锁产生的必要条件，知道了条件之后，就可以采取对应的措施。</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。</li><li> 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>通过前面死锁的产生篇章，我们知道了循环等待的条件的形成是由于线程请求锁的顺序不一致导致的。那么如果我们让线程请求锁的顺序有序的话，那就不会形成循环等待条件，这样形成死锁的条件就打破了。看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread <span class="hljs-number">1</span>:<br>  lock A <br>  lock B<br><br>Thread <span class="hljs-number">2</span>:<br>   <span class="hljs-function">wait <span class="hljs-keyword">for</span> A</span><br><span class="hljs-function">   lock <span class="hljs-title">C</span> <span class="hljs-params">(when A locked)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">Thread 3:</span><br><span class="hljs-function">   wait <span class="hljs-keyword">for</span> A</span><br><span class="hljs-function">   wait <span class="hljs-keyword">for</span> B</span><br><span class="hljs-function">   wait <span class="hljs-keyword">for</span> C</span><br></code></pre></td></tr></table></figure><p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p><p>线程2和线程3只有在获取了锁A之后才能尝试获取锁C。<strong>因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放</strong>。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p><p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。</p><p>还有一种方式，就是加上超时机制。一个线程在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程<strong>没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁</strong>，然后等待一段随机的时间再重试。看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread <span class="hljs-number">1</span> locks A<br>Thread <span class="hljs-number">2</span> locks B<br><br>Thread <span class="hljs-number">1</span> attempts to lock B but is blocked<br>Thread <span class="hljs-number">2</span> attempts to lock A but is blocked<br><br>Thread <span class="hljs-number">1</span><span class="hljs-string">&#x27;s lock attempt on B times out</span><br><span class="hljs-string">Thread 1 backs up and releases A as well</span><br><span class="hljs-string">Thread 1 waits randomly (e.g. 257 millis) before retrying.</span><br><span class="hljs-string"></span><br><span class="hljs-string">Thread 2&#x27;</span>s lock attempt on A times out<br>Thread <span class="hljs-number">2</span> backs up and releases B as well<br>Thread <span class="hljs-number">2</span> <span class="hljs-function">waits <span class="hljs-title">randomly</span> <span class="hljs-params">(e.g. <span class="hljs-number">43</span> millis)</span> before retrying.</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。<strong>这时，线程1尝试获取锁A并且处于等待状态</strong>。当线程2结束时，线程1也可以顺利的获得这两个锁。</p><p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁，<strong>也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务</strong>。</p><p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程<strong>等待相同的重试时间</strong>的概率就高的多。</p><p>还有一种避免死锁的算法（银行家算法），不过需要预先知道所有的线程，资源。</p><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p><p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p><p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。</p><p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，<strong>它需要递进地检测所有被B请求的锁</strong>。先判断B是否有A所要的锁，没有则查看线程B等待的线程C，看C是否持有A说要的锁，就这样递进的检查下去。</p><p>下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/deadlock-detection-graph.png"></p><p>那么当检测出死锁时，这些线程该做些什么呢？</p><p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。</p><p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的滑动处理（一）</title>
    <link href="/2019/08/19/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/08/19/blog_bak/Blog/Android-View/View%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="NestedScrolling"><a href="#NestedScrolling" class="headerlink" title="NestedScrolling"></a>NestedScrolling</h2><p>NestedScrolling 是从Lollipop开始出现的，用来专门处理嵌套滑动的一套机制。</p><p>NestedScrolling 仍然是基于View与ViewGroup的事件滑动机制，但是它将一个滑动事件的参与者分成了两个角色，child 与 parent。</p><p>比如：ScrollView 中嵌套了 RecyclerView，ScrollView 在这里扮演 parent，RecyclerView扮演 child。</p><p>要想触发 NestedScrolling，首先 child 需要要能够处理滑动事件，因为 NestedScrolling 的思想是：</p><blockquote><p>由 child 来接收滑动事件，然后在它的 onTouchEvent 中，做滑动处理。</p><p>做任何处理之前，先询问 parent，看parent能不能处理</p></blockquote><p>所以整个流程就是，在一个move产生后：</p><ol><li><p>child 先询问 parent，能够消耗多少，没有消耗完</p></li><li><p>child 自己消耗，没有消耗完</p></li><li><p>child 再次询问 parent，我这还有没消耗完的，你能消耗多少，如果 parent 还是没有消耗完</p></li><li><p>child 自己处理</p></li></ol><p>可以仔细思考一下整个处理流程，刚开始可能会觉得有些怪异，但是要想让嵌套滚动无缝衔接，这样的逻辑是必要的。</p><p>了解了 NestedScrolling 的流程之后，那么就会产生许多问题：</p><p>第一个是：<strong>child 是如何认定 parent 的？</strong></p><p>答案就是通过接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.core.view.NestedScrollingChild<br>androidx.core.view.NestedScrollingParent<br></code></pre></td></tr></table></figure><p>当然现在，这两个接口已经发展到第3个版本了，NestedScrollingChild3 与 NestedScrollingParent3。</p><p>在我们上面的例子中，RecyclerView 就需要实现 NestedScrollingChild 这个接口，ScrollView 需要实现 NestedScrollingParent 接口。</p><p>然后，通过循环遍历 parent 的方式找到实现了 NestedScrollingParent 接口的 parent ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewParent p = mView.getParent();<br><span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> NestedScrollingParent) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    p = p.getParent();<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里，可以看出，嵌套关系不需要是直接关系，隔几层也没有问题。</p><p>当然，上面的代码是不需要我们自己实现的，Google已经替我们实现了两个工具类，后面会详细说到。</p><p>第二个是：<strong>child 与 parent 是如何传递各自需要消耗的距离的？</strong></p><p>这个问题比较复杂了，虽然Google替我们实现了两个工具，但是遗憾的是，由于业务的逻辑的多样性，工具里面只封装了一些通用的操作，所以我们需要学习如何使用这两个工具来实现我们想要的效果。</p><p>但是幸运的是，使用这两个工具是有模板的，我们只要照着来，问题不大。</p><p>下面，我们就参考 RecyclerView 的做法来仔细说道说道。</p><h3 id="先看ACTION-DOWN的处理"><a href="#先看ACTION-DOWN的处理" class="headerlink" title="先看ACTION_DOWN的处理"></a>先看ACTION_DOWN的处理</h3><blockquote><p>androidx.recyclerview.widget.RecyclerView#onTouchEvent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>    startNestedScroll(nestedScrollAxis, TYPE_TOUCH);<br>&#125; <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>一般的，我们在 ACTION_DOWN 事件中来开启嵌套滚动，那么具体怎么开启呢？使用工具类就好了：</p><blockquote><p>androidx.recyclerview.widget.RecyclerView#startNestedScroll(int, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> axes, <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getScrollingChildHelper().startNestedScroll(axes, type);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它是直接使用了 NestedScrollingChildHelper 的 startNestedScroll 方法。所以说，使用很简单。</p><p>但是这里需要注意了，startNestedScroll 方法<strong>内部会先判断该控件是否开启了支持嵌套滚动</strong>，如果没有开启的话也是不行的，具体请看 NestedScrollingChild 接口的 isNestedScrollingEnabled 方法，要想支持嵌套滚动，这个方法返回 true 就好了。</p><p>然后，startNestedScroll 方法<strong>内部还会调用 ViewParentCompat.onStartNestedScroll(p, child, mView, axes, type) 这个方法</strong>。</p><blockquote><p>androidx.core.view.ViewParentCompat#onStartNestedScroll(android.view.ViewParent, android.view.View, android.view.View, int, int)</p><p>这个方法里面做了一些转发操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> NestedScrollingParent2) &#123;<br>    <span class="hljs-comment">// First try the NestedScrollingParent2 API</span><br>    <span class="hljs-keyword">return</span> ((NestedScrollingParent2) parent).onStartNestedScroll(child, target,<br>            nestedScrollAxes, type);<br>&#125; <br></code></pre></td></tr></table></figure><p>可以看到，它拿到了 parent，然后调用了 parent 的 onStartNestedScroll 方法，<strong>它将一些滑动信息传递到了 parent 中</strong>。</p><blockquote><p>androidx.core.view.NestedScrollingParent2#onStartNestedScroll</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View child, <span class="hljs-meta">@NonNull</span> View target, <span class="hljs-meta">@ScrollAxis</span> <span class="hljs-keyword">int</span> axes,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span></span>;<br></code></pre></td></tr></table></figure><p>仔细介绍一下这个方法的各个参数：</p><ul><li><p><strong>child：</strong>是 parent 的某个直接子View，这里parent 就是 ViewParentCompat.onStartNestedScroll 中的参数 p。</p></li><li><p><strong>target：</strong>就是嵌套的控件，在我们的例子中，就是 RecyclerView。</p></li><li><p><strong>axes：</strong>是滚动的方向，横向与竖向</p></li><li><p><strong>type：</strong>是触摸类型，一种是用户触摸，另一种一般是惯性滑动</p></li><li><p><strong>返回值：</strong>true，表示 parent 接收滑动操作，false 则不会，后面分发滚动的流程也就不会走了。</p></li></ul><p>PS: <em>一般的，我们在实现 parent 的 NestedScrollingParent 接口时，onStartNestedScroll 这个方法一般根据滚动方向来返回值，比如：(axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;</em></p><h3 id="再看ACTION-MOVE的处理"><a href="#再看ACTION-MOVE的处理" class="headerlink" title="再看ACTION_MOVE的处理"></a>再看ACTION_MOVE的处理</h3><blockquote><p>androidx.recyclerview.widget.RecyclerView#onTouchEvent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    <span class="hljs-keyword">if</span> (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般，在 ACTION_MOVE 中来分发滑动事件，这里的分发与事件分发不是一个东西。</p><blockquote><p>androidx.recyclerview.widget.RecyclerView#dispatchNestedPreScroll(int, int, int[], int[], int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-keyword">int</span>[] consumed, <span class="hljs-keyword">int</span>[] offsetInWindow,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow,<br>            type);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，这里我们使用工具来帮助我们处理。它的内部调用了 ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type); 方法。</p><blockquote><p>androidx.core.view.ViewParentCompat#onNestedPreScroll(android.view.ViewParent, android.view.View, int, int, int[], int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> NestedScrollingParent2) &#123;<br>    <span class="hljs-comment">// First try the NestedScrollingParent2 API</span><br>    ((NestedScrollingParent2) parent).onNestedPreScroll(target, dx, dy, consumed, type);<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了 NestedScrollingParent2 的 onNestedPreScroll 方法。</p><blockquote><p>androidx.core.view.NestedScrollingParent2#onNestedPreScroll</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">int</span>[] consumed,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>基本上是与前面的 startNestedScroll 是一样的流程</strong>，所以也好理解。这里重要的是需要搞清楚这个方法的参数是什么意思！！！</p><ul><li><p> <strong>target：</strong> 就是嵌套的控件，在我们的例子中，就是 RecyclerView。</p></li><li><p>dx：**滑动的x方向距离，一般计算如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>       <br>        mLastTouchX = (<span class="hljs-keyword">int</span>) (e.getX() + <span class="hljs-number">0.5f</span>);<br>        mLastTouchY = (<span class="hljs-keyword">int</span>) (e.getY() + <span class="hljs-number">0.5f</span>);<br>   <br>     <br>    &#125; <span class="hljs-keyword">break</span>;<br>        <br>    <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>   <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>) (e.getX(index) + <span class="hljs-number">0.5f</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>) (e.getY(index) + <span class="hljs-number">0.5f</span>);<br>        <span class="hljs-keyword">int</span> dx = mLastTouchX - x;<br>        <span class="hljs-keyword">int</span> dy = mLastTouchY - y;<br>        <br>        mLastTouchX = x;<br>        mLastTouchY = y;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>dy：</strong>滑动的y方向的距离，计算方式同 dx</li><li><strong>consumed：</strong>这个就比较奇特了，它是由child创建的，然后作为参数传递进取，方法内部需要改变它的值。嗯，有点抽象，举个例子，比如由一个函数 fun1，它没有返回值，但是它接收一数组作为参数，函数的内部会给这个数组赋值。consumed 的工作方式就是这样。<strong>一般情况下，我们声明一个成员变量 final int[] mReusableIntPair = new int[2]; 传递给 consumed就好了</strong>。</li><li><strong>type：</strong>是触摸类型，一种是用户触摸，另一种一般是惯性滑动</li></ul></li></ul><p>consumed 被传递到了 parent 中，<strong>我们根据需要来处理这个值，比如我们需要竖向消耗 pdy个距离，那么我们在 parent 的 onNestedPreScroll 方法中调用 consumed[1] = pdy 就好了，全部消耗则 consumed[1] = dy</strong>。</p><p>然后 child 中就需要减去 parent 中消耗的值：</p><blockquote><p>androidx.recyclerview.widget.RecyclerView#onTouchEvent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>    <span class="hljs-keyword">if</span> (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123;<br>dx -= mReusableIntPair[<span class="hljs-number">0</span>];<br>dy -= mReusableIntPair[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，<strong>判断自己是否可以滚动，并且对应的滚动方向的值是否有剩余</strong>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (<span class="hljs-name">canScrollVertically</span> <span class="hljs-symbol">&amp;&amp;</span> Math.abs(<span class="hljs-name">dy</span>) &gt; mTouchSlop)<br></code></pre></td></tr></table></figure><p>如果有剩余，自己来处理滚动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">mReusableIntPair[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>mReusableIntPair[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>scrollStep(x, y, mReusableIntPair);<br></code></pre></td></tr></table></figure><p>然后再次分发滑动事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset,<br>                TYPE_TOUCH, mReusableIntPair);<br></code></pre></td></tr></table></figure><p>同样的，这个方法会调用到 parent 的 onNestedScroll 方法，我就不贴逻辑了，与上面的传递步骤还是一样的。</p><p>说一下该方法的参数：</p><blockquote><p>androidx.core.view.NestedScrollingParent2#onNestedScroll</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View target, <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed, <span class="hljs-meta">@NestedScrollType</span> <span class="hljs-keyword">int</span> type)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>target：</strong>不说了</p></li><li><p><strong>dxConsumed：</strong>就是child处理自己的滚动，横向消耗的值</p></li><li><p><strong>dyConsumed：</strong>就是child处理自己的滚动，竖向消耗的值</p></li><li><p><strong>dxUnconsumed：</strong>就是<strong>一次滑动的距离 - parent 在 onNestedPreScroll 未消耗 - child也未消耗的</strong>，最后剩余的横向的值</p></li><li><p><strong>dxUnconsumed：</strong>同 dxUnconsumed</p></li><li><p><strong>type：</strong>不说了</p></li></ul><p>最后，再判断一下，还有没有剩余的，如果还有剩余的，child 自己处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);<br></code></pre></td></tr></table></figure><p>RecyclerView 这里是利用未消耗完的给出了一个 overScroll 效果。</p><p>PS：<em>在自己能够处理滑动事件的时候，不能让parent拦截掉事件</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getParent().requestDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h3 id="再看ACTION-UP等的处理"><a href="#再看ACTION-UP等的处理" class="headerlink" title="再看ACTION_UP等的处理"></a>再看ACTION_UP等的处理</h3><blockquote><p>androidx.recyclerview.widget.RecyclerView#onTouchEvent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> MotionEvent.ACTION_UP: &#123;<br>    stopNestedScroll(TYPE_TOUCH);<br>&#125; <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>同样的，也借用工具的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>    getScrollingChildHelper().stopNestedScroll(type);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，也会调用到 parent 的 onStopNestedScroll 方法。</p><p>现在，回过头来看看这两个接口：</p><blockquote><p>NestedScrollingChild</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNestedScrollingEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNestedScrollingEnabled</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> axes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopNestedScroll</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNestedScrollingParent</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed, <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed, <span class="hljs-keyword">int</span>[] offsetInWindow)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedPreScroll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-keyword">int</span>[] consumed, <span class="hljs-keyword">int</span>[] offsetInWindow)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedFling</span><span class="hljs-params">(<span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY, <span class="hljs-keyword">boolean</span> consumed)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchNestedPreFling</span><span class="hljs-params">(<span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>NestedScrollingParent</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(View child, View target, <span class="hljs-keyword">int</span> nestedScrollAxes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScrollAccepted</span><span class="hljs-params">(View child, View target, <span class="hljs-keyword">int</span> nestedScrollAxes)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStopNestedScroll</span><span class="hljs-params">(View target)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(View target, <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed, <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(View target, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-keyword">int</span>[] consumed)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onNestedFling</span><span class="hljs-params">(View target, <span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY, <span class="hljs-keyword">boolean</span> consumed)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onNestedPreFling</span><span class="hljs-params">(View target, <span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNestedScrollAxes</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>这些方法都是有调用关系的，理清楚了就好了。</p><p>这里关于 NestedScrollingParent，我说的不太多，只是说了方法的参数意思，下面附上一个demo，实现了微信运行排行榜的滑动效果，希望可以加深理解。</p><p><a href="https://github.com/aprz512/NestedScrollingDemos">项目地址</a></p><p>有兴趣的可以自己添加demo进去。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/f09762df81a5">Android NestedScrolling全面解析 - 带你实现一个支持嵌套滑动的下拉刷新（上篇）</a></p><p><a href="https://github.com/tobiasrohloff/NestedScrollWebView/blob/master/lib/src/main/java/com/tobiasrohloff/view/NestedScrollWebView.java"><strong>NestedScrollWebView.java</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0009-线程安全及不可变性</title>
    <link href="/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0009-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    <url>/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0009-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>当一个以上的线程对同一个资源进行写操作的时候，就会<strong>产生竟态条件</strong>。多个线程同时读不会产生竟态条件。</p><h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>如果我们让共享资源不可变的话，不提供修改方法，那就没有线程安全问题了。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableValue</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImmutableValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br><span class="hljs-keyword">this</span>.value = value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们只在构造函数里面传递值进去来实例化一个对象，该对象实例化完成之后，就无法更改里面的值了。所以这个对象是线程安全的，是不可变的。即不可变的对象是线程安全的。</p><blockquote><p>需要区分“不可变”与“只读”。</p><p>一个变量只读，不代表这个变量不可变。</p><p>举一个例子：一个人的年龄是只读的，因为无法随便更改一个人的年龄，但是随着时间的变化，这个人的年龄是可以增加的，所以年龄这个变量是只读的，但是是可变的。一个人的出生年月是不可变的。</p></blockquote><p>上面的不可变例子由于没有提供任何的修改方法，所以它是不可变的，但是需要用到这种不可变对象的需求毕竟非常少，如果有需要修改这个对象，那么有没有什么方法能保证线程安全呢？看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableValue</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImmutableValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br><span class="hljs-keyword">this</span>.value = value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ImmutableValue <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> valueToAdd)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImmutableValue(<span class="hljs-keyword">this</span>.value + valueToAdd);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们给这个不可变对象提供了一个 add 方法，但是注意，我们返回了一个新的对象。这就是一种比较常用的方法，为了保证线程的安全性，我们通常不会改变原来的对象，而是创建一个新的对象并返回。</p><h2 id="使用不可变对象不代表线程安全"><a href="#使用不可变对象不代表线程安全" class="headerlink" title="使用不可变对象不代表线程安全"></a>使用不可变对象不代表线程安全</h2><p>看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Calculator&#123;<br><span class="hljs-keyword">private</span> ImmutableValue currentValue = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ImmutableValue <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> currentValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(ImmutableValue newValue)</span></span>&#123;<br><span class="hljs-keyword">this</span>.currentValue = newValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span>&#123;<br><span class="hljs-keyword">this</span>.currentValue = <span class="hljs-keyword">this</span>.currentValue.add(newValue);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。</p><p>换句话说：<strong>ImmutableValue类是线程安全的，但使用它的类不是。</strong>当尝试通过不可变性去获得线程安全时，这点是需要牢记的。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0010-内存模型</title>
    <link href="/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0010-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0010-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在说内存模型之前，我们先来说下一CPU，对CPU有一定了解之后，再来说为何要有内存模型。</p><h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><p>我们知道CPU是用来执行计算机指令的，而指令中包含的数据是从主存（内存）当中读取的，它将读取的数据放入自己的寄存器中，然后执行操作，这个是因为CPU在寄存器上执行操作的速度远大于在主存上执行的速度。</p><p>虽然CPU访问寄存器的速度很快，但是每次执行新的指令的时候，又要重新从主存中读取数据。那么这就会产生一个问题：随着CPU技术的发展，CPU的运行速度越来越快，而内存的技术没有啥太大的改变，这就导致了CPU与内存的运行速度差距越来越大。换成人类时间举个例子，一个主频2.6G的CPU执行一个指令只需要1s，它从内存读取数据大概需要4分钟（这还假设它没有触发缺页异常）。</p><p>可以看到如果CPU只能从内存中读取数据的话，那么CPU技术发展的再快也没有用。那么有没有什么办法解决呢？显然是有的，不然我们的个人计算机也不会发展的那么迅速了。</p><p>就是给CPU加一个高速缓存，这样由于<strong>局部性原理</strong>，CPU只需要将部分数据保存在高速缓存中，就可以极大的缓解数据读取慢的问题（从高速缓存中读取数据与执行指令的速度在同一个数量级）。于是CPU工作方式如下：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p>现在的CPU有的还会有多级缓存：L1，L2，L3。工作方式与普通的缓存一样，L1中找不到找L2，L2中找不到找L3。但是每一级缓存的速度相差比较大，L1与L2的速度就不在同一个数量级。<strong>我们只需要知道CPU有一个高速缓存就好了</strong>。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-4.png"></p><p>高速缓存解决了数据访问慢的问题，但是引入了新的问题：每个CPU有自己的缓存，每个缓存中的数据都是主存中的一份拷贝。如果多个CPU都同时从主存中读取了一样的数据，都更改了这个数据，那么当CPU将缓存中的数据写回主存会发生什么呢？具体会发生啥我也不知道，反正肯定会乱成一锅粥就对了。<strong>这种问题叫做缓存一致性问题</strong>。</p><p>这里说一个小知识：我们经常说的 4核8线程是什么意思？</p><blockquote><p>4核显然是4个CPU核心，但是8线程是什么呢？难道一个CPU可以同时运行两个线程？</p><p>8线程指的是通过超线程技术，用一个物理核模拟两个虚拟核，在CPU核心没有满负荷运载时，其剩余用量可以模拟成虚拟的核心。</p></blockquote><p>除了缓存一致性问题，还有别的导致多CPU运算出错（不符合我们的预期）的问题。比如：CPU指令优化导致的问题。比如，一个32位的系统读取 double 与 long 值的时候会分两次读，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>为了保证共享内存的正确性，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。主要是抽象出了3个概念：<strong>可见性、有序性、原子性</strong>。</p><p>这3个概念就是前人们总结出来的3个前置条件，我们要想在编写出一个符合期望的多线程程序，那么内存模型就需要提供一套解决方案来实现这3个条件。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。</p><p>Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问。</p><p>线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。</p><p>工作内存中存储着主内存中的变量副本拷贝。</p><p>下面举几个例子来说明哪些变量储存在主内存，哪些变量储存在工作内存。注意不要把主内存，工作内存与堆栈搞混了。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-2.png"></p><ul><li>原始类型的本地变量是储存在栈（在工作内存中）。</li><li>对象类型的本地变量储存在堆中（在主内存中），但是该类型的引用储存在栈中（在工作内存中）。</li><li>对象的成员变量（不管这个变量是基本类型还是对象类型）是放在堆中（在主内存中）。</li><li>static变量以及类本身相关信息将会存储在方法区（在主内存中）。</li></ul><p>JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-3.png"></p><p>在上面的图中，Object3对象肯定不是在 methodOne() 中创建的，所以它们指向同一个对象。</p><p>Object1 与 Object5 才是在 methodTwo() 中创建的，所以每个线程都创建了自己的对象。</p><h2 id="Java内存模型与实际内存的关系"><a href="#Java内存模型与实际内存的关系" class="headerlink" title="Java内存模型与实际内存的关系"></a>Java内存模型与实际内存的关系</h2><p>对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分。</p><p>JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中或者CPU缓存或者寄存器中。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-memory-model-5.png"></p><h2 id="Java内存模型保证了原子性、可见性、有序性"><a href="#Java内存模型保证了原子性、可见性、有序性" class="headerlink" title="Java内存模型保证了原子性、可见性、有序性"></a>Java内存模型保证了原子性、可见性、有序性</h2><p>JMM主要是靠<code> happens-before</code> 原则，<code>sychronized</code>等同步锁， <code>volatile</code> 等关键字来保证原子性、可见性以及有序性。</p><p>下面是happens-before原则规则：</p><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ol><p>这些东西读起来像是很理所当然的东西，但是却是并发编程的基石。就像高等数学学起来很费劲，1+1却是理所当然一样。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0011-synchronized同步代码块</title>
    <link href="/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0011-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <url>/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0011-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="http://ifeve.com/wp-content/uploads/2013/04/keys_and_lock_holding250.jpg"></p><p>同步代码块就像一个锁一样，将代码给锁起来，线程需要执行同步块中的代码时需要先获取锁才能执行。一次只能有一个线程获得锁。</p><p>Java中的同步块用<code>synchronized</code>标记。同步块在Java中是同步在某个对象上。所有同步在同一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p><p>有四种不同的同步块：</p><ol><li>实例方法</li><li>静态方法</li><li>实例方法中的同步块</li><li>静态方法中的同步块</li></ol><h2 id="实例同步方法"><a href="#实例同步方法" class="headerlink" title="实例同步方法"></a>实例同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.count += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法是同步在这个方法所属的对象上的。如果<strong>有多个线程执行该对象的 add 方法</strong>，就会出现阻塞，只有获取了锁的线程才能执行。但是如果是执行的不同对象上的 add 方法，因为获取的是不同的锁，所以不会阻塞。</p><h2 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.count += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>与实例同步方法一样。不过它同步的不是实例对象，而是类对象（XXX.class）。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p><h2 id="实例方法中的同步块"><a href="#实例方法中的同步块" class="headerlink" title="实例方法中的同步块"></a>实例方法中的同步块</h2><p>有时你不需要同步整个方法，而是同步方法中的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>&#123;<br><br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>        <span class="hljs-keyword">this</span>.count += value;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意到，这里我们传递了this，说明同步代码块是作用在 this 这个对象上的，它的作用与实例同步方法一样。（在同步构造器中用括号括起来的对象叫做监视器对象）</p><p>我们出了传递 this，还可以传递别的对象，只要是你想让代码块作用在这个对象上就行。</p><h2 id="静态方法中的同步块"><a href="#静态方法中的同步块" class="headerlink" title="静态方法中的同步块"></a>静态方法中的同步块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log1</span><span class="hljs-params">(String msg1, String msg2)</span></span>&#123;<br>        log.writeln(msg1);<br>        log.writeln(msg2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log2</span><span class="hljs-params">(String msg1, String msg2)</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(MyClass.class)&#123;<br>            log.writeln(msg1);<br>            log.writeln(msg2);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>log2 与 log1 是等价的，当然静态方法中的同步块我们<strong>也可以传递别的类的 class</strong>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span></span>&#123;<br>    <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.count += value;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Counter counter = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CounterThread</span><span class="hljs-params">(Counter counter)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.counter = counter;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            counter.add(i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter();<br>        Thread  threadA = <span class="hljs-keyword">new</span> CounterThread(counter);<br>        Thread  threadB = <span class="hljs-keyword">new</span> CounterThread(counter);<br><br>        threadA.start();<br>        threadB.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了两个线程。<strong>他们的构造器引用同一个Counter实例</strong>。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。</p><p>如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Counter counterA = <span class="hljs-keyword">new</span> Counter();<br>        Counter counterB = <span class="hljs-keyword">new</span> Counter();<br>        Thread  threadA = <span class="hljs-keyword">new</span> CounterThread(counterA);<br>        Thread  threadB = <span class="hljs-keyword">new</span> CounterThread(counterB);<br><br>        threadA.start();<br>        threadB.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这两个线程，<strong>threadA和threadB不再引用同一个counter实例</strong>。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0012-线程间通信</title>
    <link href="/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0012-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <url>/2019/08/19/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0012-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>线程之间的通信通常是为了协调这些线程的工作。线程之间的通信会涉及到下面几个内容的东西：</p><ul><li>通过共享对象通信</li><li>忙等待</li><li>wait、notify、notifyAll</li><li>丢失的信号</li><li>假唤醒</li><li>不要对常量以及全局对象调用 wait</li></ul><h2 id="通过共享对象通信"><a href="#通过共享对象通信" class="headerlink" title="通过共享对象通信"></a>通过共享对象通信</h2><p>这个是最容易想到的方法：创建一个对象，在这个对象里面存放一个标识，提供更新标识的方法。然后每个线程持有这个对象的引用，即可进行通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySignal</span></span>&#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> hasDataToProcess = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasDataToProcess</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hasDataToProcess;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHasDataToProcess</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasData)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.hasDataToProcess = hasData;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>线程A和B获得<strong>指向同一个MySignal实例</strong>的引用，就可以进行通信。</p><h2 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h2><p>由于线程运行的先后顺序不固定，所以我们需要保证B线程在 hasDataToProcess 的值变为 true 之前，一直等待，否则就会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> MySignal sharedSignal = ...<br><br>...<br><br><span class="hljs-keyword">while</span>(!sharedSignal.hasDataToProcess())&#123;<br>    <span class="hljs-comment">//do nothing... busy waiting</span><br>&#125;<br></code></pre></td></tr></table></figure><p>于是，我们可以这样写，这种等待的方式就叫做忙等待。</p><p>##wait、notify、notifyAll</p><p>忙等待没有对运行等待线程的CPU进行有效的利用，<strong>除非平均等待时间非常短</strong>。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p><p>Java 里面内置了3个方法允许线程在等待信号的时候变为非运行状态。</p><blockquote><p>java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p></blockquote><p><strong>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态</strong>，直到另一个线程调用了同一个对象的notify()方法。<strong>为了调用wait()或者notify()，线程必须先获得那个对象的锁</strong>。也就是说，**线程必须在同步块里调用wait()或者notify()**。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonitorObject</span></span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWaitNotify</span></span>&#123;<br><br>    MonitorObject myMonitorObject = <span class="hljs-keyword">new</span> MonitorObject();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWait</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                myMonitorObject.wait();<br>            &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;...&#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotify</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            myMonitorObject.notify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个线程调用 notify 方法之后，将会<strong>从所有等待的线程中随机唤醒</strong>一个。</p><p>一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()，否则，会抛出IllegalMonitorStateException异常。</p><p>不知道你看到上面的话之后，有没有什么想法，<strong>如果你是刚接触这方面的内容的话，这里是有个说不通的地方的</strong>。</p><blockquote><p>上面说，wait 必须要在同步代码块里面调用，那么它调用完之后，锁还是自己持有，别的线程也没法干啥啊</p></blockquote><p>所以，为了不出现这种bug，<strong>wait方法会释放锁</strong>。</p><p>但是 notify 就不一样的，notify 不会释放锁，需要等待同步代码块执行完才会释放锁。<strong>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块</strong>。说白了，就是线程被唤醒之后，还需要等待一段时间（等notify的同步代码块执行完）才能退出 wait 方法。</p><p>如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</p><p>##丢失的信号</p><p>假如一个线程还没有进入 wait 方法，另一个线程就调用了 nofity 方法，那么就会导致这个线程错失了唤醒的机会。有些时候这没啥，但是在某些情况下，只会唤醒一次，这样这个线程就永远不会醒了。</p><p>为了避免这种情况，我们可以将信号保存起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWaitNotify2</span></span>&#123;<br><br>    MonitorObject myMonitorObject = <span class="hljs-keyword">new</span> MonitorObject();<br>    <span class="hljs-keyword">boolean</span> wasSignalled = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWait</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            <span class="hljs-keyword">if</span>(!wasSignalled)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    myMonitorObject.wait();<br>                &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;...&#125;<br>            &#125;<br>            <span class="hljs-comment">//clear signal and continue running.</span><br>            wasSignalled = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotify</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            wasSignalled = <span class="hljs-keyword">true</span>;<br>            myMonitorObject.notify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就不会错失信号了，即使信号在 wait 前发出来。</p><h2 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h2><p>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，这个是属于底层的问题。</p><p>如果上面的例子中出现了假唤醒，那么程序就会出问题，所以我们不能使用 if 判断，而是需要使用 while 来防止假唤醒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWaitNotify3</span></span>&#123;<br><br>    MonitorObject myMonitorObject = <span class="hljs-keyword">new</span> MonitorObject();<br>    <span class="hljs-keyword">boolean</span> wasSignalled = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWait</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            <span class="hljs-keyword">while</span>(!wasSignalled)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    myMonitorObject.wait();<br>                &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;...&#125;<br>            &#125;<br>            <span class="hljs-comment">//clear signal and continue running.</span><br>            wasSignalled = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotify</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            wasSignalled = <span class="hljs-keyword">true</span>;<br>            myMonitorObject.notify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 wait 写在  while 循环体里面，这样即使发生了假唤醒，由于 wasSignalled 没有更新，所以它仍然会继续进入 wait 状态。</p><p>##不要对常量以及全局对象调用 wait</p><p> 看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWaitNotify</span></span>&#123;<br><br>    String myMonitorObject = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">boolean</span> wasSignalled = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWait</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            <span class="hljs-keyword">while</span>(!wasSignalled)&#123;<br>                <span class="hljs-keyword">try</span>&#123;<br>                    myMonitorObject.wait();<br>                &#125; <span class="hljs-keyword">catch</span>(InterruptedException e)&#123;...&#125;<br>            &#125;<br>            <span class="hljs-comment">//clear signal and continue running.</span><br>            wasSignalled = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doNotify</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(myMonitorObject)&#123;<br>            wasSignalled = <span class="hljs-keyword">true</span>;<br>            myMonitorObject.notify();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子的问题在于：<strong>JVM/编译器内部会把常量字符串转换成同一个对象</strong>。</p><p>这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/strings-wait-notify.png"></p><p>那么，这会发生什么问题呢？</p><p>首先，即使创建了多个MyWaitNotify实例，它们的锁都是同一把，导致不同实例上的所有的线程竞争同一个锁，这个问题我们就不说了。我们说另外一个问题。</p><p>假设，线程B调用了 notify 方法，本来应该是线程A被唤醒，但是由于多个实例使用了同一个锁，所有可能是线程C被唤醒，由于线程C检查了信号的状态，发现它没有被更新，所以对线程C来说，这相当于一次假唤醒。但是对于线程A来说，是信号丢失了。</p><p>有的同学说，可以使用 notifyAll 来解决这个问题，但是这对性能不好。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。</p><p>所以：<strong>在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0018-静态链表</title>
    <link href="/2019/08/19/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0018-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/"/>
    <url>/2019/08/19/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0018-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>在一些早期的语言中，是没有指针这个东西的，那么就没办法实现链表了。但是我们的前辈们想出了一个办法：用数组来实现链表，是真的牛逼。我们来看看是如何实现的吧。</p><p>首先，同样是定义一个Node类，然后创建一个Node数组，为了方便插入数据，会把这个数组定义的大一些，以免溢出（这里就不考虑扩容了）。注意这里我们储存的是下一个节点的位置，而不是下一个节点的引用，因为早期的语言没有引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    Object value;<br>    <span class="hljs-keyword">int</span> nextPos;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再来思考，用数组怎么链式储存数据。</p><p>首先头指针怎么存？</p><p>新插入一个节点的时候，怎么插入？肯定不能一个个往后移动</p><p>删除节点的时候，怎么标记这个位置是空的？</p><p>直接给出答案吧，看下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-12-1.png?raw=true"></p><p>这样储存的就解决了上面的3个问题。</p><p>头节点放在最后一个位置。</p><p>第一个位置用来放备用链表，啥叫备用链表呢，就是把数组里面所有为空的位置串起来的链表。有了备用链表，想要插入的话，从备用链表里面拿第一个节点就好了。想要删除的话，将删除的节点放入备用链表就好了。</p><h2 id="静态链表的初始化"><a href="#静态链表的初始化" class="headerlink" title="静态链表的初始化"></a>静态链表的初始化</h2><p>其实静态链表的初始化就是要做3件事：</p><ul><li>头节点</li><li>备用链表头节点</li><li>备用链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;SIZE; i++) &#123;<br>        <span class="hljs-comment">// 这里初始化了备用链表的头节点与备用链表</span><br>        <span class="hljs-comment">// 原本我想的是将静态链表的头节点放在第一个位置，后来想了一下</span><br>        <span class="hljs-comment">// 放在最后一个位置会更简单一些，虽然放在第一个位置也能实现，但是就显得麻烦了</span><br>        nodes[i].nextPos = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 这里初始化了静态链表的头节点</span><br>    nodes[SIZE - <span class="hljs-number">1</span>].nextPos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是将整个数组串起来，最后将头尾连起来，形成一个闭环。</p><p>这个闭环里面其实是有两条链表，一个备用链表，一个存放数据的链表。</p><p>上面的代码中，将数据链表一开始指向了 0 位置，其实一开始指不指向 0 无所谓，只要它后来指向第一个存放数据的位置就好了。</p><h2 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h2><p>第一个插入的元素，肯定是存放在1位置的（因为备用链表初始化的时候，第一个节点是1位置），接下来插入的数据依次往后摆。</p><p>假设静态链表已经存放进去了一些数据，如下图所示：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-12-2.png?raw=true"></p><p>要想插入一个数据，需要分为这几步：</p><ul><li>拿出备用链表的头节点 H</li><li>更新备用链表的头节点</li><li>将 H 节点插入到数据链表中</li></ul><p>我们先从备用链表里面拿到其头节点，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStandByHeadNode</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取备用链表头节点的位置</span><br>    <span class="hljs-keyword">int</span> pos = table[<span class="hljs-number">0</span>].nextPos;<br><br>    <span class="hljs-comment">// 我们指定，备用链表的头节点为0，表示链表已经满了</span><br>    <span class="hljs-keyword">if</span> (pos != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 更新备用链表的头节点</span><br>        table[<span class="hljs-number">0</span>].nextPos = table[pos].nextPos;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再插入数据，这里的插入数据与之前的不一样，因为我们储存了下一个节点的位置，所以我们只需要更新一下下一个节点的位置就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Object value)</span> </span>&#123;<br>    <span class="hljs-comment">// 保证 index 在 0 与 数据链表的长度之间</span><br>    checkIndex(index);<br>    <span class="hljs-keyword">int</span> pos = getStandByHeadNode();<br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    table[pos].value = value;<br><br>    <span class="hljs-comment">// 寻找插入位置</span><br>    <span class="hljs-keyword">int</span> dataNextPos = SIZE - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        dataNextPos = table[dataNextPos].nextPos;<br>    &#125;<br><br>    <span class="hljs-comment">// 在第i个节点后面添加一个节点</span><br>    table[pos].nextPos = table[dataNextPos].nextPos;<br>    table[dataNextPos].nextPos = pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入后数据如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-12-3.png?raw=true"></p><h2 id="删除一个元素"><a href="#删除一个元素" class="headerlink" title="删除一个元素"></a>删除一个元素</h2><p>同样的，先来理思路：</p><ul><li>找到需要删除的元素 D 的前一个元素H（因为需要更改 H 元素的cur值）</li><li>将 H 的cur 值改为 D 的 cur 值</li><li>将 D 元素放入备用链表</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// 保证链表长度大于1</span><br>    checkLength();<br>    <span class="hljs-comment">// 保证 index 在 0 与 数据链表的长度之间</span><br>    checkIndex(index);<br><br>    <span class="hljs-comment">// 找到需要删除的节点的前一个节点</span><br>    <span class="hljs-keyword">int</span> dataNextPos = SIZE - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>        dataNextPos = table[dataNextPos].nextPos;<br>    &#125;<br><br>    <span class="hljs-comment">// 前一个节点</span><br>    Node p = table[dataNextPos];<br>    <span class="hljs-comment">// 需要删除的节点</span><br>    Node d = table[p.nextPos];<br>    <span class="hljs-comment">// 删除节点</span><br>    p.nextPos = d.nextPos;<br>    <span class="hljs-comment">// 将 d 放入备用链表</span><br>    d.nextPos = table[<span class="hljs-number">0</span>].nextPos;<br>    table[<span class="hljs-number">0</span>].nextPos = p.nextPos;<br>    <br>    <span class="hljs-comment">// 释放节点空间</span><br>    d.nextPos = <span class="hljs-number">0</span>;<br>    d.value = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h2><p>优点：</p><p>增删时只需要修改游标，不需要移动元素</p><p>缺点：</p><p>没有解决长度问题（长度无法确定，只能取一个估计值），失去了随机存储的特性</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android V1 V2 签名机制</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Android%20V1%20V2%20%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Android%20V1%20V2%20%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>很早之前就想写这个，直到现在才有时间。理解了这个发现对 HTTPS 也有了进一步的理解。</p></blockquote><h2 id="为什么需要签名-？"><a href="#为什么需要签名-？" class="headerlink" title="为什么需要签名 ？"></a>为什么需要签名 ？</h2><p>了解 HTTPS 通信的同学应该知道，在消息通信时，必须至少解决两个问题：</p><ul><li><p>一是确保消息来源的真实性</p></li><li><p>二是确保消息不会被第三方篡改</p></li></ul><p>我们先来看 HTTPS 签名以及校验的过程：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/%E7%AD%BE%E5%90%8D.png?raw=true"></p><p>这里只是简单的理了一下核心思路，有不懂的还是应该查看相关文献。</p><p>在安装 APK 时，同样需要确保 APK 来源的真实性，以及 APK 没有被第三方篡改。如何解决这两个问题呢？方法就是开发者对 APK 进行签名：在 APK 中写入一个“指纹”。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。</p><h2 id="V1-签名过程"><a href="#V1-签名过程" class="headerlink" title="V1 签名过程"></a>V1 签名过程</h2><p>首先我们任意选取一个签名后的 APK（Sample-release.APK）解压：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/02.png?raw=true"></p><p>在 <code>META-INF</code> 文件夹下有三个文件：<code>MANIFEST.MF</code>、<code>CERT.SF</code>、<code>CERT.RSA</code>。它们就是签名过程中生成的文件，它们就是签名三贱客。</p><h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h3><p>该文件中保存的内容其实就是<strong>逐一遍历 APK 中的所有条目</strong>，如果是目录就跳过，如果是一个文件，就用 SHA1（或者 SHA256）消息摘要算法<strong>提取出该文件的摘要然后进行 BASE64 编码</strong>后，作为“SHA1-Digest”属性的值写入到 MANIFEST.MF 文件中的一个块中。该块有一个“Name”属性， 其值就是该文件在 APK 包中的路径。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/03.png?raw=true"></p><p>在这个文件里面，我们也可以搜索到我们的dex文件的摘要，资源的摘要，有兴趣的可以自己动手试试，将apk拖到AS里面就搞定了。需要注意的是，<strong>这个文件中存放了未压缩之前的所有文件的摘要</strong>。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/mainfest_mf.png?raw=true"></p><h3 id="CERT-SF"><a href="#CERT-SF" class="headerlink" title="CERT.SF"></a>CERT.SF</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/04.png?raw=true"></p><p>发现这里里面的内容与 MANIFEST.MF 的文件差不多。MANIFEST.MF是对APK中的每个文件进行摘要，那么这个文件里面的条目是什么东西的摘要呢？</p><ul><li>SHA1-Digest-Manifest：对整个 MANIFEST.MF 文件做 SHA1（或者 SHA256）后再用 Base64 编码</li><li>SHA1-Digest：对 MANIFEST.MF 的各个条目做 SHA1（或者 SHA256）后再用 Base64 编码</li></ul><p>所以，CERT.SF 做了这些东西：</p><ol><li>计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下</li><li>逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest</li></ol><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/cert_sf.png?raw=true"></p><h3 id="CERT-RSA"><a href="#CERT-RSA" class="headerlink" title="CERT.RSA"></a>CERT.RSA</h3><p>这里会把之前生成的 CERT.SF 文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。这里要注意的是，Android APK 中的 CERT.RSA 证书是自签名的，并不需要这个证书是第三方权威机构发布或者认证的，用户可以在本地机器自行生成这个自签名证书。Android 目前不对应用证书进行 CA 认证。</p><p>我们在 gradle 文件中配置的签名文件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">signingConfigs &#123;<br>    release &#123;<br>        storeFile file(<span class="hljs-string">&#x27;..\\release.jks&#x27;</span>)<br>        storePassword <span class="hljs-string">&#x27;release&#x27;</span><br>        keyAlias = <span class="hljs-string">&#x27;key0&#x27;</span><br>        keyPassword <span class="hljs-string">&#x27;release&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>.jks 文件里面就包含了这些东西（通过 keytool 命令可以查看，但是看不到私钥）：</p><ul><li>私钥</li><li>证书</li></ul><p>这里会把之前生成的 CERT.SF文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入  CERT.RSA  中保存。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/09.png?raw=true"></p><p>需要理解的是：MANIFEST.MF 文件 与 CERT.SF 文件都是在计算 apk 文件的摘要。</p><h3 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h3><p>签名验证是发生在APK的安装过程中，一共分为三步：</p><ul><li><p>检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致。</p></li><li><p>使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过。</p></li><li><p>使用签名文件（SF 文件）检验 MF 文件没有被修改过。</p></li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/10.png?raw=true"></p><p>由于使用了自签名证书，没有CA的参与，所以公钥有被替换的可能，但是由于是第三方重新签名，所以无法覆盖已安装的应用。</p><h2 id="基于V1的多渠道打包方案"><a href="#基于V1的多渠道打包方案" class="headerlink" title="基于V1的多渠道打包方案"></a>基于V1的多渠道打包方案</h2><p>最早的多渠道打包方案是这样的，由于以前都是使用的友盟统计，按照友盟官方文档说明，渠道信息通常需要在AndroidManifest.xml中配置如下值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;Channel ID&quot;</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;UMENG_CHANNEL&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>然后，在build.gradle设置productFlavors：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;  <br>    productFlavors &#123;<br>        kuan &#123;<br>            manifestPlaceholders = [<span class="hljs-attr">UMENG_CHANNEL_VALUE:</span> <span class="hljs-string">&quot;kuan&quot;</span>]<br>        &#125;<br>        xiaomi &#123;<br>            manifestPlaceholders = [<span class="hljs-attr">UMENG_CHANNEL_VALUE:</span> <span class="hljs-string">&quot;xiaomi&quot;</span>]<br>        &#125;<br>        qh360 &#123;<br>            manifestPlaceholders = [<span class="hljs-attr">UMENG_CHANNEL_VALUE:</span> <span class="hljs-string">&quot;qh360&quot;</span>]<br>        &#125;<br>        baidu &#123;<br>            manifestPlaceholders = [<span class="hljs-attr">UMENG_CHANNEL_VALUE:</span> <span class="hljs-string">&quot;baidu&quot;</span>]<br>        &#125;<br>        wandoujia &#123;<br>            manifestPlaceholders = [<span class="hljs-attr">UMENG_CHANNEL_VALUE:</span> <span class="hljs-string">&quot;wandoujia&quot;</span>]<br>        &#125;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这样打包虽然可以工作，但是只是为了替换一个 AndroidManifest.xml 里面的 meta-data 就需要将所有的 apk 文件重新打进一个新包里面，非常的浪费时间。</p><p>那么，有没有快速打包方法呢？显然是有的，下面介绍一下美团的打包方案。</p><h3 id="美团V1签名打包方案"><a href="#美团V1签名打包方案" class="headerlink" title="美团V1签名打包方案"></a>美团V1签名打包方案</h3><p>我们上面分析过APK签名的校验，但是仔细想想，它有个漏洞，它校验了所有的 APK 里面的文件，以及签名3剑客，但是却没有对 MATE-INF 这个文件夹做校验。那么我们就可以这样做：</p><blockquote><p>在 META-INF 目录下添加空文件，用空文件的名称来作为渠道的唯一标识。</p></blockquote><p>这样我们的渠道信息就写入apk中的，而且不会影响签名。然后在app运行的时候，从 apk 文件里面读取出来就好了。</p><p>具体过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建渠道名的空文件</span><br>f_empty_channel = <span class="hljs-built_in">open</span>(channel_name, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f_empty_channel.close()<br>    <br><span class="hljs-comment"># 往渠道apk中添加空的渠道文件</span><br>dest_channel_path = <span class="hljs-string">&quot;./META-INF/&quot;</span> + channel_name<br>f = zipfile.ZipFile(dest_apk, <span class="hljs-string">&#x27;a&#x27;</span>)<br>f.write(channel_name, dest_channel_path)<br>f.close()<br></code></pre></td></tr></table></figure><p>这样就搞定了，是不是很简单呢？这种方式的特点是：生成一个渠道包，需要经过解压缩、创建空文件、压缩这些步骤。</p><h3 id="一种更快速的打包"><a href="#一种更快速的打包" class="headerlink" title="一种更快速的打包"></a>一种更快速的打包</h3><p>继美团多渠道打包方案之后，万能的网友又想出了一种更快速的打包方式。</p><p>由于apk文件实质上就是个zip包，因此可以利用zip包的文件结构，将渠道信息带进去即可。这种方式的特点：没有解压缩、压缩、重签名等步骤，比美团的打包效率还要高。</p><p>有兴趣的可以找找代码看看。</p><h2 id="V2签名过程"><a href="#V2签名过程" class="headerlink" title="V2签名过程"></a>V2签名过程</h2><p>APK 签名方案 v2 是一种全文件签名方案，该方案能够发现对 APK 的受保护部分进行的所有更改，从而有助于加快验证速度并增强完整性保证。</p><p>从 Android 7.0 开始，Android 支持了一套全新的 V2 签名机制，为什么要推出新的签名机制呢？通过前面的分析，可以发现 v1 签名有两个地方可以改进：</p><ul><li><p>签名校验速度慢<br>校验过程中需要对apk中所有文件进行摘要计算，在 APK 资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢。</p></li><li><p>完整性保障不够<br>META-INF 目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。</p></li></ul><p>为了解决这两个问题，在 Android 7.0 Nougat 中引入了全新的 APK Signature Scheme v2。</p><h3 id="V2-带来的影响"><a href="#V2-带来的影响" class="headerlink" title="V2 带来的影响"></a>V2 带来的影响</h3><p>由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。</p><p>v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。</p><h3 id="V2签名过程-1"><a href="#V2签名过程-1" class="headerlink" title="V2签名过程"></a>V2签名过程</h3><p>v2 签名模式在原先 APK 块中增加了一个新的块（签名块），新的块存储了签名，摘要，签名算法，证书链，额外属性等信息，这个块有特定的格式，具体格式分析见后文，先看下现在 APK 成什么样子了。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/11.png?raw=true"></p><p>为了保护 APK 内容，整个 APK（ZIP文件格式）被分为以下 4 个区块：</p><ul><li>ZIP 条目的内容（从偏移量 0 处开始一直到“APK 签名分块”的起始位置）</li><li>APK 签名分块</li><li>ZIP 中央目录</li><li>ZIP 中央目录结尾</li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/12.png?raw=true"></p><p>其中，应用签名方案的签名信息会被保存在 区块 2（APK Signing Block）中，而区块 1（Contents of ZIP entries）、区块 3（ZIP Central Directory）、区块 4（ZIP End of Central Directory）是受保护的，在签名后任何对区块 1、3、4 的修改都逃不过新的应用签名方案的检查。</p><h3 id="ZIP-文件结构"><a href="#ZIP-文件结构" class="headerlink" title="ZIP 文件结构"></a>ZIP 文件结构</h3><p>需要了解一下，不然不明白 ZIP 中央目录子类的东西。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/14.png?raw=true"></p><p>zip文件分为3部分：</p><ol><li><p><strong>数据区</strong></p><p>此区块包含了zip中所有文件的记录，是一个列表，每条记录包含：文件名、压缩前后size、压缩后的数据等；</p></li><li><p><strong>中央目录</strong></p><p>存放目录信息，也是一个列表，每条记录包含：文件名、压缩前后size、本地文件头的起始偏移量等。通过本地文件头的起始偏移量即可找到压缩后的数据；</p><p>对于待压缩的目录而言，每一个子目录对应一个中央目录数据项，记录该目录的描述信息。</p></li><li><p><strong>中央目录结尾记录</strong></p><p>标识中央目录结尾，包含：中央目录条目数、size、起始偏移量、zip文件注释内容等。</p></li></ol><p>继续回到正题。</p><h3 id="V2-签名摘要计算"><a href="#V2-签名摘要计算" class="headerlink" title="V2 签名摘要计算"></a>V2 签名摘要计算</h3><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/13.png?raw=true"></p><p>说一下摘要计算规则：</p><ul><li>将每个部分拆分成多个大小为 1 MB大小的chunk，最后一个chunk可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度；</li><li>计算chunk摘要：字节 <code>0xa5</code> + 块的长度（字节数） + 块的内容 进行计算；</li><li>计算整体摘要：字节 <code>0x5a</code> + chunk数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。</li></ul><p>最后，将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。</p><h3 id="V2-签名多渠道打包方案"><a href="#V2-签名多渠道打包方案" class="headerlink" title="V2 签名多渠道打包方案"></a>V2 签名多渠道打包方案</h3><p>这里就不细说 APK Signing Block 区块里面的结构了，有兴趣的可以查查资料。</p><p>V2 签名这种方案，只保证了第1、3、4部分和第 2 部分（APK签名分块）包含的APK 签名方案 v2分块中的 <code>signed data</code> 分块的完整性。</p><p>APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中<code>APK 签名方案 v2分块</code>存放在ID为0x7109871a的键值对中。</p><p>所以，我们可以定义一个新的ID-VALUE，将渠道信息写入<code>APK签名分块</code>中。</p><h2 id="V2-V1-签名校验"><a href="#V2-V1-签名校验" class="headerlink" title="V2 V1 签名校验"></a>V2 V1 签名校验</h2><p>2 签名机制是在 Android 7.0 以及以上版本才支持。因此对于 Android 7.0 以及以上版本，在安装过程中，如果发现有 v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制。</p><p>v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 .SF 文件属性当中有一个 X-Android-APK-Signed 属性：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">X</span>-Android-APK-Signed: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>因此如果想绕过 v2 走 v1 校验是不行的。</p><p>下一篇讲 V2 机制下的多渠道打包。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 应用是如何编译与运行的</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>Android Studio 负责如何构建与部署我们的应用。但是你有没有想过当你按下Run按钮时发生了什么？</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="Java-compilation"><a href="#Java-compilation" class="headerlink" title="Java compilation"></a>Java compilation</h4><p>我们的代码是用Java编写的。但是，Java代码的编译和运行方式与Web应用程序相同吗？</p><p>Android应用程序的编译过程与其他Java应用程序有很大不同。</p><p>但是它们的开始过程都是一样的：</p><p>使用javac命令将Java源代码文件编译为.class文件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/javaCompile.png?raw=true"></p><p>它会将下面的java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">super</span>();<br>  currentPosition = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>转换成这样的java字节码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">com.hfad.bitsandpizzas.MainActivity();</span><br>  <span class="hljs-attr">Code:</span><br>   <span class="hljs-attr">0:</span><span class="hljs-string">aload_0</span><br>   <span class="hljs-attr">1:</span><span class="hljs-string">invokespecial</span><span class="hljs-comment">#5; //Method android/app/Activity.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-attr">4:</span><span class="hljs-string">aload_0</span><br>   <span class="hljs-attr">5:</span><span class="hljs-string">iconst_0</span><br>   <span class="hljs-attr">6:</span><span class="hljs-string">putfield</span><span class="hljs-comment">#3; //Field currentPosition:I</span><br>   <span class="hljs-attr">9:</span><span class="hljs-string">return</span><br></code></pre></td></tr></table></figure><h4 id="Conversion-to-Dalvik-bytecodes"><a href="#Conversion-to-Dalvik-bytecodes" class="headerlink" title="Conversion to Dalvik bytecodes"></a>Conversion to Dalvik bytecodes</h4><p>.class文件包含标准的Oracle JVM Java字节码。但Android设备不使用此字节码格式。相反，Android有自己独特的字节码格式，称为Dalvik。</p><p>Dalvik字节码，与Oracle JVM字节码一样，是理论处理器的机器代码指令。</p><p>编译过程需要将.class文件和任何.jar库转换为包含Dalvik字节码的单个classes.dex文件。这是通过dx命令完成的：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/dxConvert.png?raw=true?raw=true"></p><p>dx命令将所有.class和.jar文件拼接成一个以Dalvik字节码格式编写的classes.dex文件。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">0x0000:<span class="hljs-built_in"> iput-object </span>v1, v0, <span class="hljs-class">Lcom/hfad/bitsandpizzas/MainActivity;</span> com.hfad.bitsandpizzas.MainActivity$2.this$0 // field@4869<br>0x0002:<span class="hljs-built_in"> invoke-direct </span>&#123;v0&#125;, void java.lang.Object.&lt;init&gt;() // method@13682<br>0x0005: return-void<br></code></pre></td></tr></table></figure><h4 id="Put-classes-dex-and-resources-into-a-package-file"><a href="#Put-classes-dex-and-resources-into-a-package-file" class="headerlink" title="Put classes.dex and resources into a package file"></a>Put classes.dex and resources into a package file</h4><p>然后将classes.dex文件和应用程序中的资源（如图像和布局）压缩为类似zip的文件，称为Android Package或.apk文件。这是通过 <em>Android Asset Packaging Tool</em> 或 aapt 完成的：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/apkPackage.png?raw=true"></p><p>这个步骤完成之后，.apk文件就可以安装了。但是，还有一个步骤需要做…</p><h4 id="You-might-then-also-sign-the-apk-file"><a href="#You-might-then-also-sign-the-apk-file" class="headerlink" title="You might then also sign the .apk file"></a>You might then also sign the .apk file</h4><p>如果想要通过Google Play商店分发应用，则需要对其进行签名。对应用程序包进行签名意味着您在.apk中存储了一个附加文件，该文件基于.apk内容的校验和以及单独生成的私钥。</p><p>.apk文件使用标准的jarsigner工具，该工具是Oracle Java Development Kit的一部分。创建jarsigner工具是为了签署.jar文件，但它也可以使用.apk文件，因为它们也是压缩文件。 </p><p>如果您对.apk文件进行签名，则还需要通过名为zipalign的工具运行它，这将确保文件的压缩部分在字节边界上排列。 Android希望它们按字节对齐，以便它可以轻松读取它们而无需解压缩文件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/signApk.png?raw=true"></p><p>网上还有上面所有步骤的详细图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/8f422997.png?raw=true"></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="The-adb-server-starts-if-it’s-not-already-running"><a href="#The-adb-server-starts-if-it’s-not-already-running" class="headerlink" title="The adb server starts if it’s not already running"></a>The adb server starts if it’s not already running</h4><p>该应用程序将通过Android Debug Bridge部署到Android设备。</p><p>在我们的开发端上开启一个 adb 服务进程，在 Android 设备上开启一个类似的 adb 服务（adbd）。</p><p>如果您的计算机上未运行adb进程，则adb命令将启动它。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/adbUse.png?raw=true"></p><p>adb进程将打开网络套接字，并在端口5037上侦听命令。您输入的每个adb命令都会将其指令发送到此端口。</p><h4 id="The-apk-file-is-transferred-to-the-device"><a href="#The-apk-file-is-transferred-to-the-device" class="headerlink" title="The .apk file is transferred to the device"></a>The .apk file is transferred to the device</h4><p>adb命令用于将.apk文件传输到Android设备上的文件系统中。该位置由应用程序的包名定义。</p><p>因此，例如，如果包是com.hfad.bitsandpizzas，则.apk文件将放在/data/app/com.hfad.bitsandpizzas中。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/storeApk.png?raw=true"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Android应用程序的运行方式最近发生了变化。</p><p>从API级别21开始，旧的Dalvik虚拟机已被新的Android Runtime取代。</p><p>让我们看一下应用程序运行时一步一步发生的事情。</p><h4 id="A-user-asks-for-an-app-to-be-launched"><a href="#A-user-asks-for-an-app-to-be-launched" class="headerlink" title="A user asks for an app to be launched"></a>A user asks for an app to be launched</h4><p>一个名为Zygote的过程用于启动应用程序。 Zygote是Android进程的不完整版本 —— 其内存空间包含任何应用程序所需的所有核心库，但它尚未包含特定于特定应用程序的任何代码。 Zygote使用fork系统调用创建自己的副本。</p><p> Android是一个Linux系统，fork调用可以很快复制像Zygote这样的进程。<strong>这就是使用Zygote进程的原因：复制像Zygote这样的半启动进程比从主系统文件加载新进程要快得多。</strong> Zygote意味着您的应用程序启动速度更快。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/forkProcess.png?raw=true"></p><h4 id="Android-converts-the-dex-code-to-native-OAT-format"><a href="#Android-converts-the-dex-code-to-native-OAT-format" class="headerlink" title="Android converts the .dex code to native OAT format"></a>Android converts the .dex code to native OAT format</h4><p>新的app进程现在需要加载我们的应用程序的代码。请记住，您的应用代码存储在.apk包中的classes.dex文件中。因此，会从.apk中提取classes.dex文件并放入一个单独的目录中。但是，不是简单地放置classes.dex文件的副本，Android会将classes.dex中的Dalvik字节码转换为本机机器码。</p><p>所有以Java代码开头的代码现在都转换为一段本机编译代码。从技术上讲，classes.dex将转换为ELF共享对象。 Android调用此库格式OAT，转换classes.dex文件的工具称为dex2oat。（<strong>Android 5.0 开始，dex -&gt; oat 这个转换过程发生在安装过程中</strong>）</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/runDex2Oat.png?raw=true"></p><p>转换后的文件存储在如下的目录中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">/<span class="hljs-keyword">data</span>/dalvik-cache/x86/<span class="hljs-symbol">data@</span><span class="hljs-symbol">app@</span>com.hfad.<span class="hljs-symbol">bitsandpizzas@</span>base.<span class="hljs-symbol">apk@</span>classes.dex<br></code></pre></td></tr></table></figure><p><strong>该路径将包含应用程序的包名称，以确保它不会覆盖任何其他应用程序。</strong></p><p>转换后的代码将在特定于Android设备CPU的机器代码中。例如，如果Android设备是x86，则OAT文件将如下所示：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x001db888</span>:         85842400E0FFFF    <span class="hljs-keyword">test</span>    <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">esp</span> + -<span class="hljs-number">8192</span>]<br>suspend point dex PC: <span class="hljs-number">0x0000</span><br>GC map objects:  v0 (<span class="hljs-built_in">r5</span>), v1 (<span class="hljs-built_in">r6</span>)<br><span class="hljs-number">0x001db88f</span>:                 83EC1C    <span class="hljs-keyword">sub</span>     <span class="hljs-built_in">esp</span>, <span class="hljs-number">28</span><br><span class="hljs-number">0x001db892</span>:               896C2410    <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span> + <span class="hljs-number">16</span>], <span class="hljs-built_in">ebp</span><br><span class="hljs-number">0x001db896</span>:               <span class="hljs-number">89742414</span>    <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span> + <span class="hljs-number">20</span>], <span class="hljs-built_in">esi</span><br><span class="hljs-number">0x001db89a</span>:               897C2418    <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span> + <span class="hljs-number">24</span>], <span class="hljs-built_in">edi</span><br><span class="hljs-number">0x001db89e</span>:                   8BF8    <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-number">0x001db8a0</span>:                 <span class="hljs-number">890424</span>    <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">esp</span>], <span class="hljs-built_in">eax</span><br>...<br></code></pre></td></tr></table></figure><h4 id="The-app-loads-the-native-library"><a href="#The-app-loads-the-native-library" class="headerlink" title="The app loads the native library"></a>The app loads the native library</h4><p>然后将 native library 直接映射到应用程序进程的内存中。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Android%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84/mapOat.png?raw=true"></p><p>此时开始，应用程序将启动初始界面，应用程序将出现在屏幕上。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 无障碍服务</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Android%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Android%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>由于某种原因，我们需要屏蔽某些界面上的无障碍服务的使用，刚开始我以为是做不到的。因为我们的思路出了问题，就直接想着要去停止系统的这个服务。但是经过一番搜索之后，没有发现任何结果。官方文档也说了：</p><blockquote><p>The lifecycle of an accessibility service is managed exclusively by the system and follows the established service life cycle.</p></blockquote><p>无障碍服务是只由系统管理的。</p><p>然后我就又开始搜索其他方面的资料，比如：无障碍的原理与使用。巧合的是，我搜索到了这篇文章：</p><p><a href="https://juejin.im/post/5af95b46f265da0ba2671c16">随手记Android无障碍实践</a></p><p>看着看着，我发现这是一篇关系如何优化自己的App，让应用可以被障碍人士使用的文章。当我失望的准备关掉页面的时候，突然我想到了，既然他能优化使用，那我是不是能做一个反优化，让它不能使用呢！！！</p><p>于是，我仔细的看了文章，果然找到了一个令我感兴趣的东西。</p><p>在它们改造非标准组件的选中状态的时候，是这样做的：</p><blockquote><p>给控件添加无障碍代理（AccessibilityDelegate），在onInitializeAccessibilityNodeInfo()方法中调用AccessibilityNodeInfo对象的setChecked方法设置选中状态。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">rootView.setAccessibilityDelegate(<span class="hljs-keyword">new</span> View.AccessibilityDelegate() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInitializeAccessibilityNodeInfo</span><span class="hljs-params">(View host, AccessibilityNodeInfo info)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onInitializeAccessibilityNodeInfo(host, info);<br>        info.setCheckable(<span class="hljs-keyword">true</span>);<br>        info.setChecked(itemData.isSelected());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>看到没有，View 是可以设置一个关于无障碍的代理的。</p><p>既然可以设置代理，那么思路就很清晰了，一个好的代理，可以省很多事，但是我也可以搞一个吊都不吊你的代理。</p><p>在设置了一个代理之后，在用我们自己写的无障碍app测试的时候，果然无效了，而且自动化测试也失效了，效果还是可以的，对原来的逻辑也基本没有影响。</p><p>后来，我又找了一些关系 AccessibilityService 的文章，也看官方文档的东西，总算对这个东西有了一个整体的了解。贴一个比较有趣的图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%80%9D%E8%80%83/20160804232139269?raw=true"></p><p>这个图讲的是 AccessibilityEvent 事件产生后是如何发送到 AccessibilityService 的。</p><p>刚开始，我有点无法理解这个图，因为我对无障碍的理解，最初是从抢红包开始的，总觉得它是一个可以用来在别的App里面搞一些操作的东西。所以我总搞不明白为啥事件是从 App 里面传到 Service 里面，而不是 Service 传递到 App 里面，如果不是这样，它是怎么点别的 App 里面的东西的呢？？？</p><p>在我看完了官方文档，我才知道能够点击别的App的方法是在后来才加进去的，原本是没有这些操作的。也就是说 AccessibilityService 最初涉及出来是用来做一些辅助操作的，比如我们有一个 App，我们可以在这个 App 里面自己实现一个 AccessibilityService，当用户点击了某个按钮的时候，我们就可以提示用户你点击了啥按钮，你点击的按钮是啥颜色的等等…，这样的话事件的传递才是有用的，正确的。</p><p>后面加入的按钮点击操作，应该与 AccessibilityEvent  无关。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Apk 打包流程及扩展</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>我们开发一个应用，大概会有这些东西：</p><ul><li><p>源代码</p></li><li><p>三方库</p></li><li><p>图片，so等一些资源</p></li></ul><p>那我们从源文件说起，一个项目的源文件一般都是java文件，有需要还可能会有AIDL 文件。</p><blockquote><p>Java文件会毫无疑问的被 javac 编译成 class 文件。</p><p>而 AIDL 文件经过 aidl 工具编译之后也会生成相应的 Java 代码，被编译成 class 文件。</p><p>还有一个不要忘记了，资源文件经过编译之后会生成 R.java 文件，它也会被编译成 class 文件。</p></blockquote><p>这里扩展一下，我们知道 app 的 R.java 文件里面的变量都是 final 的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> main=<span class="hljs-number">0x7f030004</span>;<br></code></pre></td></tr></table></figure><p>而 lib 工程的 R.java 文件的变量却不是 final 的（从 ADT14 开始），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> main=<span class="hljs-number">0x7f030004</span>;<br></code></pre></td></tr></table></figure><p>那么这个又是什么原因呢？</p><p>其实很简单，如果lib中 R.java 文件里面的变量是 final 的，那么会有两个问题：</p><ul><li>编译速度：每次编译都需要将所有的资源与代码都编译一次，以免变量值产生碰撞</li><li>lib无法复用：如果生成的值是 final 的，那么这个lib给别人用的时候，值很可能与其他 lib 一样，导致问题</li></ul><p>所以，为了避免上面的问题，就将变量改为非 final 的，从而 lib 中使用 id 的时候，就只能使用 if-else，而不是使用 switch。</p><p>好的，源代码我们处理完了，接下来就需要处理 class 文件了，class 文件除了上面生成的之外，还有我们引入的三方库，他们也是 class 文件。</p><blockquote><p>dx工具会将这些 class 文件打包成 dex 文件。</p><p>主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。</p></blockquote><p>我们回头在说说资源文件的处理。</p><p>Android中的资源文件有那些呢?</p><p>res 文件夹下的资源，以及 assets 目录下的资源。</p><p>res 资源经过 aapt 的编译之后，会编译为二进制文件。</p><blockquote><p>会为每个文件赋予一个resource id。<strong>对于该类资源的访问，应用层代码则是通过resource id进行访问的</strong>。</p><p>生成一个resource.arsc文件，resource.arsc文件相当于一个文件索引表，记录了很多跟资源相关的信息。</p></blockquote><p>而 assets 的资源保持不动，所以我们只能通过名字来获取它。</p><p>资源处理完了，class文件也达成dex包了，接下来就要使用 apkBuilder 将<strong>编译后的资源、dex文件、so文件</strong>等等打成 apk 包了。</p><p>打好apk包了之后，需要签名，因为一旦APK文件生成，它必须被签名才能被安装在设备上。</p><p>签好名之后，还需要对<strong>apk文件进行对齐处理</strong>。那么对齐的作用是什么呢？让我们细细道来。</p><p>在开发人员的眼中，CPU是这样访问内存的：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/apk%E6%89%93%E5%8C%85/howProgrammersSeeMemory.jpg?raw=true"></p><p>CPU 读取内存中的数据是一个一个读取的。</p><p>然而，实际上CPU是这样读取内存数据的：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/apk%E6%89%93%E5%8C%85/howProcessorsSeeMemory.jpg?raw=true"></p><p>它是一块一块的读取的，CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的，可以当成是内存读取粒度。</p><p>那么这样会导致啥问题呢？假设我们需要读取一个 int 值到寄存器，分两种情况讨论：</p><ul><li>数据从地址0开始</li><li>数据从地址1开始</li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/apk%E6%89%93%E5%8C%85/singleByteAccess.jpg?raw=true"></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/apk%E6%89%93%E5%8C%85/doubleByteAccess.jpg?raw=true"></p><p>当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。</p><p>当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。</p><p>最后贴一张Google官方为我们提供的详细的构建过程图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/apk%E6%89%93%E5%8C%85/1612d19485723038?raw=true"></p><p>PS：</p><p>AnnotationProcessor 发生在 java -&gt; class 之前，因为它需要生成 java 文件。</p><p>Transform 发生在 class -&gt; dex 之前，它需要修改class。</p><p>Proguard 发生在 Transform 之后，因为混淆后就找不到方法名了。</p><p>流程是这样的：</p><p><code>annotationProcessor</code> -&gt;<code>javac</code>-&gt; <code>proguard</code> -&gt; <code>Transform </code></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bitmap</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Bitmap/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Bitmap/</url>
    
    <content type="html"><![CDATA[<p>记录一下以前看到过的知识点。</p><h3 id="Bitmap-像素数据的储存位置"><a href="#Bitmap-像素数据的储存位置" class="headerlink" title="Bitmap 像素数据的储存位置"></a>Bitmap 像素数据的储存位置</h3><p>先看<a href="https://developer.android.com/topic/performance/graphics/manage-memory">官方文档</a>：</p><blockquote><p>在Android 3.0之前，Bitmap对象放在Java堆，⽽像素数据是放在Native内存中。如果不⼿动调⽤recycle，Bitmap Native内存的回收完全依赖finalize函数回调，熟悉Java的同学应该知道，这个时机不太可控。 </p><p>Android 3.0～Android 7.0将Bitmap对象和像素数据统⼀放到Java堆中，这样就算我们不调⽤recycle，Bitmap内存也会随 着对象⼀起被回收。不过Bitmap是内存消耗的⼤户，把它的内存放到Java堆中似乎不是那么美妙。即使是最新的华为Mate 20，最⼤的Java堆限制也才到512MB，可能我的物理内存还有5GB，但是应⽤还是会因为Java堆内存不⾜导致OOM。 </p><p>Bitmap放到Java堆的另外⼀个问题会引起⼤量的GC，对系统内存也没有完全利⽤起来。 有没有⼀种实现，可以将Bitmap内存放到Native中，也可以做到和对象⼀起快速释放，同时GC的时候也能考虑这些内存防 ⽌被滥⽤？NativeAllocationRegistry可以⼀次满⾜你这三个要求，Android 8.0正是使⽤这个辅助回收Native内存的机制，来实现像素数据放到Native内存中。Android 8.0还新增了硬件位图Hardware Bitmap，它可以减少图⽚内存并提升绘制效率。</p></blockquote><p>假设我们有这样的一个手机，它的 system/build.prop 配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示应用程序启动后为其分配的初始大小为8m</span><br>dalvik.vm.heapstartsize=8m<br><br><span class="hljs-comment">// 每个应用程序最大内存可分配到64m</span><br>dalvik.vm.heapgrowthlimit=192m<br><br><span class="hljs-comment">// 单个虚拟机可分配的最大内存256m</span><br><span class="hljs-comment">// 使用大堆时，极限堆大小。一旦dalvik heap size超过这个值，直接引发oom。</span><br><span class="hljs-comment">// 在android开发中，如果要使用大堆，需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。</span><br>dalvik.vm.heapsize=512m<br><br><span class="hljs-comment">//  设定内存利用率的百分比，当实际的利用率偏离这个百分比的时候，虚拟机会在GC的时候调整堆内存大小，让实际占用率向个百分比靠拢。</span><br>dalvik.vm.heaptargetutilization=<span class="hljs-number">0.75</span><br><br>dalvik.vm.heapminfree=512k<br><br>dalvik.vm.heapmaxfree=8m<br></code></pre></td></tr></table></figure><p>我们不断的解析图片并持有所有图片的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> test&#123;<br>Map&lt;String, Bitmap&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.green);<br>map.put(<span class="hljs-string">&quot;&quot;</span> + System.currentTimeMillis(), bitmap);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 6.0 的手机中，实际测试应用出现OOM的时候，是在 200M 左右。对于现在动辄6G内存的手机而言，存在严重的资源浪费。所以8.0之后，Android也向这个方向靠拢，最好的下手对象就是Bitmap，因为它是耗内存大户。图片内存被转移到native之后，一个APP的图片处理不仅能使用系统绝大多数内存，还能降低Java层内存使用，减少OOM风险。</p><p>在 8.0 的手机中，实际测试应用出现OOM的时候，是在 2G 左右，所以，内存无限增长的情况下，也会导致APP崩溃，但是这种崩溃已经不是OOM崩溃了，Java虚拟机也不会捕获。</p><p>注意，<strong>上面的测试都是针对图片而言</strong>。</p><h3 id="Bitmap-的复用"><a href="#Bitmap-的复用" class="headerlink" title="Bitmap 的复用"></a>Bitmap 的复用</h3><ul><li><p>一是使用缓存：使用LruCache对Bitmap进行缓存，当再次使用到这个Bitmap的时候直接获取，而不用重走编码流程。</p></li><li><p>二是使用 inBitmap 字段：<br>Android3.0(API 11之后)引入了BitmapFactory.Options.inBitmap字段，设置此字段之后解码方法会尝试复用一张存在的Bitmap。这意味着Bitmap的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。不过，使用这个字段有几点限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">声明可被复用的Bitmap必须设置inMutable为<span class="hljs-keyword">true</span>；<br>Android4<span class="hljs-number">.4</span>(API <span class="hljs-number">19</span>)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为<span class="hljs-number">1</span>的Bitmap才可以复用；<br>Android4<span class="hljs-number">.4</span>(API <span class="hljs-number">19</span>)之前被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap设置的inPreferredConfig；<br>Android4<span class="hljs-number">.4</span>(API <span class="hljs-number">19</span>)之前待加载Bitmap的Options.inSampleSize必须明确指定为<span class="hljs-number">1</span>。<br>Android4<span class="hljs-number">.4</span>(API <span class="hljs-number">19</span>)之后被复用的Bitmap的内存必须大于需要申请内存的Bitmap的内存；<br></code></pre></td></tr></table></figure><p><strong>使用 inBitmap 之前</strong>：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/Bitmap/20190708114053537.png?raw=true"></p></li></ul><p><strong>使用 inBitmap 之后</strong>：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/Bitmap/20190708114228791.png?raw=true"></p><p>我刚开始看到这两张图的时候是很蛋疼的，因为它看起来就像是3张图片同时使用了一块内存，这特么怎么可能呢。但是实际上它是这样工作的：</p><blockquote><p>假设我们需要在Android应用程序中加载一些图。 当我们加载bitmap1时，它将为bitmap1分配内存。 然后，如果我们不再需要bitmap1，请不要回收位图（因为回收涉及调用GC）。相反，使用此bitmap1作为bitmap2的inBitmap。这样，bitmap2可以复用bitmap1的内存位置。</p></blockquote><h3 id="Bitmap-占用的内存大小"><a href="#Bitmap-占用的内存大小" class="headerlink" title="Bitmap 占用的内存大小"></a>Bitmap 占用的内存大小</h3><ul><li>getByteCount()：代表存储Bitmap的像素需要的最少内存。</li><li>getAllocationByteCount()：代表在内存中为Bitmap分配的内存大小。</li></ul><p>一般情况下两者是相等的。但是通过复用Bitmap来解码图片，如果被复用的Bitmap的内存比待分配内存的Bitmap大,那么getByteCount()表示新解码图片占用内存的大小（并非实际内存大小,实际大小是复用的那个Bitmap的大小），getAllocationByteCount()表示被复用Bitmap真实占用的内存大小（即mBuffer的长度）。</p><h3 id="如何计算Bitmap占用的内存大小"><a href="#如何计算Bitmap占用的内存大小" class="headerlink" title="如何计算Bitmap占用的内存大小"></a>如何计算Bitmap占用的内存大小</h3><p>公式：<strong>占用的内存 = width * height * 一个像素所占的内存</strong>。</p><p>一般情况下是正确的，但是有时候还需要考虑屏幕密度问题。比如，我们从资源文件中加载一张图片（BitmapFactory.decodeResource）：</p><blockquote><p>它占用的内存 = width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存</p></blockquote><p>nTargetDensity/inDensity 实际上就是图片被缩放了，因为屏幕密度与图片资源文件夹密度不一致时，系统就会缩放图片，所以这里就会影响到计算结果。</p><p>除了加载本地资源文件的解码方法会默认使用资源所处文件夹对应密度和手机系统密度进行缩放之外，别的解码方法默认都不会。</p><h3 id="Bitmap-的压缩"><a href="#Bitmap-的压缩" class="headerlink" title="Bitmap 的压缩"></a>Bitmap 的压缩</h3><h4 id="inSampleSize"><a href="#inSampleSize" class="headerlink" title="inSampleSize"></a>inSampleSize</h4><p>不多说了，注意会将所设置的值自动更正为2的幂次方（接近并且小于所设置的值），有人说不是所有版本都这样，但也无从考究了。</p><h4 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h4><p>压缩了文件的质量。这个玩意要了解还需要一定的储备知识，让我们从头说起。</p><p>首先我们需要了解的是图片各种相关的大小，文件大小、占用硬盘大小、占用内存大小。对于文件的大小实际就是它本身的包含的信息的大小，即实际具有的字节数，它以Byte为衡量单位，只要文件内容和格式不发生变化，文件大小就不会发生变化。我们可以直接拿File的length()方法就能获得文件的大小。那么硬盘的大小是什么呢？不管在什么系统中，我们经常会看到文件大小和占用磁盘空间的大小不一致，这是为什么呢？</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/Bitmap/20190708140031172.png?raw=true"></p><p>文件在磁盘上的所占空间不是以Byte为衡量单位的，它最小的计量单位是“簇(Cluster)”。 扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 为了更好地管理磁盘空间和更高效地从硬盘读取数据，<strong>操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。</strong>从上面的图可以看出，Windows 的一簇是4KB，所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。</p><p>这样我们就理解了为什么文件大小和实际占用硬盘大小不一样了。那么现在就剩内存的大小了。<br>图片在内存里占用的大小和它本身的大小没有关系。我们知道图像是由一个一个的像素组成的，我们的图片的尺寸就是像素的多少，例如宽高是1024*1024的图像就是横竖都有1024个像素的图片，根据图片的编码格式不同，每个像素所占的内存大小是不一样的：</p><ul><li><p>ALPHA_8：表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度</p></li><li><p>ARGB_4444：表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节</p></li><li><p>ARGB_8888：表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节</p></li><li><p>RGB_565：表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节</p></li></ul><p>其中A代表透明度；R代表红色；G代表绿色；B代表蓝色。</p><p>最终，图片在内存所占空间的大小是：图片长度 x 图片宽度 x 一个像素点占用的字节数。即，例如我们有一个1024*1024大小的ARGB的图，那么它在内存里的大小为1024*1024*4=4M，但是在硬盘上的大小甚至可以小到6.4k。</p><p>这是为什么，为什么差别这么大？因为图片在内存中时是完整的图片信息，例如即使一个图是全白不透明或全黑全透明也会全部在内存中 (FFFFFFFF/00000000) 占用空间。但是在硬盘上却是被压缩的状态，例如平时我们常见的jpg和png，都是将图片信息进行了压缩，然后存储在了硬盘上。所以说一个图片在内存中占用的空间要远大于在硬盘的空间。</p><p>以上说了这么多，最后的引出的结论很关键：<strong>jpg和png都是对图片信息进行压缩然后存储到硬盘上的。它们有什么区别呢？jpg实际是有损压缩，而png是无损压缩。</strong>现在来看最上面的图片压缩的方法，可以看到Bitmap的压缩格式是JPEG（即jpg）。为什么是jpg，因为只有jpg才支持压缩，png是无损的，根本就不能进行再压缩。所以说Bitmap的compress方法只能对jpg起作用，当然，局限不仅仅是这一点。我们不禁要问，jpg能再压缩，那到底压缩了什么呢？</p><p>首先jpg与png不同，png支持透明度，但是jpg不支持，所以jpg本身就比png小了四分之一的空间。其次jpg是有损压缩，除了透明度被干掉外，本身的RGB颜色也被压缩了，当然了，<strong>压缩的算法非常复杂，不在本文的研究范围内。压缩本身也是有等级的，压缩的越厉害，图像失真也越厉害，但是最终压缩都是有上限的，就是说从算法上来说就不支持任意一个图片压缩到任意小</strong>。我们可以<strong>参考PS工具</strong>最后保存jpg图片的质量（品质）那个选项，可以选择从0到100，0当然代表质量最差了，我们选择0那么就会出来最小的图片，这个应该就是这张jpg图片能够压缩到的最小值。有人说可以把压缩到0后的图片再去重复一遍这个步骤就好了嘛。实际这样是不行的，这里要说明的是0到100是一个绝对值，就是说一个图片的质量（品质）就是0到100，<strong>不能循环压缩</strong>，你可以试一下，用一个已经是0得图片再次压缩到50，那么它的大小不但不会小，反而会增大！！！</p><p>最后，compress方法是质量压缩，压缩后改变大小的是jpg文件的大小，图片在内存中的大小还是不变的！因为宽高和每个像素占的空间都是没有变化的！</p><h4 id="inDensity-与-inTargetDensity"><a href="#inDensity-与-inTargetDensity" class="headerlink" title="inDensity 与 inTargetDensity"></a>inDensity 与 inTargetDensity</h4><p>这个是我在《Android权威编程指南》上看到的。</p><p>上面说的，inSampleSize 只能缩放 2 的幂次方。这个在某些情况下可能不好满足需求，比如：一张1200 * 1200 的图，想要缩放到 500 * 500。这个时候使用 inSampleSize 就搞不定了！</p><p>所以可以借助于 inDensity 和 inTargetDensity，用 inDensity 与 inTargetDensity 就能做到任意等比缩放。</p><p>可以先使用 inSampleSize 缩小到 600 * 600（不直接使用 inDensity 与 inTargetDensity的原因书上没有说，但是我猜想应该是它的效率高），然后再使用 inDensity 与 inTargetDensity ，将 inDensity 设置成 600，将 inTargetDensity 设置成 500，就可以了。</p><p>实际上原理，就是与 android.graphics.BitmapFactory#decodeResourceStream 差不多啦。</p><p>给出项目代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calInSampleSize</span><span class="hljs-params">(BitmapFactory.Options options,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = options.outHeight;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = options.outWidth;<br>    <span class="hljs-keyword">int</span> inSampleSize = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfHeight = height / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> halfWidth = width / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight<br>                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;<br>            inSampleSize *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> inSampleSize;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BitmapFactory.<span class="hljs-function">Options <span class="hljs-title">getOptions</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        BitmapFactory.Options options, <span class="hljs-keyword">int</span> reqWidth, <span class="hljs-keyword">int</span> reqHeight)</span> </span>&#123;<br>    options.inSampleSize = calInSampleSize(options, reqWidth, reqHeight);<br>    options.inScaled = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 这里使用设置要缩放的宽高比，与 decodeResource 的缩放一样</span><br>    options.inDensity = options.outHeight;<br>    options.inTargetDensity = reqHeight * options.inSampleSize;<br>    options.inJustDecodeBounds = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> options;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用这个方法就可以做出任意的等比例缩放了。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FileProvider</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/FileProvider/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/FileProvider/</url>
    
    <content type="html"><![CDATA[<p>从 Android N（7.0） 开始，将严格执行 StrictMode 模式，也就是说，将对安全做更严格的校验。而从 Android N 开始，将不允许在 App 间，使用 <code>file://</code> 的方式，传递一个 File ，否者会抛出 FileUriExposedException 的错误，会直接引发 Crash。只能使用FileProvider 将<code> file://</code> 替换为 <code>content://</code>。</p><p>FileProvider 本质上就是一个 ContentProvider ，它其实也继承了 ContentProvider 的特性。ContentProvider 其实就是在可控的范围内，向外部其他的 App 分享数据。而 FileProvider 将这样的数据变成了一个 File 文件而已。</p><p>下面的代码演示了如何使用 FileProvier：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.myapp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">application</span></span><br><span class="hljs-tag">        <span class="hljs-attr">...</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.v4.content.FileProvider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.example.myapp.fileprovider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/filepaths&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>provider 标签下，配置了几个属性：</p><ul><li>name ：配置当前 FileProvider 的实现类。</li><li>authorities：配置一个 FileProvider 的名字，<strong>它在当前系统内需要是唯一值</strong>。</li><li>exported：表示该 FileProvider 是否需要公开出去，这里不需要，所以是 false。</li><li>granUriPermissions：是否允许授权文件的临时访问权限。这里需要，所以是 true。</li></ul><p>在配置 Provider 的时候，还需要额外配置一个 <code>&lt;meta-data/&gt;</code> 标签，它用于配置 FileProvider 支持分享出去的目录。这个 <code>&lt;meta-data/&gt;</code> 标签的 <strong>name  值是固定的</strong>，resource 需要指向一个 根节点为 <code>paths</code> 的 xml 资源文件。在 <code>src/main/res/xml/</code>文件夹下面:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">paths</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 表示 files/images/myimages 下的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">files-path</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;images/&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myimages&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">paths</span>&gt;</span><br></code></pre></td></tr></table></figure><p>path下面可以配置多个节点：</p><ul><li><p><strong>root-path</strong>：表示根目录，『/』。</p></li><li><p><strong>files-path</strong>：表示 content.getFileDir() 获取到的目录。</p></li><li><p><strong>cache-path</strong>：表示 content.getCacheDir() 获取到的目录</p></li><li><p><strong>external-path</strong>：表示Environment.getExternalStorageDirectory() 指向的目录。</p></li><li><p><strong>external-files-path</strong>：表示 ContextCompat.getExternalFilesDirs() 获取到的目录。</p></li><li><p><strong>external-cache-path</strong>：表示 ContextCompat.getExternalCacheDirs() 获取到的目录。</p></li></ul><p>具体可以参考 <code>FileProvider</code>  的官方说明文档 。</p><p>定义好需要分享的文件之后，在ClientApp请求文件的时候，我们就可以返回一个 Uri 给它。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> requestFile = File(imageFilenames[position])<br><span class="hljs-keyword">val</span> fileUri: Uri? = <span class="hljs-keyword">try</span> &#123;<br>    FileProvider.getUriForFile(<br>        <span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>,<br>        <span class="hljs-string">&quot;com.example.myapp.fileprovider&quot;</span>,<br>        requestFile)<br>&#125; <span class="hljs-keyword">catch</span> (e: IllegalArgumentException) &#123;<br>    Log.e(<span class="hljs-string">&quot;File Selector&quot;</span>,<br>          <span class="hljs-string">&quot;The selected file can&#x27;t be shared: <span class="hljs-variable">$requestFile</span>&quot;</span>)<br>        <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获取文件的 Uri 一定要使用 <code>FileProvider.getUriForFile</code> 这个方法，<strong>不要使用<code>Uri.fromFile()</code>这个方法</strong>。因为这个方法要求 ClientApp 具有读权限，并且无法跨App分享文件。</p><p>在返回Uri之后，还需要给 Intent 加上临时权限：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Grant temporary read permission to the content URI</span><br>resultIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)<br><span class="hljs-comment">// Put the Uri and MIME type in the result Intent</span><br>resultIntent.setDataAndType(fileUri, contentResolver.getType(fileUri))<br><span class="hljs-comment">// Set the result</span><br>setResult(Activity.RESULT_OK, resultIntent)<br></code></pre></td></tr></table></figure><p>还有另外一种授权方式，但是不建议使用：</p><p>使用 <code>Context.grantUriPermission()</code> 为其他 App 授予 Uri 对象的访问权限。这种情况下，授权的有效期限，从授权一刻开始，<strong>截止于设备重启或者手动调用 <code>Context.revokeUriPermission()</code> 方法，才会收回对此 Uri 的授权。</strong></p><p>而使用 Flag 的方式，当 ClientApp 的任务栈结束的时候，就会自动收回权限。</p><p>ClientApp 获取到 Uri 之后，就可以访问文件了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Get the file&#x27;s content URI from the incoming Intent</span><br>returnIntent.<span class="hljs-keyword">data</span>?.also &#123; returnUri -&gt;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Try to open the file for &quot;read&quot; access using the</span><br><span class="hljs-comment">     * returned URI. If the file isn&#x27;t found, write to the</span><br><span class="hljs-comment">     * error log and return.</span><br><span class="hljs-comment">     */</span><br>    inputPFD = <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Get the content resolver instance for this context, and use it</span><br><span class="hljs-comment">         * to get a ParcelFileDescriptor for the file.</span><br><span class="hljs-comment">         */</span><br>        contentResolver.openFileDescriptor(returnUri, <span class="hljs-string">&quot;r&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: FileNotFoundException) &#123;<br>        e.printStackTrace()<br>        Log.e(<span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;File not found.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// Get a regular file descriptor for the file</span><br>    <span class="hljs-keyword">val</span> fd = inputPFD.fileDescriptor<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Intent 数据传输限制</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Intent%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%99%90%E5%88%B6/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Intent%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>当我们启动一个Activity的时候，这个过程是需要与AMS进行进程之间通信的。</p><p>启动 Activity 的时候，需要使用Intent，所以我们在intent中携带的数据也要从APP进程传输到AMS进程，再由AMS进程传输到目标Activity所在进程。</p><p>通过阅读 Activity 的启动过程，我们知道app与AMS 的进程通信是使用Binder来完成的，看一张图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE/Intent.png?raw=true"></p><p>普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 <strong>(1x1024x1024) - (4096 x2)</strong> ，但是由于Intent中还有其他的信息，所以能够放入的数据肯定比这个值还要小。</p><p>这个限制定义在<code>frameworks/native/libs/binder/processState.cpp</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#<span class="hljs-function">define <span class="hljs-title">BINDER_VM_SIZE</span> <span class="hljs-params">((<span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)</span> - <span class="hljs-params">(<span class="hljs-number">4096</span> *<span class="hljs-number">2</span>)</span>)</span><br></code></pre></td></tr></table></figure><p>如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的。</p><p>PS：<strong>注意上面的图：Binder进行数据传递的时候，只需要一次数据拷贝。</strong></p><p>这是因为Binder借助内存映射，在<code>内核空间</code>和接收方的<code>用户空间</code>的数据缓存区做了一层内存映射。也就是说，在发送方将数据拷贝到内存空间的时候，内核空间的这部分地址同时也会被映射到接收方的内存缓存中，这样子，就少了一次从内和空间拷贝到用户空间。</p><h3 id="代替方案"><a href="#代替方案" class="headerlink" title="代替方案"></a>代替方案</h3><ul><li><p>写入临时文件或者数据库，通过FileProvider将该文件或者ContentProvider通过Uri发送至目标。一般适用于不同进程，比如分离进程的UI和后台服务，或不同的App之间。之所以采用FileProvider是因为7.0以后，对分享本App文件存在着严格的权限检查。</p><p>因为 ContentProvider 是使用匿名共享内存来交换数据的，所以没有限制。</p></li><li><p>同一个进程中，通过单利来传递数据。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MultiDex</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/MultiDex%E5%A4%84%E7%90%86/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/MultiDex%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h3><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，其中包含用来运行您的应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内可引用的方法总数限制在 65,536，其中包括 Android 框架方法、库方法以及您自己代码中的方法。</p><p>单个Dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。</p><p>对于Dex文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是使用Dex工具将class文件转化为Dex文件的过程中， 单个Dex文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536。</p><p>这就是65536问题的根本来源。</p><p>另外还有一种情况，有时候方法数没有达到 65536，并且编译器也正常的完成了编译工作，但是应用在低版本手机安装是异常终止，异常信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">E/dalvikvm: Optimization failed<br>E/installd: dexopt failed on <span class="hljs-string">&#x27;/data/dalvik-cache/data@app@com.aprz.test.apk@classes.dex&#x27;</span> res = <span class="hljs-number">65433</span><br></code></pre></td></tr></table></figure><p>为什么会出现这种情况呢？其实是这样的，dexopt是一个程序，应用在安装时，系统会通过dexopt 来优化dex文件，在优化的过程中 dexopt 采用一个固定大小的缓冲去来储存应用中的所有方法的信息，这个缓冲区就是 LinearAlloc。LinearAlloc缓冲区在新版本的 Android 系统中其大小时是 8MB 或者 16MB，但是在 Android 2.2和2.3中却只有5MB，当待安装的apk方法数比较多的时候，尽管它没有达到65536的限制，但是它的储存空间仍然有可能超过5MB，这中情况下dexopt程序就会报错。</p><h3 id="Android-5-0-之前版本的-Dalvik-可执行文件分包支持"><a href="#Android-5-0-之前版本的-Dalvik-可执行文件分包支持" class="headerlink" title="Android 5.0 之前版本的 Dalvik 可执行文件分包支持"></a>Android 5.0 之前版本的 Dalvik 可执行文件分包支持</h3><p>Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 限制应用的每个 APK 只能使用单个 classes.dex 字节码文件。想要绕过这个限制，就需要使用Google提供的<a href="https://developer.android.com/tools/support-library/features.html?hl=zh-cn#multidex">Dalvik 可执行文件分包支持库</a>。</p><p>因为Android系统在启动应用时只加载了主dex（Classes.dex），其他的 dex 需要我们在应用启动后进行动态加载安装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SomeOtherApplication</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attachBaseContext</span><span class="hljs-params">(Context base)</span> </span>&#123;<br>     <span class="hljs-keyword">super</span>.attachBaseContext(base);<br>     <span class="hljs-comment">// 加载其他的dex文件</span><br>      <span class="hljs-comment">// 原理就是：通过反射手动添加其他Dex文件中的class到 ClassLoader 的 pathList字段中，就可以实现类的动态加载</span><br>     MultiDex.install(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程一般只在第一次冷启动应用的时候比较耗时，除了要抽取其他的 dex 文件，Dalvik 虚拟机还会使用 dex2oat 将 dex 文件优化成 odex 文件，将生成的文件放在手机的data/dalvik-cache目录下，便于以后使用。以后再次运行时，因为不用再次生成 odex，所以运行速度很快。</p><h3 id="Android-5-0-及更高版本的-Dalvik-可执行文件分包支持"><a href="#Android-5-0-及更高版本的-Dalvik-可执行文件分包支持" class="headerlink" title="Android 5.0 及更高版本的 Dalvik 可执行文件分包支持"></a>Android 5.0 及更高版本的 Dalvik 可执行文件分包支持</h3><p>Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，后者原生支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 <code>classesN.dex</code> 文件，并将它们编译成单个 <code>.oat</code> 文件，供 Android 设备执行。因此，如果您的 <code>minSdkVersion</code> 为 21 或更高值，则不需要 Dalvik 可执行文件分包支持库。只需要在模块级 build.gradle 文件中将 multiDexEnabled 设置为 true，如此处所示：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    defaultConfig &#123;<br>        ...<br>        minSdkVersion <span class="hljs-number">21</span> <br>        targetSdkVersion <span class="hljs-number">28</span><br>        multiDexEnabled <span class="hljs-literal">true</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MultiDex-install-带来的问题"><a href="#MultiDex-install-带来的问题" class="headerlink" title="MultiDex.install 带来的问题"></a>MultiDex.install 带来的问题</h3><p>当我们使用了分包支持库之后，在运行app时可能会出现这样的错误</p><h4 id="java-lang-NoClassDefFoundError"><a href="#java-lang-NoClassDefFoundError" class="headerlink" title="java.lang.NoClassDefFoundError"></a>java.lang.NoClassDefFoundError</h4><p>出现这个问题的原因是：</p><p>在应用启动期间，需要该类，但是这个类不在 MainDex 中，所以解决方案就是将这个类放到 MainDex 中。</p><p>具体可以参考官方文档： <a href="https://developer.android.com/studio/build/multidex?hl=zh-cn#keep">声明主 DEX 文件中需要的类</a> 。</p><h4 id="dexopt-failed"><a href="#dexopt-failed" class="headerlink" title="dexopt failed"></a>dexopt failed</h4><p>dalvik的dexopt程序分配一块内存来统计你的app的dex里面的classes的信息，由于classes太多方法太多超过这个linearAlloc 的限制 。</p><p>解决方案就是减少 dex 的大小。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android.applicationVariants.all &#123;<br>    variant -&gt;<br>        dex.doFirst&#123;<br>            dex-&gt;<br>            <span class="hljs-keyword">if</span> (dex.additionalParameters == <span class="hljs-literal">null</span>) &#123;<br>                dex.additionalParameters = []<br>            &#125;<br>                dex.additionalParameters += <span class="hljs-string">&#x27;--set-max-idx-number=48000&#x27;</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="启动过程中-ANR"><a href="#启动过程中-ANR" class="headerlink" title="启动过程中 ANR"></a>启动过程中 ANR</h4><p>启动期间在设备数据分区中安装 DEX 文件的过程相当复杂，如果辅助 DEX 文件较大，可能会导致应用无响应 (ANR) 错误。在此情况下，您应该<a href="https://developer.android.com/studio/build/shrink-code.html?hl=zh-cn">通过 ProGuard 应用代码压缩</a>以尽量减小 DEX 文件的大小，并移除未使用的那部分代码。</p><p>这个是官方给出的建议，但是显然不太合适中国程序员国情，所以需要使用别的方案：</p><ul><li><a href="https://www.cnblogs.com/CharlesGrant/p/5112597.html">异步加载方案</a></li><li><a href="https://www.jianshu.com/p/c2d7b76ff063">多进程加载方案</a></li><li>插件化</li><li>这两个实现其实差不多，都是提供了一种避免在其他Dex文件未加载完成时，造成的ClassNotFoundException的手段。</li></ul><h3 id="分包后-MainDex-仍然爆掉"><a href="#分包后-MainDex-仍然爆掉" class="headerlink" title="分包后 MainDex 仍然爆掉"></a>分包后 MainDex 仍然爆掉</h3><ul><li><a href="https://juejin.im/post/5c5bee986fb9a049bc4d1b58#heading-1">MainDex 瘦身</a></li><li>自行分包，直接指定哪些类放到 MainDex</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Parcelable与Serializable</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Parcelable%E4%B8%8ESerializable/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Parcelable%E4%B8%8ESerializable/</url>
    
    <content type="html"><![CDATA[<p>通常，在Android里面传递数据都是使用的 Intent，而 Intent 里面想要放一个 Java 对象，那这个对象要么实现 Parcelable 要么实现 Serializable 。</p><p>一般我们都是选择实现 Parcelable，因为它的<strong>效率高</strong>，而且不会产生很多的临时对象。</p><p>当然这些都是网上说的，并没有证明，现在我们来测试一下，从传输效率开始。当然我也懒得做测试的，所以我找了一篇<a href="http://www.developerphil.com/parcelable-vs-serializable/">文章</a>，个人觉得还是可以的，有好奇心的小伙伴可以自己测试一下。</p><p>测试过程如下：</p><ul><li>模拟将对象传递给Activity的过程：直接调用 [Bundle#writeToParcel(Parcel, int)](<a href="https://developer.android.com/reference/android/os/Bundle.html#writeToParcel">https://developer.android.com/reference/android/os/Bundle.html#writeToParcel</a>(android.os.Parcel, int))，然后再取出来。</li><li>循环 1000 次</li><li>做10次测试，取平均值</li><li>在多个设备上测试</li></ul><p>下面给出该作者测试的结果：</p><p><img src="http://www.developerphil.com/assets/parcelable-vs-serializable-e1366334109758.png"></p><blockquote><h6 id="Nexus-10"><a href="#Nexus-10" class="headerlink" title="Nexus 10"></a>Nexus 10</h6><p>Serializable: 1.0004ms,  Parcelable: 0.0850ms - 10.16x improvement.</p><h6 id="Nexus-4"><a href="#Nexus-4" class="headerlink" title="Nexus 4"></a>Nexus 4</h6><p>Serializable: 1.8539ms - Parcelable: 0.1824ms - 11.80x improvement.</p><h6 id="Desire-Z"><a href="#Desire-Z" class="headerlink" title="Desire Z"></a>Desire Z</h6><p>Serializable: 5.1224ms - Parcelable: 0.2938ms - 17.36x improvement.</p></blockquote><p>可以看出，区别还是很明显的。可能几ms对我们人类来说，感觉不到什么，但是对于CPU就像是过了几个月了。特别是Android需要16ms来绘制一帧，你传递一个对象就花了几ms，就没剩多少时间了。</p><p>好了说完了效率，我们再说说<strong>为啥 Serializable 会产生很多临时对象</strong>。</p><p>看一个简单的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span><span class="hljs-params">(String name, String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们把这个对象序列化到文件中的时候，它的内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">aced</span> <span class="hljs-number">0005</span> <span class="hljs-number">7372</span> <span class="hljs-number">0011</span> <span class="hljs-number">636</span>f <span class="hljs-number">6</span>d<span class="hljs-number">2</span>e <span class="hljs-number">6578</span> <span class="hljs-number">616</span>d<br><span class="hljs-attribute">706c</span> <span class="hljs-number">652</span>e <span class="hljs-number">5068</span> <span class="hljs-number">6</span>f<span class="hljs-number">6</span>e <span class="hljs-number">6551</span> <span class="hljs-number">4868</span> <span class="hljs-number">16</span>d<span class="hljs-number">4</span> <span class="hljs-number">8</span>afd<br><span class="hljs-attribute">8702</span> <span class="hljs-number">0002</span> <span class="hljs-number">4</span>c<span class="hljs-number">00</span> <span class="hljs-number">0761</span> <span class="hljs-number">6464</span> <span class="hljs-number">7265</span> <span class="hljs-number">7373</span> <span class="hljs-number">7400</span><br><span class="hljs-attribute">124c</span> <span class="hljs-number">6</span>a<span class="hljs-number">61</span> <span class="hljs-number">7661</span> <span class="hljs-number">2</span>f<span class="hljs-number">6</span>c <span class="hljs-number">616</span>e <span class="hljs-number">672</span>f <span class="hljs-number">5374</span> <span class="hljs-number">7269</span><br><span class="hljs-attribute">6e67</span> <span class="hljs-number">3</span>b<span class="hljs-number">4</span>c <span class="hljs-number">0004</span> <span class="hljs-number">6</span>e<span class="hljs-number">61</span> <span class="hljs-number">6</span>d<span class="hljs-number">65</span> <span class="hljs-number">7100</span> <span class="hljs-number">7</span>e<span class="hljs-number">00</span> <span class="hljs-number">0178</span><br><span class="hljs-attribute">7074</span> <span class="hljs-number">0007</span> <span class="hljs-number">6265</span> <span class="hljs-number">696</span>a <span class="hljs-number">696</span>e <span class="hljs-number">6774</span> <span class="hljs-number">0008</span> <span class="hljs-number">7</span>a<span class="hljs-number">68</span><br><span class="hljs-attribute">616e</span> <span class="hljs-number">6773</span> <span class="hljs-number">616</span>e<br></code></pre></td></tr></table></figure><p>我就不解释一个个解释它们代表什么了，这些数据包含了如下内容：</p><ul><li>序列化协议，固定值</li><li>序列化协议版本</li><li>对象的开始标记，类的开始标记</li><li>类名长度，类名</li><li>有多少个字段</li><li>每个字段长度，字段名，字段值</li></ul><p>嗯，还有一些东西，特别是有父类的，更蛋疼。可以看到，本来我们只需要传递 name 与 address 的值，它给我们搞了一大堆东西，非常的浪费。还有反序列的时候，由于它使用了反射机制，所以会产生很多的临时变量，可能会增加GC的频率。</p><p>Parcelable 的序列化与反序列化的过程就不一样了，它不像 Serializable 那么严格，它只存放了变量的值，其他的都没有存放。我们看一下实现 Parcelable 的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-keyword">int</span> flags)</span> </span>&#123;<br>    dest.writeString(name);<br>    dest.writeString(type);<br>    dest.writeString(accessId);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们将对象的属性值写入到了 parcel 中。</p><p>而 parcel 里面可以理解为有一块内存空间，用来储存这些属性值，还有一个指针指向准备写入的位置，写入一个属性后就往后偏移一段距离。所以读取的时候，一定要按照写入的顺序，否则会出错。</p><p>然后在使用 parcel 读取出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">createFromParcel</span><span class="hljs-params">(Parcel source)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Account(source);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(Parcel in)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = in.readString();<br>    <span class="hljs-keyword">this</span>.type = in.readString();<br>    <span class="hljs-keyword">this</span>.accessId = in.readString();<br>&#125;<br></code></pre></td></tr></table></figure><p>序列化与反序列化的核心都是 Parcel。</p><p>Parcel 的注释上说了，它是消息的容器，可以通过 IBinder 来传输。</p><p>我们再来思考一下，Bundle 中的 Serializable 数据是如何传输的。</p><blockquote><p>android.os.Parcel#writeValue</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br>            <span class="hljs-comment">// Must be last</span><br>            writeInt(VAL_SERIALIZABLE);<br>            writeSerializable((Serializable) v);<br>        &#125;<br></code></pre></td></tr></table></figure><p>writeSerializable 里面仍然是调用了 <code>java.io.ObjectOutputStream#writeObject</code> 方法来写对象。</p><blockquote><p>android.os.Parcel#readSerializable(java.lang.ClassLoader)</p></blockquote><p>同样的，读取一个 Serializable 对象的时候，也是通过 <code>java.io.ObjectInputStream#readObject</code>  来获取的，走的是 Java 的序列化与反序列化逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Window 与 View的动态更改思考</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Window%20%E4%B8%8E%20View%E7%9A%84%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E6%80%9D%E8%80%83/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Window%20%E4%B8%8E%20View%E7%9A%84%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>我们创建一个悬浮窗的时候，需要使用 WindowManager 来创建。</p><p>WindowManager 是一个接口，它继承至 ViewManager，主要有3个方法供我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeView</span><span class="hljs-params">(View view)</span></span>;<br></code></pre></td></tr></table></figure><p>我们获取WindowManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WindowManager windowManager = (WindowManager)context().getSystemService(Context.WINDOW_SERVICE);<br></code></pre></td></tr></table></figure><p>一般通过这种方法调用的，最终都会触发一个 IPC 调用。</p><p>那么，这就引发了我的一个猜想：我们在 Activity 的布局里面，每次动态添加和删除 View 的时候，里面有没有触发 IPC 调用？？？</p><p>我们拿 WindowManager的addView方法来分析一下，它的实现类是 <code>android.view.WindowManagerGlobal</code>。</p><blockquote><p>android.view.WindowManagerGlobal#updateViewLayout</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">root.setLayoutParams(wparams, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>它调用了 ViewRootImpl 的 setLayoutParams 方法。</p><blockquote><p>android.view.ViewRootImpl#setLayoutParams</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">scheduleTraversals();<br></code></pre></td></tr></table></figure><p>这个方法内部又会调用 performTraversals方法，这个方法我们就很熟悉了，它就是 View 的绘制流程的入口。</p><blockquote><p>android.view.ViewRootImpl#performTraversals</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">relayoutWindow(...)<br></code></pre></td></tr></table></figure><p>这个方法就会发起IPC调用来更新Window。</p><p>我们的普通的 ViewGroup 的addView等方法，会触发 requestLayout 方法，同样的会导致 scheduleTraversals 方法的调用，所以也会有 IPC 调用。</p><p>可以想象到，addView 是一个比较重量的操作。</p><p>update at 2020/4/20</p><p>今天看书又有新的理解。</p><p>先上一张图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%80%9D%E8%80%83/wms.png?raw=true"></p><p>上图讲的是：我们使用 WindowManager 将一个 view add 到 window 所涉及到的关键类。</p><p>但是里面有一个叫做 IWindowSession 的东西，这个就是用来与 WMS 交互的类。刚开始我以为我们是直接与WMS进行交互的，没想到居然又转了一层。</p><p>关于 ViewRootImpl 与 WMS 的交互，并不是直接操作的，而是通过 Session 来进行的，看下面的这张图：</p><p><img src="https://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image006.png"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ViewModel 与数据保存思考</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/ViewModel%20%E4%B8%8E%20setRetainInstance/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/ViewModel%20%E4%B8%8E%20setRetainInstance/</url>
    
    <content type="html"><![CDATA[<p>今天在做一个需求的时候，为了用户的体验，我想在进程被回收的时候保存一下数据，等 activity 重新创建的时候再取出来。</p><p>我之前看过一些文章，关于 ViewModel 的，说是 ViewModel 在屏幕方向发生变化的时候不用重新储存数据（与版本有关系）。我也是看了相关代码，确实是这样。</p><p>我们可以看看 ViewModel 是如何创建与保存的。</p><p>当我们调用 <code>ViewModelProviders.of(this).get(xxx.class); </code>来获取（创建一个）viewModel 的时候：</p><blockquote><p>android.arch.lifecycle.ViewModelProvider#get(java.lang.String, java.lang.Class<T>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T extends ViewModel&gt; <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> String key, <span class="hljs-meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;<br>    ViewModel viewModel = mViewModelStore.get(key);<br><br>    <span class="hljs-keyword">if</span> (modelClass.isInstance(viewModel)) &#123;<br>        <span class="hljs-comment">//noinspection unchecked</span><br>        <span class="hljs-keyword">return</span> (T) viewModel;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//noinspection StatementWithEmptyBody</span><br>        <span class="hljs-keyword">if</span> (viewModel != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> log a warning.</span><br>        &#125;<br>    &#125;<br><br>    viewModel = mFactory.create(modelClass);<br>    mViewModelStore.put(key, viewModel);<br>    <span class="hljs-comment">//noinspection unchecked</span><br>    <span class="hljs-keyword">return</span> (T) viewModel;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法内部实际上是缓存了 ViewModel 对象的，所以你多次调用get方法，不会创建多个。再看看 key 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DEFAULT_KEY + <span class="hljs-string">&quot;:&quot;</span> + canonicalName<br></code></pre></td></tr></table></figure><p>可以看到 key 只与 class 有关，所以只要 class 一样，就会获取到同一个对象。</p><p>那么，即使屏幕旋转之后，activity创建了新的对象，但是它的 class 是不会变的，所以仍然可以引用到同一个 ViewModel。</p><p>嗯，上面是有关activity方向的处理，但是我的需求是内存不足被回收，如果进程都被回收掉了，堆里面的对象就也都被回收了，ViewModel 对象也就不存在了，也就是说，ViewModel 无法满足我的需求。</p><p>但是我又想到了一件事，ViewModel 之所以能感知宿主的声明周期，是因为它内部创建了 <code>android.arch.lifecycle.HolderFragment</code> 对象（不了解原理的可以去看 Glide 源码）。而这个对象的构造方法里面有这样的一行代码：</p><blockquote><p>android.arch.lifecycle.HolderFragment#HolderFragment</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">setRetainInstance(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>我以前一直对这个方法有误解，没有理解它的真正作用，现在来看看为什么写这个方法：</p><p>调用了这个方法的fragment不会随着activity一起被销毁。相反，它会一直保留(<strong>进程不消亡的前提下</strong>)，并在需要时原封不动地传递给新的Activity。</p><p>当设备配置发生变化时，FragmentManager首先销毁队列中fragment的视图（因为可能有更合适的匹配资源）；<br>紧接着，FragmentManager将检查每个fragment的retainInstance属性值。</p><p>如果retainInstance属性值为false，FragmentManager会立即销毁该fragment实例。 随后，为适应新的设备配置，新的Activity的新的FragmentManager会创建一个新的fragment及其视图。</p><p>如果retainInstance属性值为true，则<strong>该fragment的视图立即被销毁，但fragment本身不会被销毁</strong>。 为适应新的设备配置，当新的Activity创建后，新的FragmentManager会找到被保留的fragment，并重新创建其试图。</p><p>虽然保留的fragment没有被销毁，但它已脱离消亡中的activity并处于保留状态。 尽管此时的fragment仍然存在，但已经没有任何activity托管它。</p><p>只有调用了fragment的setRetainInstance(true)方法， 并且因设备配置改变，托管Activity正在被销毁的条件下，<br>fragment才会短暂的处于保留状态。</p><p><strong>如果activity是因操作系统需要回收内存而被销毁，则所有的fragment也会随之销毁</strong>。</p><p>理解了上面的话，现在想一下，为何要保存 fragment 的实例？是因为 </p><blockquote><p>android.arch.lifecycle.HolderFragment</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ViewModelStore mViewModelStore = <span class="hljs-keyword">new</span> ViewModelStore();<br></code></pre></td></tr></table></figure><p>它有这样的一个变量，而这个 ViewModelStore 实际上就是一个 map，它保存它对应的 ViewMode 对象。如果 fragment被回收了，那么这个 ViewModel 肯定也会被回收（没有其他地方引用它了），这样ViewModel就达不到设计的目的了。</p><p>所以最终，还是要配合 onSaveInstanceState 来保存数据，因为 onSaveInstanceState 是将数据存到了系统进程中。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多渠道打包</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>在 【Android V1 V2 签名机制】里面分析了美团在 V1 签名机制下的多渠道打包，但是没有分析 V2 机制的多渠道打包。</p><p>由于 V2 机制下多渠道打包涉及到 APK 结构，所以这里专门新起一篇。</p><p>由于 APK 也是一个压缩包，所以我们先来看一下 ZIP 文件的结构。</p><h2 id="ZIP-文件结构"><a href="#ZIP-文件结构" class="headerlink" title="ZIP 文件结构"></a>ZIP 文件结构</h2><p>一个普通的 ZIP 文件结构如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[文件头+文件数据+数据描述符]</span>&#123;此处可重复n次&#125; + 中央目录 + 中央目录结束标识<br></code></pre></td></tr></table></figure><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E7%AD%BE%E5%90%8D/11.png?raw=true"></p><p>我们对着这个图看一下，apk在签名前和一个普通的 zip 文件的结构一样，<strong>中央目录</strong> 与 <strong>中央目录结束标识</strong> 对应后面两块。</p><p>ZIP 文件分3块，每块内容大致如下：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">数据区（<span class="hljs-variable">Contents</span> <span class="hljs-variable">of</span> <span class="hljs-variable">ZIP</span> <span class="hljs-variable">entries</span>）：存储文件压缩内容<br>中央目录区（<span class="hljs-variable">Central</span> <span class="hljs-built_in">Directory</span> <span class="hljs-variable">Header</span>）：存储<span class="hljs-variable">zip</span>文件里面包含的所有目录<br>中央目录结束标识（<span class="hljs-built_in">End</span> <span class="hljs-variable">of</span> <span class="hljs-variable">Central</span> <span class="hljs-built_in">Directory</span> <span class="hljs-built_in">Record</span>：<span class="hljs-variable">ECDR</span>）：存储<span class="hljs-variable">zip</span>文件的整体信息<br></code></pre></td></tr></table></figure><p>其中，<strong>中央目录结束标识</strong>的结构是我们最需要搞清楚的。</p><p>我们拿一个例子来分析 中央目录结束标识 里面都有什么东西。</p><blockquote><p>新建一个名为123.txt的文本文件，内容为123456，将123.txt压缩为123.zip</p></blockquote><p>使用notepad++打开该文件，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/10.png?raw=true"></p><p>有8根红线，每根红线对应的数据意义如下：</p><table><thead><tr><th>地址</th><th>字节数</th><th>字节内容</th><th>意义</th></tr></thead><tbody><tr><td>00000062</td><td>4</td><td>50 4b 05 06</td><td>中央目录结束标记（0x06054b50，<strong>固定内容</strong>）</td></tr><tr><td>00000084</td><td>2</td><td>00 00</td><td>当前磁盘编号</td></tr><tr><td>00000088</td><td>2</td><td>00 00</td><td>中央目录开始位置的磁盘编号</td></tr><tr><td>0000008a</td><td>2</td><td>01 00</td><td>该磁盘上所记录的核心目录数量</td></tr><tr><td>0000008c</td><td>2</td><td>01 00</td><td>中央目录结构总数</td></tr><tr><td>0000008e</td><td>4</td><td>59 00 00 00</td><td>中央目录的大小</td></tr><tr><td>00000090</td><td>4</td><td>2b 00 00 00</td><td><strong>中央目录开始位置</strong>相对于archive开始的位移</td></tr><tr><td>00000094</td><td>2</td><td>00 00</td><td>注释长度</td></tr></tbody></table><p>中央目录结束标识 <strong>这一块的数据长度是不固定的，因为注释的长度不固定</strong>。</p><p>但是 中央目录结束标识 的<strong>起始位置的内容是固定的</strong>，我们就可以从 ZIP 文件的最后往前遍历，直到找到 4 个连续直接的内容与 0x06054b50 相等。找到了起始地址，从这个<strong>起始地址往后偏移 20 个字节，我们就知道了注释的长度</strong>。</p><p>我们看一下 walle 的代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> expectedCommentLength = <span class="hljs-number">0</span>; expectedCommentLength &lt;= maxCommentLength;<br>     expectedCommentLength++) &#123;<br>    <span class="hljs-comment">// 这里假设 注释的长度为 expectedCommentLength，从 0 开始一个一个试</span><br>    <br>    <span class="hljs-comment">// 我们从文件的倒数第 22 个字节开始往前遍历</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> eocdStartPos = eocdWithEmptyCommentStartPosition - expectedCommentLength;<br><br>    <span class="hljs-comment">// 分配4个字节</span><br>    <span class="hljs-keyword">final</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 定位到倒数第22、23、24...个字节的位置</span><br>    fileChannel.position(eocdStartPos);<br>    <span class="hljs-comment">// 读取4个字节到buffer中</span><br>    fileChannel.read(byteBuffer);<br>    <span class="hljs-comment">// 将字节排序，因为 zip 文件的字节排序与我们阅读的顺序不一样</span><br>    <span class="hljs-comment">// 比如：0X0ff8，在 zip 文件中是这样存放的：f8 0f</span><br>    byteBuffer.order(ByteOrder.LITTLE_ENDIAN);<br><br>    <span class="hljs-comment">// 判断该 4 个字节的值是不是 0x06054b50</span><br>    <span class="hljs-keyword">if</span> (byteBuffer.getInt(<span class="hljs-number">0</span>) == ZIP_EOCD_REC_SIG) &#123;<br>        <span class="hljs-comment">// 分配2个字节</span><br>        <span class="hljs-keyword">final</span> ByteBuffer commentLengthByteBuffer = ByteBuffer.allocate(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 往前 22 个字节，定位到存放 注释长度 的字节处</span><br>        fileChannel.position(eocdStartPos + ZIP_EOCD_COMMENT_LENGTH_FIELD_OFFSET);<br>        fileChannel.read(commentLengthByteBuffer);<br>        commentLengthByteBuffer.order(ByteOrder.LITTLE_ENDIAN);<br><br>        <span class="hljs-comment">// 获取</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actualCommentLength = commentLengthByteBuffer.getShort(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (actualCommentLength == expectedCommentLength) &#123;<br>            <span class="hljs-keyword">return</span> actualCommentLength;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>拿到注释长度之后，我们就可以准确的定位到记录“中央目录开始位置”的字节处</strong>（其实上面如果不往后20个字节，只往后16个字节，就可以直接拿到，但是这里为了分析源码）。</p><p>再看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-keyword">final</span> ByteBuffer zipCentralDirectoryStart = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>      zipCentralDirectoryStart.order(ByteOrder.LITTLE_ENDIAN);<br><span class="hljs-comment">// 6 = 2 (Comment length) + 4 (Offset of start of central directory, relative to start of archive)</span><br>      fileChannel.position(fileChannel.size() - commentLength - <span class="hljs-number">6</span>); <br>      fileChannel.read(zipCentralDirectoryStart);<br>      <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> centralDirStartOffset = zipCentralDirectoryStart.getInt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这都不用说了，很清晰，ZIP 文件的长度 - 注释的长度 - 存放注释长度的2个字节 - 存放中央目录偏移位置的4个字节，就是存放中央目录偏移位置的字节起始位置了。</p><p>我们知道，apk 签名之后是多了一块叫做 ‘APK Signing Block’ 的东西，这块内容正好在中央目录的前面。而上面我们又知道了中央目录的偏移位置，所以只要我们知道 ‘APK Signing Block’  的大小，我们就能将 ‘APK Signing Block’  这一块里面的所有字节都取出来。</p><p>要想知道 ‘APK Signing Block’  的大小，我们还是要了解 ‘APK Signing Block’  的结构：</p><table><thead><tr><th>偏移</th><th>字节数</th><th>描述</th></tr></thead><tbody><tr><td>@+0 （从前往后第0个字节）</td><td>8</td><td>这个 block 的长度 （不包括这8个字节）</td></tr><tr><td>@+8 （从前往后第8个字节）</td><td>n</td><td>一组 ID-VALUE</td></tr><tr><td>@-24 （从后往前第24个字节）</td><td>8</td><td>这个 block 的长度（与上面的值一样）</td></tr><tr><td>@-16 （从后往前第16个字节）</td><td>16</td><td>魔数 “APK Sig Block 42”</td></tr></tbody></table><p>可以看出，APK Signing Block 分为4小块，第1、3块都储存的是 APK Signing Block 的大小。第 4 块是固定的。第 3块是不固定的，我们的渠道信息就是写在这个键值对区域的。</p><p>我们知道了中央目录的偏移位置，知道了中央目录的偏移位置前是一个固定的魔数，魔数前就是 APK Signing Block 的大小，这样，我们就可以拿到整个 APK Signing Block 块里面的所有东西了。</p><p>看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中央目录偏移位置往前24个字节，就是存 APK Signing Block 的长度的字节起始位置</span><br>fileChannel.position(centralDirOffset - <span class="hljs-number">24</span>);<br><span class="hljs-comment">// 分配24个字节空间</span><br><span class="hljs-keyword">final</span> ByteBuffer footer = ByteBuffer.allocate(<span class="hljs-number">24</span>);<br>fileChannel.read(footer);<br><span class="hljs-comment">// 读取前8个字节，就是 APK Signing Block 的长度</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> apkSigBlockSizeInFooter = footer.getLong(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 拿到储存的 APK Signing Block 的长度，还要加上 8 个字节，才是整个 APK Signing Block 的长度</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalSize = (<span class="hljs-keyword">int</span>) (apkSigBlockSizeInFooter + <span class="hljs-number">8</span>);<br><span class="hljs-comment">// 计算 APK Signing Block 的起始偏移位置</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> apkSigBlockOffset = centralDirOffset - totalSize;<br><br><span class="hljs-comment">// 定位到 APK Signing Block 的起始偏移位置</span><br>fileChannel.position(apkSigBlockOffset);<br><span class="hljs-keyword">final</span> ByteBuffer apkSigBlock = ByteBuffer.allocate(totalSize);<br><span class="hljs-comment">// 读取整个 APK Signing Block 块</span><br>fileChannel.read(apkSigBlock);<br>apkSigBlock.order(ByteOrder.LITTLE_ENDIAN);<br></code></pre></td></tr></table></figure><p>拿到了 APK Signing Block 块，我们就可以拿到里面 ID-VALUE 键值对了，由于我们在打包时放入了渠道名，现在我们就可以取出来。</p><p>我们先看看一个 ID-VALUE 键值对的结构：</p><table><thead><tr><th>字节数</th><th>描述</th></tr></thead><tbody><tr><td>8</td><td>该 ID-VALUE 的长度（不包括自己）</td></tr><tr><td>4</td><td>ID</td></tr><tr><td>n - 4</td><td>VALUE</td></tr></tbody></table><p>看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 去掉前8与后24个字节</span><br><span class="hljs-keyword">final</span> ByteBuffer pairs = sliceFromTo(apkSigningBlock, <span class="hljs-number">8</span>, apkSigningBlock.capacity() - <span class="hljs-number">24</span>);<br><br><span class="hljs-keyword">int</span> entryCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (pairs.hasRemaining()) &#123;<br>    entryCount++;<br><br>    <span class="hljs-comment">// 取当前这个 ID-VALUE 对的长度</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> lenLong = pairs.getLong();<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>) lenLong;<br>    <br>    <span class="hljs-comment">// 下一个 ID-VALUE 对的起始位置</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextEntryPos = pairs.position() + len;<br><br>    <span class="hljs-comment">// 取 ID 的值</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = pairs.getInt();<br>    <span class="hljs-comment">// 取 VALUE 的值</span><br>    idValues.put(id, getByteBuffer(pairs, len - <span class="hljs-number">4</span>));<br><br>    pairs.position(nextEntryPos);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还需要判断一下，是否有V2签名标识：</p><blockquote><p><a href="https://source.android.com/security/apksigning/v2.html#apk-signing-block">https://source.android.com/security/apksigning/v2.html#apk-signing-block</a></p><p>根据官方文档的描述，V2签名信息储存在 ID 为  0x7109871a 的键值对中。</p></blockquote><p>我们可以判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Find the APK Signature Scheme v2 Block inside the APK Signing Block.</span><br><span class="hljs-keyword">final</span> ByteBuffer apkSignatureSchemeV2Block = originIdValues.get(ApkUtil.APK_SIGNATURE_SCHEME_V2_BLOCK_ID);<br><br><span class="hljs-keyword">if</span> (apkSignatureSchemeV2Block == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<br>        <span class="hljs-string">&quot;No APK Signature Scheme v2 block in APK Signing Block&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此为止，我们就完整了分析了多渠道相关的知识，现在我们看看 walle 是如何注入 ID-VALUE 渠道信息的，因为注入信息之后，必然需要更新相关的地址值，否则就错乱了。</p><p>我们可以回想一下，需要更新哪些值。</p><p>当我们写完渠道信息之后，中央目录起始偏移肯定变了，所以需要更新储存这个值的字节。</p><p>APK Signing Block 块的大小也变了，也需要更新，这有两个地方存，所以一共需要更新3个地方。</p><p>但是由于我们有了 APK Signing Block 的所有字节信息，所以我们可以直接覆盖原来的 APK Signing Block  块，最后更新 中央目录起始偏移 位置就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将中央目录与中央目录结尾标识的所有字节存起来</span><br>centralDirBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>) (fileChannel.size() - centralDirStartOffset)];<br>fIn.read(centralDirBytes);<br><br><span class="hljs-comment">// 写更新之后的 APK Signing Block</span><br>fileChannel.position(apkSigningBlockOffset);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> length = apkSigningBlock.writeApkSigningBlock(fIn);<br><br><span class="hljs-comment">// 写中央目录与中央目录结尾标识</span><br>fIn.write(centralDirBytes);<br><br><span class="hljs-comment">// 更新长度</span><br>fIn.setLength(fIn.getFilePointer());<br><br><span class="hljs-comment">// 定位到储存中央目录结束标志的字节位置</span><br>fIn.seek(fileChannel.size() - commentLength - <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">// 更新该值</span><br><span class="hljs-comment">// 6 = 2(Comment length) + 4 (Offset of start of central directory, relative to start of archive)</span><br><span class="hljs-keyword">final</span> ByteBuffer temp = ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>temp.order(ByteOrder.LITTLE_ENDIAN);<br>temp.putInt((<span class="hljs-keyword">int</span>) (centralDirStartOffset + length + <span class="hljs-number">8</span> - (centralDirStartOffset - apkSigningBlockOffset)));<br><span class="hljs-comment">// 8 = size of block in bytes (excluding this field) (uint64)</span><br>temp.flip();<br>fIn.write(temp.array());<br></code></pre></td></tr></table></figure><p>好了， walle 的核心代码就分析的差不多了，多渠道打包的原理也讲的差不多了。</p><h2 id="手动的分析一个apk"><a href="#手动的分析一个apk" class="headerlink" title="手动的分析一个apk"></a>手动的分析一个apk</h2><p>随便取一个 apk，用 notepad++ 打开，定位到文件末尾：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/1.png?raw=true"></p><p>可以看到，确实是有一个固定的标识的。</p><p>然后我们找到 中央目录的偏移位置：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/2.png?raw=true"></p><p>中央目录结束标记 0x06054b50 的后面 16 个就是中央目录的偏移地址了。</p><p>偏移位置为 <code>74 ee 50 02</code>，但是我们知道这个地址是反过来的，所以正确的地址为 <code>0x0250ee74</code>。</p><p>我们搜索这个地址：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/3.png?raw=true"></p><p>在这个地址的前面，应该是也是固定的字节，为魔数”APK Sig Block 42”，将它换成字节，是 <code>41 50 4B 20 53 69 67 20 42 6C 6F 63 6B 20 34 32</code>，我们对比一下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/4.png?raw=true"></p><p>果然是一摸一样的。</p><p>魔数前面8个字节存放的是 APK Signing Block 的长度，我们往前找8个字节看看：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/5.png?raw=true"></p><p>看来，APK Signing Block 的长度为 <code>0x0ff8</code>。由于中央目录偏移地址为 <code>0x025ee74</code>，减去这个地址得到<code>0x0250de7c</code>：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/6.png?raw=true"></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/7.png?raw=true"></p><p>再搜索这个地址：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/8.png?raw=true"></p><p>可以看到，这个地址往前8个字节也是储存的 APK Signing Block 的长度，这样就说明，我们分析的过程是正确的。所以 APK Signing Block 的所有字节如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/9.png?raw=true"></p><p>图中 1 和 2 之间的内容，就是 ID-VALUE 键值对了。由于我分析的这个 apk 没有写入渠道信息，所以我找了一个网上的图片：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E5%A4%9A%E6%B8%A0%E9%81%93/11.png?raw=true"></p><p>这个里面，写入了渠道信息：</p><ul><li>ID 为：0x71777777</li><li>渠道信息为：<code>&#123;&quot;channel&quot;:&quot;meituan&quot;&#125;</code></li></ul><p>我们直接在 ID-VALUE 里面搜索 <code>0x71777777</code>，就可以得到上面的图了。</p><ul><li>长度：00 00 00 00 00 00 00 19=25 （长度是25字节）</li><li>ID：71 77 77 77 （我们自定义的ID）</li><li>存入内容： {“channel”:”meituan”} 21字节</li><li>21+4=25，刚好等于长度的值</li></ul><p>至此，我们就成功的通过分析APK的二进制数据，得到了walle注入的数据。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>混合编译器</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>我们先来看一看编译器的发展历程，顺便也看一下虚拟机（与它有关系）的。</p><p><strong>虚拟机的变迁</strong>：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%871.png?raw=true"></p><p><strong>编译器的变迁</strong>：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%872.png?raw=true"></p><p>我们知道，Java是有自己的虚拟机的，那么Google为何放着现有的JVM不用，而是设计一个新的虚拟机？？？</p><p>在解答这问题之前，我们先来看看 Dalvik 与 JVM 的不同之处吧。</p><table><thead><tr><th>JVM</th><th>Dalvik</th></tr></thead><tbody><tr><td>基于堆栈的Java指令(1个字节)</td><td>基于寄存器的Dalvik指令(2、4或者6个字节)</td></tr><tr><td>执行同样的功能， Java虚拟机需要更多的指令（主要是load和store指令），需要更多指令意味着要多占用CPU的时间。</td><td>执行同样的功能，Dalvik虚拟机需要更多的指令空间，需要更多指令空间意味着指令缓冲（i-cache）更易失效</td></tr><tr><td>使用class格式的类文件</td><td>使用dex（Dalvik Executable）格式的类文件</td></tr></tbody></table><p>从这个表格中，能看出为什么不？</p><p>一个dex文件可以包含若干个类，而一个class文件只包括一个类。由于一个dex文件可以包含若干个类，因此它可以将各个类中重复的字符串只保存一次，从而<strong>节省了空间</strong>，适合在内存有限的移动设备使用。提前调整好字节序和字对齐方式，使得它们更适合于本地机器，以便<strong>提高指令执行速度</strong>。</p><p>Dalvik虽然设计精巧，但是每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高，<strong>会让用户经常感到系统卡顿</strong>。</p><p>为了解决这个的问题，Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%873.png?raw=true"></p><p>但是它也有自己的问题：</p><ul><li>使用JIT也不一定加快执行速度，如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行dex的时间。所以JIT不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码。</li><li>dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要进行JIT编译。</li><li>对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间。</li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%874.png?raw=true"></p><p>JIT 虽然在某种程度上弥补了 Dalvik 的不足，但是仍然浪费了不少性能，所以从 Android 5.0 开始，就摒弃了 Dalvik 虚拟机，开发出了 ART 虚拟机。</p><p>与Dalvik不同，在ART 环境中，<strong>应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用</strong>。之后打开App的时候，直接使用本地机器码运行，因此运行速度提高。</p><p>ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%。由于有了一个转码的过程，<strong>所以应用安装时间难免会延长</strong>。</p><p>安装的时候，字节码会预先编译成机器码就是由 AOT 编译器执行的，对比JIT就很好理解了，一个是运行时编译，一个是安装时编译。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%875.png?raw=true"></p><p>编译好的文件是OAT文件，该文件本质上是一个ELF文件，这里与dex(Odex)文件最大的区别是<strong>OAT文件不再是字节码文件，而是一个可执行文件</strong>，可以更底层的与硬件接触，运行时也省去了预编译和转译的时间。</p><p>ART + AOT 虽然解决了 Dalvik + JIT 的不足，但是它也带来了新的问题：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%876.png?raw=true"></p><p>更多需要解决的问题：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%877.png?raw=true"></p><p>有一张图，我们应该会非常熟悉，大多数人应该都碰到过这样的场景：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%878.png?raw=true"></p><p>这就是由于使用 ART + AOT 导致的。由于系统更新时，所有的应用都需要重新安装，这会导致所有的应用都需要在重新编译一遍，导致更新时间非常久。</p><p>那么，应该如何去解决这些问题呢？</p><p>首先，我们思考一个问题：<strong>用户会使用App里面的每个功能吗？</strong></p><p>绝大多数用户只会使用App的部分功能。只有被用户频繁使用的功能（这个功能背后的代码）才值得被编译成本地代码。</p><p>所以，我们就可以不用预编译整个app，这样做：</p><p>在 JIT 阶段，我们可以先找出被频繁执行的代码，然后在使用预编译来优化和加速这些被频繁执行的代码，从而避免编译那些很少被用户使用的代码带来的额外消耗（储存空间，编译行为等等）。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%879.png?raw=true"></p><p>当用户安装App的时候，不再进行预编译了，这个和KitKat的时候一样。当用户安装之后立即使用该App，仍然使用JIT编译模式来执行App，但是同时会生成一个离线的 profile 文件，这个 profile 文件会记录JIT运行时的所有 hot code（热点代码）信息。然后在未来的某个时间点，Android Framework 会基于这个 profile 文件来启动一个预编译行为，它只便于记录的热点代码。</p><p>在 JIT 阶段，它带来的好处：</p><ul><li>快速安装</li><li>系统快速更新</li></ul><p>在 AOT 阶段，它带来的好处：</p><ul><li>快速启动，更好的运行性能</li><li>低消耗：CPU，储存空间，电量…</li></ul><p>可以看到，它们 JIT 与 AOT 互相弥补了自己的不足。</p><p>获取有的人会觉得，JIT 是即时编译会比较慢，但是真的是这样吗？下面看一组数据测试：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%8710.png?raw=true"></p><p>AOT与JIT在Micro Benchmark测试中各有优劣，所以预编译还不一定快。</p><p>下面贴出几组使用混合编译后的数据：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%8711.png?raw=true"></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8/%E5%9B%BE%E7%89%8712.png?raw=true"></p><p>提升还是非常明显的。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Navigation 的使用记录</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-JetPack/Navigation%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-JetPack/Navigation%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>接到一个处理流程的需求，有好几个界面，界面之间的跳转有点复杂，还需要支持回退，于是想到使用 Jetpack 的 Navigation 包。</p><p>具体的使用可以参考<a href="https://developer.android.com/guide/navigation/">官方文档</a> 。暂时不做介绍，考虑做一个翻译系列，将 Jetpack 全部翻译一遍，不过现在没有精力。</p><p>等使用 Navigation 写完全部的跳转之后，发现一个严重的问题，那么就是 Navigation 不支持 Fragment 的状态保存。也就是说我在 FragmentA 做了一些操作，然后调到 FragmentB，在 FragmentB 中准备做一些操作的时候，突然发现有问题，想回到 FragmentA ，于是我点击了返回键回到 FragmentA ，就会发现 FragmentA  中的数据被重置了，我在 FragmentA  的操作没有了，这是用户无法接受的。</p><p>然后我去看了官方的 demo，发现它居然可以记录操作，我对比了一下工程代码，发现官方demo里面的是 EditText，我的项目里面是 CheckBox，只有控件的区别，于是我果断在官方的demo里面添加了CheckBox控件，发现也无法保存CheckBox的状态。<strong>这就让我无法理解了，为啥 EditText 可以保存状态，CheckBox 就不行？</strong>这个问题我现在还没有答案。</p><p>我又去翻了一下，Navigation 的相关源码，控制 Fragment 跳转的是<code>androidx.navigation.fragment.FragmentNavigator</code>。</p><p>它有一个 navigate 方法：</p><blockquote><p>androidx.navigation.fragment.FragmentNavigator#navigate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Nullable</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> NavDestination <span class="hljs-title">navigate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Destination destination, <span class="hljs-meta">@Nullable</span> Bundle args,</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-meta">@Nullable</span> NavOptions navOptions, <span class="hljs-meta">@Nullable</span> Navigator.Extras navigatorExtras)</span> </span>&#123;<br>      ...<br>      <span class="hljs-keyword">final</span> Fragment frag = instantiateFragment(mContext, mFragmentManager,<br>              className, args);<br>      frag.setArguments(args);<br>      <span class="hljs-keyword">final</span> FragmentTransaction ft = mFragmentManager.beginTransaction();<br>...<br><br>      ft.replace(mContainerId, frag);<br>      ft.setPrimaryNavigationFragment(frag);<br><br>      ...<br>      ft.commit();<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>这个逻辑很明显了，首先实例化要跳转到的 Fragment，然后直接替换原来的 fragment。</p><p>这里说一下，当使用 replace 的时候会发生什么：</p><p>假设 A 已经添加到了 mContainerId，这个时候调用了 replace B。</p><blockquote><p>Fragment B</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onAttach</span><br><br><span class="hljs-literal">on</span>Create<br></code></pre></td></tr></table></figure><blockquote><p>Fragment A</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onPause</span><br><br><span class="hljs-literal">on</span>Stop<br><br><span class="hljs-literal">on</span>DestroyView<br><br><span class="hljs-literal">on</span>Destroy<br><br><span class="hljs-literal">on</span>Detach<br></code></pre></td></tr></table></figure><blockquote><p>Fragment B</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onCreateView</span><br><br><span class="hljs-literal">on</span>ActivityCreated<br><br><span class="hljs-literal">on</span>Start<br><br><span class="hljs-literal">on</span>Resume<br></code></pre></td></tr></table></figure><p>可以看到，Fragment A 执行了 onDestroyView 与 onDetach，也就是说它完全从 Activity 上脱离了。再显示出来需要重新走一遍生命周期流程，<strong>但是这里需要注意的是，这个生命周期流程是没有添加到会退栈的，添加到会退栈的有点不一样。</strong></p><p>因为 FragmentNavigator 内部将 Fragment A 添加到了会退栈，所以调用 replace B 的生命周期流程如下：</p><blockquote><p>Fragment B</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onAttach</span><br><br><span class="hljs-literal">on</span>Create<br></code></pre></td></tr></table></figure><blockquote><p>Fragment A</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onPause</span><br><br><span class="hljs-literal">on</span>Stop<br><br><span class="hljs-literal">on</span>DestroyView<br></code></pre></td></tr></table></figure><blockquote><p>Fragment B</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">onCreateView</span><br><br><span class="hljs-literal">on</span>ActivityCreated<br><br><span class="hljs-literal">on</span>Start<br><br><span class="hljs-literal">on</span>Resume<br></code></pre></td></tr></table></figure><p>可以看到与上面的区别是，Fragment A 只执行到了 onDestroyView，并没有走下面的 onDestroy 等方法。虽然它只执行到了 onDestroyView，<strong>但是它重新显示的时候，肯定要重新走 onCreateView</strong>，而一般我们的初始化逻辑都是在 onCreateView 中执行的，所以操作就都被重置了。</p><p>要想解决这个问题，现在就有两种选择：一是放弃 Navigation，二是自定义 FragmentNavigation，虽然我知道</p><p>第二种方法比较蛋疼，但是我还是想试一下，虽然最后还是失败了，但是还是记录一下过程。</p><p>自定义 Navigation 的文档在 <a href="https://developer.android.com/guide/navigation/navigation-add-new">这里</a>，也可以参考这个<a href="https://github.com/STAR-ZERO/navigation-keep-fragment-sample">项目</a> 。</p><p>首先要处理 Fragment 每次都实例化的问题，这里可以自己缓存起来。</p><p>然后是想办法将 replace 替换为 add 之类的方法。我是覆盖了 navigate 方法，然后copy出了一部分源码，效果是达到了。</p><p>最后是处理返回键，这个我没有处理好。其实，不继承 FragmentNavigation，而是继承 Navigator，完全自己实现一个，或许会更简单一些，不过需要对 Fragment 的理解比较深入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WorkManager 与 LowMemoryKiller 理解</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-JetPack/WorkManager%E4%B8%8ELowMemoryKiller/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-JetPack/WorkManager%E4%B8%8ELowMemoryKiller/</url>
    
    <content type="html"><![CDATA[<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>今天在查看bugly的时候，发现了如下错误：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">android.app.RemoteServiceException<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Context</span>.</span></span>start<span class="hljs-constructor">ForegroundService()</span> did not <span class="hljs-keyword">then</span> call <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Service</span>.</span></span>start<span class="hljs-constructor">Foreground()</span><br></code></pre></td></tr></table></figure><p>发现是由于WorkManager引起的，原因是由于我们刚刚引入了WorkManager，不想对原来的代码改动太大，所以只是将AlarmManager替换成了WorkManager。</p><p>但是我突然想到，既然已经使用了WorkManager，它能保证任务的执行，那为啥还要启动Service呢？不是多次一举吗！</p><p>现在我们来从头理一下，<strong>为啥我们需要在Service里面启动线程？</strong></p><p>Android是基于linux内核的系统，但是它与其他基于linux内核的系统有一个不同之处，就是它没有“交换空间”。</p><p>交换空间的作用：<strong>当 RAM 满了之后，而系统还需要额外的内存空间，系统会将内存中的相对不经常使用的内存页放入到硬盘上，腾出位置给正在运行的应用程序。</strong></p><p>取而代之的，它使用 OOM Killer 来管理内存。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-JetPack/WorkManager/1_92pIQu01ijeZ08BulvDm3Q.png?raw=true"></p><p>OOM Killer 的目标是通过基于其“可见性状态”和消耗的内存量来杀死进程来释放内存。</p><p>ActivityManager 会给每个进程一个 oom_adj 值，这个值越大，表示该进程的优先级越低。比如，前台进程的优先级就是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"># Define the oom_adj values <span class="hljs-keyword">for</span> the classes of processes that can be<br><span class="hljs-meta"># killed by the kernel.  These are used in ActivityManagerService.</span><br>    setprop ro.FOREGROUND_APP_ADJ <span class="hljs-number">0</span><br>    setprop ro.VISIBLE_APP_ADJ <span class="hljs-number">1</span><br>    setprop ro.SECONDARY_SERVER_ADJ <span class="hljs-number">2</span><br>    setprop ro.BACKUP_APP_ADJ <span class="hljs-number">2</span><br>    setprop ro.HOME_APP_ADJ <span class="hljs-number">4</span><br>    setprop ro.HIDDEN_APP_MIN_ADJ <span class="hljs-number">7</span><br>    setprop ro.CONTENT_PROVIDER_ADJ <span class="hljs-number">14</span><br>    setprop ro.EMPTY_APP_ADJ <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>Android 中，存在着一张内存阈值表，这张阈值表是可以在 init.rc 中进行配置的，合理配置这张表，对于小内存设备有非常重要的作用。我们来看 lowmemorykiller.c 中这张默认的阈值表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> lowmem_adj[<span class="hljs-number">6</span>] = &#123;<br>    <span class="hljs-number">0</span>,<br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-number">6</span>,<br>    <span class="hljs-number">12</span>,<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> lowmem_adj_size = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> lowmem_minfree[<span class="hljs-number">6</span>] = &#123;<br>    <span class="hljs-number">3</span> * <span class="hljs-number">512</span>,<span class="hljs-comment">/* 6MB */</span><br>    <span class="hljs-number">2</span> * <span class="hljs-number">1024</span>,<span class="hljs-comment">/* 8MB */</span><br>    <span class="hljs-number">4</span> * <span class="hljs-number">1024</span>,<span class="hljs-comment">/* 16MB */</span><br>    <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>,<span class="hljs-comment">/* 64MB */</span><br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> lowmem_minfree_size = <span class="hljs-number">4</span>;<br><br></code></pre></td></tr></table></figure><p>这个表的意思是：</p><blockquote><p>当系统的可用内存小于6MB时，警戒级数为0；<br>当系统可用内存小于8M而大于6M时，警戒级数为1；<br>当可用内存小于64M大于16MB时，警戒级数为12。</p></blockquote><p>比如，当 LMK 被触发的时候，发现系统的内存只剩下了 7M，那么查找上面的表会发现，警戒级数为 1。那么 LMK 会开始遍历系统所有进程，过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (遍历所有进程) &#123;<br><span class="hljs-keyword">if</span> (p is 内核进程) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (p.oom_score_adj &lt; 警戒值) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (有被选中的进程) &#123;<br><span class="hljs-keyword">if</span> (当前进程的 oom_score_adj 比选中进程的小) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (当前进程的 oom_score_adj 等于选中进程的小 &amp;&amp; 当前进程占用的内存小) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>&#125;<br><br>选中当前进程<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出如下结论：</p><blockquote><p>内核线程不参加这个杀进程的游戏<br>进程的 oom_score_adj 越大越危险<br>进程的 oom_score_adj 相同的情况下，占用内存越大越危险</p></blockquote><p>Low memory killer的规则就是根据当前系统的可用内存多少来获取当前的警戒级数，如果进程的oom_adj大于警戒级数并且最大，进程将会被杀死（<strong>具有相同omm_adj的进程，则杀死占用内存较多的</strong>）。omm_adj越小，代表进程越重要。一些前台的进程，oom_adj会比较小，而后台的服务，omm_adj会比较大，所以当内存不足的时候，Low memory killer必然先杀掉的是后台服务而不是前台的进程。</p><p>所以，我们要使用 Service 的原因：</p><ul><li>我们需要执行一个长时间运行的操作，所以需要一个比较低的 oom_adj 值 （服务进程比后台进程值小）</li><li>可以单独开启一个进程</li></ul><p>但是随着Android版本的升级，使用 Service 会带来一些其他的问题：</p><ol><li><p>电量消耗</p><p>开发人员可以在后台做任何他们想做的事情，没有任何限制。</p><p>所以Google搞了一个Doze模式：</p><blockquote><p>简而言之 - 在用户关闭设备屏幕后，Doze 模式启动并禁用网络，同步，GPS，警报和wifi扫描。直到用户打开屏幕或连接到充电器。这是为了 - 减少执行不重要工作的应用程序的数量，并且这样做 - 节省了用户的电量</p></blockquote></li><li><p>使用限制</p><p>从 API 26 开始，如果应用的 targetSdkVersion 在 26 以上，在后台进程里面调用 startService 方法会抛出 <a href="https://developer.android.com/reference/java/lang/IllegalStateException.html">IllegalStateException</a>。</p></li></ol><p>说了这么多，得出一个结论：苍天已死，黄天当立。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-JetPack/WorkManager/1_ISeFOxwzOKMzsoz3SMm9Nw.png?raw=true"></p><p>既然Service已经不再能够实现它的主要目的（在后台长时间的运行任务），所以最好就不要在使用它了。</p><h3 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h3><h4 id="特点与使用场景"><a href="#特点与使用场景" class="headerlink" title="特点与使用场景"></a>特点与使用场景</h4><p><strong>特点：</strong></p><ol><li>保证任务一定会被执行<br>WorkManager有自己的数据库，每一个任务的信息与任务状态，都会保存在本地数据库中。所以即使程序没有在运行，或者在设备重启等情况下，WorkManager依然可以保证任务的执行，只是不保证任务立即被执行。</li><li>合理使用设备资源<br>在执行很多周期性或非立即执行的任务时，WorkManager提供我们API，帮助我们合理利用设备资源，避免不必要的内存，流量，电量等消耗。</li></ol><p><strong>适用场景：</strong></p><ol><li>可延迟进行的任务<br>a.满足某些条件才执行的任务，如需要在充电时才执行的任务。<br>b.用户无感知或可延迟感知的任务，如同步配置信息，同步资源，同步通讯录等。</li><li>定期重复性任务，但时效性要求不高的，如定期log上传，数据备份等。</li><li>退出应用后还应继续执行的未完成任务。</li></ol><p>可以看出，WorkManger 与 Service 的使用场景并不完全重合。比如，我们的应用像采集用户的 GPS 信息，在旧 Android 时代，是一个很轻松的事情，做个保活就可以了，但是现在，Service 有了很大的限制，而且国产 ROM 也不允许app在后台运行太长时间（5分钟，不能再多了）。现在虽然出了  WorkManager，但是它也无法实现这个功能，因为，它不保证任务立即被执行，这样的话，采集出来的数据没有意义。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="# 参考文档"></a># 参考文档</h1><p><a href="https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6">Services. The life with/without. And WorkManager.</a></p><p><a href="https://www.wolfcstech.com/2015/10/04/lowmemorykiller/">Android low memory killer 机制</a></p><p><a href="https://developer.android.com/topic/libraries/architecture/workmanager">Schedule tasks with WorkManager</a></p><p><a href="https://medium.com/@prithvibhola08/location-all-the-time-with-workmanager-8f8b58ae4bbc">Location all the time with WorkManager!!</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Activity 的 onDestroy 方法里面调用 finish 会发生什么</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-Bugs/%E5%9C%A8%20Activity%20%E7%9A%84%20onDestroy%20%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%20finish%20%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-Bugs/%E5%9C%A8%20Activity%20%E7%9A%84%20onDestroy%20%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%20finish%20%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>发现这个奇怪问题的起因在于同事看了MVVM的相关文章，里面提到<strong>屏幕旋转时，Activity 销毁重建不会导致 ViewModel随着销毁而重建</strong>。</p><p>于是，就在项目中写了测试代码来验证。然后就发现了一个诡异的问题，<strong>打开的界面旋转后自动关闭了！！</strong>后来断点调试发现是因为 onDestroy 走了两次，分析逻辑之后，还原了执行流程，如下代码所示：</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    <span class="hljs-comment">// 由于历史原因，我们的项目里面出现了这样的代码（经过简化逻辑之后）。</span><br>    finish();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么问题就来了，<strong>Activity 在重建时，是创建了新的对象，为何旧的对象调用 finish 方法会将新创建的 Activity 对象给销毁？</strong></p><p>查看 finish 的源码：</p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><blockquote><p>android.app.Activity#finish(int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> finishTask)</span> </span>&#123;<br>    <span class="hljs-comment">// mParent 为空，走里面的逻辑</span><br>    <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>        <br>        ...<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ...<br>            <span class="hljs-comment">// 这里是最可疑的地方，AMS 是根据 mToken 的值去判断该 finish 哪个 Activity    </span><br>            <span class="hljs-keyword">if</span> (ActivityManager.getService()<br>                    .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;<br>                mFinished = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-comment">// Empty</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mParent.finishFromChild(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，打印 mToken 的值看一下：</p><h4 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        Class aClass = <span class="hljs-keyword">this</span>.getClass();<br><br>        <span class="hljs-keyword">while</span> (aClass != Activity.class) &#123;<br>            aClass = aClass.getSuperclass();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Field mToken = aClass.getDeclaredField(<span class="hljs-string">&quot;mToken&quot;</span>);<br>            mToken.setAccessible(<span class="hljs-keyword">true</span>);<br>            Object o = mToken.get(<span class="hljs-keyword">this</span>);<br>            Log.e(<span class="hljs-string">&quot;mToken&quot;</span>, o.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        finish();<br>    &#125;<br></code></pre></td></tr></table></figure><p>输出 log 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">E/mToken: android.os.BinderProxy@57d9656<br>E/mToken: android.os.BinderProxy@57d9656<br></code></pre></td></tr></table></figure><p>不出所料，那么现在就来看看源码，看 AMS 是如何根据 mToken 来管理 Activity 的。</p><p>Android 是如何根据手机方向来旋转屏幕的，这个我没法探究，但是 Activity 有一个方法，也可以设置屏幕方向，想来分析这个方法也是可行的。</p><h3 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h3><blockquote><p>android.app.Activity#setRequestedOrientation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequestedOrientation</span><span class="hljs-params">(<span class="hljs-meta">@ActivityInfo</span>.ScreenOrientation <span class="hljs-keyword">int</span> requestedOrientation)</span> </span>&#123;<br>    <span class="hljs-comment">// mParent 为null</span><br>    <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 走这里</span><br>            ActivityManagerNative.getDefault().setRequestedOrientation(<br>                    mToken, requestedOrientation);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-comment">// Empty</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mParent.setRequestedOrientation(requestedOrientation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 Binder 机制，ActivityManagerNative.getDefault() 会返回 ActivityManagerProxy 对象，然后会调用到 ActivityManagerService 的 setRequestedOrientation 方法。</p><h3 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h3><blockquote><p>com.android.server.am.ActivityManagerService#setRequestedOrientation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequestedOrientation</span><span class="hljs-params">(IBinder token, <span class="hljs-keyword">int</span> requestedOrientation)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span>) &#123;<br>            r.frozenBeforeDestroy = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">// 这里处理了方向的改变，里面还涉及到对 activity 方向改变的回调</span><br>            <span class="hljs-keyword">if</span> (!updateConfigurationLocked(config, r, <span class="hljs-keyword">false</span>)) &#123;<br>                mStackSupervisor.resumeFocusedStackTopActivityLocked();<br>            &#125;<br>        &#125;<br>        Binder.restoreCallingIdentity(origId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面的代码还是比较深的，这里就不贴出来了，跟踪到后面，会发现它调用了这样的一个方法。</p><blockquote><p>com.android.server.am.ActivityStack#ensureActivityConfigurationLocked</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">ensureActivityConfigurationLocked</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">          ActivityRecord r, <span class="hljs-keyword">int</span> globalChanges, <span class="hljs-keyword">boolean</span> preserveWindow)</span> </span>&#123;<br>      ...<br>relaunchActivityLocked(r, r.configChangeFlags, <span class="hljs-keyword">true</span>, preserveWindow);<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里它重新启动了这个 Activity（demo里面没有对方向变化做任何处理）。</p><p>我们知道，AMS 处理 Activity 的方法，都会通知到到应用进程，由应用进程自己处理。</p><h3 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h3><blockquote><p>android.app.ActivityThread#handleRelaunchActivity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRelaunchActivity</span><span class="hljs-params">(ActivityClientRecord tmp)</span> </span>&#123;<br>    <br>    ...<br>        <span class="hljs-comment">// tmp 是从需要重启的集合中找出来的</span><br>        <span class="hljs-comment">// 这里再次找一下，按照正常逻辑这里找出来的，应该还是同一个对象</span><br>        ActivityClientRecord r = mActivities.get(tmp.token);<br>    ...<br>    <br>        <span class="hljs-comment">// r.token 传递进去</span><br>            handleDestroyActivity(r.token, <span class="hljs-keyword">false</span>, configChanges, <span class="hljs-keyword">true</span>);<br>    <br>    ...<br>    <span class="hljs-comment">// r 传递进去</span><br>            handleLaunchActivity(r, currentIntent, <span class="hljs-string">&quot;handleRelaunchActivity&quot;</span>);<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>ActivityClientRecord 是属于应用进程的，它里面存有 Activity 的信息。一个 ActivityClientRecord 对应一个 Activity。</p><p>这里可以看出，Activity销毁重建的时候，都使用的是同一个 ActivityClientRecord，mToken 没有变化。</p><p>当我们在 onDestroy 里面，调用 finish 的时候，传递的 mToken 值与重新创建的 Activity 的 mToken 值是一样的，所以会销毁掉刚刚启动的 Activity。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/post/5c88fac76fb9a049c16013c6">https://juejin.im/post/5c88fac76fb9a049c16013c6</a></p><p><a href="https://blog.csdn.net/guoqifa29/article/details/46819377">https://blog.csdn.net/guoqifa29/article/details/46819377</a></p><p><a href="https://www.jianshu.com/p/94816e52cd77">https://www.jianshu.com/p/94816e52cd77</a></p>]]></content>
    
    
    <categories>
      
      <category>bugs</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Drawable 介绍</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/Drawable%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/Drawable%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>Drawable 的内部宽高比较重要，通过 getIntrinsicWidth 等可以获取。</p><p>不是所有的 Drawble 都有内部宽高，对于图片形成的 drawble ，它的内部宽高就是图片的宽高，对于颜色形成的 drawable，它没有内部宽高。</p><p>Drawble 没有大小的概念，都会拉伸到与 View 一样大。</p><h2 id="BitmapDrawable"><a href="#BitmapDrawable" class="headerlink" title="BitmapDrawable"></a>BitmapDrawable</h2><p>属性介绍：</p><ul><li><p>antialias： 抗锯齿，就是画线的时候锯齿会减少，特别是画斜线与园</p></li><li><p>dither： 开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一样的时候，开启这个可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果。</p><blockquote><p>比如：图片的色彩模式为 ARGB8888，手机屏幕只支持 RGB555，这个时候，开启抖动选项可以让图片显示不会太过失真。</p></blockquote></li><li><p>filter：图片拉伸或者压缩时可以保持较好的效果</p></li><li><p>gravity：与 scaleType 类似</p></li><li><p>tileMode：平铺模式，有重复平铺（repeat），镜像平铺（mirror），边缘拉伸（clamp），禁止（disable）</p></li></ul><p>BitmapDrawable 用起来比较简单。</p><p>.9 图片需要特殊说明以下：</p><ul><li><p>left 线：表示纵向可拉伸区域</p></li><li><p>top 线：表示横向可拉伸区域</p></li><li><p>bottom 线 与 right 线交叉的区域：表示内容显示的区域</p></li></ul><p>具体的请点击<a href="https://blog.csdn.net/lastwarmth/article/details/49991445">这里</a> 。</p><h2 id="ShapeDrawable"><a href="#ShapeDrawable" class="headerlink" title="ShapeDrawable"></a>ShapeDrawable</h2><p>比较常用，可以画各种图形，渐变，只有 size 属性需要说一下。</p><ul><li>size ： 这个属性可以设置 getIntrinsicWidth 的返回值。表示 drawble 的内部宽高。</li></ul><p>这里有个比较神奇的地方：</p><p>首先，我们写一个 shape：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">android:dither</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">size</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:height</span>=<span class="hljs-string">&quot;1dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;5dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;2dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;@color/colorPrimaryDark&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:dashWidth</span>=<span class="hljs-string">&quot;3dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:dashGap</span>=<span class="hljs-string">&quot;3dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后，设置到一个 View 上面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;200dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_centerInParent</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/shape_drawable&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World!&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后，获取它的 background：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">TextView tv = (TextView)findViewById(R.id.tv);<br>Drawble drawable = (GradientDrawable) tv.getBackground();<br></code></pre></td></tr></table></figure><p>你会发现，它获取到的不是 ShapeDrawable，而是 GradientDrawable。</p><h2 id="LayerDrawable"><a href="#LayerDrawable" class="headerlink" title="LayerDrawable"></a>LayerDrawable</h2><p>层叠的 drawble。它可以画出单一边线的效果，其实就是利用几个大小差一点点的矩形做成的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layer-list</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--底层使用蓝色填充色--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#02a0ef&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--上面一层距离底层的顶部1dp,类似marginTop,填充色为白色，这样就形成了一个带有蓝色顶部边线的白色背景的图--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:top</span>=<span class="hljs-string">&quot;1dp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#fff&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layer-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p>![](F:\note-markdown\Drawable 介绍\20161206100146670.jpg)</p><h2 id="StateListDrawble"><a href="#StateListDrawble" class="headerlink" title="StateListDrawble"></a>StateListDrawble</h2><p>就是对应于 selector 标签，还是非常常用的。</p><p>不过需要注意的是，系统会根据当前的状态从selector中选择对应的 item，系统会按照从上往下的顺序查找，知道找到第一条匹配的 item。</p><p>这里就要注意了，如果你把默认的item放在第一条的话，系统寻找的时候，无论是选中，按压等所有的情况都会匹配第一条，因为默认的不带任何状态，系统认为它匹配所有的状态。</p><h2 id="LevelListDrawble"><a href="#LevelListDrawble" class="headerlink" title="LevelListDrawble"></a>LevelListDrawble</h2><p>对应于 level-list 标签。</p><p>可以用于切换图片，一个等级对应一张图，换图的时候只需要调用 img.setImageLevel 就好了。</p><h2 id="TransitionDrawable"><a href="#TransitionDrawable" class="headerlink" title="TransitionDrawable"></a>TransitionDrawable</h2><p>对应于 transition 标签。</p><p>可以用于给一张图切换到另一张图时的过渡动画。</p><h2 id="InsetDrawable"><a href="#InsetDrawable" class="headerlink" title="InsetDrawable"></a>InsetDrawable</h2><p>对应于 inset 标签。</p><p>当一个 View 需要背景比内容区域要小的时候，可以使用这个。</p><h2 id="ScaleDrawable"><a href="#ScaleDrawable" class="headerlink" title="ScaleDrawable"></a>ScaleDrawable</h2><p>对应于 scale 标签。</p><p>ScaleDrawable 有一个等级的概念，等级不仅会影响缩放的比例，还会影响绘制。</p><blockquote><p>android.graphics.drawable.ScaleDrawable#draw</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Drawable d = getDrawable();<br>    <span class="hljs-keyword">if</span> (d != <span class="hljs-keyword">null</span> &amp;&amp; d.getLevel() != <span class="hljs-number">0</span>) &#123;<br>        d.draw(canvas);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，如果 level 是 0 的时候，不会绘制 drawble。</p><p>对于缩放比例，它内部还有这样的一个公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br>w -= (<span class="hljs-keyword">int</span>) (w * (<span class="hljs-number">10000</span> - level) * mScaleState.mScaleWidth / <span class="hljs-number">10000</span>)<br></code></pre></td></tr></table></figure><p>可以看到，如果 level 越接近于0（需要大于0），那么缩放的比例就与 （1- mScaleState.mScaleWidth） 越相近。如果 level 为 10000，那么就是不缩放，不管 mScaleState.mScaleWidth 的值为多少。</p><p>mScaleState.mScaleWidth 就是我们在 xml 中设置的 scaleWidth 等属性。</p><p>看一个例子，将一张图缩小为原来的30%左右（之所以是为左右，是因为 level 最小为1，所有会有 1/10000的 误差）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;scale xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:drawable=<span class="hljs-string">&quot;@drawable/logo&quot;</span><br>    android:scaleGravity=<span class="hljs-string">&quot;center_vertical|center_horizontal&quot;</span><br>    android:scaleHeight=<span class="hljs-string">&quot;70%&quot;</span><br>    android:scaleWidth=<span class="hljs-string">&quot;70%&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>注意，这里是缩小 70%。由于 level 默认为0，所以我们还需要用代码设置以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">scaleDrawable.setLevel(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="ClipDrawable"><a href="#ClipDrawable" class="headerlink" title="ClipDrawable"></a>ClipDrawable</h2><p>对应于 clip 标签。</p><p>对一个drawable进行裁剪。其中 gravity 属性表示裁剪方向。</p><p>需要设置 leve 来表示裁剪多少，范围是 0~10000，0表示完全裁剪，即整个drawable都不见了，而 10000 表示不裁剪。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View 的 onMeasure 方法</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%20onMeasure%20%E6%96%B9%E6%B3%95/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%20onMeasure%20%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>View 的测量过程中，有一个比较重要的类需要掌握：MeasureSpec。我们在阅读源码的时候会发现，在 View 的测量过程中，MeasureSpec 是一个会经常出现的类，如果不先掌握这个类的话，是没法阅读下去的。</p><p>MeasureSpec 会在很大程度上决定一个 View 的尺寸规格，之所以是很大程度上是因为这个过程还受父容器的影响，因为父容器影响 View 的 MesaureSpec 的创建过程。</p><p>在测量过程中，系统会将 View 的 LayoutParams 根据父容器所施加的规则转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来测量出 View 的宽/高。</p><h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>MeasureSpec 是一个int值，但是这个int值被分为了两部分，一部分表示 SpecMode （测量模式），一部分表示 SpecSize（在某种测量模式下的大小）。</p><p>可能有很多人想不通，一个int型整数怎么可以表示两个东西（大小模式和大小的值），一个int类型我们知道有32位。而<strong>模式有三种</strong>，要表示三种状态，至少得2位二进制位。于是系统采用了最高的2位表示模式。如图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View/1346374636_1935.png?raw=true"></p><p>最高两位是00的时候表示”未指定模式”，即MeasureSpec.UNSPECIFIED。</p><p>最高两位是01的时候表示”‘精确模式”，即MeasureSpec.EXACTLY。</p><p>最高两位是11的时候表示”最大模式”，即MeasureSpec.AT_MOST。</p><ul><li><p>精确模式（MeasureSpec.EXACTLY）</p><p>在这种模式下，尺寸的值是多少，那么这个组件的长或宽就是多少。</p></li><li><p>最大模式（MeasureSpec.AT_MOST）</p><p>这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。</p></li><li><p>未指定模式（MeasureSpec.UNSPECIFIED）</p><p>这个就是说，当前组件，可以随便用空间，不受限制。</p></li></ul><p>MeasureSpec 通过将 SpecMode 与 SpecSize 打包成一个 int 值来避免过多的对象内存分配。为了方便操作，它还提供了对应的打包与解包方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将 size 与 mode 组合成一个 MeasureSpec 对象</span><br>android.view.View.MeasureSpec#makeMeasureSpec<br><br><span class="hljs-comment">// 从 MeasureSpec 中获取 mode</span><br>android.view.View.MeasureSpec#getMode<br><br><span class="hljs-comment">// 从 MeasureSpec 中获取 size</span><br>android.view.View.MeasureSpec#getSize<br></code></pre></td></tr></table></figure><p>在 View 测量的时候，系统会将 LayoutParams 在父容器的约束下转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来确定 View 测量后的大小。（<strong>这里需要注意，MeasureSpec 不是由 LayoutParams 唯一决定的，而是由 LayoutParams 与父布局一起决定的</strong>）</p><h3 id="各种-View-测量的区别"><a href="#各种-View-测量的区别" class="headerlink" title="各种 View 测量的区别"></a>各种 View 测量的区别</h3><h4 id="顶层-View"><a href="#顶层-View" class="headerlink" title="顶层 View"></a>顶层 View</h4><p>我们知道一般的 View 都会有父布局，但是最顶层的 View 是没有的，那么它是如何测量的呢？</p><p>首先它会获取 LayoutParams，再判断 LayoutParams 宽高的值：</p><ul><li>如果为 LayoutParams.MATCH_PARENT，这表示精确模式，大小就是窗口大小。</li><li>如果为 LayoutParams.WRAP_CONTENT，这表示最大模式，大小未定，但是不能超过窗口大小。</li></ul><p>这就比较简单了，顶层View的测量，一般宽高都是 LayoutParams.MATCH_PARENT，大小为窗口大小。</p><h4 id="子-View"><a href="#子-View" class="headerlink" title="子 View"></a>子 View</h4><p>对于普通的 View 来说，它的测量与父布局有关，而每个父布局的特性又不同，无法每个都涉及到，所以这里采取一个“管中窥豹，可见一斑”的方法。</p><p>这里介绍一下 ViewGroup 的 measureChildWithMargins 方法。</p><blockquote><p>android.view.ViewGroup#measureChildWithMargins</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(View child,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> parentWidthMeasureSpec, <span class="hljs-keyword">int</span> widthUsed,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> parentHeightMeasureSpec, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,<br>            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin<br>                    + widthUsed, lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,<br>            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin<br>                    + heightUsed, lp.height);<br><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法中的 getChildMeasureSpec 方法比较长，就不贴代码了，下面会有文字说明。</p><p>getChildMeasureSpec 其实最后就是生成了一个 MeasureSpec 对象。</p><p>它的 size 由<strong>两部分决定</strong>，一个是 <code>parentWidthMeasureSpec</code>，一个是 <code>lp.width / lp.height</code>。</p><p>具体的规则用表说明：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View/%E6%8D%95%E8%8E%B7.PNG?raw=true"></p><p>从这个表中我们可以看到，在构造 child 的 MeasureSpec 还是优先考虑了 child 自身的 size 的，特别是 child 直接要求一个固定的值的时候。</p><p>我们深入思考一下，比如我们经常使用到的 LinearLayout（竖向），它在决定 child 的大小的时，肯定不能让 child 的高度与自己的高度一样大，那么它是如何处理的呢？我们看看源码：</p><blockquote><p>android.widget.LinearLayout#measureVertical</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(<span class="hljs-number">0</span>, childHeight), MeasureSpec.EXACTLY);<br><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,lp.width);<br>child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br></code></pre></td></tr></table></figure><p>可以看到，LinearLayout 并没有使用 ViewGroup 提供的 measureChild 方法，因为它并不符合 LinearLayout 的特性。那么哪一个布局符合呢？？？FrameLayout！！！</p><blockquote><p>android.widget.FrameLayout#onMeasure</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = getChildCount();<br><br>    ...<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> View child = getChildAt(i);<br>        <span class="hljs-keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;<br>            measureChildWithMargins(child, widthMeasureSpec, <span class="hljs-number">0</span>, heightMeasureSpec, <span class="hljs-number">0</span>);<br>...<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它就是直接使用了 measureChildWithMargins 方法，因为它的特性只是做了一个层叠，并没有其他对 child 有其他限制，所以可以直接使用。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>说了这么多，我们来看看一个实际的应用场景吧。</p><p>我们知道，TextView 是有自己的 onMeasure 方法的。系统提供的 TextView，文字是从做到右的，那么我们现在想做这样的一个效果，将 TextView 的显示旋转一下，从上到下。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View/%E6%8D%95%E8%8E%B71.PNG?raw=true"></p><p>变成这样：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/View/%E6%8D%95%E8%8E%B72.PNG?raw=true"></p><p>那么，有的同学就说话了，这旋转一下不就不可以了吗！是这样吗？在我们的屏幕中，不可能只会有一个 TextView，所以这个 TextView 很可能会与其他控件一起排列，当我们在旋转之前，假设它的宽与高是 100*300，那么旋转之后，它的高度变成了300，这个时候，由于父布局的限制，我们很可能看不到整个 TextView。而且我们在 xml 中也不好去预览它的效果。</p><p>那么下面，我们就来实现一下这个效果。</p><p>首先我们需要处理该控件的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.measure(heightMeasureSpec, widthMeasureSpec);<br>    setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先来看这个方法：<code>super.measure(heightMeasureSpec, widthMeasureSpec);</code>。</p><p>这行代码非常容易引起误解，<strong>有的人就以为，我们将 widthMeasureSpec 与 heightMeasureSpec 换了一下，那么它测量出来的宽高自然就会互换。这是错误的理解！！！</strong></p><p>比如，我们在 xml 中是这样使用这个自定义控件的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/com.yoog.widget&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span> &gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">com.yoog.widget.VerticalTextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;20:59&quot;</span>                              </span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>我们假设<code>20：59</code>这串文字的长度为 300，高度为 100。父布局的宽高均大于 300。</p><p>所以，TextView 测量出来的就是 300*100，VerticalTextView 测量出来的值应该是 100 * 300。</p><p>但是，如果父布局的高度只有 250 的时候，横着测量的时候，是完全没有问题的，仍然测量出 300 * 100，但是竖着测量的时候，高度只能有 250，它需要换行，所以，结果是 100 * 250。</p><p>所以说，<strong>将 widthMeasureSpec 与 heightMeasureSpec 互换，只是为了正确的将父布局对 child 的影响正确的传递进去</strong>。</p><p>由于，正确的传递了父容器的宽与高，走 TextView 的方法自然就会测量出正确的值，然后我们调用 <code>setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());</code> 方法，就可以将宽与高换过来了。</p><p>至于 onDraw 方法，我们就不深入了，只需要在 view 的左上角旋转一下画布就好了。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View 的事件分发</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="事件的传递流"><a href="#事件的传递流" class="headerlink" title="事件的传递流"></a>事件的传递流</h3><p>Activity -&gt; Window -&gt; ViewGroup - &gt; View</p><blockquote><p>Activity.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>        onUserInteraction();<br>    &#125;<br>    <span class="hljs-comment">// 交给 window</span><br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>PhoneWindow.java</p></blockquote><p>因为 PhoneWindow 暂时是 Window 类的唯一实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 mDecor 就是 DecorView 了，它继承至 FrameLayout，所以它是一个 ViewGroup。</p><p>然后 ViewGroup <strong>可能会</strong>将事件就传递给它的子 View。</p><h3 id="onTouch-amp-onTouchEvent-amp-onClick"><a href="#onTouch-amp-onTouchEvent-amp-onClick" class="headerlink" title="onTouch &amp; onTouchEvent &amp; onClick"></a>onTouch &amp; onTouchEvent &amp; onClick</h3><p>在 View 的 dispatchTouchEvent 方法中，在调用 onTouchEvent 之前，会先调用 mListenerInfo.mOnTouchListener.onTouch  方法，这个就是我们在外部设置的监听了。如果这个方法返回了 true，那么 onTouchEvent 方法就不会调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">         ListenerInfo li = mListenerInfo;<br>         <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span><br>                 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>                 &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123;<br>             result = <span class="hljs-keyword">true</span>;<br>         &#125;<br><span class="hljs-comment">// result 为 true 是无法进入这个条件的</span><br>         <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>             result = <span class="hljs-keyword">true</span>;<br>         &#125;<br></code></pre></td></tr></table></figure><p>onClick 是在 onTouchEvent 中调用的，现在的 Android studio 在我们复写 View 的 onTouchEvent 的时候，都会给这么一个警告：</p><blockquote><p>Custom view MotionView overrides onTouchEvent but not performClick less… (Ctrl+F1)<br>Inspection info:If a View that overrides onTouchEvent or uses an OnTouchListener does not also implement performClick and call it when clicks are detected, the View may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in View#performClick as some accessibility services invoke performClick when a click action should occur.</p></blockquote><p>简单来说就是，复写这个方法可能会导致 performClick 方法不会触发。从而影响 accessibility  的动作行为。</p><h3 id="onClick-amp-onLongClick"><a href="#onClick-amp-onLongClick" class="headerlink" title="onClick &amp; onLongClick"></a>onClick &amp; onLongClick</h3><p>一般的，手指点击然后抬起，就会触发一个 onClick 时间，但是不知道你有没有想过，onLongClick 是如何触发的呢？系统是如何判断我们是长按，而不是点击？</p><p>话说，肯定是一句时间来判断，但是具体的思路是怎么样的呢？</p><blockquote><p>使用 Handler post 一个延时 xxx ms消息，如果收到这个延时消息就会触发一个事件。 然而某些情况下，会提前将该消息 remove 掉，这样就收不到这个消息，无法触发事件。</p><p>拿长按事件举例：比如长按1s算一个长按事件，那么我们就可以post一个延时1000ms的消息，收到这个消息就触发长按回调，如果没到1s用户就放开了手指，那么就移除这个消息，这样就不会触发长按回调了。</p></blockquote><p>onLongClick 方法有返回值，返回 true 表示消耗这个事件，那么 onClick 就无法触发了。</p><h3 id="clickable-amp-enable"><a href="#clickable-amp-enable" class="headerlink" title="clickable &amp; enable"></a>clickable &amp; enable</h3><p>一个 View 只有是 clickable 才会消耗事件，与 enable 没有关系。</p><h3 id="onInterceptTouchEvent-的调用"><a href="#onInterceptTouchEvent-的调用" class="headerlink" title="onInterceptTouchEvent 的调用"></a>onInterceptTouchEvent 的调用</h3><p>onInterceptTouchEvent  这个方法只有 ViewGroup 才有。</p><p>这个方法的调用条件有两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><p>第一个是按下事件才会触发，第二个是<strong>有可以消耗这次事件的子 View</strong>。</p><p>根据这个我们可以推理出如下结论：</p><p>当一个 ViewGroup 拦截事件的时候，它会将事件交给自己处理，那么它不会把事件传递给子 View，也就是说，<strong>它没有可以消耗这次事件的子View</strong>。即在接下来的 MOVE、UP等事件，都不会调用这个方法。</p><h3 id="requestDisallowInterceptTouchEvent"><a href="#requestDisallowInterceptTouchEvent" class="headerlink" title="requestDisallowInterceptTouchEvent"></a>requestDisallowInterceptTouchEvent</h3><p>当子View调用这个方法之后，ViewGroup <strong>无法拦截除了 ACTION_DOWN 以外的事件</strong>。</p><p>这是因为，ACTION_DOWN 事件会重置和清除一些状态，其中就包括 FLAG_DISALLOW_INTERCEPT。</p><h3 id="ViewGroup-拦截事件"><a href="#ViewGroup-拦截事件" class="headerlink" title="ViewGroup 拦截事件"></a>ViewGroup 拦截事件</h3><p>当 ViewGroup 决定拦截事件，那么 mFirstTouchTarget == null，那么 ViewGroup 的 dispatchTouchEvent 方法会调用 super.dispatchTouchEvent(event); 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mFirstTouchTarget == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// No touch targets so treat this as an ordinary view.</span><br>    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-keyword">null</span>,<br>            TouchTarget.ALL_POINTER_IDS);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>    handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 super 就是 View，因为 ViewGroup 也是继承至 View 的。</p><p>所以就调用到了 View 的 dispatchTouchEvent 方法，我们都知道，View 的 dispatchTouchEvent 方法会直接调用自己的 onTouchEvent 方法，而<strong>这里自己表示ViewGroup</strong>。所以，当 ViewGroup 决定拦截事件，会将事件交给自己处理。</p><h3 id="ACTION-DOWN"><a href="#ACTION-DOWN" class="headerlink" title="ACTION_DOWN"></a>ACTION_DOWN</h3><p>当某个 View 可以消耗事件的时候，这个 View 的父布局的 mFirstTouchTarget 变量就指向了这个 View，然后接下来的事件都会交给这个 View 来处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>    handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    handled = child.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，直接调用 child （mFirstTouchTarget  指向的值） 的 dispatchTouchEvent。</p><p>当 View 不消耗 ACTION_DOWN 事件的时候，它的父布局的 mFirstTouchTarget 就为null，后面的事件该View 的 父布局就不会再往下传递了。它也就接受不到后续事件了。</p><h3 id="ACTION-CANCEL"><a href="#ACTION-CANCEL" class="headerlink" title="ACTION_CANCEL"></a>ACTION_CANCEL</h3><p>当一个 ViewGroup 不拦截 ACTION_DOWN 事件，并且有可以消耗 ACTION_DOWN 的子 View 时，接下来的事件都会交给这个子 View 来处理，但是每次都会询问父布局是否拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>        || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>    <span class="hljs-comment">// 因为 mFirstTouchTarget 不会空，所以会走这里</span><br>        intercepted = onInterceptTouchEvent(ev);<br>        ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而如果在后续的事件中，父布局突然拦截了事件，即 intercepted 为 true，那么先前可以处理该事件的子View会收到一个 ACTION_CANCEL 事件。后面的事件就都会传递给父布局，而不往下传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// intercepted 为 true，则 cancelChild 也为 true</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child) || intercepted;<br><span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;<br>    handled = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldAction = event.getAction();<br><span class="hljs-keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;<br>    <span class="hljs-comment">// 强制将 action 改成 cancel</span><br>    event.setAction(MotionEvent.ACTION_CANCEL);<br>    <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) &#123;<br>        handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        handled = child.dispatchTouchEvent(event);<br>    &#125;<br>    event.setAction(oldAction);<br>    <span class="hljs-keyword">return</span> handled;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里它将 ACTION_CANCEL  传递给了子 View。</p><p>传递 cancel 成功之后，会重置一些状态，包括 mFirstTouchTarget，将它的值清空。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View 的工作原理</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/View%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="ViewRootImpl-amp-DecorView"><a href="#ViewRootImpl-amp-DecorView" class="headerlink" title="ViewRootImpl &amp; DecorView"></a>ViewRootImpl &amp; DecorView</h3><p>当我们在 Activity 中调用 setContentView 方法的时候，实际上 Activity 是将这个方法转发给了 Window。</p><blockquote><p>android.app.Activity#setContentView(int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;<br>    getWindow().setContentView(layoutResID);<br>    initWindowDecorActionBar();<br>&#125;<br></code></pre></td></tr></table></figure><p>而 Window 的 setContentView 方法会创建 DecorView 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;<br>       <span class="hljs-comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br>       <span class="hljs-comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span><br>       <span class="hljs-comment">// before this happens.</span><br>       <span class="hljs-keyword">if</span> (mContentParent == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-comment">// 这个方法里面就实例化了一个 DecorView</span><br>           installDecor();<br>       &#125;<br>       ...<br>   &#125;<br></code></pre></td></tr></table></figure><p>那么，有了 DecorView 之后，后面的流程就是解析我们在 xml 中写的布局，将xml转换成真正的 View 对象，然后添加到 DecorView 中（DecorView 是继承至 FrameLayout）。</p><hr><p>但是我们都知道，在 onCreate 中我们是无法看到布局的，就像我们在内存中创建了一个 View 对象，我们是看不到它的，只有将它添加到界面上我们才能看到。</p><p>那么，如何将一个 View 添加到界面上呢？想必大家都知道以前手机上的悬浮按钮很流行，我们自己想要做一个这样的效果，一般都是通过 WindowManager 来实现的。所以说，使用 WindowManger 就可以将一个 View 显示到界面上了。当一个 View 已经显示到界面上之后，在给他添加子 View 就不用 WindowManager 了，可以直接添加，这就是我们可以动态更改布局，而不用通过WindowManager 的原因，因为 Activity 已经通过 WindowManager 将 DecorView 添加到了 PhoneWindow 上。我们操作的是 DecorView 的子 View。</p><blockquote><p>android.app.ActivityThread#handleResumeActivity</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的 l 是 WindowManager.LayoutParams 对象的类型</span><br>wm.addView(decor, l);<br></code></pre></td></tr></table></figure><p>可以看到在 Activity 的 onResume 执行后，View 才会被添加到 Window 上，所以在这之前，我们是看不到界面的，故而不要在这之前做太多的事件，以免黑（白）屏时间太长，给用户一个不好的体验。</p><p>看到这里，我们已经知道 DecorView 与 WindowManager 是如何产生关系的了！</p><hr><p>那么 ViewRootImpl 又是如何插一脚的呢？</p><p>上面的 addView 方法中，其实创建了一个 ViewRootImpl 对象：</p><blockquote><p>android.view.WindowManagerGlobal#addView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ViewRootImpl root;<br>...<br>root = <span class="hljs-keyword">new</span> ViewRootImpl(view.getContext(), display);<br>...<br><span class="hljs-comment">// 这个 view 就是上面的 DecorView 对象</span><br><span class="hljs-comment">// 这里将 view 保存到了自己的成员变量 mView 中</span><br>root.setView(view, wparams, panelParentView);<br></code></pre></td></tr></table></figure><p>我们先来看看官方对 ViewRootImpl 的介绍：</p><blockquote><p>ViewRootImpl是View中的最高层级，属于所有View的根（<code>但ViewRootImpl不是View，只是实现了ViewParent接口</code>），实现了View和WindowManager之间的通信协议，实现的具体细节在WindowManagerGlobal这个类当中。</p></blockquote><p>也就是说，View 并不会与 WindowManager 直接交流，他们有一个中间人，就是 ViewRootImpl，但是它的功能不止于此，它还负责 View 的测量-布局-绘制流程。可以看作是 View 树的操纵者。</p><h3 id="View的测量过程"><a href="#View的测量过程" class="headerlink" title="View的测量过程"></a>View的测量过程</h3><p>对于 DecorView ，其 MeasureSpec 由<strong>窗口的尺寸</strong>和其<strong>自身的 LayoutParams</strong> 来共同决定。</p><p>对于普通的 View，其 MeasureSpec 由<strong>父容器的 MeasureSpec</strong> 和<strong>自身的 LayoutParams</strong> 来共同决定。</p><p>具体一点来说：</p><ul><li>当 View 采用具体数值的宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是EXACTLY并且其大小遵循 LayoutParams 中的大小。</li><li>当 View 的宽/高是 match_parent 时，如果父容器的模式是EXACTLY模式，那么 View 也是EXACTLY模式并且其大小是父容器的剩余空间。如果父容器是AT_MOST模式，那么View 也是AT_MOST模式并且大小为父容器的剩余空间（可以看出，View 与 父容器的模式一样）。</li><li>当 View 的宽/高是 warp_content 是时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是 AT_MOST 模式并且大小为父容器的剩余空间。</li></ul><p>决定了 View 的 MeasureSpec 值之后，就可以开始执行 View 的 measure 方法了。</p><p>measure 方法就是执行测量过程的方法，它会调用 onMeasure 方法，经常自定义控件的就很熟悉这个方法了。我们可以通过复写 onMeasure 这个方法来绝定一个控件在各种情况下应该有多大。</p><p>onMeasure  方法有两个参数：</p><blockquote><p>android.view.View#onMeasure</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),<br>            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>widthMeasureSpec 与 heightMeasureSpec 这两个值就是根据上面的规则得到的（虽然上面我们只说了测量模式，没有测量大小）。View 有了这两个值就可以知道自己在各种情况下应该占多大的位置了。</p><p>一般情况下，View 测量出来的大小就是 widthMeasureSpec / heightMeasureSpec 中的 size 值。</p><p>但是也有例外，这个时候，View 的宽/高由 minWidth 与 background 一起决定，如果 background 为空，那么值就是 minWidth/minHeight，如果有 background，那么值就取 minWidth/minHeight 与 background 的原始宽/高 中的较大者。</p><p>当我们继承一个 View 来自定义控件的时候，如果不复写 onMeasure 就会出现一个问题：</p><p>在使用 wrap_content 属性的时候，是不生效的，效果与 match_parent 一样！！</p><p>导致这个的原因是：View 为 wrap_content 的时候，模式是 AT_MOST，大小为父容器的剩余空间。这样的话，与match_parent 的表现形式是一样的。</p><p>所以，可以这样解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> modeW = MeasureSpec.getMode(widthMeasureSpec);<br>    <span class="hljs-keyword">int</span> sizeW = MeasureSpec.getSize(widthMeasureSpec);<br><br>    <span class="hljs-keyword">int</span> modeH = MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-keyword">int</span> sizeH = MeasureSpec.getSize(heightMeasureSpec);<br><br>    <span class="hljs-keyword">int</span> width, height;<br>    <span class="hljs-keyword">if</span> (modeW == MeasureSpec.AT_MOST) &#123;<br>        width = mMyWidth;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        width = sizeW;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (modeH == MeasureSpec.AT_MOST) &#123;<br>        height = mMyHeight;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        width = sizeH;<br>    &#125;<br>    <br>    setMeasuredDimension(width, height);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，只是指定了 AT_MOST 模式下的值，其他的没有改变。</p><h3 id="ViewGroup-的测量过程"><a href="#ViewGroup-的测量过程" class="headerlink" title="ViewGroup 的测量过程"></a>ViewGroup 的测量过程</h3><p>ViewGroup 在测量的时候，会先去测量所有的 Child。调用 child 的 measure 方法来测量 child 的大小，然后根据 child 的大小以及自己的布局规则来决定自己的大小。</p><p>之所以，还涉及 ViewGroup 的布局规则，是因为每个ViewGroup 都不一样，比如：LinearLayout 是按照线程布局，FrameLayout是按照层叠布局，即使他们的所有child都一样，测量出来的结果肯定不是一样的。</p><blockquote><p>android.view.ViewGroup#measureChildren</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildren</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> View child = children[i];<br>        <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>android.view.ViewGroup#measureChild</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChild</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> LayoutParams lp = child.getLayoutParams();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,<br>            mPaddingLeft + mPaddingRight, lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,<br>            mPaddingTop + mPaddingBottom, lp.height);<br><br>    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，measureChild 就是取出LayoutParams，然后和 parentMeasureSpec 一起来决定child 的 MeasureSpec，这个过程与 View 的测量过程是一样的。</p><h3 id="android-view-ViewRootImpl-performTraversals-是谁触发的"><a href="#android-view-ViewRootImpl-performTraversals-是谁触发的" class="headerlink" title="android.view.ViewRootImpl#performTraversals 是谁触发的"></a>android.view.ViewRootImpl#performTraversals 是谁触发的</h3><p>我们知道在 ViewRootImpl 创建出来之前，View是不会执行测量等一系列流程的，这是因为View的测量等都是由 ViewRootImpl 操纵的。</p><p>那么，View的第一次测量是从什么时候开始的呢？</p><blockquote><p>android.view.ViewRootImpl#setView</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Schedule the first layout -before- adding to the window</span><br><span class="hljs-comment">// manager, to make sure we do the relayout before receiving</span><br><span class="hljs-comment">// any other events from the system.</span><br>requestLayout();<br></code></pre></td></tr></table></figure><p>当 View 被添加到 window 上之前，ViewRootImpl 会执行一次 requestLayout，这个货会触发一系列连锁反应，最后调用到 performTraversals 里面。</p><h3 id="为什么使用-view-post-xxx-可以获取到-view-的宽高？？？"><a href="#为什么使用-view-post-xxx-可以获取到-view-的宽高？？？" class="headerlink" title="为什么使用 view.post(xxx) 可以获取到 view 的宽高？？？"></a>为什么使用 view.post(xxx) 可以获取到 view 的宽高？？？</h3><p>这是因为 view 将 runnable 都存到了自己维护的一个队列中。</p><blockquote><p>android.view.HandlerActionQueue#postDelayed</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postDelayed</span><span class="hljs-params">(Runnable action, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> HandlerAction handlerAction = <span class="hljs-keyword">new</span> HandlerAction(action, delayMillis);<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mActions == <span class="hljs-keyword">null</span>) &#123;<br>            mActions = <span class="hljs-keyword">new</span> HandlerAction[<span class="hljs-number">4</span>];<br>        &#125;<br>        mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction);<br>        mCount++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等到 view 显示出来的时候，才会取出来执行。</p><blockquote><p>android.view.ViewRootImpl#performTraversals</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Execute enqueued actions on every traversal in case a detached view enqueued an action</span><br>getRunQueue().executeActions(mAttachInfo.mHandler);<br></code></pre></td></tr></table></figure><p>可以看到，每次执行 performTraversals 的时候，就调用了 View 维护的队列的 executeActions 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeActions</span><span class="hljs-params">(Handler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">final</span> HandlerAction[] actions = mActions;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, count = mCount; i &lt; count; i++) &#123;<br>            <span class="hljs-keyword">final</span> HandlerAction handlerAction = actions[i];<br>            handler.postDelayed(handlerAction.action, handlerAction.delay);<br>        &#125;<br><br>        mActions = <span class="hljs-keyword">null</span>;<br>        mCount = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而这个队列，将 runnable 交给了 handler 去执行，这个 handler 是主线程的 handler。那么这个 runnable 会什么时候执行呢？这里我们先不管，我能只需要知道这个 runnable 与 测量流程 那个先执行就好了。</p><p>performTraversals 在调用了 executeActions 之后，将 runnable 放入主线程的队列，然后就接续往下执行，下面就是 View 的测量-布局-绘制流程了，所以说不管 runnable 什么时候执行，它肯定是在测量流程的后面执行，这也是为什么能在 view.post 的 runnable 可以拿到 view 的宽高的原因。</p><h3 id="View-的-layout-过程"><a href="#View-的-layout-过程" class="headerlink" title="View 的 layout 过程"></a>View 的 layout 过程</h3><p>一个 view 在 layout 方法中会决定自己在父布局的位置，如果这个 view 还有 child，那么它会在 onLayout 方法中调用 child 的 layout 方法，决定 child 的位置。这样达到一个循环…</p><p>其实自定义一个 ViewGroup，它的 onLayout 实现还是比较简单的，只要按照业务流程，慢慢写就好了，就和摆东西一样，每个东西的大小你都知道了，想怎么摆就怎么摆。就是里面的 margin 比较蛋疼，需要细心一点。</p><h3 id="View-的-draw-过程"><a href="#View-的-draw-过程" class="headerlink" title="View 的 draw 过程"></a>View 的 draw 过程</h3><ol><li><p>先绘制背景（肯定的，不然内容被背景盖住了）</p></li><li><p>绘制自己（onDraw）</p></li><li><p>绘制 children （dispatchDraw）</p></li><li><p>绘制装饰 （onDrawScrollBars）</p></li></ol><p>与这个过程有关的有一个很重要的东西，就是补间动画执行的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas canvas, ViewGroup parent, <span class="hljs-keyword">long</span> drawingTime)</span> </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">//获取当前Animation</span><br>    <span class="hljs-keyword">final</span> Animation a = getAnimation();<br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-keyword">null</span>) &#123;<br>        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);<br>        ...<br>    &#125;<br>    ...<br>    <span class="hljs-comment">//处理滑动</span><br>    <span class="hljs-keyword">if</span> (offsetForScroll) &#123;<br>        canvas.translate(mLeft - sx, mTop - sy);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!drawingWithRenderNode) &#123;<br>             <span class="hljs-comment">//处理滑动</span><br>            canvas.translate(mLeft, mTop);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (scalingRequired) &#123;<br>            ...<br>            <span class="hljs-comment">// mAttachInfo cannot be null, otherwise scalingRequired == false</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> scale = <span class="hljs-number">1.0f</span> / mAttachInfo.mApplicationScale;<br>            <span class="hljs-comment">//处理缩放</span><br>            canvas.scale(scale, scale);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//处理透明度</span><br>    <span class="hljs-keyword">float</span> alpha = drawingWithRenderNode ? <span class="hljs-number">1</span> : (getAlpha() * getTransitionAlpha());<br>    ...<br><span class="hljs-keyword">if</span> (drawingWithRenderNode) &#123;<br>        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (layerType == LAYER_TYPE_NONE) &#123;<br>        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),<br>                              multipliedAlpha);<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> more;<br>&#125;   <br></code></pre></td></tr></table></figure><p>可以看到，在 View 的绘制过程中，会获取 view 相关的动画，然后根据动画来计算当前 view 应该所处的位置，透明度等等。所以，如果一个 view 不执行重绘，动画是显示不出来的。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ViewGroup 的 generateLayoutParams 方法的作用</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/ViewGroup%20%E7%9A%84%20generateLayoutParams%20%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/ViewGroup%20%E7%9A%84%20generateLayoutParams%20%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>不知道大家在编写布局的时候有没有这样的疑问：在 RelativeLayout 布局里面可以对子控件使用 layout_alignParentRight 等属性，但是在 FrameLayout 或者 LinearLayout 中就没有，这是为什么呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentRight</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而且，在代码中，我们获取子控件的 LayoutParams 的时候，默认是 ViewGroup.LayoutParams  类型的，我们想要使用某些特殊的字段，还需要转换为 RelativeLayout.LayoutParams 或其他具体的 LayoutParams 才行。这又是为什么呢？</p><p>下面，我们一一道来。</p><p>当我们自定义一个控件的时候，如果我们做的灵活一点，一般会提供一些属性配置方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TagGroup</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(context, attrs);<br><br>    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TagGroup);<br><br>    <span class="hljs-keyword">int</span> targetColorInt = typedArray.getInt(R.styleable.TagGroup_targetColor, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (targetColorInt != <span class="hljs-number">0</span>) &#123;<br>        targetColor = context.getResources().getColor(targetColorInt);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        targetColor = Color.WHITE;<br>    &#125;<br><br>    typedArray.recycle();<br>&#125;<br></code></pre></td></tr></table></figure><p>在 attrs.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TagGroup&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;targetColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;integer&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是使用这种方式的话，不管你在什么 ViewGroup 下使用，它都有这个属性。而且，在xml中，这个属性只能给自己用，无法给它的子控件使用。 显然，RelativeLayout 没有使用这种方式。那它是怎么做的呢？答案是通过复写 ViewGroup 的 generateLayoutParams 方法实现的。</p><p>这里我们据一个例子来说明，我们自定义一个控件：</p><blockquote><p>com.aprz.myapplication.MyViewGroup</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyViewGroup</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<br>    context: Context,<br>    attributeSet: AttributeSet? = <span class="hljs-literal">null</span>,<br>    defStyleAttr: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : ViewGroup(context, attributeSet, defStyleAttr) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(changed: <span class="hljs-type">Boolean</span>, l: <span class="hljs-type">Int</span>, t: <span class="hljs-type">Int</span>, r: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// TODO(&quot;not implemented&quot;)</span><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们关注的重点不在控件的功能，所以我们不重写 onLayout 方法。这里我们需要重写的是它的 generateLayoutParams  方法：</p><blockquote><p>com.aprz.myapplication.MyViewGroup#generateLayoutParams</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateLayoutParams</span><span class="hljs-params">(attrs: <span class="hljs-type">AttributeSet</span>?)</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> MyLayoutParams(context, attrs)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们返回了我们自己创建的 MyLayoutParams 对象。它的实现如下：</p><blockquote><p>com.aprz.myapplication.MyViewGroup.MyLayoutParams</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLayoutParams</span></span>(context: Context, attrs:AttributeSet?) : ViewGroup.MarginLayoutParams(context, attrs) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> stayLeft : <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> stayRight : <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">val</span> a = context.obtainStyledAttributes(<br>            attrs,<br>            R.styleable.MyViewGroup_Layout<br>        )<br><br>        stayLeft = a.getResourceId(R.styleable.MyViewGroup_Layout_stayLeft, <span class="hljs-number">0</span>)<br>        stayRight = a.getResourceId(R.styleable.MyViewGroup_Layout_stayRight, <span class="hljs-number">0</span>)<br><br>        a.recycle()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的代码应该就很熟悉了，与自定义控件的属性的配置方式与流程基本是一摸一样的。同样的也需要在 attrs.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MyViewGroup_Layout&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stayLeft&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stayRight&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;reference&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，我们在 xml 中使用该布局的时候，就可以给子控件配置这两个属性了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.aprz.myapplication.MyViewGroup</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:stayRight</span>=<span class="hljs-string">&quot;@id/tv1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">com.aprz.myapplication.MyViewGroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其实generateLayoutParams方法的作用其实就是定义你的控件下所有子控件所使用的layoutParams类，通过这种形式使你的控件可以按自己想要的方式和属性来操作它的子view，你甚至不需要关心子view本身，只要你重写过generateLayoutParams方法，他们就会使用你给的LayoutParams来修饰自己。</p><p>但是，这里有个问题，就是 IDE 好像无法识别自定义的属性，在 xml 中使用的时候会报红线，但是可以运行。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>插值器与估值器</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%E4%BC%B0%E5%80%BC%E5%99%A8/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%E4%BC%B0%E5%80%BC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>想来了解以下动画的定义：</p><blockquote><p><strong>动画</strong>是指由许多<a href="https://zh.wikipedia.org/wiki/%E5%B8%A7">帧</a>静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因<a href="https://zh.wikipedia.org/wiki/%E8%A7%86%E8%A7%89%E6%AE%8B%E8%B1%A1">视觉残象</a>产生<a href="https://zh.wikipedia.org/wiki/%E9%8C%AF%E8%A6%BA">错觉</a>，而误以为画面活动的作品。</p></blockquote><p>Android中的动画也遵循这个原理，只不过它的每一帧都是通过插值器与估值器动态计算出一个矩阵，然后应用到控件上得到的。</p><p>在计算的过程中，<strong>插值器负责计算动画执行的百分比，估值器负责根据百分比来计算属性值</strong>。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>valueAnimator.setDuration(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>这里，我们以 ValueAnimator 举例，做一个值动画，让 1 在 1000ms 内匀速变到 100。</p><p>假设这个动画有11帧，那么在第一帧的时候，是保持原来的位置不动，随着时间的流逝，在过了100ms之后，来到了第2帧，这个时候插值器就派上用场了。根据<strong>匀速运行</strong>的计算，在 100ms 的时候，动画应该执行了 10%，所以会出现一个时间 t 与动画值的函数：</p><blockquote><p>f(t) = t / duration * 100</p><p>记住这个函数，后面的东西都是围绕它来的</p></blockquote><p>让我们看看线性插值器的代码，来对比一下：</p><blockquote><p>android.view.animation.LinearInterpolator#getInterpolation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> input;<br>   &#125;<br><span class="hljs-comment">// 转换成函数就是 f(x) = x，这个f(x) 相当于上面函数的 t / duration</span><br><span class="hljs-comment">// 也就是说，这里只是计算了动画执行的百分比，还没有计算到动画的具体值</span><br></code></pre></td></tr></table></figure><p>这里的 input 参数，表示的是<strong>时间的流逝百分比</strong>，它返回的是<strong>动画执行的百分比</strong>。</p><p>这与上面的 f(t) 函数的意义是一样的，只不过 f(t) 的参数是 t， 而 getInterpolation 的参数是 t/duration。</p><p>回想一下，刚接触函数的时候，f(x) = x 这个函数，就是一条直线，所以这个插值器叫线性插值器。</p><p>我们再来看看加速插值器的代码：</p><blockquote><p>android.view.animation.AccelerateInterpolator#getInterpolation</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mFactor == <span class="hljs-number">1.0f</span>) &#123;<br>        <span class="hljs-keyword">return</span> input * input;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>)Math.pow(input, mDoubleFactor);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们只考虑 mFactor == 1.0f 的情况，所以有这样的一个函数 f(x) = x * x 。</p><p>那么这个函数是什么意思呢？首先，输入范围是 【0，1】，经过函数变换之后，还是【0，1】。这个是很重要的，虽然你可以返回大于1或者小于0的值，但是大于1的会被当成最后一帧处理，小于0的作为第一帧处理。具体请看 android.animation.KeyframeSet#getValue 这个方法。</p><p>再回想一下  f(x) = x * x  这个函数的图像，在【0，1】的范围，它的斜率是从低到高的，所以表现出来的就是一个加速行为。想不通的可以这样想，在前面的 【0， 0.5】 的范围内，f(x) 的值从0只增加到了0.25，而在后面的【0.5，1】的范围内，f(x) 的值从 0.25 增加到了 1，所以是增加的速度越来越快。</p><p>那么，这里我们自定义一个插值器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getInterpolation</span><span class="hljs-params">(<span class="hljs-keyword">float</span> input)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - input;<br>&#125;<br></code></pre></td></tr></table></figure><p>猜猜，它会是一个什么样的行为？其实就是一个反向的线性插值器，比如，从 1 到 100，这个插值器会从 100 变到 1。</p><hr><p>再看估值器，一般的我们很少会自定义估值器，除非有特殊的需要，比如计算颜色，颜色的算法不像数值的计算，按照百分比乘一下就完事了，因为颜色涉及到 RGB 3个值，所以需要将 RGB 分开来计算。</p><p>我们还是看看自带的几个估值器的代码。</p><p>先看简单的 int 估值器，这个我们也能写出来，动画的百分比知道了，需要变化的范围我们也知道，用百分比乘以变化范围再加上起始值就ok了。</p><blockquote><p>android.animation.IntEvaluator#evaluate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, Integer startValue, Integer endValue)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> startInt = startValue;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(startInt + fraction * (endValue - startInt));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，和我们想的一摸一样，下一个。</p><p>看看 ARGB 的估值器：</p><blockquote><p>android.animation.ArgbEvaluator#evaluate</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">evaluate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> startInt = (Integer) startValue;<br>    <span class="hljs-keyword">float</span> startA = ((startInt &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> startR = ((startInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> startG = ((startInt &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> startB = ( startInt        &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br>    <span class="hljs-keyword">int</span> endInt = (Integer) endValue;<br>    <span class="hljs-keyword">float</span> endA = ((endInt &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> endR = ((endInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> endG = ((endInt &gt;&gt;  <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br>    <span class="hljs-keyword">float</span> endB = ( endInt        &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br>    <span class="hljs-comment">// convert from sRGB to linear</span><br>    startR = (<span class="hljs-keyword">float</span>) Math.pow(startR, <span class="hljs-number">2.2</span>);<br>    startG = (<span class="hljs-keyword">float</span>) Math.pow(startG, <span class="hljs-number">2.2</span>);<br>    startB = (<span class="hljs-keyword">float</span>) Math.pow(startB, <span class="hljs-number">2.2</span>);<br><br>    endR = (<span class="hljs-keyword">float</span>) Math.pow(endR, <span class="hljs-number">2.2</span>);<br>    endG = (<span class="hljs-keyword">float</span>) Math.pow(endG, <span class="hljs-number">2.2</span>);<br>    endB = (<span class="hljs-keyword">float</span>) Math.pow(endB, <span class="hljs-number">2.2</span>);<br><br>    <span class="hljs-comment">// compute the interpolated color in linear space</span><br>    <span class="hljs-keyword">float</span> a = startA + fraction * (endA - startA);<br>    <span class="hljs-keyword">float</span> r = startR + fraction * (endR - startR);<br>    <span class="hljs-keyword">float</span> g = startG + fraction * (endG - startG);<br>    <span class="hljs-keyword">float</span> b = startB + fraction * (endB - startB);<br><br>    <span class="hljs-comment">// convert back to sRGB in the [0..255] range</span><br>    a = a * <span class="hljs-number">255.0f</span>;<br>    r = (<span class="hljs-keyword">float</span>) Math.pow(r, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br>    g = (<span class="hljs-keyword">float</span>) Math.pow(g, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br>    b = (<span class="hljs-keyword">float</span>) Math.pow(b, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br><br>    <span class="hljs-keyword">return</span> Math.round(a) &lt;&lt; <span class="hljs-number">24</span> | Math.round(r) &lt;&lt; <span class="hljs-number">16</span> | Math.round(g) &lt;&lt; <span class="hljs-number">8</span> | Math.round(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，看上去代码很多，但是我们这里取 R 来分析，G、B 是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 拿到起始颜色值的16-24位</span><br><span class="hljs-keyword">float</span> startR = ((startInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br><span class="hljs-comment">// 拿到终止颜色值的16-24位</span><br><span class="hljs-keyword">float</span> endR = ((endInt &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>) / <span class="hljs-number">255.0f</span>;<br><br><span class="hljs-comment">// 将起始颜色与终止颜色转化为线性的，便于用百分比计算</span><br>startR = (<span class="hljs-keyword">float</span>) Math.pow(startR, <span class="hljs-number">2.2</span>);<br>endR = (<span class="hljs-keyword">float</span>) Math.pow(endR, <span class="hljs-number">2.2</span>);<br><br><span class="hljs-comment">// 这里我们就很熟悉了，与 int 是一样的</span><br><span class="hljs-keyword">float</span> r = startR + fraction * (endR - startR);<br><br><span class="hljs-comment">// 再将线性的转回 RGB</span><br>r = (<span class="hljs-keyword">float</span>) Math.pow(r, <span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>) * <span class="hljs-number">255.0f</span>;<br></code></pre></td></tr></table></figure><p>这样一看，是不是条理很清晰。</p><p>总结一下：</p><ul><li>插值器负责计算动画执行的百分比</li><li>估值器起始就是根据动画的百分比、动画变化量（插值器计算得到的）来计算动画值，如果不能直接计算的，需要转换一下再计算。嗯，就这么多。</li></ul>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义LayoutManager</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/</url>
    
    <content type="html"><![CDATA[<p>在做了这么长时间的Android开发，还没有遇到过这个需求，不过看了别人的很多效果，感觉很棒，所以找了时间就研究了一下，现在做一些记录，等以后有了相关需要可以快速回顾。</p><p>在我学习的过程中，不可避免的遇到了很多问题，有的已经解决，有的还未解决，所以这个 Demo 就是看个乐呵吧。</p><p>自定义一个 LayoutManager 整体给我的感觉是与实现自定义 ViewGroup 的 onLayout 比较像。其他的测量绘制方法都不需要我们实现，测量方法还有很多可以直接使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.recyclerview.widget.RecyclerView.LayoutManager#measureChild<br>androidx.recyclerview.widget.RecyclerView.LayoutManager#measureChildWithMargins<br></code></pre></td></tr></table></figure><p>这两个方法可以测量 child 的大小，一个不计算 child.layoutParams，一个计算。</p><p>测量完成之后，我们就可以获取 child 的大小了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredWidth<br>androidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredHeight<br></code></pre></td></tr></table></figure><p>这里不直接使用 child.getMeasureWidth 显然是因为 RecyclerView 是有一个 ItemDecorate 可以设置，不设置就是获取的 getMeasureWidth 的值。</p><p>更完美的是，layout child 的时候，也有相应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.recyclerview.widget.RecyclerView.LayoutManager#layoutDecoratedWithMargins<br></code></pre></td></tr></table></figure><p>使用这个方法，我们就可以将 child 摆到我们想要摆放的位置了，我们只需要传递四大金刚的位置：l,t,r,b。网上看到一个效果就是，它计算出某个 path 的所有点，然后存起来，根据滚动的距离，来取相应的点，然后根据这个点以及child的大小，就可以将这个 child 摆到 path 的路径上，实现一个 item 跟随 path 的效果。只要想清楚了还是不难的。</p><p>了解这些，我们还需要了解一下 RecyclerView 的回收机制，因为 RecyclerView 最吊的地方就是回收复用，如果你搞了一个 LayoutManager 但是却无法回收复用，那岂不是很沙雕，关于回收这里就不仔细讲了，看[我的另一篇文章](<a href="https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-View/RecyclerView">https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-View/RecyclerView</a> 的缓存机制.md) 吧。</p><p>有了上面这些基础，我们就可以开始动手写了。</p><p>首先，我们需要确定我们想要的效果，我们先看一下这个效果图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/layoutmanager/Gif_20190805_140935.gif?raw=true"></p><p>可以看到：</p><ul><li>最左边，是有几个 item 堆在一起了的，那么是怎么实现的呢，其实就是 layout 的时候将 item 之间摆进一点就好了。比如：item 的宽度是 100，高度是 150，第一个item的位置为 【（0，0），（100， 150）】，第二个 item 的位置（假设 item 的 divider 宽度为 0）为 【（100, 0），（200, 150）】。但是我在摆第二个 item 的时候，我偏不从 100 开始摆，我从 20 开始摆，那么第二个 item 就叠在第一个 item 上面了。</li><li>右边的就简单了，按照通常的摆法就好了，不搞啥幺蛾子。</li></ul><p>对效果了然于胸，我们就可以开始敲代码了，首先自然是继承父类：</p><blockquote><p>androidx.recyclerview.widget.RecyclerView.LayoutManager#LayoutManager</p></blockquote><p>它只有一个抽象方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateDefaultLayoutParams</span><span class="hljs-params">()</span></span>: LayoutParams &#123;<br>    <span class="hljs-keyword">return</span> LayoutParams(<br>        LayoutParams.WRAP_CONTENT,<br>        LayoutParams.WRAP_CONTENT<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，网上一致都是这样实现的，我就很蛋疼了，都不说为什么。</p><p>然后，我就去查看了注释，它是这样说的：为 RecyclerView 的 child 生成一个默认的 LayoutParams。那么为何要生成一个默认的 LayoutParams 呢？比如，有的同学在 Adapter 里面加载布局的时候，parent 会传 null，这个时候 child 的就是没有 LayoutParams 的，所以需要生成一个。同样的，PopupWindow 也会遇到。这里我就清楚了，传递 WRAP_CONTENT 是一个保险行为，有最好，没有就使用这个。</p><p>注释还说了，这个返回的是 RecyclerView.LayoutParams，所以如果你还想带一些自带的信息在 LayoutParams 里面，你可以继承这个 LayoutParams，然后实现下面3个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.recyclerview.widget.RecyclerView.LayoutManager#checkLayoutParams<br>androidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.view.ViewGroup.LayoutParams)<br>androidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.content.Context, android.util.AttributeSet)<br></code></pre></td></tr></table></figure><p>就 OK 了。</p><p>搞定了唯一的一个抽象方法，我们就可以正常运行了，但是没啥效果，我们还需要实现  child 的摆放与回收。首先我们搞定 child 的摆放。child 的摆放是在 </p><blockquote><p>androidx.recyclerview.widget.RecyclerView.LayoutManager#onLayoutChildren </p></blockquote><p>这个方法里面。我们复写一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(recycler: <span class="hljs-type">Recycler</span>?, state: <span class="hljs-type">State</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onLayoutChildren(recycler, state)<br>&#125;<br></code></pre></td></tr></table></figure><p>好奇的点进去看看父类做了什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void onLayoutChildren(Recycler recycler, State state) &#123;<br>    Log.e(TAG, <span class="hljs-string">&quot;You must override onLayoutChildren(Recycler recycler, State state) &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，他要我们必须重写这个方法，但是又不是抽象的方法，嗯…有趣的女人…</p><p>一开始，我是完全不知道应该怎么搞了，所以我看了别人的 demo，发现他们都在最开头搞了这样的一个开头：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 这个方法看不出来有啥意义啊，应该是根据</span><br><span class="hljs-comment">// androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren</span><br><span class="hljs-comment">// copy 出来的</span><br><span class="hljs-keyword">if</span> (state?.itemCount == <span class="hljs-number">0</span>) &#123;<br>    recycler?.apply &#123;<br>        removeAndRecycleAllViews(<span class="hljs-keyword">this</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，我是很奇怪的，为啥要写这个玩意啊，后来我戳到 LinearLayoutManager 学习了一下，发现它有一个类似的代码，但是它是嵌套在 if 里面的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mPendingSavedState != <span class="hljs-keyword">null</span> || mPendingScrollPosition != RecyclerView.NO_POSITION) &#123;<br>    <span class="hljs-keyword">if</span> (state.getItemCount() == <span class="hljs-number">0</span>) &#123;<br>        removeAndRecycleAllViews(recycler);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我是真的没有搞懂哦。除非是 itemCount 突然变成 0 了，那么需要将所有 child 都移除并且放到 recycler 里面，但是为啥 LinearLayoutManager 是有条件的呢？？？嗯，猜一下与动画相关吧…</p><p>好的，我们继续往下，这里只不过是一个前置处理，处理某些特殊情况，下面我们开始摆放 child，为了方便我们写一个方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(recycler: <span class="hljs-type">Recycler</span>?, state: <span class="hljs-type">State</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onLayoutChildren(recycler, state)<br><br>    <span class="hljs-comment">// 这个方法看不出来有啥意义啊，应该是根据</span><br>    <span class="hljs-comment">// androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren</span><br>    <span class="hljs-comment">// copy 出来的</span><br>    <span class="hljs-keyword">if</span> (state?.itemCount == <span class="hljs-number">0</span>) &#123;<br>        recycler?.apply &#123;<br>            removeAndRecycleAllViews(<span class="hljs-keyword">this</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    layoutChildren(recycler, state)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看着会舒服一点，一般我不知道咋下手的时候，就会抽一个方法出来，把能写的都写了，至少思路清晰。</p><p>开始摆放 child，我们需要计算出第一个 item 的 left：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> left = paddingLeft<br></code></pre></td></tr></table></figure><p>嗯，很简单。</p><p>这个时候，就有一个问题浮现出来了，我们的每个 item 是一样大吗？？？</p><p>如果是的话，好说，但是 RecyclerView 就成了岳不群了。如果不是的话，那就复杂了。这里为了简单，我们要求 item 是一样的，毕竟，不一样大也没法堆叠。所以其实仔细想想，实现一个看起来特别酷的效果，限制也很多。</p><p>我们定义两个索引值，一个指向屏幕上的第一个 item，一个指向屏幕上的最后一个 item 的后一个位置，就像一个半开区间。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> firstVisiblePos = <span class="hljs-number">0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastVisiblePos = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>然后，我们随便取一个 item，测量一下它的大小：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 需要每个child一样大小</span><br><span class="hljs-keyword">val</span> firstView: View = recycler.getViewForPosition(firstVisiblePos)<br>measureChildWithMargins(firstView, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>unitDistance = getDecoratedMeasuredWidth(firstView) + gap<br><span class="hljs-comment">// 这个时候，还没有开始摆放，所以用完了再放回去，为了后面的逻辑统一处理</span><br>recycler.recycleView(firstView)<br></code></pre></td></tr></table></figure><p>这里的逻辑很简单，算出 child 的大小，加上 item 之间的距离，算作一个单元距离，就是一个item从一个位置移动到相邻位置的绝对距离。</p><p>这里要说的一个重要的点就是，如果我们需要摆一个 child，只能像 recycler 要，并且，用完了还给 recycler，这样我们神不知鬼不觉的就达成了复用的效果。</p><p>接着，我们根据滚动的距离来计算出第一个item的索引：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 根据 scroll 的距离来计算 firstPos 的位置</span><br>firstVisiblePos = floor(abs(scrollX).toDouble() / unitDistance).toInt()<br></code></pre></td></tr></table></figure><p>这里，我们也可以利用 RecyclerView 的宽度算出 lastVisiblePos 的值，但是就有点重复了，我们在摆放 child 的时候去动态的计算会更好一点，所以这里，我们将 lastVisiblePos 赋值为 itemCount。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 该值会动态更新</span><br>lastVisiblePos = state.itemCount<br></code></pre></td></tr></table></figure><p>计算好了两个索引值，我们还需要处理一个问题，就是根据滚动的距离来计算出 View 的偏移距离。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> frac: <span class="hljs-built_in">Float</span> = (abs(scrollX) % unitDistance) / (unitDistance * <span class="hljs-number">1f</span>)<br><span class="hljs-keyword">val</span> stackOffset = (frac * stackGap).toInt()<br><span class="hljs-keyword">val</span> viewOffset = (frac * unitDistance).toInt()<br></code></pre></td></tr></table></figure><p>unitDistance 是相邻item的单位距离，frac就表示移动到的百分比。利用这个百分比换算出堆叠区域和普通区域布局起始位置的偏移量，然后可以开始布局了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 属于堆叠区域</span><br><span class="hljs-keyword">if</span> (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123;<br>    <span class="hljs-comment">// 手指向左滑动，则 scrollX 的值会越来越大，frac 也会慢慢变大（0 -&gt; 1 为一个周期）</span><br>    <span class="hljs-comment">// item 会向右移动</span><br>    <span class="hljs-comment">// 这里需要减去，item 才会向左移动</span><br>    left -= stackOffset<br>&#125;<br></code></pre></td></tr></table></figure><p>这里又有几个问题：</p><ul><li>这个 layoutManager 一初始化就会堆叠起来，导致前面几个的内容看不到了， 解决办法就是做出一个无限循环的效果，这样就会对数目有所限制，至少是知道有多少数据，或者是做成动态的，一开始不会堆叠， 滑动的时候再考虑如何堆叠。</li><li>stackOffset 只需要减去一次，后面的 item 不用重复减去该值，这里我使用了笨办法，搞一个变量标识一下</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123;<br>    <span class="hljs-keyword">if</span> (!stackOffsetDone) &#123;<br>        left -= stackOffset<br>        stackOffsetDone = <span class="hljs-literal">true</span><br>    &#125;<br>    left += stackGap<br>&#125;<br></code></pre></td></tr></table></figure><p> 这个 left 就是 child 布局时用到的值了。对于非堆叠区域同样处理。</p><p>后面的代码就简单了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> view = recycler.getViewForPosition(i)<br>addView(view)<br>measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">val</span> l = left<br><span class="hljs-keyword">val</span> t = paddingTop<br><span class="hljs-keyword">val</span> r = l + getDecoratedMeasuredWidth(view)<br><span class="hljs-keyword">val</span> b = t + getDecoratedMeasuredHeight(view)<br>layoutDecoratedWithMargins(view, l, t, r, b)<br></code></pre></td></tr></table></figure><p>把上面的这些逻辑放入循环就搞定了。</p><p>这里效果基本就实现了，但是实际上测试的时候会发现，回收复用会有问题。这个有两个方面的问题：</p><ul><li>在 layout 的时候需要将所有 view 全部 detach 再重新布局</li><li>detach 的 view 被放入了 scrap 中，我们需要将 scrap 中残留的 item 全部放入 pool 中。</li></ul><p>所以，我们可以不用自己一个一个的手动回收，而是可以这样：</p><p>在 layout 的前面调用 detachAndScrapAttachedViews ，然后在最后回收。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">layoutChildren</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    recycler: <span class="hljs-type">Recycler</span>?,</span></span><br><span class="hljs-params"><span class="hljs-function">    state: <span class="hljs-type">State</span>?</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br><br>    <span class="hljs-keyword">if</span> (recycler == <span class="hljs-literal">null</span> || state == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    detachAndScrapAttachedViews(recycler)<br><br>    ...<br><br>    <span class="hljs-keyword">val</span> scrapList = recycler.scrapList<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> scrapList.indices) &#123;<br>        <span class="hljs-keyword">val</span> holder = scrapList[i]<br>        removeAndRecycleView(holder.itemView, recycler)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我测试的效果比之前好了很多，但是我还是不太满意，因为有的时候还是会出现 createViewHolder 的调用，虽然次数极少，但是肯定是哪里出了问题，不然是不会这样的。</p><p>所以建议还是手动的一个个标记回收。我也对回收这个问题还有疑问，所以这里就不说下去了。</p><p>除了回收还有一个问题，就是关于 fling 效果。我测试这个demo 的时候，发现我从最后一个一下滑动到第一个的时候，item停留的位置总是不对，我一直以为是我的计算有问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dx(dy) 表示本次较于上一次的偏移量，&lt;0为 向右(下) 滚动，&gt;0为向左(上) 滚动；</span><br><span class="hljs-comment"> * 这个算法还是无法满足 fling 的要求，fling 的时候 停留的位置不对</span><br><span class="hljs-comment"> * 查了一些资料，可能还需要自定义一个 SnapHelper -&gt; https://www.jianshu.com/p/0e4a93d8e2de</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(dx: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">val</span> consumed: <span class="hljs-built_in">Int</span><br>    <span class="hljs-comment">// dx &lt; 0 表示向右滚动，需要显示左边的内容</span><br>    <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 到了最左边</span><br>        <span class="hljs-keyword">if</span> (scrollX + dx &lt; <span class="hljs-number">0</span>) &#123;<br>            consumed = <span class="hljs-keyword">if</span> (scrollX &gt; <span class="hljs-number">0</span>) &#123;<br>                dx - scrollX<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-number">0</span><br>            &#125;<br>            scrollX = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">return</span> consumed<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// dx &gt; 0 表示向左滚动，右边的内容需要显示出来</span><br>    <span class="hljs-keyword">if</span> (dx &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (scrollX + dx &gt; maxScrollX) &#123;<br>            consumed = <span class="hljs-keyword">if</span> (scrollX &lt; maxScrollX) &#123;<br>                maxScrollX - scrollX<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-number">0</span><br>            &#125;<br>            scrollX = maxScrollX<br>            <span class="hljs-keyword">return</span> consumed<br>        &#125;<br>    &#125;<br><br>    scrollX += dx<br><br>    <span class="hljs-keyword">return</span> dx<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，经过我的打印，发现，这个计算是没有问题了。</p><p>顺便说一下，要想滑动，需要重写 LayoutManager 的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">canScrollHorizontally</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在 scrollHorizontallyBy 返回消耗的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">scrollHorizontallyBy</span><span class="hljs-params">(dx: <span class="hljs-type">Int</span>, recycler: <span class="hljs-type">Recycler</span>?, state: <span class="hljs-type">State</span>?)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (dx == <span class="hljs-number">0</span> || state?.itemCount == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    layoutChildren(recycler, state)<br><br>    <span class="hljs-keyword">return</span> consume(dx)<br>&#125;<br></code></pre></td></tr></table></figure><p>我就感觉这个与 NestedScrolling 接口很相似。</p><p>跑题了，关于 fling，查了一些资料，可能还需要自定义一个 SnapHelper -&gt; <a href="https://www.jianshu.com/p/0e4a93d8e2de%E3%80%82">https://www.jianshu.com/p/0e4a93d8e2de。</a></p><p>当然你也可以自己监控滑动状态，然后自动的调整滑动位置，就像画廊一样。</p><p>项目地址：</p><p><a href="https://github.com/aprz512/LayoutManagerDemo">https://github.com/aprz512/LayoutManagerDemo</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android进程与应用的生命周期</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%B1%89%E5%8C%96/Android%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%B1%89%E5%8C%96/Android%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>官方文档在<a href="https://developer.android.com/guide/components/activities/process-lifecycle">这里</a>。</p><p>本来，官方文档的部分内容已经汉化了，但是翻译实在是惨不忍睹，而且有些内容<strong>与原文还不一致</strong>，真不晓得是怎么回事。</p><p>大多数情况下，每个 Android 应用程序运行在自己的 Liunx 进程当中。在应用中的某些代码需要运行的时候，这个进程就会被创建出来，它会一直运行，直到该进程不再被需要了或者系统需要释放该进程占用的内存以便让别的应用运行。</p><p>Android 有一个特殊的基本特征：<strong>应用程序进程的生命周期不是由自己本身直接控制的</strong>。取而代之的，是由系统通过几个方面的综合考量来决定的：系统知道的正在运行的应用程序，这些应用程序对用户的重要性，系统可用的剩余内存。</p><p>开发者需要理解应用程序的不同组件（特别是 Activity，Service，BroadcastReceiver）对应用程序进程生命周期的影响。如果没有正确的使用这些组件，可能会导致你在执行某些很重要的任务时突然进程被系统给干掉了。</p><p>这里有一个例子，是关于进程生命周期的 bug 的。我们在使用 BroadcastReceiver 的时候，当它的 onReceive 方法被触发，我们会开启一个线程去执行任务，onReceive 方法会直接返回。一旦 onReceive 方法返回了，系统就会认为 BroadcastReceiver 不再处于活动状态，所以，它所在的进程也就不需要了（除非进程里面还有其他的组件处于活动状态）。然后系统可能在任何时候杀掉这个进程来回收内存，这样就会终止进程里面正在运行的线程。这个问题的解决方案是使用 JobService，使用了 JobSerive 之后，系统就会知道进程里面仍然有活要干。</p><p>为了确定在内存不足的时候应该干掉哪些进程，Android 会根据进程中运行的组件以及这个组件的状态来给每个进程分配一个级别（按重要性排序）：</p><ol><li><p><strong>前台进程</strong>：用户正在与之交互的进程。前台进程有多种产生的情况：</p><ul><li>有一个用户正在交互的处于屏幕最顶部的 Activity（onResume 执行过了）</li><li>有一个正在运行的广播（BroadcastReceiver.onReceive() 方法正在执行）</li><li>有一个正在执行回调方法代码（onCreate，onStart，onDestroy）的 Service</li></ul><p>系统中这样的进程非常少，只有当可用内存极少，而且这些进程都无法正常运行的时候，才会将它们杀掉。</p><p>文档还有一句话，我不是很理解：</p><blockquote><p> Generally, at this point, the device has reached a memory paging state, so this action is required in order to keep the user interface responsive.</p></blockquote><p><strong>内存分页我知道，内存分页状态是个啥？？？</strong></p></li><li><p><strong>可见进程</strong>：可见进程中运行的任务用户是可以注意到的，所以杀掉它会给用户体验产生明显的负面影响。满足下面的一些条件的是可见进程：</p><ul><li><p>Activity 可见但是不处于前台，比如：一个前台的 activity 以 dialog 的形式显示出来，那么在它后面的那个 activity 就是可见状态。</p></li><li><p>Service 调用了  <code>Service.startForeground()</code> 方法。这会让系统意识到该服务是会让用户注意到或者可见的。</p></li><li><blockquote><p>It is hosting a service that the system is using for a particular feature that the user is aware, such as a live wallpaper, input method service, etc.</p><p>这个我不太明白意思。</p></blockquote></li></ul><p>可见进程的数量比前台进程要多，但是也多不了多少，处于可管控的范围之内。这些进程是非常重要的，只有在前台进程无法正常运行的时候，才会杀掉它们。</p></li><li><p><strong>服务进程</strong>：一个Service通过 <code>startService()</code> 方法启动即为服务进程。尽管它们对用户不可见，但是它们通常都在后台做一些用户关系的事情（比如：上传与下载）。所以系统一般也不会杀掉它们，除非系统无法保证所有的前台与可见进程正常运行。</p><p>长时间运行的服务（超过30分钟）其优先级会降低（在下面所说的 LRU 表中会向后移动）。这有助于避免出现内存泄漏或其他问题的长时间运行的服务占用大量RAM而导致系统无法有效使用缓存进程的情形。</p></li><li><p><strong>缓存进程</strong>：缓存进程是指当前不需要的，当系统需要内存的时候是可以随意杀掉的进程。在一个正常运行的系统中，内存管理应该只会涉及到缓存进程：运行良好的系统将始终提供多个缓存进程（以便在应用程序之间进行更高效的切换），并根据需要定期终止最旧的进程。只有在非常极端（且不可取）的情况下，系统才会杀死所有缓存进程，而且必须开始终止服务进程。</p><p>这些进程通常保留了一个或者多个 Activity 的实例（onStop 方法被调用而且返回了），这些 Activity 对用户都不可见。如果开发者正确的实现了 Activity 的生命周期，当系统杀掉这些进程的时候，用户是感知不到的，而且当用户返回这个 App 的时候，也不会影响用户体验：因为系统保存了当前 Activity 的状态，会重新创建该 Activity。</p><p>这些进程保存在伪LRU列表中，列表中的最后一个进程是第一个被回收内存的进程。这个列表通常会将更有用的进程（桌面应用程序，用户最后一个使用的 app）放到其他进程的前面。杀掉进程可能还会有其他的策略（依赖于具体平台的实现）：对进程的数量进行限制，对进程可缓存的时间进行限制。</p><p>在决定如何对进程进行分类时，系统将根据进程中当前活动的所有组件中找到的最重要级别做出决策。具体查看  <code>Activity</code>, <code>Service</code>, and <code>BroadcastReceiver</code> 的文档。它们的文档都详细地描述了它们是如何影响应用程序的整个生命周期的。</p><p>当一个进程被其他进程依赖时，该进程的优先级可能会增加。例如，进程A使用Context.BIND_AUTO_CREATE标志绑定到Service，或者正在使用进程B中的ContentProvider，则进程B的重要级别将始终至少与进程A一样重要。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Android-汉化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>productFlavors与buildTypes</title>
    <link href="/2019/08/18/blog_bak/Blog/Gradle/productFlavors%E4%B8%8EbuildTypes/"/>
    <url>/2019/08/18/blog_bak/Blog/Gradle/productFlavors%E4%B8%8EbuildTypes/</url>
    
    <content type="html"><![CDATA[<blockquote><p>modify at 2019-8-26</p><p>节操社要祸祸“食戟之灵”了，我TM…口吐芬芳</p></blockquote><hr><blockquote><p>之所以会想到要写这个，是发现了很多以前没注意过的东西，记录一下。</p></blockquote><p>起因是由于一个紧急版本，然后我需要配置一下一个新增的H5地址，发现在配置的过程中非常的麻烦。</p><ol><li>config.gradle 中添加地址</li><li>app / build.gradle 添加 manifestPlaceholders ，为不同的 productFlavors 配置不同的地址</li><li>AndroidManifest.xml 中添加 meta-data</li><li>Java 中添加Key</li></ol><p>这是在是太麻烦了，很容易哪一步就忘记了。于是问了一下，为啥要写在 AndroidManifest.xml 里面？然后给出的答案是为了安全！</p><p>嗯，无稽之谈，于是我就收集了一些证据：</p><ul><li>将 debug，release，加固后的release包都拖到 AS 中，打开 AndroidManifest.xml，显然里面的每一根毛都看的清清楚楚</li><li>使用压缩文件解压apk包，用notepad++等工具打开，显示是二进制</li></ul><p>显然用文本编辑器打开，看不出什么，就是所谓的“安全”了。当是这种东西就相当于序列化一个 Java 对象，你看不出什么来，不代表别人看不出来，写一个工具就好了，里面的二进制数据都是有规则的，不然怎么读取里面的东西。</p><p>好了，有了这个作为前提，由于我们的包是加固的，所以放在 Java 里面比 AndroidManifest.xml 要安全很多，至少你要懂脱壳（这里不讨论别的了）。于是我就想将地址放在 BuildConfig 里面，减少配置的步骤，我使用一个单独的 gradle 文件配置一下，然后每个 variant 取相应的地址就好了。（虽然后来才发现，需要在base库里面生成才能有用，但是在学习的过程中还是很有收获的。）</p><p>比如，我在 urls.gradle 中这样写：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy">ext &#123;<br><br>    urls = [<br>            <span class="hljs-symbol">HOME:</span> [<br>                    <span class="hljs-attr">DEBUG_HOST    :</span> <span class="hljs-string">&quot;https://www.debug.com&quot;</span>,<br>                    <span class="hljs-symbol">RELEASE_HOST:</span> <span class="hljs-string">&quot;https://www.release.com&quot;</span>,<br>                    <span class="hljs-attr">PATHS       :</span> [<br>                            <span class="hljs-symbol">a:</span> <span class="hljs-string">&#x27;/1&#x27;</span>,<br>                            <span class="hljs-symbol">b:</span> <span class="hljs-string">&#x27;/2&#x27;</span>,<br>                            <span class="hljs-symbol">c:</span> <span class="hljs-string">&#x27;/3&#x27;</span>,<br>                            <span class="hljs-symbol">d:</span> <span class="hljs-string">&#x27;/4&#x27;</span><br>                    ]<br>            ]<br><br>    ]<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在BuildConfig里面生成这样的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_a = <span class="hljs-string">&quot;https://www.debug.com/1&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_b = <span class="hljs-string">&quot;https://www.debug.com/2&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_c = <span class="hljs-string">&quot;https://www.debug.com/3&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_d = <span class="hljs-string">&quot;https://www.debug.com/4&quot;</span>;<br></code></pre></td></tr></table></figure><p>当我将 Build Variant 切换为 release 的时候，BuildConfig 会变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_a = <span class="hljs-string">&quot;https://www.release.com/1&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_b = <span class="hljs-string">&quot;https://www.release.com/2&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_c = <span class="hljs-string">&quot;https://www.release.com/3&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOME_d = <span class="hljs-string">&quot;https://www.release.com/4&quot;</span>;<br></code></pre></td></tr></table></figure><p>那么，如何才能做到上面的效果呢？我们先从 build type 说起。</p><h2 id="BuildType"><a href="#BuildType" class="headerlink" title="BuildType"></a>BuildType</h2><p>首先，我们需要知道的是，当我们创建一个 module 的时候，AS 会自动的为我们创建 debug 与 release 这两个构建类型，不管我们写没写，就算你把它给删了，仍然会有。从源码里面没有找到对应的地方，可能是在插件的代码里面，不管这个，我们继续。</p><p>我们点击 release 进入源码，发现它是一个 <code>com.android.build.gradle.internal.dsl.BuildType</code> 对象。</p><p>里面会有很多我们熟悉的方法，比如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@NonNull</span><br><span class="hljs-keyword">public</span> BuildType proguardFiles(<span class="hljs-meta">@NonNull</span> Object... files) &#123;<br>    checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, <span class="hljs-string">&quot;proguardFiles&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Object <span class="hljs-attr">file :</span> files) &#123;<br>        proguardFile(file);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br><br></code></pre></td></tr></table></figure><p>这个货，就对应着我们配置的混淆文件。如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br></code></pre></td></tr></table></figure><p>由于上面的方法是一个可变参数作为参数，所以我们可以在 <code>proguardFiles</code>后面，添加多个 proguard 文件。</p><p>除了 proguardFiles，还有其他的很多属性可以配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">minifyEnabled <span class="hljs-literal">false</span><br>applicationIdSuffix <span class="hljs-string">&quot;.debug&quot;</span><br>debuggable <span class="hljs-literal">true</span><br>buildConfigField <span class="hljs-string">&quot;boolean&quot;</span>, <span class="hljs-string">&quot;DEBUG&quot;</span>, <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-comment">// release版的签名</span><br>signingConfig signingConfigs.app<br><br><span class="hljs-comment">// 还有一个 initWith 属性</span><br>initWith debug<br></code></pre></td></tr></table></figure><p>说一下这个 initWith 属性，比如上面我们指定了 debug，那么就是说将 debug 里面的所有属性都继承过来，算是一种复用。</p><p>再说 product flavors。</p><h2 id="Product-Flavors"><a href="#Product-Flavors" class="headerlink" title="Product Flavors"></a>Product Flavors</h2><p>build type，我们比较好理解，debug 用于开发，release 用于发布，一般这两个就够用了。那么 product flavors 又是什么鬼呢？可以这样想，幸平创真在创造一道新菜的时候，在创造的过程中，会慢慢的调配各种配料的比例，这中间烧的菜就是 debug，当创造完成之后可以端给客人吃了，烧的菜就是 release。但是经过观察后，幸平创真发现，不同的人口味不同，然后他就又为不同的人调配了不同口味的蘸料，这些不同口味的蘸料就是 product flavors。</p><p>我们看看配置代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy">productFlavors &#123;<br>    demo &#123;<br>        <span class="hljs-comment">// productFlavors 需要指定 dimension</span><br>        <span class="hljs-comment">// 如果你的 flavorDimensions 只有一个值，</span><br>        <span class="hljs-comment">// 那么可以不用指定，会自动赋值，但是一定要声明 flavorDimensions</span><br>        dimension <span class="hljs-string">&quot;version&quot;</span><br>        applicationIdSuffix <span class="hljs-string">&quot;.demo&quot;</span><br>        versionNameSuffix <span class="hljs-string">&quot;-demo&quot;</span><br>    &#125;<br>    full &#123;<br>        dimension <span class="hljs-string">&quot;version&quot;</span><br>        applicationIdSuffix <span class="hljs-string">&quot;.full&quot;</span><br>        versionNameSuffix <span class="hljs-string">&quot;-full&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置好了 product flavors 之后，你就可以打多个不同的包了，包的个数为 【build type 的个数】x 【product flavors  的个数】，相当于交叉的集合：</p><blockquote><ul><li><em>demoDebug</em></li><li><em>demoRelease</em></li><li><em>fullDebug</em></li><li><em>fullRelease</em></li></ul></blockquote><p>这个很好理解，拿煎饼举例：</p><blockquote><p>开发版鸡蛋煎饼</p><p>完成版鸡蛋煎饼</p><p>开发版培根煎饼</p><p>完成版培根煎饼</p></blockquote><p>下面再说说 <code>flavorDimensions</code> 的作用，不知道从哪个版本开始，<code>productFlavors</code> 需要配合 <code>flavorDimensions</code> 使用才行。一般的，没有特殊需求的话，<code>buildTypes</code>加上 <code>productFlavors</code> 已经完全够用了，<code>flavorDimensions</code> 是用于这样的需求的：</p><blockquote><p>还是拿煎饼举例，有的人喜欢鸡蛋煎饼，有的人喜欢培根煎饼，但是有的人都喜欢，那怎么办呢？总不能买两个吧，所以好的办法是做一个加鸡蛋和培根的煎饼。这个就是 flavorDimensions 的作用了。</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>  ...<br>  buildTypes &#123;<br>    debug &#123;...&#125;<br>    release &#123;...&#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Specifies the flavor dimensions you want to use. The order in which you</span><br>  <span class="hljs-comment">// list each dimension determines its priority, from highest to lowest,</span><br>  <span class="hljs-comment">// when Gradle merges variant sources and configurations. You must assign</span><br>  <span class="hljs-comment">// each product flavor you configure to one of the flavor dimensions.</span><br>  flavorDimensions <span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-string">&quot;mode&quot;</span><br><br>  productFlavors &#123;<br>    demo &#123;<br>      <span class="hljs-comment">// Assigns this product flavor to the &quot;mode&quot; flavor dimension.</span><br>      dimension <span class="hljs-string">&quot;mode&quot;</span><br>      ...<br>    &#125;<br><br>    full &#123;<br>      dimension <span class="hljs-string">&quot;mode&quot;</span><br>      ...<br>    &#125;<br><br>    <span class="hljs-comment">// Configurations in the &quot;api&quot; product flavors override those in &quot;mode&quot;</span><br>    <span class="hljs-comment">// flavors and the defaultConfig block. Gradle determines the priority</span><br>    <span class="hljs-comment">// between flavor dimensions based on the order in which they appear next</span><br>    <span class="hljs-comment">// to the flavorDimensions property above--the first dimension has a higher</span><br>    <span class="hljs-comment">// priority than the second, and so on.</span><br>    minApi24 &#123;<br>      dimension <span class="hljs-string">&quot;api&quot;</span><br>      minSdkVersion <span class="hljs-number">24</span><br>      <span class="hljs-comment">// To ensure the target device receives the version of the app with</span><br>      <span class="hljs-comment">// the highest compatible API level, assign version codes in increasing</span><br>      <span class="hljs-comment">// value with API level. To learn more about assigning version codes to</span><br>      <span class="hljs-comment">// support app updates and uploading to Google Play, read Multiple APK Support</span><br>      versionCode <span class="hljs-number">30000</span> + android.defaultConfig.versionCode<br>      versionNameSuffix <span class="hljs-string">&quot;-minApi24&quot;</span><br>      ...<br>    &#125;<br><br>    minApi23 &#123;<br>      dimension <span class="hljs-string">&quot;api&quot;</span><br>      minSdkVersion <span class="hljs-number">23</span><br>      versionCode <span class="hljs-number">20000</span>  + android.defaultConfig.versionCode<br>      versionNameSuffix <span class="hljs-string">&quot;-minApi23&quot;</span><br>      ...<br>    &#125;<br><br>    minApi21 &#123;<br>      dimension <span class="hljs-string">&quot;api&quot;</span><br>      minSdkVersion <span class="hljs-number">21</span><br>      versionCode <span class="hljs-number">10000</span>  + android.defaultConfig.versionCode<br>      versionNameSuffix <span class="hljs-string">&quot;-minApi21&quot;</span><br>      ...<br>    &#125;<br>  &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>这样我们就可以打更多的包了：</p><blockquote><p>Build variant: <code>[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]</code></p><p>Corresponding APK: <code>app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk</code></p></blockquote><p>flavorDimensions 有两个值，一个值有 3 个对应的 <code>productFlavor</code>，一个值有 2 个对应的 <code>productFlavor</code>。<code>buildTypes</code> 有 2 个 ，所以共有 3 x 2 x 2 = 12 个构建变体。</p><p>我们知道，<code>productFlavors</code> 相当于蘸料，作为一个蘸料，它肯定要与主食材配合，互相激发各自的味道才行，那么 <code>productFlavors</code>是如何影响打包内容的呢？我们介绍一下 sourceSet。</p><p>SourceSets中的属性，可以<strong>指定哪些文件夹下的源文件、资源要被编译，哪些源文件要被排除</strong>。</p><p>从我们的工程目录可以看出来，<code>com.android.application</code>插件默认就给我们定了3个 sourceSet：</p><ul><li>main</li><li>androidTest</li><li>test</li></ul><p>默认情况下，main里面的东西大概是这样的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">main &#123;<br>    manifest.srcFile <span class="hljs-string">&#x27;src/main/AndroidManifest.xml&#x27;</span><br>    java.srcDirs = [<span class="hljs-string">&#x27;src/main/java&#x27;</span>]<br>    res.srcDirs = [<span class="hljs-string">&#x27;src/main/res&#x27;</span>]<br>    assets.srcDirs = [<span class="hljs-string">&#x27;src/main/assets&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这都是我们熟悉的目录，既然 sourceSet 是可以配置的，就说明只要我们有需求，我们的 Java 文件就可以写到其他地方，而不是只能在 <code>src/main/java</code> 中。比如我们再添加一个 java 目录：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">main &#123;<br>    manifest.srcFile <span class="hljs-string">&#x27;src/main/AndroidManifest.xml&#x27;</span><br>    java.srcDirs = [<span class="hljs-string">&#x27;src/main/java&#x27;</span>, <span class="hljs-string">&#x27;src/main/java2&#x27;</span>]<br>    res.srcDirs = [<span class="hljs-string">&#x27;src/main/res&#x27;</span>]<br>    assets.srcDirs = [<span class="hljs-string">&#x27;src/main/assets&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就有了两个 java 目录，用于存放不同作用的文件集合。这个功能配合 <code>productFlavors</code> 管理不同作用版本的源代码就很方便了。比如，我出一个 free 版的应用，功能简单，代码都放在 java 里面，我再出一个 pro 版的，高级功能，代码放在 java2 里面，打包的时候将 java2 与 java 都打进去，就是一个完整版的。</p><p>我们的 src 是存放所有源代码与资源的目录，默认它有3个子目录，但是我们也可以添加自己的目录。比如：</p><ul><li>src/demoDebug/ 这个就是 <code>productFlavors</code> 为 demo，<code>buildTypes</code>为 debug 的构建变体的目录。</li><li>src/debug/ 这个是 <code>buildTypes</code>为 debug 的构建变体的目录。</li></ul><p>当我们构建的时候，会根据选择的构建类型来合并某些目录，比如构建 demoDemo，会合并 main + debug + debugDemo，合并的时候会有优先级的，构建变体越具体的优先级越高，demoDebug 就比 debug 要具体，所以 demoDebug  的优先级高，而 debug 又比 mian 高。资源会替换，但是 Java 类会报类重复的错。</p><p>当然 sourceSet 还有更多的用法，这里就不深入了。</p><p>还有一个很重要的知识需要补充，因为我最早是认为为不同 build type 产生不同的 BuildConfig 文件内容是不可行的，因为我们的 BuildConfig 需要在APP结构的最底层生成，这样才能被其他组件所引用到。而我是一直认为 library 工程只能打 release 包的，所以它只能生成  release 版的 BuilConfig 文件。直到我看到了官方文档的描述：</p><blockquote><p>Android plugin 3.0.0 and higher include a new dependency mechanism that automatically matches variants when consuming a library. </p></blockquote><p>也就是说从 3.0.0 的插件开始，就可以自动匹配了，而不是一直打 release 版的了，Nice~~~</p><p>另外说一句，如果 library 没有匹配的，可以使用 matchingFallbacks 指定备用匹配的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// In the app&#x27;s build.gradle file.</span><br>android &#123;<br>    buildTypes &#123;<br>        debug &#123;&#125;<br>        release &#123;&#125;<br>        staging &#123;<br>            <span class="hljs-comment">// Specifies a sorted list of fallback build types that the</span><br>            <span class="hljs-comment">// plugin should try to use when a dependency does not include a</span><br>            <span class="hljs-comment">// &quot;staging&quot; build type. You may specify as many fallbacks as you</span><br>            <span class="hljs-comment">// like, and the plugin selects the first build type that&#x27;s</span><br>            <span class="hljs-comment">// available in the dependency.</span><br>            matchingFallbacks = [<span class="hljs-string">&#x27;debug&#x27;</span>, <span class="hljs-string">&#x27;qa&#x27;</span>, <span class="hljs-string">&#x27;release&#x27;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们正式进入主题，实现我们所说的功能，有了上面的基础，我们缺的就只是 gradle api 的熟悉程度了，这个没什么办法，只能自己查资料了。</p><p>首先，根据官方文档的例子，我们知道，android 为我们提供了一个叫做 <code>variantFilter</code>的东西，就是一个过滤器，显然是用来过滤哪些我们不想打的包：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>  ...<br>  buildTypes &#123;...&#125;<br><br>  flavorDimensions <span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-string">&quot;mode&quot;</span><br>  productFlavors &#123;<br>    demo &#123;...&#125;<br>    full &#123;...&#125;<br>    minApi24 &#123;...&#125;<br>    minApi23 &#123;...&#125;<br>    minApi21 &#123;...&#125;<br>  &#125;<br><br>  variantFilter &#123; variant -&gt;<br>      <span class="hljs-keyword">def</span> names = variant.flavors*.name<br>      <span class="hljs-comment">// To check for a certain build type, use variant.buildType.name == &quot;&lt;buildType&gt;&quot;</span><br>      <span class="hljs-keyword">if</span> (names.contains(<span class="hljs-string">&quot;minApi21&quot;</span>) &amp;&amp; names.contains(<span class="hljs-string">&quot;demo&quot;</span>)) &#123;<br>          <span class="hljs-comment">// Gradle ignores any variants that satisfy the conditions above.</span><br>          setIgnore(<span class="hljs-literal">true</span>)<br>      &#125;<br>  &#125;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>嗯，不符合我们的要求，但是它给了我们一个提示，既然有过滤器，那么应该也有一个遍历所有构建变体的方法，我们在遍历的时候，去读取 urls.gradle 里面的 map，然后动态的添加进去不就好了吗！！</p><p>经过搜索之后，我就发现了这个东西：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">applicationVariants.all &#123;<br>    variant -&gt;<br>        <span class="hljs-keyword">def</span> buildType = getBuildType()<br>        rootProject.ext.urls.each &#123;<br>            entry -&gt;<br>                entry.value[<span class="hljs-string">&#x27;PATHS&#x27;</span>].each &#123;<br>                    path -&gt;<br>                        <span class="hljs-keyword">def</span> key = <span class="hljs-string">&quot;$&#123;entry.key&#125;_$&#123;path.key&#125;&quot;</span><br>                        <span class="hljs-keyword">def</span> value<br>                        <span class="hljs-keyword">if</span> (getFlavorName() == <span class="hljs-string">&#x27;full&#x27;</span> &amp;&amp; buildType.name == <span class="hljs-string">&#x27;release&#x27;</span>) &#123;<br>                            value = <span class="hljs-string">&quot;$&#123;entry.value[&#x27;PRODUCT_HOST&#x27;]&#125;$&#123;path.value&#125;&quot;</span><br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            value = <span class="hljs-string">&quot;$&#123;entry.value[&#x27;SIT_HOST&#x27;]&#125;$&#123;path.value&#125;&quot;</span><br>                        &#125;<br>                        variant.buildConfigField <span class="hljs-string">&quot;String&quot;</span>, key, <span class="hljs-string">&quot;\&quot;$&#123;value&#125;\&quot;&quot;</span><br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>applicationVariants 里面有所有需要打包的变体，我们遍历一下，既可以获取变体对象，然后动态的添加我们想要添加的 buildConfigField。</p><p>需要注意的是，我最开始以为 <code>com.android.build.gradle.api.BaseVariant#getBuildType</code>返回的是<code>com.android.build.gradle.internal.dsl.BuildType</code> ，但是没想到返回的是<code>com.android.builder.model.BuildType</code>，稍不注意就搞错了。</p><p><code>com.android.builder.model.BuildType</code>里面是无法添加 buildConfigField 的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture 的使用</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/CompletableFuture%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/CompletableFuture%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>遇到这样的一个实际问题：</p><p>写一个任务控制器，支持添加多个任务异步执行，任务间可以设置依赖，没有依赖的任务并行，有依赖的串行。</p><p>我刚开始一想，发现这个不是很简单么，写了包装类包装一下 Runnable，然后给它加一个添加依赖的功能不就好了么。后来发现没有我想的这么简单，首先循环依赖没有解决，这个问题这里就不深入了，就假设它没有循环依赖。</p><p>有了这个假设作为前提，我写出了第一版代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String) : Runnable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> dependencies = mutableListOf&lt;Task&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addDependency</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> task: <span class="hljs-type">Task</span>)</span></span> &#123;<br>        dependencies.addAll(task)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 让 dependencies 先运行</span><br>        dependencies.forEach &#123;<br>            it.run()<br>        &#125;<br><br>        <span class="hljs-comment">// 自己再运行</span><br>        doSome()<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSome</span><span class="hljs-params">()</span></span> &#123;<br>        println(name)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当我，发给另一个小伙伴看的时候，他就说了，这个没有处理并发的执行啊，我一想，果然是这样。这里都没有多线程，全是一个线程。</p><p>问题的关键就是在于，需要将循环的那部分代码变为多线程代码。</p><p>本来，我想的是使用一些别的方法来做，比如，搞几个 future，等他们全部拿到结果了，在执行 doSome 的逻辑，但是这样写就有点麻烦了。突然，我想起了看《Java并发实践》这本书的时候，有提到过一个叫做 CompletableFuture  的类，它可以控制多个 Future，用在之类正好啊。</p><p>先看一下说明：</p><p>future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p><ul><li>将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第<br> 一个的结果。</li><li>等待 Future 集合中的所有任务都完成。</li><li>仅等待 Future 集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同<br> 一个值），并返回它的结果。</li><li>通过编程方式完成一个 Future 任务的执行（即以手工设定异步操作结果的方式）。</li><li>应对 Future 的完成事件（即当 Future 的完成事件发生时会收到通知，并能使用 Future<br> 计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）</li></ul><p>新的 CompletableFuture 将使得这些成为可能。</p><p>来看一下，改版之后的代码吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.N)</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 让 dependencies 先运行</span><br>        <span class="hljs-keyword">val</span> cfs = dependencies.stream()<br>            .map &#123;<br>                CompletableFuture.runAsync(it)<br>            &#125;<br>            .collect(Collectors.toList())<br><br>        <span class="hljs-keyword">val</span> array = cfs.toTypedArray()<br>        CompletableFuture.allOf(*array).join()<br>        <span class="hljs-comment">// 自己再运行</span><br>        doSome()<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里就是不直接执行 it.run() 了，而是交给 CompletableFuture 里面的 pool 去执行，这样就是并发的了。</p><p>拿到所有结果之后，自己的代码才能执行，所以我们使用了 join 方法。</p><p>逻辑还是非常清晰的，对 Stream 不了解的就需要去学习一下了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 阻塞</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/IO%E9%98%BB%E5%A1%9E/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/IO%E9%98%BB%E5%A1%9E/</url>
    
    <content type="html"><![CDATA[<p>昨天在整理自己的博客的时候，想到的一个问题：进程在从磁盘中读取内容的时候，CPU 在干什么？？？</p><p>之所以会这样问，是因为，CPU的速度比磁盘要快很多，具体有多块，看<a href="https://zhuanlan.zhihu.com/p/24726196">这篇文章。</a></p><blockquote><p>磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。</p></blockquote><p>这是从文中截取的一段，可以体会一下。</p><p>那么我的问题的本质是，在这段等带的时间中，CPU 是去搞别的是事情了（执行别的线程），还是空等呢？？？IO 阻塞与线程遇到锁产生的阻塞是一样的吗？</p><p>经过查询资料，Linux系统下，CPU与磁盘交互时大致发生了如下事情：</p><ul><li><p>进程调用库函数向内核发起读文件请求（切换到内核态）；</p></li><li><p>在 Page Cache（它位于内存和文件之间缓冲区，文件IO操作实际上只和page cache交互，不直接和内存交互。） 中查询数据是否存在。</p></li><li><p>如果页缓存命中，那么直接返回文件内容；如果页缓存缺失，那么产生一个页缺失异常，需要从磁盘读取数据。</p></li><li><p>CPU向磁盘发送数据读取指令。</p></li><li><p>然后，发送完指令后，<strong>CPU会转去执行其它任务</strong>（为了提高效率），磁盘则会将逻辑块号转换成对应的盘片、磁道、扇区组成的三元组，从而定位到了数据所在的扇区。之后磁盘会采用DMA（直接存储器访问技术，其不需要CPU干预）传送数据到CPU指定的主存地址。 </p></li><li><p>最后，磁盘传送完毕后，会直接发送一个中断信号给CPU芯片的一个外部引脚，把CPU“召唤”回来重新执行先前未完成的任务。 </p></li></ul><p>上面的过程不一定准确，但是比较符合我的期望了，准备恶补一下计算机的相关原理。</p><p>所以，在 IO 阻塞的时间之内，CPU 也没有闲着（反过来想一下，如果CPU无法干别的事情的话，那么只要IO线程大于CPU线程，那么就卡死了）。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>其实这里面也有提到，我之前没有注意。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/base/20011044-cffc02c7b77b49dfaf42ed611c8b1cf8.png?raw=true"></p><p>线程的状态分为：</p><ol><li><p>可运行（就绪）：线程被创建之后，调用Start（）函数就到了这个状态。</p></li><li><p>运行：Start（）函数之后，CPU切换到了这个线程开始执行里面的Run方法就称为运行状态。</p></li><li><p>阻塞：阻塞状态是指线程因为某种原因放弃了cpu执行权，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 执行权 转到运行(running)状态。阻塞的情况分三种。</p></li></ol><ul><li><p>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</p></li><li><p>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</p></li><li><p>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p></li></ul><ol start="4"><li><p>结束</p><p>线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><h3 id="线程的个数"><a href="#线程的个数" class="headerlink" title="线程的个数"></a>线程的个数</h3><p>一般说来，大家认为线程池的大小经验值应该这样设置：（其中N为CPU的个数）</p><ul><li>如果是CPU密集型应用，则线程池大小设置为N+1</li><li>如果是IO密集型应用，则线程池大小设置为2N+1</li></ul><p>我们简单的思考一下，为什么会这样？？？</p><p>对于CPU密集型任务，尽量使用较小的线程池，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加<strong>上下文切换的次数，因此会带来额外的开销</strong>。</p><p>IO密集型任务<br>可以使用稍大的线程池，<strong>IO密集型任务CPU使用率并不高</strong>，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p><p>但是，其实最让我疑惑的是，为何要 +1？</p><p>然后我看到了这句话：</p><blockquote><p>即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。</p></blockquote><p>额，这里节省的时间能够补回来由于多了一个线程导致的线程切换的开销吗？？？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Final 关键字</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/Java%20Final%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/Java%20Final%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>final 关键字一般会多用于这样的几个地方：</p><ul><li><p>变量<br>当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。</p></li><li><p>防止被重写<br>比如：java.lang.String 类</p></li><li><p>内部类访问外部局部变量<br>这个我们经常使用，而且IDE也会提示你。但是你有没有想过Java为什么要设计成这样，这其中的秘密何在？</p><p>比如，我们有这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法没有意义</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>       <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">int</span> c = i + <span class="hljs-number">10</span>;<br>           &#125;<br>       &#125;).start();<br>   &#125;<br></code></pre></td></tr></table></figure><p>如果，我们没有给 i 声明 final 修饰符，IDE就会报一个错误（need to be final）。需要声明为 final 是因为，编译器编译的时候其实悄悄对函数做了手脚，偷偷把外部环境方法的局部变量 i，拷贝了一份到匿名内部类里。其实我们的代码经过编译之后变成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-comment">// copy 了一份</span><br>        <span class="hljs-keyword">int</span> copyI = i;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> c = i+<span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，这样就知道为啥需要声明为 final 了，因为内部拷贝了一份，而内部使用到了这个变量的值，如果在运行时外部的值改变了，那么内部的值却没有更新，就会出现各种问题，所以就干脆不让它改变。</p></li><li><p>以前在面试的时候，总是有很多面试官喜欢问：final、finally的区别！这特么就很蛋疼，这两货除了长的像，有啥是一样的。其实他们应该问 <strong>final 与 volatile 有啥区别？</strong>这个问题就比较阴险了，如果你不往并发上想的话，就会觉得这特么是什么脑残问题！！</p><p>说到这里，我们还是应该从 <strong>Java 的内存模型</strong>说起。</p></li></ul><h3 id="计算机内存模型"><a href="#计算机内存模型" class="headerlink" title="计算机内存模型"></a>计算机内存模型</h3><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，<strong>由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度，因此在CPU里面就有了高速缓存。</strong></p><p>也就是，<strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中</strong>，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">i = i + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>这个代码在单线程中运行是没有任何问题的，<strong>但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存</strong>（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的，下面以多核CPU为例）。</p><p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>最终结果i的值是1，而不是2。<strong>这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</strong></p><p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><ul><li>通过在总线加LOCK#锁的方式</li><li>通过缓存一致性协议</li></ul><p>这2种方式都是硬件层面上提供的方式。</p><p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>但是上面的方式会有一个问题，<strong>由于在锁住总线期间，其他CPU无法访问内存，导致效率低下</strong>。</p><p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：<strong>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</strong></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/base/cache_yizhixing.jpg?raw=true"></p><p>说完了内存模型，我们还要了解并发中的3个名词。</p><h3 id="3个名词"><a href="#3个名词" class="headerlink" title="3个名词"></a>3个名词</h3><ul><li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li></ul><p>这3个名词就不细说了，有兴趣的可以自己查查资料。</p><p>最后，我们来说，Java 的内存模型。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>在Java虚拟机规范中试图<strong>定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</strong>那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p><strong>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</strong></p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><p>了解了这些，我们再来看看 volatile 的作用。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ol><p>那么这两句话是什么意思呢？可见性比较好理解，就是一个线程更改了值，另外一个线程需要重新读取这个值。这里又有一个很有趣的问题，看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> inc = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>inc++;<br>&#125;<br></code></pre></td></tr></table></figure><p>当这个方法在多线程中运行的时候，会出现问题。我们来细细说到一下：</p><blockquote><p>假如某个时刻变量inc的值为10，</p></blockquote><blockquote><p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p></blockquote><blockquote><p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p></blockquote><blockquote><p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p></blockquote><blockquote><p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p></blockquote><p>这里可能就有人想不通了，线程 1 从阻塞变为运行状态后，应该还需要再次读取 inc 的值才对啊，为啥它没有读取呢？其实还是那个原因，我们写的是Java代码，而程序运行的是指令，我们将 inc++ 这行代码转成指令看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_1<br><span class="hljs-number">1</span>: istore_1<br><span class="hljs-number">2</span>: iinc <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那么，这3个指令是啥意思呢？我们再将这3个指令转为 Java 代码看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> tmp = inc; <span class="hljs-comment">// 0</span><br>tmp = tmp + <span class="hljs-number">1</span>; <span class="hljs-comment">// 1</span><br>inc = tmp; <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，现在明白了吧。再 inc++ 这个过程中，由于对 inc 的读取在阻塞前已经完成了，所以后面就不用再次读取了。</p><p>再说一个有趣的例子，我们有这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1</span><br><span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">while</span>(!stop)&#123;<br>    doSomething();<br>&#125;<br> <br><span class="hljs-comment">//线程2</span><br>stop = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？</p><p>答案是不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>也许你会很奇怪，就算是多线程，这段代码也不会出现问题啊，怎么可能会出现死循环，简直是无稽之谈！</p><p>实际上，从代码上来看，只要线程2后执行，那么就一定会终止线程。但是，我们需要知道我们写出来的代码不一定就是运行的代码（编译器还会做一些手脚的）。在某些情况下，编译器会直接将上面的代码优化成下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1</span><br><span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">// 这里编译器做了优化</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>    doSomething();<br>&#125;<br> <br><span class="hljs-comment">//线程2</span><br>stop = <span class="hljs-keyword">true</span>;<br></code></pre></td></tr></table></figure><p>可以看到，由于没有 volatile 关键字，编译器不知道它是多线程程序，所以就直接优化成了死循环。</p><p>下面，来到了我们想要说的重点，重排序。啥是重排序呢？<strong>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</strong></p><p>一般情况下，这个优化没啥问题，它不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程1:</span><br>context = loadContext();   <span class="hljs-comment">//语句1</span><br>inited = <span class="hljs-keyword">true</span>;             <span class="hljs-comment">//语句2</span><br> <br><span class="hljs-comment">//线程2:</span><br><span class="hljs-keyword">while</span>(!inited )&#123;<br>  sleep()<br>&#125;<br>doSomethingwithconfig(context);<br></code></pre></td></tr></table></figure><p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>如果，我们给 inited 添加 volatile 关键字，那么就不会发生指令重排序，程序也就不会出错。</p><p>说完了 volatile 对重排序的影响，下面我们说说 final，它对重排序也有一点的影响。</p><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><blockquote><p>在构造函数内对一个 final 域的写，与随后把这个构造对象的引用赋值给一个变量，这两个操作之间不能重排序</p><p>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序</p></blockquote><p>举个例子（摘自《Java并发编程实践》）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Holder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-keyword">this</span>.n = n; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertSanity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n != n)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设这里有一个线程A执行了下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Holder holder = <span class="hljs-keyword">new</span> Holder(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>同时有另一个线程B也在执行下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (holder != <span class="hljs-keyword">null</span>) holder.assertSanity();<br></code></pre></td></tr></table></figure><p>那么在某些情况下就会抛出上面的异常，原因就是：<br><strong>Holder holder = new Holder(10);其实是由三步组成的</strong></p><ol><li>给holder分配内存</li><li>调用构造函数</li><li>将holder指向刚分配的内存</li></ol><p>理想中是这个执行顺序，然而事实上这三步并不一定按照这个顺序执行，是为了优化效率而存在的指令重排在作怪，假如一个执行顺序为1 3 2，那么在刚执行完1和3的时候线程切换到B，这时候holder由于指向了内存所以不为空并调用assertSanity函数，该函数中的if语句并不是一步完成：</p><ol><li>取左表达式n的值</li><li>取右表达式n的值</li><li>进行！=表达式运算</li></ol><p>那么假设刚执行完第一步的时候B线程挂起并重新回到A线程，A线程继续执行构造函数并将n赋值为10，然后再次跳回B线程，这时候执行第2步，那么就会造成前后取到的n不一样，从而抛出异常。</p><p>那么加了final修饰之后会如何呢，JVM做了如下保证：一旦对象引用对其他线程可见，则其final成员也必须正确的赋值了。就是说一旦你得到了引用，<strong>final域的值(即n)都是完成了初始化的</strong>，因此不会再抛出上面的异常。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中点圆算法</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>当我们在手机屏幕上绘制一个圆的时候，有没有想过这个圆是怎么绘制出来的呢？由于屏幕的像素是一粒一粒的，所以不像我们在一张纸上，可以利用 sin/cos 函数计算出来。</p><p>看一张图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95/Bresenham_circle.png?raw=true"></p><p>将手机屏幕放大了看，你就会看到上图所示的情景，那么这些像素点的位置是如何计算出来的呢？其实就是使用了中点圆算法。</p><p><strong>在计算机图形学中，中点圆算法是一种用于确定绘制一个圆所需的像素点的算法。</strong></p><h3 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h3><p>该算法的目标是找到一个通过使用像素网格的使得每个像素点尽可能接近 $x^2 + y^2 = R^2$ 的路径。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>由于圆具有对称性，所以我们只要考虑1/8个圆即可，我们选择y轴正方向到延其顺时针旋转45°的这个区间为例。就是上图中的 <code>2nd octant</code> 区域。</p><p>我们先假设要画的圆的圆心在坐标原点，最后再平移到其应该存在的位置。</p><p>设要画的圆的圆心在原点**(0，0)<strong>，半径为</strong>R<strong>，起点在</strong>(0，R)**处，终点在 $(\frac{R}{\sqrt2}, \frac{R}{\sqrt2})$ 处，顺时针生成八分之一圆，利用对称性画出全部的圆。</p><p>为了应用中点画圆法，我们还需要定义一个检测函数：<br>$$<br>F(x, y) = x^2 + y^2 - R^2<br>$$<br>任何点 (x，y) 的相对位置可由圆函数的符号来检测：</p><ul><li>&lt;0　点(x，y)位于数学圆内</li><li>=0　点(x，y)位于数学圆上</li><li>&gt;0　点(x，y)位于数学圆外</li></ul><h3 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h3><p>如下图所示，图中有两条圆弧A和B，假定当前取点为$P_i(x_i, y_i)$，如果顺时针生成圆，那么下一点只能取正右方的点 $E(x_i, y_i)$ 或者右下方的 $SE(x_i+1, y_i-1)$。 </p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95/midpoint_cicle.png?raw=true" alt="图1"></p><p>假设M是E和SE的中点，即，则：</p><ol><li>对圆A来说，<code>F(M)&lt;0</code>，M在圆A内，这说明点E距离圆更近，应取点E作为下一象素点；</li><li>对圆B来说，当<code>F(M)&gt;0</code>，M在圆B外，表明SE点离圆更近，应取SE点为下一象素点；</li><li>而当<code>F(M)=0</code>时，在E点与SE点之中随便取一个即可，我们约定取SE点。</li></ol><h3 id="算法推导"><a href="#算法推导" class="headerlink" title="算法推导"></a>算法推导</h3><p>我们将中点M代入检测函数可以得到一个值，用 $d_i$表示，它就是该点的决策变量。</p><p>然后我们再用它来推导出下一个中点决策变量 $d_{i+1}$ 。</p><p>$$ d_i = F(x_i+1， y_i-\frac{1}{2}) = (x_i+1)^2 + (y_i - \frac{1}{2})^2 - R^2 $$</p><p>下面分两种情况来讨论在迭代计算中决策变量  $d_{i+1}$ 的推导。</p><p>看上面的算法演示图：</p><ul><li><p>如果 $d_i &lt; 0$，则选择E点，接着下一个中点就是 $M_E(x_i+2,y_i-\frac{1}{2})$，这时新的决策变量为：</p><p>$$ d_{i+1} = F(x_i+2， y_i-\frac{1}{2}) = (x_i+2)^2 + (y_i - \frac{1}{2})^2 - R^2 $$</p><p>用 $d_{i+1}$ - $d_i$，可以得到： </p><p>$$ d_{i+1} = d_i  + 2x_i   + 3$$</p></li><li><p>如果 $d_i &gt; 0$ ，则选择 SE 点，接着下一个中点就是$M_{SE}(x_i+2,y_i-\frac{3}{2})$，这时新的决策变量为：</p><p>$$d_{i+1} = F(x_i+2, y_i-\frac{3}{2}) = (x_i+2)^2 + (y_i-\frac{3}{2})^2 - R^2$$</p><p>用 $d_{i+1}$ - $d_i$，可以得到： </p><p>$$d_{i+1} = d_i  + 2(x_i-y_i)   + 5$$</p></li></ul><p>我们利用递推迭代计算这八分之一圆弧上的每个点，每次迭代需要两步处理：</p><p>（1）用前一次迭代算出的决策变量的正负来决定本次选择的点</p><p>（2）对本次选择的点，递推计算得出新的决策变量的值</p><p>接下来只要计算出初始决策变量$d_0$的值即可，对于初始坐标$(0,R)$，显然顺时针生成的下一个决策点坐标是$(1, R-\frac{1}{2})$，此时决策变量 $d_0$为：$d_0 = (1)^2 + (R-\frac{1}{2})^2 - R^2 = \frac{5}{4} - R$ 。显然，如果半径大于 $\frac{5}{4}$，则我们应该取 E 点，否则取 SE 点。</p><p>就这样不断的递推下去，就可以得到八分之一圆弧的所有点。</p><h3 id="算法表示"><a href="#算法表示" class="headerlink" title="算法表示"></a>算法表示</h3><p>输入：圆半径$R$、圆心$(x_0，y_0)$，</p><p>确定初值：$x=0$，$y=R$，$d=\frac{5}{4}$，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(x &lt;= y)&#123;<br>    <span class="hljs-keyword">if</span>(d &gt;= <span class="hljs-number">0</span>)&#123;<br>        x = x + <span class="hljs-number">1</span>;<br>        y = y - <span class="hljs-number">1</span>;<br>        d = d + <span class="hljs-number">2</span> * (x - y) + <span class="hljs-number">5</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        x = x + <span class="hljs-number">1</span>;<br>        d = d + <span class="hljs-number">2</span> * x + <span class="hljs-number">3</span>;<br>    &#125;<br>    println(<span class="hljs-string">&quot;(&quot;</span> + x + <span class="hljs-string">&quot;, &quot;</span> + y + <span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让 CPU 告诉你硬盘和网络到底有多慢</title>
    <link href="/2019/08/18/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E8%AE%A9%20CPU%20%E5%91%8A%E8%AF%89%E4%BD%A0%E7%A1%AC%E7%9B%98%E5%92%8C%E7%BD%91%E7%BB%9C%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2/"/>
    <url>/2019/08/18/blog_bak/Blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E8%AE%A9%20CPU%20%E5%91%8A%E8%AF%89%E4%BD%A0%E7%A1%AC%E7%9B%98%E5%92%8C%E7%BD%91%E7%BB%9C%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2/</url>
    
    <content type="html"><![CDATA[<p>经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。</p><p>最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。</p><p>希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。</p><p>注：所有的数据都是来自<a href="https://link.zhihu.com/?target=https://gist.github.com/hellerbarde/2843375">这个地址</a>。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，<a href="https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html">这个网址</a>给出了不同年份一些指标的数值。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 2.6*10^9个指令，每个指令只需要 0.38ns（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 1s，因为 1s 大概是人类能感知的最小时间单位。</p></li><li><p>一级缓存读取时间为 0.5ns，换算成人类时间大约是 1.3s，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。</p></li><li><p>分支预测错误需要耗时 5ns，换算成人类时间大约是 13s，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如<a href="https://link.zhihu.com/?target=http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">这个得分非常高的 stackoverflow 问题</a>。</p></li><li><p>二级缓存时间就比较久了，大约在 7ns，换算成人类时间大约是 18.2s，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。</p></li></ul><p><strong>小知识：</strong>为什么需要多层的 CPU 缓存呢？<a href="https://link.zhihu.com/?target=https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/">这篇文章通过一个通俗易懂的例子给出了讲解</a>。</p><ul><li>我们继续，互斥锁的加锁和解锁时间需要 25ns，换算成人类时间大约是 65s，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。</li><li>然后就到了内存，每次内存寻址需要 100ns，换算成人类时间是 260s，也就是4分多钟，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。到了内存之后，时间就变得一个量级，CPU 和内存之间的速度瓶颈被称为<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Von_Neumann_architecture%23Von_Neumann_bottleneck">冯诺依曼瓶颈</a>。</li><li>一次 CPU 上下文切换（系统调用）需要大约 1500ns，也就是 1.5us（这个数字参考了<a href="https://link.zhihu.com/?target=http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">这篇文章</a>，采用的是单核 CPU 线程平均时间），换算成人类时间大约是65分钟，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，<strong>这段时间里 CPU 没有做任何有用的计算</strong>，只是切换了两个不同进程的寄存器和内存状态；而且这个过程<strong>还破坏了缓存，</strong>让后续的计算更加耗时。</li><li>在 1Gbps 的网络上传输 2K 的数据需要 20us，换算成人类时间是 14.4小时，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。</li><li>SSD 随机读取耗时为 150us，换算成人类时间大约是 4.5天。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。I/O 设备 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 memcached 和 redis 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。</li><li>从内存中读取 1MB 的连续数据，耗时大约为 250us，换算成人类时间是 7.5天，这次假期升级到国庆七天国外游了。</li><li>同一个数据中心网络上跑一个来回需要 0.5ms，换算成人类时间大约是 15天，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。</li><li>从 SSD 读取 1MB 的顺序数据，大约需要 1ms，换算成人类时间是 1个月。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，<strong>SSD</strong> 已经很快啦，不信你看下面机械磁盘的表现。</li><li>磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 RPM(Revolutions Per Minute/每分钟转速) 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。</li><li>从磁盘读取 1MB 连续数据需要 20ms，换算成人类时间是 20个月。<strong>IO 设备是计算机系统的瓶颈</strong>，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。</li><li>而从世界上不同城市网络上走一个来回，平均需要 150ms（参考<a href="https://link.zhihu.com/?target=https://wondernetwork.com/pings/">世界各地 ping 报文的时间</a>），换算成人类时间是 12.5年。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Content_delivery_network">CDN</a> 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。</li><li>虚拟机重启一次大约要 4s 时间，换算成人类的时间是 3百多年。对于此，我想到了乔布斯要死命<a href="https://link.zhihu.com/?target=http://stevejobsdailyquote.com/2014/03/26/boot-time/">优化 Mac 系统开机启动时间</a>的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。</li><li>物理服务器重启一次需要 5min，换算成人类时间是 2万5千年，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（四）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>本篇主要分析 RxJava2 中的线程池与线程调度时的源码流程。</p><p>顺便介绍RxJava2中常用的几个线程池。</p><p>上一篇文章，我们的demo中，指定线程时，使用的是 Schedulers 这个类。那我们直接从这个类入手。</p><blockquote><p>Schedulers.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Static factory methods for returning standard Scheduler instances.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schedulers</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>一般看一个类的时候，先看注释会让你对这个类又一个全局的概念，它起一个什么作用。</p><p>上面的注释说的比较清楚了，它是一个工厂方法，返回一些 Scheduler 对象的实例。</p><p>那么下面我们看看 Scheduler 类。</p><blockquote><p>Scheduler.java</p><p>这个类提供了API，用来调度工作单元。你可以指定延迟时间，周期性。</p><p>我们可以想到很多别的东西，Timer，Executors.newScheduledThreadPool(2)等等</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这个类的代码不多，我们打开 Structure 视图，可以看到该类的一个结构，这里展示一下 Scheduler 最核心的定义部分：</p><blockquote><p>Scheduler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Worker <span class="hljs-title">createWorker</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run)</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">long</span> delay, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodicallyDirect</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span> </span>&#123;<br>      <br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run)</span> </span>&#123;<br>            ...<br>        &#125;<br><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">long</span> delay, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span></span>;<br><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodically</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> TimeUnit unit)</span> </span>&#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的定义可以看出，Scheduler 本质上就是用来调度 Runnable 的，支持<strong>立即、延时和周期形式的调用</strong>。</p><p>我们从其中一个方法入手，就选择最简单的 <code>public Disposable scheduleDirect(@NonNull Runnable run) &#123;...&#125;</code> 方法。分析完这个方法之后，在看其他的方法，应该就是差不多的了。</p><blockquote><p>Scheduler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> scheduleDirect(run, <span class="hljs-number">0L</span>, TimeUnit.NANOSECONDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面说过，Scheduler 支持延迟调用，那么这里传递0，就表示不延迟。</p><blockquote><p>Scheduler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">long</span> delay, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-comment">// ① 创建了一个 Worker</span><br>    <span class="hljs-keyword">final</span> Worker w = createWorker();<br><br>    <span class="hljs-comment">// 装饰一下，但是通常会将 run 原封不动的返回</span><br>    <span class="hljs-keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);<br><br>    <span class="hljs-comment">// ② 创建 Task</span><br>    DisposeTask task = <span class="hljs-keyword">new</span> DisposeTask(decoratedRun, w);<br><br>    <span class="hljs-comment">// ③ 执行 task</span><br>    w.schedule(task, delay, unit);<br><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，我加了一点注释，下面来一行一行的分析。</p><blockquote><p>io.reactivex.Scheduler#scheduleDirect(java.lang.Runnable, long, java.util.concurrent.TimeUnit)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Worker w = createWorker();<br></code></pre></td></tr></table></figure><p>由于，Scheduler 是一个抽象类，所以只有它的子类才知道具体的实现，这里我们用 Schedulers.io 为例。</p><p>由于篇幅问题，如果这里深入的话，会很容易丢失目标，所以我将 IoScheduler 这个类的分析提出来了，放到了[另外一篇文章](<a href="https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2">https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-源码解析/RxJava2/RxJava2</a> 源码分析（2.5）.md)中。</p><p>看完这篇文章之后，就知道 Worker 有点像命令，它里面指定了任务需要执行的线程池（因为Worker是Scheduler的子类创建的，Scheduler的子类创建了自己的线程池），当我们调用 <code>work.schedule</code> 的时候，就会将任务交给work中指定的线程池去执行。</p><p>这样一来，①处与③处的代码都说清楚了。现在还剩②处的代码。看看 DisposeTask 这个类吧。</p><h4 id="DisposeTask"><a href="#DisposeTask" class="headerlink" title="DisposeTask"></a>DisposeTask</h4><blockquote><p>DisposeTask</p><p>看它的构造方法与类结构，可以大概猜到它可能会起一个代理委托的作用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DisposeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Disposable</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Runnable decoratedRun;<br>    <span class="hljs-keyword">final</span> Worker w;<br><br>    Thread runner;<br><br>    DisposeTask(Runnable decoratedRun, Worker w) &#123;<br>        <span class="hljs-keyword">this</span>.decoratedRun = decoratedRun;<br>        <span class="hljs-keyword">this</span>.w = w;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        runner = Thread.currentThread();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 运行 task 中的代码</span><br>            decoratedRun.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 执行完之后，调用 dispose </span><br>            dispose();<br>            runner = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (runner == Thread.currentThread() &amp;&amp; w <span class="hljs-keyword">instanceof</span> NewThreadWorker) &#123;<br>            <span class="hljs-comment">// 如果 worker 是 NewThreadWorker，则关闭自己 </span><br>            ((NewThreadWorker)w).shutdown();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 调用 worker 的 dispose</span><br>            <span class="hljs-comment">// 之前我们分析过 IoScheduler.EventLoopWorker 类</span><br>            <span class="hljs-comment">// 它的 dispose 会将自己重新放到线程池中，重复利用</span><br>            w.dispose();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDisposed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> w.isDisposed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以这个类的主要作用是起到一个让 worker 重复利用的作用，但是这只是针对 IoScheduler 的 Worker 来说，别的 Worker 可能会不一样。</p><p>因为它调用了 Worker 的 dispose 方法，所以 Worker 的收尾工作可以全部放到这个方法中。</p><p>Scheduler类的重要方法都分析完了，其他的方法，就交给你们了。看完了这几篇文章，你应该具有了能够看懂其他 Scheduler 的能力，GOOD LUCK !!!</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://juejin.im/post/5b75207ce51d45565d23e093">https://juejin.im/post/5b75207ce51d45565d23e093</a></p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（二）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>这篇文章的主要目的就是弄清楚链式调用与线程切换。</p><p>如果你读懂了第一篇文章，这篇文章阅读起来还是非常简单的。因为链式调用和线程切换无非就是多了些 “数据源-观察者” 对。</p><p>线程切换还涉及到线程池相关的东西，由于篇幅问题，线程池相关的东西会放到下一篇。</p><h3 id="从一个例子开始："><a href="#从一个例子开始：" class="headerlink" title="从一个例子开始："></a>从一个例子开始：</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-comment">// 观察者 -- 蝙蝠侠</span><br>    <span class="hljs-keyword">val</span> observerBatMan = <span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().name + <span class="hljs-string">&quot;--observer&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">// 数据源 -- 小丑</span><br>    <span class="hljs-keyword">val</span> sourceClown = ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>        it.onNext(<span class="hljs-number">1</span>)<br>        it.onComplete()<br>        System.<span class="hljs-keyword">out</span>.println(Thread.currentThread().name + <span class="hljs-string">&quot;--source&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 开始观察</span><br>    Observable<br>            <span class="hljs-comment">// ①</span><br>            .create&lt;<span class="hljs-built_in">Int</span>&gt;(sourceClown)<br>            <span class="hljs-comment">// ② 指定数据源执行的线程</span><br>            .subscribeOn(Schedulers.computation())<br>            <span class="hljs-comment">// ③ 指定观察者执行的线程</span><br>            .observeOn(Schedulers.io())<br>            <span class="hljs-comment">// ④</span><br>            .subscribe(observerBatMan)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，和上一篇文章的例子差不多，就多了几行线程切换而已，我们先给出数据的日志。有一个大致的印象，再来深入分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shel">RxComputationThreadPool-1--source<br>RxCachedThreadScheduler-1--observer<br></code></pre></td></tr></table></figure><h3 id="demo-里面的-②-处"><a href="#demo-里面的-②-处" class="headerlink" title="demo 里面的 ② 处"></a>demo 里面的 ② 处</h3><p>有了第一篇的基础，那么我们直接从 <strong>demo 里面的 ② 处</strong>入手：</p><blockquote><p> Observable.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">&quot;scheduler is null&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));<br>&#125;<br></code></pre></td></tr></table></figure><p>你使用了套路一，效果拔群，得到结果如下：</p><blockquote><p>Observable.java</p><p>简化之后的 subscribeOn 代码，实际上就是创建并返回了一个 ObservableSubscribeOn 对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续看 ObservableSubscribeOn。</p><blockquote><p>ObservableSubscribeOn.java</p><p>AbstractObservableWithUpstream.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ObservableSubscribeOn 继承了 AbstractObservableWithUpstream</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableSubscribeOn</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractObservableWithUpstream</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; </span>&#123;...&#125;<br><br><span class="hljs-comment">// AbstractObservableWithUpstream 继承了 Observable</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractObservableWithUpstream</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">U</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">HasUpstreamObservableSource</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>所以，ObservableSubscribeOn 最终还是继承至 Observable的。</p><p>在第一篇文章中，我们分析的对象是 ObservableCreate，而现在我们分析的对象是 ObservableSubscribeOn。为了能够更加清晰的列出不同点，还是搞一个表格吧：</p><table><thead><tr><th></th><th>ObservableSubscribeOn</th><th>ObservableCreate</th></tr></thead><tbody><tr><td>直接父类</td><td>AbstractObservableWithUpstream（最终还是继承 Observable）</td><td>Observable</td></tr><tr><td>构造方法参数个数</td><td>两个：(ObservableSource&lt;T&gt; source, Scheduler scheduler)</td><td>一个：(ObservableOnSubscribe&lt;T&gt; source)</td></tr></tbody></table><p>主要的不同点，还是在构造参数这里。</p><ol><li>参数个数不同，这个好理解，因为需要切换线程，肯定需要指定切换到哪个线程，所以多一个参数</li><li>source 类类型不同，这个需要深入分析，往下看</li></ol><p>看看 source 类有哪些不同之处：</p><blockquote><p>ObservableOnSubscribe.java</p><p>ObservableSource.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObservableOnSubscribe</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ObservableEmitter&lt;T&gt; e)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObservableSource</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个类都是接口，都只有一个 subscribe 方法，看起来比较类似。</p><p>除了类名不同之外，就只有<strong>方法的参数不同</strong>了。</p><p>ObservableOnSubscribe 接收的参数 ObservableEmitter，上一篇文章说过，是将 Observer 包装了一层。</p><p>ObservableSource 直接接收了 Observer，嗯，很牛逼，后面我们来分析看看，它为啥不要包装，你也可以思考一下，嘿嘿嘿。</p><p>经过上面的分析，总的来说，区别不大，所以我们仍然可以套第一篇的套路来分析。</p><p>到这里先上个图，为后面做好心理准备。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_21.png?raw=true"></p><h3 id="demo-里面的-③-处"><a href="#demo-里面的-③-处" class="headerlink" title="demo 里面的 ③ 处"></a>demo 里面的 ③ 处</h3><p>接下来，<strong>我们看 demo 里面的 ③ 处</strong>：</p><blockquote><p>Observable.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> observeOn(scheduler, <span class="hljs-keyword">false</span>, bufferSize());<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了同名方法：</p><blockquote><p>Observable.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler, <span class="hljs-keyword">boolean</span> delayError, <span class="hljs-keyword">int</span> bufferSize)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">&quot;scheduler is null&quot;</span>);<br>    ObjectHelper.verifyPositive(bufferSize, <span class="hljs-string">&quot;bufferSize&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler, delayError, bufferSize));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用套路一，简化代码：</p><blockquote><p>Observable.java</p><p>observeOn 简化后的代码</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(<span class="hljs-built_in">Scheduler</span> scheduler, <span class="hljs-keyword">boolean</span> delayError, <span class="hljs-keyword">int</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler, delayError, bufferSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，实际上就是创建了一个 ObservableObserveOn 对象。</p><p>看看这个对象吧，不出意外，和 ObservableOnSubscribe 应该很像。</p><p>先看类的结构：</p><blockquote><p>ObservableObserveOn.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableObserveOn</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractObservableWithUpstream</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>与 ObservableOnSubscribe 一样，继承同一个类。</p><p>再看类的构造方法：</p><blockquote><p>ObservableObserveOn.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObservableObserveOn</span><span class="hljs-params">(ObservableSource&lt;T&gt; source, Scheduler scheduler, <span class="hljs-keyword">boolean</span> delayError, <span class="hljs-keyword">int</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(source);<br>    <span class="hljs-keyword">this</span>.scheduler = scheduler;<br>    <span class="hljs-keyword">this</span>.delayError = delayError;<br>    <span class="hljs-keyword">this</span>.bufferSize = bufferSize;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的参数就更多了，前面两个我们应该熟悉了，看看后面的两个参数是什么意思。虽然这里没有注释，但是这个参数的值是从别处传来的，所以只要找到源头，还是可以找到相关注释的。</p><ol><li><p>delayError </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">indicates</span> if the <span class="hljs-literal">on</span>Error notification may not cut ahead of <span class="hljs-literal">on</span>Next notification <span class="hljs-literal">on</span> the other side of the scheduling boundary. If <span class="hljs-literal">true</span> a sequence ending in <span class="hljs-literal">on</span>Error will be replayed in the same order as was received from upstream<br></code></pre></td></tr></table></figure><p>额，我只能明白一个大概：<strong>若存在Error事件，则如常执行，执行完后再抛出错误异常</strong></p></li><li><p>bufferSize 缓存大小，暂时还不知道缓存在哪里，所以先放着。</p></li></ol><p>到了这里，我们再上一个图吧，后面的流程要起飞了。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_22.png?raw=true"></p><h3 id="demo-里面的-④-处"><a href="#demo-里面的-④-处" class="headerlink" title="demo 里面的 ④ 处"></a>demo 里面的 ④ 处</h3><p>接下来，就到了一个转折点，就是 demo 中的 ④ 处，它调用了 subscribe 方法。</p><p>在第一篇中，我们分析过，subscribe 方法会调用 subscribeActual 方法，所以这里，我们直接进入到 ObservableObserveOn 的 subscribeActual 方法中，看看它做了什么。</p><blockquote><p>ObservableObserveOn .java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (scheduler <span class="hljs-keyword">instanceof</span> TrampolineScheduler) &#123;<br>        source.subscribe(observer);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Scheduler.Worker w = scheduler.createWorker();<br><br>        source.subscribe(<span class="hljs-keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于，我们传递的 scheduler 肯定不是 TrampolineScheduler，所以会直接进入到 else 分支。</p><p>else 分支里面的代码也很简单，我们先跳过线程池相关的东西，所以需要分析的就只有一行代码：</p><blockquote><p>ObservableObserveOn.java</p><p>subscribeActual 方法的 else 分支</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">source.subscribe(<span class="hljs-keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));<br></code></pre></td></tr></table></figure><p>按照套路二，ObserveOnObserver 其实就是对 observer 做了一个包装。</p><p>这个 observer 就是我们自己创建的 observerBatMan，上个图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_23.png?raw=true"></p><p>现在比较绕的是，ObservableObserveOn 类中的 subscribeActual  方法中的 source 变量是谁。由于 source 是从构造函数传递进来的，我们再回到 Observerable 的 observeOn 方法：</p><blockquote><p>Observable.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">observeOn</span><span class="hljs-params">(Scheduler scheduler, <span class="hljs-keyword">boolean</span> delayError, <span class="hljs-keyword">int</span> bufferSize)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">&quot;scheduler is null&quot;</span>);<br>    ObjectHelper.verifyPositive(bufferSize, <span class="hljs-string">&quot;bufferSize&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler, delayError, bufferSize));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在创建 ObservableObserveOn 对象的时候，第一个参数传递的是 this。</p><p>这里有一个稍微绕的点，<strong>因为 observerOn 方法是 ObservableSubscribeOn 对象调用的，所以 this，指向的是 ObservableSubscribeOn。</strong></p><p>所以，这里相当于 ObservableObserveOn  是一个桥梁，让 ObservableSubscribeOn  与 ObservableOnObserve 搭上了关系。</p><p>上一个图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_24.png?raw=true"></p><p>同样的，我们再来分析 <code>ObservableSubscribeOn</code>类的 <code>subscribeActual</code> 方法：</p><blockquote><p>ObservableSubscribeOn.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; s)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="hljs-keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);<br><br>    s.onSubscribe(parent);<br><br>    parent.setDisposable(scheduler.scheduleDirect(<span class="hljs-keyword">new</span> SubscribeTask(parent)));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 subscribeActual 内部的代码风格与想象的完全不一样啊，虽然前2行很熟悉，但是第3行完全没见过啊。</p><p>现在，我们来分析第3行代码，先看 parent.setDisposable(xxx)：</p><blockquote><p>SubscribeOnObserver.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDisposable</span><span class="hljs-params">(Disposable d)</span> </span>&#123;<br>    DisposableHelper.setOnce(<span class="hljs-keyword">this</span>, d);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>DisposableHelper.java</p><p>该方法，用来将 field 的值，设置为 d。</p><p>如果，设置的时候，field 已经有值了，返回false。</p><p>如果 field 有值， 并且值不是 DISPOSED，抛出异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setOnce</span><span class="hljs-params">(AtomicReference&lt;Disposable&gt; field, Disposable d)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(d, <span class="hljs-string">&quot;d is null&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!field.compareAndSet(<span class="hljs-keyword">null</span>, d)) &#123;<br>        d.dispose();<br>        <span class="hljs-keyword">if</span> (field.get() != DISPOSED) &#123;<br>            <span class="hljs-comment">// 抛出异常</span><br>            reportDisposableSet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样来看，其实  <code>parent.setDisposable(xxx) </code>这行代码也没做什么，正常情况下，就是将 <code>scheduler.scheduleDirect(new SubscribeTask(parent))</code> 的值设置给了 parent。</p><p>下面，继续看 <code>scheduler.scheduleDirect()</code>做了什么，由于篇幅问题，这里不分析线程池的东西，只说一下这个方法的作用，<strong>其实就是将一个 runnable，放到线程池中去执行，这里可以知道，线程切换了</strong>。</p><p>再继续，看看 SubscribeTask 类：</p><blockquote><p>SubscribeTask.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableSubscribeOn</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractObservableWithUpstream</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<br>    ...<br>    <span class="hljs-comment">// 内部类</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubscribeTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;<br><br>        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;<br>            <span class="hljs-keyword">this</span>.parent = parent;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// source 变量是 ObservableSubscribeOn 的变量</span><br>            source.subscribe(parent);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承了 Runnable，在 run 方法中，我们终于看到了 subscribe 方法。</p><p>继续深入，看看 source 对象是谁：</p><blockquote><p>Observable.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Observable&lt;T&gt; <span class="hljs-title">subscribeOn</span><span class="hljs-params">(Scheduler scheduler)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(scheduler, <span class="hljs-string">&quot;scheduler is null&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="hljs-keyword">this</span>, scheduler));<br>&#125;<br></code></pre></td></tr></table></figure><p>source 参数传递的是this，所以 source 对象是 ObservableCreate 对象。</p><p>到这里，还可以解释上面的问题：为啥 ObservableSource 的 subscribe 方法的参数是一个 Observer？</p><blockquote><p>ObservableSource.java</p><p>为了方便，我又把这个接口代码贴了一遍</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObservableSource</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们的例子中，observer 参数就是 ObservableCreate  对象。</p><p>其实，从这个类名都可以看出 ObservableSource 这个接口表示的是数据源，因为 Observerable 类就实现了这个接口，所以这个接口的 subscribe 方法的实现就是 Observable 的内部实现。</p><p>当我们调用 subscribeOn 与 observeOn 这两个方法的时候，其实是将调者这做为数据源的意思。</p><p>另外，可以推出 ObservableOnSubscribe 这个接口，应该是专门<strong>用来处理数据源的源头的</strong>（方便我们调用 emitter.onNext 等方法），两个接口的意义不一样。</p><p>所以，我们可以得到这样的一个图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_25.png?raw=true"></p><p>把这几个类，整合到调用图里面，得到如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_26.png?raw=true"></p><p>上面的图，看起来还算清晰，但是没有线程切换的内容，下面会说到。</p><p>与上一篇一样，我们再来整理一下这个demo的执行流程图，你可以先自行想一下这个图应该是什么样子的。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_27.png?raw=true"></p><p>图中灰色的长方体，表示的是调用 subscribeOn 与 observerOn 产生的 “数据源-观察者”对。</p><p>图中 subscribeOn 蓝色方块表示的是 subscribeOn  指定的线程切换的地方，可以看到，它指定的线程会影响到后续的所有流程。</p><p>图中 observerOn 黄色的方块表示的是 observerOn 指定的线程切换的地方，它会影响后续流程。</p><p>在回想一下，其实每次 observerOn 或者 subscribeOn  都创建了一个链条一样的节点，然后在 subscribeActual 将这些节点连接起来：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_28.png?raw=true"></p><p>好了，这篇文章的东西就差不多了，关于线程剩下的东西，本章中都只是一笔带过，详细的内容，留到下一篇。</p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（五）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>本文主要分析操作符的实现原理，关于操作符的使用不做讲解，想了解的可以参考<a href="https://github.com/amitshekhariitbhu/RxJava2-Android-Samples">Github上的例子项目</a>以及<a href="http://reactivex.io/documentation/operators.html">官方文档</a>。</p><h3 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h3><p>这里我们以最常用的 map 为例。首先我们写一个demo：</p><blockquote><p>Demo</p><p>这个demo演示了如何将一个int转成string。Kotlin 赛高！！！</p><p>虽然看起来没有什么屌用，但是如果int值是一个图片的资源id，我们要将这个id转成一个Bitmap，那么也可以用map操作法，再配上前几篇文章说的线程切换，岂不美哉！~</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Observable.just(<span class="hljs-number">1</span>).map &#123;<br>    <span class="hljs-comment">// map 的作用主要是做一个变化，这里是将发射的 int 值变成 string</span><br>    <span class="hljs-string">&quot;<span class="hljs-variable">$it</span>-covert&quot;</span><br>&#125;.subscribe &#123;<br>    <span class="hljs-comment">// 打印接收到的 string</span><br>    System.<span class="hljs-keyword">out</span>.println(it)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个为了简单我用到了 just 操作符，其实和 create 差不多，如果你强迫症想搞清楚，可以自己戳戳源码，前面的文章如果你真的看懂了，戳进去几分钟就知道它的原理啦。</p><p>这里我们直接从 map 方法开始分析：</p><h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><blockquote><p>Observable</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> &lt;R&gt; <span class="hljs-function">Observable&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(mapper, <span class="hljs-string">&quot;mapper is null&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableMap&lt;T, R&gt;(<span class="hljs-keyword">this</span>, mapper));<br>&#125;<br></code></pre></td></tr></table></figure><p>按住 ctrl 键，点击鼠标左键：</p><h4 id="ObservableMap"><a href="#ObservableMap" class="headerlink" title="ObservableMap"></a>ObservableMap</h4><blockquote><p>类结构</p><p>它也是继承了 AbstractObservableWithUpstream，这个是我们的老相好了，就不介绍了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableMap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractObservableWithUpstream</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>下面看构造函数：</p><blockquote><p>构造函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObservableMap</span><span class="hljs-params">(ObservableSource&lt;T&gt; source, Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; function)</span> </span>&#123;<br>    <span class="hljs-comment">// source 不多说</span><br>    <span class="hljs-keyword">super</span>(source);<br>    <span class="hljs-comment">// 这里就是我们做变换的函数</span><br>    <span class="hljs-keyword">this</span>.function = function;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是看 <code>subscribeActual</code> 方法了，看，只要掌握了套路，分析起源码来，还是比较轻松的。</p><blockquote><p>subscribeActual 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> U&gt; t)</span> </span>&#123;<br>    source.subscribe(<span class="hljs-keyword">new</span> MapObserver&lt;T, U&gt;(t, function));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法很直接，不做作，直接将 t 与 functiaon 全部扔进 MapObserver 里面，交给 MapObserver 去处理。下面来分析分析 MapObserver 这个类。</p><h4 id="ObservableMap-MapObserver"><a href="#ObservableMap-MapObserver" class="headerlink" title="ObservableMap.MapObserver"></a>ObservableMap.MapObserver</h4><blockquote><p>类结构</p><p>MapObserver 继承了 BasicFuseableObserver</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapObserver</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BasicFuseableObserver</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h4 id="BasicFuseableObserver"><a href="#BasicFuseableObserver" class="headerlink" title="BasicFuseableObserver"></a>BasicFuseableObserver</h4><p>书里说过，信息太多与信息太少，都会对理解力造成阻碍。</p><p>这个类的蛋疼之处就在于，里面的代码不多，很简单，但是又没简单到你可以一下子就能明白这个类的作用。所以如果我把这个类的代码贴出来，作用也不大，我说不出一个道道来。</p><p>这里我说一下我自己对这个类的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Base <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">for</span> <span class="hljs-title">a</span> <span class="hljs-title">fuseable</span> <span class="hljs-title">intermediate</span> <span class="hljs-title">observer</span>.</span><br></code></pre></td></tr></table></figure><p>上面的一串英文是类的注释，翻译过来就是说 <strong>一个用于可融合的中间观察者的基类</strong>，反正我还是没太明白。</p><p>既然它是一个中间观察者，我们就看看它作为一个“中介”，搞了一些啥事情。</p><blockquote><p>BasicFuseableObserver#onSubscribe</p><p>在这个方法里面，它作为第三者，插入到了原来的 parent 与 observer 之间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Disposable s)</span> </span>&#123;<br>    <span class="hljs-comment">// 该方法用于判断 this.s 为 null，并且 s 不为 null</span><br>    <span class="hljs-keyword">if</span> (DisposableHelper.validate(<span class="hljs-keyword">this</span>.s, s)) &#123;<br><br>        <span class="hljs-comment">// 这行代码很重要</span><br>        <span class="hljs-keyword">this</span>.s = s;<br>        <br>        <span class="hljs-comment">// QueueDisposable 是一个接口，后面会讲</span><br>        <span class="hljs-keyword">if</span> (s <span class="hljs-keyword">instanceof</span> QueueDisposable) &#123;<br>            <span class="hljs-keyword">this</span>.qs = (QueueDisposable&lt;T&gt;)s;<br>        &#125;<br><br>        <span class="hljs-comment">// 这里有两个钩子</span><br>        <span class="hljs-keyword">if</span> (beforeDownstream()) &#123;<br><br>            <span class="hljs-comment">// 调用了 actual 的 onSubscribe</span><br>            <span class="hljs-comment">// 这个方法我们在之前分析 subscribeActual 方法的时候，都是跳过的</span><br>            <span class="hljs-comment">// 下面我们会分析这个方法的作用</span><br>            actual.onSubscribe(<span class="hljs-keyword">this</span>);<br><br>            afterDownstream();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在之前的文章中，我们忽略了 onSubscribe，而这个类用到了这个方法，所以现在我们拿 ObservableCreate 来分析一下 onSubscribe 这个方法的作用。</p><h4 id="ObservableCreate"><a href="#ObservableCreate" class="headerlink" title="ObservableCreate"></a>ObservableCreate</h4><blockquote><p>ObservableCreate#subscribeActual</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    observer.onSubscribe(parent);<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>其实从这两行代码就可以看出，onSubscribe 的参数就是我们的老父亲 parent。</p><p>之前我们说过，CreateEmitter 就是将 observer 包装了一下，即 CreateEmitter 持有 observer 。</p><p>现在看 onSubscribe 方法就是反过来，即 observer  “参数持有” CreateEmitter 。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_41.png?raw=true"></p><p>让我们再次回到 BasicFuseableObserver 类中的 onSubscribe 方法里面：</p><p>####BasicFuseableObserver</p><blockquote><p>BasicFuseableObserver#onSubscribe</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这行代码很重要</span><br><span class="hljs-comment">// s 是原来的 parent，它把这个对象保存起来</span><br><span class="hljs-keyword">this</span>.s = s;<br><br><span class="hljs-comment">// actual 是我们 demo 中创建的匿名内部类（虽然真正的情况是将 consumer 包成了 observer）</span><br><span class="hljs-comment">// 将 this 作为 parent 传递进去</span><br><span class="hljs-comment">// 所以，这样他就成了一个中间观察者</span><br>actual.onSubscribe(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>上面的代码，你可以联想一下链表的插入操作。</p><p><strong>前面的文章里面，onSubscribe 的调用都是放在 subscribeActual 中的，这里为啥要放到 Observer 类里面呢</strong>？我猜想是因为操作符会导致数据源的不稳定（同步，异步数据），因为 BasicFuseableObserver 还实现了 QueueDisposable 这个接口，这个接口类注释比较多，可以详细看看。</p><p>那么，分析到了这里，我们就将 MapObserver 当作一个普通的 Observer 的包装类来看待吧。反正这里我们还用不到里面的 poll 方法。</p><h4 id="ObservableMap-MapObserver-1"><a href="#ObservableMap-MapObserver-1" class="headerlink" title="ObservableMap.MapObserver"></a>ObservableMap.MapObserver</h4><p>我们直接看 onNext 方法：</p><blockquote><p>onNext</p><p>这里该方法由 MapObserver 的包装类调用，我们了解了套路，更不需要从头跟踪源码，就知道它由谁调用。只要知道它会被调用，在具体的代码中会被谁调用，分析源码的时候管他调用者是谁呢。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (done) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在这个 demo 中，sourceMode 一直为 NONE</span><br>    <span class="hljs-keyword">if</span> (sourceMode != NONE) &#123;<br>        actual.onNext(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    U v;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这里就执行变化了，注意变换结果不能返回null</span><br>        v = ObjectHelper.requireNonNull(mapper.apply(t), <span class="hljs-string">&quot;The mapper function returned a null value.&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        fail(ex);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将变化的结果返回</span><br>    actual.onNext(v);<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，到这里，demo的流程就分析完了，还是很简单的，主要是例子简单。</p><p>其实，该类还有一个 poll 方法，应该会在某些情况下调用，这里没有用到，里面的水应该还有点深。</p><p>其他的操作符，这里就不讲了。</p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-引言</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0001-%E5%BC%95%E8%A8%80/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0001-%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>这个系列为并发入门系列，有些东西不会深入介绍，主要是有一个对并发全局的掌握，有兴趣可以自行深入了解。</p><p>该系列参考文章为：</p><p><a href="http://tutorials.jenkov.com/java-concurrency/index.html">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-并发介绍</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0002-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0002-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>在远古时代，我们的计算机只有一个 CPU，而且一次只能运行一个程序。</p><p>接着多任务系统被引入，单个 CPU 可以同时运行多个程序了，虽然并不是真正意义上的“同一时间点”。它是这样工作的：多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</p><p>从多任务系统开始，程序设计者就需要考虑该程序不能独占所有的CPU时间、所有的内存和其他计算机资源，因为别的程序也要运行。</p><p>再接着，多线程被引入：使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。但是需要注意的是，虽然名义上叫多线程，因为只有一个CPU，所以两个线程从来不会得到真正的并行执行。</p><p>（之所以能够这么设计，是因为 CPU 实在是太快了，看过 三体 么，里面的智子只有一个，但是却监控了整个地球，就是因为它跑的太快了，让人感觉到它无处不在，同样的，CPU 在切换线程的时候，我们根本就感觉不到）</p><p>再接着，多核 CPU 出现了，意味着不同的线程能被不同的CPU核得到真正意义的并行执行。以前的程序可能会出现一些从未见过的问题：因为多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/java-concurrency-tutorial-introduction-1.png"></p><p>如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003多线程的优点</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0003-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0003-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>尽管使用多线程会遇到很多困难，但是由于它带来的好处实在是太大了，所以掌握多线程是必须的。</p><p>下面我们举几个例子来说一下多线程的好处：</p><h2 id="更高的资源利用率"><a href="#更高的资源利用率" class="headerlink" title="更高的资源利用率"></a>更高的资源利用率</h2><p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。</p><p>比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1 | 5s读取文件A<br>2 | 2s处理文件A<br>3 | 5s读取文件B<br><span class="hljs-section">4 | 2s处理文件B</span><br><span class="hljs-section">-----------------</span><br>一共耗时 5 <span class="hljs-code">+ 5 +</span> 2 + 2 = 14s<br></code></pre></td></tr></table></figure><p>我们思考一下可以优化的地方：</p><blockquote><p>从磁盘中读取文件的时候，这段时间内，CPU 是没有做任何事情的，就白白浪费了</p></blockquote><p>在这段时间里，CPU非常的空闲。它可以做一些别的事情。那么，怎么利用这段时间，用 CPU 去做别的事情呢。</p><p>通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1 | 5秒读取文件A<br>2 | 5秒读取文件B + 2秒处理文件A<br><span class="hljs-section">3 | 2秒处理文件B</span><br><span class="hljs-section">----------------------------</span><br>一共耗时 5 <span class="hljs-code">+ 5 +</span> 2 秒<br>(仔细想了一下，这个例子应该是单CPU的情况下的顺序)<br></code></pre></td></tr></table></figure><p>CPU等待第一个文件被读取完，然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。<strong>记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的</strong>。</p><p>总的说来，<strong>CPU能够在等待IO的时候做一些其他的事情</strong>。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。</p><h2 id="更简单的程序设计"><a href="#更简单的程序设计" class="headerlink" title="更简单的程序设计"></a>更简单的程序设计</h2><p>在单线程应用程序中，如果你想编写程序处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。</p><p>但是如果你启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。</p><p>其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。</p><h2 id="更快的响应速度"><a href="#更快的响应速度" class="headerlink" title="更快的响应速度"></a>更快的响应速度</h2><p>假设我们有一个服务器，我们写了一个服务应用用来处理用户的请求，它的大致流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(server is active) &#123;<br>    listen <span class="hljs-keyword">for</span> request<br>process request<br>&#125;<br></code></pre></td></tr></table></figure><p>假如处理有的用户请求需要占用很长的时间，那么在这段时间之内，服务器就无法响应别的用户的请求了。</p><p>所以我们可以这样设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(server is active)&#123;<br>    listen <span class="hljs-keyword">for</span> request<br>    hand request to worker thread<br>&#125;<br></code></pre></td></tr></table></figure><p>我们为每个请求单独分配一个线程去处理，然后服务端线程立刻再去监听用户请求。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p><p>我们的应用也是如此。如果我们点击了一个按钮，要去开始一个非常耗时的任务，如果我们直接在 UI 线程执行，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。</p><p>但是如果我们开启一个工作线程去处理，当工作者线程在繁忙地处理任务的时候，UI线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。UI线程便可以更新应用程序窗口，并显示任务的结果。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0004-多线程的代价</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0004-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0004-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://huiji-thumb.huijistatic.com/hearthstone/uploads/5/59/%E5%8A%9B%E9%87%8F%E7%9A%84%E4%BB%A3%E4%BB%B7.png"></p><p>多线程的代价虽然没有这么大，但是也有很多让人头疼的地方。</p><p>我们在使用多线程的时候，最好先衡量一下。除非我们确定了使用多线程带来的好处要比付出的代价大，才应该使用。如果不确定，应该测试一下更改前后的程序性能，不要仅靠猜测。</p><p>（我就有一次，优化程序的某个地方，花了两天时间，改成多线程之后，最后测量的时候发现速度只提升了 200ms，说实话，挫败感很大，原以为会有很大的提升，最后为了避免改动过大带来的影响，把代码回退了）</p><h2 id="使代码变复杂"><a href="#使代码变复杂" class="headerlink" title="使代码变复杂"></a>使代码变复杂</h2><p>虽然有些多线程程序写起来要比单线程简单，但是毕竟是少数情况，一般情况下，设计一个多线程程序需要考虑很多东西。</p><p>特别是关于共享数据的问题，这部分的代码需要特别注意。线程之间的交互可能非常复杂，需要理清楚的之后正确的使用同步。</p><p>还有一个问题就是，多线程产生的bug，可能难以复现，可能线上出现了几次，然后就再也不出现了，自己怎么弄都复现不出来，多线程的bug难以解决。</p><h2 id="上下文切换开销"><a href="#上下文切换开销" class="headerlink" title="上下文切换开销"></a>上下文切换开销</h2><p>当 CPU 从一个线程切换到另一个线程的时候，需要做很多事，不是仅仅换个线程执行就好了。</p><p>这是因为在切换的时候，我们需要保存关于这个线程的所有信息，比如：这个线程执行到哪里了，线程里面的栈数据。（它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。）如果不储存这些信息，那么 CPU 再次切回来的时候，就一脸懵逼了。</p><p><strong>上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。</strong></p><h2 id="增加资源消耗"><a href="#增加资源消耗" class="headerlink" title="增加资源消耗"></a>增加资源消耗</h2><p>曾经，我遇到过有人问这样的一个问题：</p><blockquote><p>我们创建线程的数量有限制吗？</p></blockquote><p>线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。而且操作系统也需要管理这些线程。</p><p>我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。</p><p>就算线程不占别的资源，它也是一个类吧，创建一个类对象也需要资源。我们能创建无限个对象吗，显然不行。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0005-并发编程模型</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0005-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0005-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>嗯，说实话。这个我没看太懂，原文地址如下：</p><blockquote><p><a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html">http://tutorials.jenkov.com/java-concurrency/concurrency-models.html</a></p></blockquote><p>我只说我看懂的部分吧。</p><p>并发模型与分布式系统中使用的体系结构很相似。并发系统中是线程之间相互通信，分布式系统中是进程之间相互通信（进程有可能在不同的机器中）。线程与进程又有很多相似的特性，也就是为什么很多并发模型通常类似于各种分布式系统架构。</p><h2 id="并行工作者"><a href="#并行工作者" class="headerlink" title="并行工作者"></a>并行工作者</h2><p><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png"></p><p>在这个模型中，每个 Worker 线程都负责一个完整的工作。</p><p>如果我们拿汽车工厂举例，那么就是每台车都交给一个工人来生产，工人们都从 0 开始，攒一个完整的车出来。</p><p>这个模型很容易理解，代码也易于阅读，提高并发度只需要增加线程就好了。</p><p>并行工作者模型虽然看起来简单，却隐藏着一些缺点。</p><p>如果，Worker 需要访问共享数据的话，这个模型就会变得复杂：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png"></p><p>Worker 之间需要避免竞态，死锁等问题。而且，在访问共享数据的时候，如果这个时候竞争很激烈的话，会导致出现线程串行化的现象。</p><h2 id="流水线模式"><a href="#流水线模式" class="headerlink" title="流水线模式"></a>流水线模式</h2><p>看下模型图：</p><p><img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png"></p><p>这个就类似于工厂里面的那种流水线了，每个 Worker 负责不同的部分，当前面的 Worker 完成了自己的任务之后就会将结果交给下一个 Worker。这样的话，就不会与别的 Worker 共享数据。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0006-如何创建并运行 java 线程</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0006-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%20java%20%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0006-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%20java%20%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>java 中线程也是一个类（Thread），继承至 Object 类。我们创建一个线程实例，需要继承至 Thread 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Tread thread = <span class="hljs-keyword">new</span> Thread();<br></code></pre></td></tr></table></figure><p>执行这个线程，需要调用 thread 的 <strong>start</strong> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">thread.start();<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们并没有为线程编写运行代码，因此调用该方法后线程就终止了。</p><p>想要给线程编写执行代码，有两种方案：</p><ul><li>创建Thread子类的一个实例并重写run方法</li><li>创建 Thread 实例的时候，传入一个 Runnable 对象</li></ul><h2 id="创建-Thread-子类"><a href="#创建-Thread-子类" class="headerlink" title="创建 Thread 子类"></a>创建 Thread 子类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread running&quot;</span>);<br>    &#125;<br>&#125;;<br>thread.start();<br></code></pre></td></tr></table></figure><p>一旦thread线程启动后start方法就会立即返回，而<strong>不会等待到run方法执行完毕才返回</strong>，就好像run方法是在另外一个cpu上执行一样。</p><p>当run方法执行后，将会打印出字符串MyThread running。</p><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;MyRunnable running&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。</span><br>Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());<br>thread.start();<br></code></pre></td></tr></table></figure><p>当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。</p><p>那么，这两种方案，哪种好呢？</p><p>对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。我自己倾向于 实现 Runnable 接口 的方式，因为它将任务从线程里面分离出来了。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>创建并运行一个线程所犯的<strong>常见错误是调用线程的run()方法而非start()方法</strong>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread newThread = <span class="hljs-keyword">new</span> Thread(MyRunnable());<br>newThread.run();  <span class="hljs-comment">//should be start();</span><br></code></pre></td></tr></table></figure><p>起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。</p><h2 id="线程起名"><a href="#线程起名" class="headerlink" title="线程起名"></a>线程起名</h2><p>当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">MyRunnable runnable = <span class="hljs-keyword">new</span> MyRunnable();<br>Thread thread = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;New Thread&quot;</span>);<br>thread.start();<br>System.out.println(thread.getName());<br></code></pre></td></tr></table></figure><p>我们可以使用如下方法来获取当前线程的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String threadName = Thread.currentThread().getName();<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里是一个小小的例子。首先输出执行main()方法线程名字。这个线程是JVM分配的。然后开启10个线程，命名为1~10。每个线程输出自己的名字后就退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;&quot;</span> + i)&#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + getName() + <span class="hljs-string">&quot;running&quot;</span>);<br>                &#125;<br>            &#125;.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，尽管启动线程的顺序是有序的，但是<strong>执行的顺序并非是有序的</strong>。也就是说，<strong>1号线程并不一定是第一个将自己名字输出到控制台的线程</strong>。这是因为线程是并行执行而非顺序的。Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0007-竟态条件与临界区</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0007-%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0007-%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>在一个程序中运行多个线程本身不会有问题，有问题的是这些线程同时访问了同样的资源。</p><p>比如：同一个变量，同一个数据库。当然如果这些线程都只是读取，那不会有问题，但是如果有一个或者多个写线程就会有问题。</p><p>多线程同时执行下面的代码可能会出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>&#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span></span>&#123;<br><span class="hljs-keyword">this</span>.count = <span class="hljs-keyword">this</span>.count + value;   <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">从内存获取 <span class="hljs-keyword">this</span>.<span class="hljs-keyword">count</span> 的值放到寄存器<br>将寄存器中的值增加value<br>将寄存器中的值写回内存<br></code></pre></td></tr></table></figure><p>假设线程交替执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br><br>  A:读取 <span class="hljs-keyword">this</span>.count 到一个寄存器 (<span class="hljs-number">0</span>)<br>  B:读取 <span class="hljs-keyword">this</span>.count 到一个寄存器 (<span class="hljs-number">0</span>)<br>  B: 将寄存器的值加<span class="hljs-number">2</span><br>  B:回写寄存器值(<span class="hljs-number">2</span>)到内存. <span class="hljs-keyword">this</span>.count 现在等于 <span class="hljs-number">2</span><br>  A:将寄存器的值加<span class="hljs-number">3</span><br>  A:回写寄存器值(<span class="hljs-number">3</span>)到内存. <span class="hljs-keyword">this</span>.count 现在等于 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。</p><p>然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。</p><p>然后各自加了2和3，并分别写回内存。</p><p>最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。</p><h2 id="竟态条件与临界区"><a href="#竟态条件与临界区" class="headerlink" title="竟态条件与临界区"></a>竟态条件与临界区</h2><p>当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</p><p>导致竞态条件发生的代码区称作临界区。</p><p>上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0008-线程安全与共享资源</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0008-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/%E5%B9%B6%E5%8F%91/0008-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>我们知道竟态条件指的是多个线程访问共享资源需要依赖线程的执行顺序，说白了就是计算的结果依赖线程的执行顺序，线程顺序OK才能到正确的结果。</p><p>一份代码到底是否线程安全，需要看它是否有共享资源。那么线程会共享哪些资源呢？</p><p>通常，我们的资源一般都是 文件，数据库，图片等，或许还有其他的，但是不管他们都是什么，在Java里面都是用一个变量表示。即我们只需要分析代码里面有哪些共享变量就好了。</p><p>变量分为局部变量与成员变量。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量存储在线程自己的栈中。</p><p>局部变量也有两种：基本类型与类类型。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span>&#123;<br>  <br>  <span class="hljs-keyword">long</span> threadSafeInt = <span class="hljs-number">0</span>;<br><br>  threadSafeInt++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>对象的局部引用与基本类型不一样。它虽然本身没有被共享，但引用所指的对象并没有存储在线程的栈内，而是在共享堆中。</p><p>其实，只要别的线程获取不到这个类类型，它也是线程安全的。</p><p>下面是一个线程安全的局部引用样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">()</span></span>&#123;<br>  LocalObject localObject = <span class="hljs-keyword">new</span> LocalObject();<br><br>  localObject.callMethod();<br>  method2(localObject);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(LocalObject localObject)</span></span>&#123;<br>  localObject.setValue(<span class="hljs-string">&quot;value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。</p><p>每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。</p><p>因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。</p><p>即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。</p><p>当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了，但是它在 someMethod 这个方法中还是线程安全的。</p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotThreadSafe</span></span>&#123;<br>    StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">add</span><span class="hljs-params">(String text)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.builder.append(text);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个线程同时调用同一个<code>NotThreadSafe</code>实例上的add()方法，就会有竞态条件问题。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">NotThreadSafe sharedInstance = <span class="hljs-keyword">new</span> NotThreadSafe();<br><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable(sharedInstance)).start();<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable(sharedInstance)).start();<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>  NotThreadSafe instance = <span class="hljs-keyword">null</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRunnable</span><span class="hljs-params">(NotThreadSafe instance)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.instance = instance;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.instance.add(<span class="hljs-string">&quot;some text&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。</p><p>当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-keyword">new</span> NotThreadSafe())).start();<br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable(<span class="hljs-keyword">new</span> NotThreadSafe())).start();<br></code></pre></td></tr></table></figure><p>现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。</p><h2 id="线程控制逃逸规则"><a href="#线程控制逃逸规则" class="headerlink" title="线程控制逃逸规则"></a>线程控制逃逸规则</h2><p>根据我们上面所说的，如果我们把一个变量控制在线程之内，让别的线程无法访问，那么就不会有多线程问题了。</p><p>那么我们如何判断这个变量<strong>是否是被控制在线程之内</strong>的？下面就说一下判断规则。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">如果一个资源的创建，使用，销毁都在同一个线程内完成，<br>且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。<br></code></pre></td></tr></table></figure><p>即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。</p><p>比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的（这里其实就是违反了上面的规则–<strong>没有在线程内创建资源，我们只是持有了这个资源的引用</strong>）。比如，2个线程执行如下代码：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">检查记录<span class="hljs-meta">X</span>是否存在，如果不存在，插入<span class="hljs-meta">X</span><br></code></pre></td></tr></table></figure><p>如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">线程1检查记录<span class="hljs-meta">X</span>是否存在。检查结果：不存在<br>线程2检查记录<span class="hljs-meta">X</span>是否存在。检查结果：不存在<br>线程1插入记录<span class="hljs-meta">X</span><br>线程2插入记录<span class="hljs-meta">X</span><br></code></pre></td></tr></table></figure><p>同样的问题也会发生在文件或其他共享资源上。因此，<strong>区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java-并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0000-前言</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0000-%E5%89%8D%E8%A8%80/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0000-%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>因为会做成一个系列，所以每篇的东西会比较少，嗯，大概吧。</p><p>尽量不copy书里面的文字，用自己的话来说一遍。</p><p>文章中的例子是我自己写的，只是经过了简单的测试，并不保证一定完全正确。可以作为参考，但是还是需要自己想想再写。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0001-数据结构的起源</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0001-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B5%B7%E6%BA%90/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0001-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习任何一种知识，了解一下起源总是会感觉更加有兴趣一些（心里安慰）。</p></blockquote><p>早期的计算机一般都是用来做数值计算的，但是数值计算只能解决一部分问题，还有一部分问题是无法化解为数值计算问题。</p><p>有时候某些问题涉及到的数据，是无法用纯数据来表示的。比如我们想要将一份表格数据输入到程序中，表格一般会有很多列，所有列的同一行数据都是属于某一项数据的。这个时候，只输入纯数据值肯定是不行的，这样数据值之间的关系就丢失了。</p><p>还有的问题需要对数据做一些特殊处理，比如需要对数据一个个按顺序处理，我们就需要一种结构（表，树，图等等），将这些数据存起来以便取用。</p><p>然后，1968年，一位大佬就写了一本书，系统的阐述了数据的逻辑结构和储存结构及其操作，正式开宗立派。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0002-逻辑结构与物理结构</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0002-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0002-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>数据结构就是说，一堆数据放在一起，它们之间会有某种关系在里面。</p><p>下面，我们就来聊聊储存这些关系的结构，按照角度的不同，我们分为两大类：逻辑结构、物理结构。</p><p>逻辑结构<strong>是描述数据之间的关系的</strong>，是我们今后要关注的，这是从我们的理解角度出发的。</p><p>物理结构<strong>是数据之间的关系在计算机中的储存形式</strong>，是从计算机的角度出发的。</p><h4 id="逻辑结构分为四种："><a href="#逻辑结构分为四种：" class="headerlink" title="逻辑结构分为四种："></a>逻辑结构分为四种：</h4><ul><li><p><strong>集合结构</strong>：可以理解为数学中的集合概念，就是一堆同性质（一般是）的数据放在一起，没啥别的要求。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection.png?raw=true"></p></li><li><p><strong>线性结构</strong>：数据项之间是一对一的关系。比如，幼儿园放学的时候，小孩儿都拍成一排。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection2.png?raw=true"></p></li><li><p><strong>树形结构</strong>：数据项之间是一对多的关系。比如：公司上下级的关系。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection3.png?raw=true"></p></li><li><p><strong>图形结构</strong>：数据项之间是多对多的关系。比如：一个班级中的同学之间的朋友关系。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection4.png?raw=true"></p></li></ul><h4 id="物理结构分为两种"><a href="#物理结构分为两种" class="headerlink" title="物理结构分为两种"></a>物理结构分为两种</h4><p>虽然计算机有多种储存介质，但是对于数据结构来说，都是针对内存说的。我们可以将内存理解为一个一个的格子。</p><ul><li><p>顺序储存关系</p><p>顺序就是强迫症一样的摆东西，一个格子挨着一个格子，整整齐齐的。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection5.png?raw=true"></p></li><li><p>链式储存关系</p><p>链式储存就是瞎几把乱放，有空位置就塞一个，但是需要额外的信息来储存下一个储存位置在哪，不然就找不到了。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/collection6.png?raw=true"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0003-抽象数据类型</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0003-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0003-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>因为我们是用的 Java，所以这个就不介绍了哈，面向对象牛逼！！！</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0004-数据结构与算法的关系</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0004-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0004-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>如果一部电影光有特效没有剧情，看完了之后，让你说一下这部电影，你会发现不知道怎么说起，感觉自己都知道，但是却没什么好说的。</p><p>学数据结构就是这样，如果只讲数据结构，那么学完了就会发现没啥感觉，你不知道这个东西可以做什么，没有内涵。</p><p>PS：现在供人消遣的短视频，娱乐节目什么的越来越多，我们花在看视频的时间上越来越多，这会对我们自身有个非常不好的影响，就是会变的越来越不想自己思考，而是借着视频放空脑子，不去思考什么。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0005为啥需要算法</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0005-%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0005-%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>写一个从1加到100的程序。</p><p>我们是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++) &#123;<br>    sum += i<br>&#125;<br></code></pre></td></tr></table></figure><p>大佬高斯是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n= <span class="hljs-number">100</span><br>sum = (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>哪个算的快，不用我多说了吧！！！</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0006-算法的特性</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0006-%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0006-%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>算法的定义我就不写了，写了也记不住，就理解为<strong>解决某个问题的具体步骤，可以翻译为计算机语言</strong>。</p><p>拿破仑说过，不想当厨子的司机不是好裁缝。那么一个算法应该具备什么样的特性，才算是一个合格的算法呢？</p><ul><li><strong>输入输出</strong>：可以不需要输入（生成随机数之类的），但是一定要有输出，不然写这个算法搞毛。</li><li><strong>有穷性</strong>：可以在一个合理的时间内运算完成。写一个需要耗时几十年的算法，那就没什么意思了。</li><li><strong>确定性</strong>：同样的输入会得出同样的输出。</li><li><strong>可行性</strong>：这个有点不好理解，有些算法是无法转换为程序的，由于现在科技与人类认知的局限性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0007-算法设计的要求</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0007-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0007-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>这个不要跟算法的特性搞混了，这里说的是一个好的算法有哪些要求。上一篇说的是算法的基本特性，即基本要求，如果连这个都不满足，那就更不用说好坏了。</p><ul><li><strong>正确性</strong>：能够得出正确答案。</li><li><strong>可读性</strong>：可以方便阅读，供人交流，写的只有自己能看懂，那就只能与计算机交流了。</li><li><strong>健壮性</strong>：对于一些不合法的输入，可以做合适的处理，而不是直接抛出异常。</li><li><strong>时间效率高与储存量低</strong>：耗时肯定是越少越好，同时对空间的要求也越低越好。就是传说中的，用最少的钱把事办了，而且还要办的漂漂亮亮的，越快越好。</li></ul>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0008-度量一个算法的效率</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0008-%E5%BA%A6%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0008-%E5%BA%A6%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>如何去测量一个算法的效率，还是值得思考一下的。</p><p>比如，我们用算法实现了一个功能，那么想要测量这个算法的运行速度，通常都会直接运行一下，看看它消耗的时间，然后得出一个主观的判断，但是这个测量的结果有用吗？</p><p>显然没有，因为有很多外在的因素影响了我们测量的结果：</p><ul><li>每个计算机运行的速度不一样</li><li>测试数据的大小对算法也有影响，有些算法在小型测试数据集合表现很好，但是数据集合大了之后就会变得效率很低</li></ul><p>另外，还有一个问题，那就是就算我们找了某些方法，可以避免这些因素，那么还有一个问题就是，我们需要写出我们的程序，才能进行测量，这其实也是一个很严重的问题，因为如果每个算法都需要实现了才能测量，那无疑要消耗很多精力。</p><p>那么有没有不需要写出算法的程序，就能测量出算法的效率的方法呢？肯定是有的，就是我们所说的大O阶方法。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0009-大O阶方法</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0009-%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0009-%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在说这个测量方法之前，我们还介绍一些大家最喜欢的数学知识。</p><h2 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h2><p>比如，我们有两个函数：<br>$$<br>f(n) = 4*n + 8<br>$$</p><p>$$<br>g(n) = n*n<br>$$</p><p>当 n&lt;=5 的时候，f(n) 是比 g(n) 大的，当 n &gt; 5 后，f(n) 就比 g(n) 小了。对于这两个函数，我们称 g(n) 的渐近增长要快于 f(n) 的渐近增长。</p><p>其实，可以画一个图，显然当 n 越大的时候，g(n)  - f(n) 的值也是越来越大。</p><p>好的，了解了这个，我们就开始介绍大O阶方法。</p><h2 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h2><p>看下面这个算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, n=<span class="hljs-number">100</span>;<span class="hljs-comment">/* 执行一次 */</span><br>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<span class="hljs-comment">/* 执行一次 */</span><br>System.out.println(sum);<span class="hljs-comment">/* 执行一次 */</span><br></code></pre></td></tr></table></figure><p>我们用一个函数$T(N) =  O(f(n))$ 来表示这个算法的时间复杂度（即<strong>算法语句的执行次数与问题规模大小之间的关系</strong>）。</p><p>可以得出$T(N) = O(3)$，简记为 $O(3)$，但是通常我们不会这么表示，而是写作 $O(1)$ ，这是为什么呢？</p><p>假设，我们的算法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, n=<span class="hljs-number">100</span>;<span class="hljs-comment">/* 执行一次 */</span><br>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<span class="hljs-comment">/* 执行一次 */</span><br>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<span class="hljs-comment">/* 执行一次 */</span><br>System.out.println(sum);<span class="hljs-comment">/* 执行一次 */</span><br></code></pre></td></tr></table></figure><p>那么，时间复杂度为 $O(4)$ ，但是实际上，这个算法与上面的算法都有一个特点，就是他们的执行次数都是固定的，与问题规模大小没有关系，是一个执行时间恒定的算法。</p><p>对于这样的算法，不管常熟是多大，我们都记为 $O(1)$。</p><p>所以我们总结出第一条攻略：</p><ul><li><strong>用常数1取代运行时间中所有加法常数</strong></li></ul><h2 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h2><p>看下面这个算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>    <span class="hljs-comment">/* 时间复杂度为 O(1)的程序步骤序列 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显然，时间复杂度为 $O(n)$ 。</p><h2 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h2><p>看下面这个算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i, j<span class="hljs-comment">/* 执行一次 */</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<span class="hljs-comment">/* 执行N次 */</span><br>    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;<span class="hljs-comment">/* 执行N次 */</span><br>        <span class="hljs-comment">/* 时间复杂度为 O(1)的程序步骤序列 */</span><br>    &#125;<br>&#125;<br>System.out.println(sum);<span class="hljs-comment">/* 执行一次 */</span><br></code></pre></td></tr></table></figure><p>可以看到，循环部分占了 $N^2$  次，时间复杂度为 $O(n^2+2)$，但是我们不会记为  $O(n^2+2)$，而是写作  $O(n^2)$。</p><p>这是因为，我们最需要关心的是循环里面的部分，其他的可以忽略，而且，随着 N 的增大，$n^2+2$ 与 $n^2$ 的差别可以忽略不记。</p><p>所以我们总结出第二条攻略：</p><ul><li><strong>只保留函数中的最高阶项</strong></li></ul><p>比如：$O(n^2 +n)$，我们也写作 $O(n^2)$，显然 n 越大，他们的区别越小。</p><p>还有一个比较特殊的情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i, j<span class="hljs-comment">/* 执行一次 */</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<span class="hljs-comment">/* 执行N次 */</span><br>    <span class="hljs-keyword">for</span> (j=i; j&lt;n; j++) &#123;<span class="hljs-comment">/* 执行N-i次 */</span><br>        <span class="hljs-comment">/* 时间复杂度为 O(1)的程序步骤序列 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，它的时间复杂度为多少呢？看上去这个不好下手，但是却可以这样算：</p><p>当 i = 0，内层循环 n 次</p><p>当 i = 1，内层循环 n - 1 次</p><p>…..</p><p>所以内层循环一共循环了 n + (n-1) + … + 1 次，为 $\frac{n(n+1)}2$ 次。</p><p>记为 $O(\frac{n^2}2)$，与省略低阶项同样的道理，我们也可以省略这个相乘的常数，记为 $O(n^2)$。</p><h2 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h2><p>下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (count &lt; n) &#123;<br>    count *= <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/* 时间复杂度为 O(1)的程序步骤序列 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>假设循环执行了 x 次，则 $2^x = n$，所以算法时间复杂度为 $O(log_2n)$，通常，我们省略底数2，记为  $O(logn)$。</p><p>最后，总结一下：</p><blockquote><ol><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数中，只保留最高阶项</li><li>如果最高阶存在且不是1，则去除与这个项相乘的常数</li></ol></blockquote><p>其实，大O阶考察的还是我们的数学功底。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0010最坏情况与平均情况</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0010-%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0010-%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>最坏情况，指的是运行时间最长的情况。</p><p>举个例子，我们要在抽屉里面找一个东西，最好的情况是将抽屉打开，一眼就看到了，最坏的情况是我们要将抽屉里的东西一个一个翻一遍才能找到。</p><p>平均情况，是比较有意义的情况，就是取一个平均值。</p><p><strong>一般情况下，我们说的时间复杂度指的是最坏时间复杂度。</strong></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0011-空间复杂度</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0011-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0011-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>如果我们想要判某年是不是闰年，可以有两种做法：</p><ul><li>写一个算法，输入一个年份，就可以得出结果</li><li>建一个数组，数组的大小比现实年份多一点，把所有的年份按照下标的数字对应，如果是闰年就将值赋值为1，不是就赋值为0</li></ul><p>这两种做法，一个空间复杂度基本是 O(1)，另一个空间复杂度基本是 o(2022)，假设给数组的大小为 2022。</p><p>空间复杂度指的是：一个程序在机器上执行时，除了储存程序本身的指令，变量等，还需要一个额外的内存来帮助实现这个算法，这些消耗的额外内存就是空间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0012-线性表</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0012-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0012-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>什么是线性表呢？可以理解为用一根线可以将所有数据串起来的数据集合。</p><p>比如：星座列表。</p><p><a href="https://baike.baidu.com/item/%E5%B7%A8%E8%9F%B9%E5%BA%A7/25908">巨蟹座</a> -&gt; <a href="https://baike.baidu.com/item/%E7%99%BD%E7%BE%8A%E5%BA%A7/2151709">白羊座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%8F%8C%E5%AD%90%E5%BA%A7/2535152">双子座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%AE%9D%E7%93%B6%E5%BA%A7">宝瓶座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%AE%A4%E5%A5%B3%E5%BA%A7">室女座</a> -&gt; <a href="https://baike.baidu.com/item/%E7%8B%AE%E5%AD%90%E5%BA%A7/9897905">狮子座</a> -&gt; <a href="https://baike.baidu.com/item/%E9%87%91%E7%89%9B%E5%BA%A7/9442523">金牛座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%8F%8C%E9%B1%BC%E5%BA%A7/2074740">双鱼座</a> -&gt; <a href="https://baike.baidu.com/item/%E6%91%A9%E7%BE%AF%E5%BA%A7/25946">摩羯座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%A4%A9%E8%9D%8E%E5%BA%A7/25945">天蝎座</a> -&gt; <a href="https://baike.baidu.com/item/%E5%A4%A9%E7%A7%A4%E5%BA%A7/25966">天秤座</a> -&gt; <a href="https://baike.baidu.com/item/%E4%BA%BA%E9%A9%AC%E5%BA%A7">人马座</a></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0013-线性表的抽象数据类型</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0013-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0013-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>这个了解了面向对象，还是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-comment">// 判断表是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 清空线性表</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 获取指定位置的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findNode</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 在指定位置添加一个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, <span class="hljs-keyword">int</span> index)</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 删除指定位置的元素，并返回它的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;&#125;<br>    <br>    <span class="hljs-comment">// 大小</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不同的需求，不同的线性表会有不同的方法，上面所写的，基本是最通用的一些方法。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0014-线性表的顺序储存</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0014-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0014-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>我们说过，顺序储存，就是一个一个的挨着摆好，在 Java 里面就是对应的数组。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-4-2.png?raw=true"></p><p>下面，我们就用数组来实现一个线性表。</p><p>首先，我们定义一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 因为无法创建泛型数组，所以我们使用 Object 来接受</span><br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">5</span>];<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们来实现，他的插入方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在指定位置添加一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkIndex(index);<br><br><br>    <span class="hljs-keyword">if</span> (isFull()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size() - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;<br>        array[i + <span class="hljs-number">1</span>] = array[i];<br>    &#125;<br><br>    array[index] = t;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面有两个新方法，一个 checkIndex，是用来判断 index 是否是有效的。一个是 size 是用来储存当前数组已被占用的大小，可以用一个 int 来储存，只要随时更新它的大小就好了。</p><p>看其他的逻辑，还是蛮简单的，当在一个指定的位置插入数据的时候，其他位置的数据都要向后移动一格。可以想象一下我们排队，有一个人插队的时候，后面的人就不得不往后退一步。如图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-5-1.png?raw=true"></p><p>再看一下删除方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除指定位置的元素，并返回它的值</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    checkIndex(index);<br><br>    <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    T temp = (T) array[index];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index + <span class="hljs-number">1</span>; i &lt; size(); i++) &#123;<br>        array[i - <span class="hljs-number">1</span>] = array[i];<br>    &#125;<br><br>    array[size() - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实与插入的逻辑一样，只不过插入是往后移动一格，删除是往前移动一格。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-5-2.png?raw=true"></p><p>实现了插入与删除之后，我们再来思考一下，这两个方法的时间复杂度。</p><p>根据前面学过的知识，我们知道，他的平均复杂时间度为 $O(\frac{n}2)$，最坏时间复杂度为  $O(n)$。</p><p>也就是说，我们每次的插入与删除操作，都可能需要面临移动所有元素的风险。这是顺序储存结构的不足。但是他也有优点，就是获取元素，非常快，只要知道元素的位置，可以立马找到，时间复杂度为  $O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0015-线性表的链式储存结构</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0015-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0015-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>之前，我们说过，用顺序储存在插入与删除的情况下是效率比较低的。我们分析一下原因：</p><p>每个元素是相邻的，当需要插入的时候，就必须要移动一些元素。想要提高插入与删除的效率，那么就不能让元素相邻。所以另外一种储存方案就被设计出来了——链式储存。</p><p>所谓链式储存，就是不仅储存数据，还需要储存下一个元素储存的位置，就像一条链子一样，<strong>我们叫这种数据结构为单链表</strong>。如图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-6-2.png?raw=true"></p><p>要注意的是：<strong>链表中的第一个节点的储存位置叫头指针。</strong></p><p>有两个概念比较容易混淆：头节点与头指针。</p><p>头指针是指向第一个节点的指针，如果链表有头节点，则头指针指向头节点，如果链表没有头节点，则头指针指向第一个元素的节点。</p><p><strong>头节点是为了操作统一而创建的</strong>，一般只会储存第一个元素节点的位置信息。</p><p>看下面两个图：</p><ul><li>没有头节点</li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-6-7.png?raw=true"></p><ul><li>有头节点</li></ul><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-6-8.png?raw=true"></p><p>现在，我们来定义一下链表储存结构的节点的数据类型。</p><blockquote><p>首先，它要储存下一个元素的位置</p><p>然后，它还有能储存数据</p></blockquote><p>那么类就应该是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <br>    T t;<br>    Node&lt;T&gt; next;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>链表就可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Node&lt;T&gt; head;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>    &#125;<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0016-单链表的读取、插入、删除</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0016-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0016-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p>在开始一系列的插入删除方法之前，需要讲解一个东西，对代码的阅读非常有好处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">node1.next = node.next;<br>node.next = node1;<br></code></pre></td></tr></table></figure><p>我们先不讨论这两行代码有什么意思。光从代码上看，发现 node.next 既可以在 = 的左边，也可以在 = 的右边。在左边与在右边有着不同的意义。</p><p>在 = 左边表示 node.next 是当作一个容器，在 = 右边表示需要使用 node.next 容器里面的值。</p><p>在链式存储结构中，读取效率为比较低，不像在顺序储存结构中，可以直接拿出来。原因就是因为我们需要知道前一个元素，才能获取到后一个元素的位置。所以我们想要获取一个元素，需要从头指针开始寻找。</p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>看看读取的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 从第一个节点开始遍历</span><br>    Node&lt;T&gt; temp = head.next;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span> &amp;&amp; p &lt; index) &#123;<br>        p++;<br>        temp = temp.next;<br>    &#125;<br><br>    <span class="hljs-comment">// temp 不能为 null，为 null 表示 index 超过了链表的大小</span><br>    <span class="hljs-comment">// 理论上来说，p 是不会大于 index 的</span><br>    <span class="hljs-keyword">if</span> (p &gt; index || temp == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> temp.t;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>思路解说：</p><ol><li>拿到第一个节点，因为我们不能直接改头节点，所以需要声明一个临时变量</li><li>将 next 节点赋值给自己，这样不断的寻找下一个节点</li><li>直到到达指定的位置</li></ol><p>时间复杂度为 $O(n)$。所以链表在获取元素的时候，效率很低。虽然它在获取元素时效率很低，但是对于插入与删除元素，效率很高哦。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>我们先来看两张图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-8-2.png?raw=true"></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-8-3.png?raw=true"></p><p>可以看出，插入节点的时候，不用管其他节点，只需要插入位置的前后两个节点即可。核心代码就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">newNode.next = p.next; <span class="hljs-comment">// 让新节点指向 p 后面的节点</span><br>p.next = newNode; <span class="hljs-comment">// 让 p 节点指向新节点</span><br></code></pre></td></tr></table></figure><p>还是非常简单的，但是千万不要搞反了，如果我们先执行了 <code>p.next = newNode</code>，那么 p 后面的那个节点，我们就找不到了，相当于链条断了。插入的过程，相当于将一个链条分成了两段，<strong>我们需要这两段的头指针（p 与 p.next</strong>），执行 <code>p.next = newNode</code> 就相当于丢弃了后面链条的头指针。</p><p>看看完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(T t, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// 从头节点开始遍历</span><br>    Node&lt;T&gt; temp = head;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span> &amp;&amp; p &lt; index) &#123;<br>        p++;<br>        temp = temp.next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p &gt; index || temp == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node&lt;T&gt; newNode = <span class="hljs-keyword">new</span> Node&lt;&gt;();<br>    newNode.t = t;<br><br>    newNode.next = temp.next;<br>    temp.next = newNode;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们还是需要先找到插入的位置的节点，才能开始进行插入。那么问题就来了，它的效率怎么就高了，不也是 $O(n)$ 么？</p><p>其实是这样的，如果我们不知道插入位置的节点指针，那么效率是没有什么优势的。但是如果我们知道了指针的值，则效率就会高很多，比如在第 i 个位置，插入 10 个、100个元素，这样的情况下，我们就不用每次都重新找节点的指针了，而是第一次找到之后，后面只需要更新一下指针的值就好了。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除过程也很简单，先看图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-8-5.png?raw=true"></p><p>思路如下：</p><ol><li>寻找要删除的节点</li><li>创建一个临时变量Q，指向要删除节点P的下一个节点</li><li>然后将要删除节点的前一个节点R的next赋值为Q</li><li>将 P 的数据清空</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// 从头节点开始遍历</span><br>    Node&lt;T&gt; temp = head;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span> &amp;&amp; p &lt; index) &#123;<br>        p++;<br>        temp = temp.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里还需要额外判断一下 temp.next</span><br>    <span class="hljs-comment">// 因为 temp.next 是要删除的节点</span><br>    <span class="hljs-comment">// 与插入不一样，插入时，temp.next为null不影响</span><br>    <span class="hljs-comment">// 删除、插入有多种写法，思路是一样的，只是细节不一样</span><br>    <span class="hljs-keyword">if</span> (p &gt; index || temp == <span class="hljs-keyword">null</span> || temp.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node&lt;T&gt; delete = temp.next;<br>    temp.next = delete.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0017-单链表的整表创建与整表删除</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0017-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0017-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<p>整表创建其实可以理解为一下子插入n个节点就好了。</p><h2 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h2><p>思路：</p><ul><li>创建一个新节点</li><li>将新节点插入到头节点后面</li><li>不断的循环这个过程n次</li></ul><p>看看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Node&lt;T&gt; newNode = createNewNode();<br>        newNode.next = head.next;<br>        head.next = newNode;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>非常 easy 啊。这种创建 List 的方法叫做头插法，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-9-1.png?raw=true"></p><h2 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h2><p>既然有头插法，肯定就有尾插法，嘿嘿嘿。了解了头插法，尾插法也差不多，我们理理思路：</p><ul><li><p>创建一个新节点</p></li><li><p>将新节点插入到头节点后面</p></li><li><p>不断的循环这个过程n次</p></li></ul><p>看起来很美好，但是有个问题，我们需要一个指针指向尾部，不然每次都要从头找起，就太沙雕了。</p><p>看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createList2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    Node&lt;T&gt; tail = head;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Node&lt;T&gt; newNode = createNewNode();<br>        newNode.next = tail.next;<br>        tail.next = newNode;<br>        tail = newNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是尾插法了，还是非常简单的，就多了一个变量而已。如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-9-3.png?raw=true"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除一个 list，思路与创建一个表反过来就好了。</p><p>因为我们持有了头节点，只要不断的删除头节点后面的那个节点就好了。</p><p>我们看看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearAll</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Node&lt;T&gt; delete = head.next;<br>    Node&lt;T&gt; next;<br>    <span class="hljs-keyword">while</span> (delete != <span class="hljs-keyword">null</span>) &#123;<br>        next = delete.next;<br>        <span class="hljs-comment">// 这个假设节点需要释放内存</span><br>        free(delete);<br>        delete = next;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有其他的需要，可以直接 head.next = null 就好了。嗯，应该可以的，反正是可以自动回收内存（没有别的地方引用Node）。</p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0052-2-3树</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0052-2-3%E6%A0%91/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0052-2-3%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>对于平衡二叉树来说，它的查询速度是没什么问题的，但是却有一个问题，每次插入元素之后，都需要保证树的平衡，而维持平衡的代价有点过于昂贵。 而为了<strong>解决查询效率同时有兼顾插入效率</strong>，于是提出了2-3树。 </p><h2 id="2-3树的定义"><a href="#2-3树的定义" class="headerlink" title="2-3树的定义"></a>2-3树的定义</h2><p>2-3树的每个节点可以保存1个和2个元素值。保存1个元素值的就叫 2 节点，保存2个元素值的就叫3节点。</p><p>2节点的只能有0个或2个孩子，3节点只能有0个或者3个孩子。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2_3_tree_1.png?raw=true"></p><p>上图中，红色为2节点，绿色为3节点。</p><p><strong>2-3树所有的叶子节点在同一层</strong>。这个特性比较关键。</p><p>2-3树也是排序树。2节点不用说，3节点的左子树小于节点左边元素值，中间子树介于节点两个元素之间，右子树大于节点右边的元素值。</p><h2 id="2-3树之插入节点"><a href="#2-3树之插入节点" class="headerlink" title="2-3树之插入节点"></a>2-3树之插入节点</h2><p>我们从一个空树讲起。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2_3_tree_2.png?raw=true"></p><p>可以看到，一个2节点变成了3节点，再升级为4节点，但是由于节点限制，必须要将4节点分裂成2节点。有没有像生命的循环一样。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2_3_tree_3.png?raw=true"></p><p>这个过程与上面的其实差不多，只不过上面的一开始是一个空树，所以可以直接分裂，但是这里不是空树，直接分裂是不可行的，需要将一个元素往父节点浮动，如果父节点也是一个3节点，那就继续往上浮动。</p><p>再看一个例子：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2_3_tree_4.png?raw=true"></p><p>这几个图看懂了之后，插入应该就没问题了（要用4节点做辅助思考，会更容易理解，也不容易忘记）。</p><h2 id="2-3树之删除节点"><a href="#2-3树之删除节点" class="headerlink" title="2-3树之删除节点"></a>2-3树之删除节点</h2><p>2-3树的删除很麻烦，就没找到一个能说的清除的，都是有多少中情况，一个一个的给你列出来，让你自己去体会去。</p><p>维基百科上也只说了插入与查找。</p><p>在一个网站上找了有删除逻辑的，用文字描述的，但是没看懂：</p><p> <a href="https://pages.cs.wisc.edu/~deppeler/cs400/readings/23Trees/">https://pages.cs.wisc.edu/~deppeler/cs400/readings/23Trees/</a> </p><p>似乎是以待删除节点的父节点为参考对象，分几种情况。</p><h2 id="B树的性质"><a href="#B树的性质" class="headerlink" title="B树的性质"></a>B树的性质</h2><p> B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-树就是指的B树。特此说明。</p><p>下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：</p><ol><li><p>根结点至少有两个子女。</p></li><li><p>每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m</p></li><li><p>每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m</p></li><li><p>所有的叶子结点都位于同一层。</p></li><li><p>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p></li></ol><h2 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h2><p> 一棵含有n个关键字数的m阶的B树的最大高度是多少? </p><p>有 n 个关键字的B树，有n+1个叶子节点（可以回想一下二叉树的性质）。</p><p>由于我们计算的是最坏情况，所以让每个节点的关键字最少即可，这样B树的高度会更大。</p><p>第一层只有一个根节点。</p><p>第二层最少可以只有两个节点。</p><p>第三层最少可以有 $2 * \frac{m}{2} $ 个节点（B树的性质，除根节点外，每个分支节点至少有m/2个子树）。</p><p>第 k 层最少可以有 $ 2 * (\frac{m}{2})^{k - 2}$ 个节点。</p><p>第 k+1 层 （叶子节点层，在原来的B树上再扩展一层，即为叶子节点）</p><p>即 n +1 = $ 2 * (\frac{m}{2})^{k - 1}$，</p><p>所，k = $log_{\frac{m}{2}} (\frac{n+1}{2}) + 1 $</p><h2 id="B-树的性质"><a href="#B-树的性质" class="headerlink" title="B+树的性质"></a>B+树的性质</h2><ol><li><p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p></li><li><p>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p></li><li><p>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p></li></ol><h2 id="B-树介绍"><a href="#B-树介绍" class="headerlink" title="B+树介绍"></a>B+树介绍</h2><p><img src="http://img.mp.sohu.com/upload/20170713/358025867be14bb99bf8806b98e774d9_th.png"></p><p>B+树看起来很奇怪：</p><ul><li>它的节点之间有重复的元素</li><li>它的叶子节点之间还有指针</li></ul><p>看它的重复元素的规律：</p><p><img src="http://img.mp.sohu.com/upload/20170713/0611ff5a5103461e843ab627f8821419_th.png"></p><p>每个父节点的元素都出现在子节点中。</p><p>我们拿数据库来距离说明它的作用：假设上图中的数字是数据库中的行号（行中有我们想要查询的数据）。</p><p>当我们想要查询第 5 行的数据时，查询过程是这样的：</p><p>第一次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/6808907785b84be09d8c6b7c8acb5d2a_th.png"></p><p>第二次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/0193eedf3a5b47129340e2b6c654ef72_th.png"></p><p>这里虽然，我们查询到了 5，但是这里只有一个索引记录，没有行中的数据，想要行中的数据，我们需要找到叶子节点，所以继续往下查询。</p><p>第三次磁盘IO：</p><p><img src="http://img.mp.sohu.com/upload/20170713/68553d369a304d798116f432247c6e3f_th.png"></p><p>这里，我们才能可以从这个节点中拿到卫星数据，卫星数据就是该行号对应的行数据。</p><p>除了随机查询外，B+树最大的优势在于范围查询，也就是子节点的要用指针链接起来的原因。</p><p>比如，我想查第 5-11行的数据，如果是B树的话，需要先查到5，然后使用中序遍历到6到11。而B+树的话，先查询到5之后，直接在指针上往后查询就好了，非常的方便。</p><p>参考链接： </p><p><a href="https://www.jishuwen.com/d/2VPs">漫画：什么是B-树？</a></p><p><a href="https://blog.csdn.net/qq_26222859/article/details/80631121">漫画：什么是b+树</a></p><p> <a href="https://www.youtube.com/watch?v=qlH4-oHnBb8">https://www.youtube.com/watch?v=qlH4-oHnBb8</a> </p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0053-面试中的算法</title>
    <link href="/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/18/blog_bak/Blog/%E7%AE%97%E6%B3%95/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="面试中的算法"><a href="#面试中的算法" class="headerlink" title="面试中的算法"></a>面试中的算法</h2><p>当时间复杂度为 O(1) 时，则无法再优化，需要从空间方面想办法。</p><p>同样的，当空间复杂度为 O(1)时，只能从算法时间方面想办法（需出奇兵）。</p><h3 id="如何判断链表中是否有环？"><a href="#如何判断链表中是否有环？" class="headerlink" title="如何判断链表中是否有环？"></a>如何判断链表中是否有环？</h3><p>最容易想到的就是将每个节点记录下来，然后判断判断是否出现过即可。这样的话空间复杂度为0(n)，如果想要空间复杂度为 O(1)，该如何做呢？</p><p>可以将链表想象成一条路，链表有环，即路也有环。想象一下操场。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574176264655&di=d230987c76ffce6b2f6c2e6c29da9eaa&imgtype=0&src=http://imgs.focus.cn/upload/news/7709/b_77082888.jpg"></p><p>操场的圆圈即链表的环。</p><p>判断一个链表有没有环，可以这样来。</p><p>我们小时候不是会进程做这样的题目么： 两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过 。这是因为跑的快的已经比跑的慢的多跑了一圈了，所以，我们可以利用这个现象来解决这个问题。</p><p>这个解决办法叫做快慢指针法。具体过程如下：</p><p>首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。</p><p>好的，解决方法理解了，那么下面出一些扩展内容：</p><h4 id="如何求出环的长度？"><a href="#如何求出环的长度？" class="headerlink" title="如何求出环的长度？"></a>如何求出环的长度？</h4><p>如果你能想出快慢指针法，那么这个问题也不难。如果你真的理解了快慢指针法，这个问题也不难。</p><p>就是让指针继续跑，再次相遇时，快指针就比慢指针多跑了一圈了，这个长度就是环的长度。我们只需要记下循环次数就好了。</p><h4 id="如何找到入环点？"><a href="#如何找到入环点？" class="headerlink" title="如何找到入环点？"></a>如何找到入环点？</h4><p>这个问题就有点难度了，涉及到数学知识。看下面的图：</p><p><img src="linklist_ring.png"></p>]]></content>
    
    
    <categories>
      
      <category>大话数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法-大话数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle Transform API ：直接修改 class 文件</title>
    <link href="/2019/08/18/blog_bak/Blog/Android/Gradle%20Transform%20API%20%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%20class%20%E6%96%87%E4%BB%B6/"/>
    <url>/2019/08/18/blog_bak/Blog/Android/Gradle%20Transform%20API%20%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%20class%20%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>首先，我要说的是，我没想到写这篇文章会遇到那么多的难点。其次在写这篇文章的时候，我还是处于一个半吊子的状态，但是我想应该还是会比现有的大部分blog要好的多。我几乎将Google到的索引到的前几页文章全部看了一遍，但是大部分都是相同的内容，就只有一篇我印象比较深，写的比较全面，但是我仍然还有很多疑问。</p><p>下面的文章我会提出我自己在学习这个知识点时想要问的问题，有些问题我可以自己解答，但是有些还是摸棱两可。</p><p>首先列出阅读这篇文章所需要的基础知识，如果你连这些都没有掌握的话，就不建议往下看了，会很痛苦，除非你只是想了解一下。</p><ul><li>Goorvy 基本语法</li><li>Gradle 构建</li><li><a href="https://my.oschina.net/ta8210?tab=newest&catalogId=388001">ASM</a></li></ul><p>前两个知识点有一个快速掌握的方法，阅读这个 <a href="http://wiki.jikexueyuan.com/project/deep-android-gradle/">PDF</a> 文件，写的还是非常不错的，我花了一个小时看完，我看的比较快，因为我看过《Gradle权威指南》这本书。</p><p>好了，从这里开始，我就当你已经掌握了上面的相关知识点。</p><h3 id="Gradle-工作流程"><a href="#Gradle-工作流程" class="headerlink" title="Gradle 工作流程"></a>Gradle 工作流程</h3><p>Gradle 是一个框架，它定义一套自己的游戏规则。我们要玩转 Gradle，必须要遵守它设计的规则。</p><p>下面我们来讲讲 Gradle 的基本组件：</p><ul><li>Gradle 中，<strong>每一个待编译的工程都叫一个 Project</strong>。每一个 Project 在构建的时候都包含一系列的 Task。比如<br>一个 Android APK 的编译可能包含：Java 源码编译 Task、资源编译 Task、JNI 编译 Task、lint 检查 Task、打包生成 APK 的 Task、签名 Task 等。</li><li><strong>一个 Project 到底包含多少个 Task，其实是由编译脚本指定的插件决定</strong>。插件是什么呢？插件就是用来定义 Task，并具体执行这些 Task 的东西。</li></ul><p>Gradle 作为框架，它负责定义流程和规则，而具体的编译工作则是通过插件的方式来完成的。比如编译 Java 有 Java 插件，编译 Groovy 有 Groovy 插件，编译 Android APP 有 Android APP 插件，编译 Android Library 有 Android Library 插件。好了，到现在为止，你知道 Gradle 中每一个待编译的工程都是一个 Project，一个具体的编译过程是由一个一个的 Task 来定义和执行的。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B7.PNG?raw=true"></p><p>在 Android Stuido 中，每个 moudle  都有自己的 build.gradle 文件。在构建的时候，<strong>每一个 build.gradle 文件都会转换成一个 Project 对象</strong>。</p><p>一个 Project 会包含若干 Tasks。另外，由于 Project 对应具体的工程，所以需要为 Project 加载所需要的插件，比如：为 Java 工程加载 Java 插件，为 Android 工程加载 Android 插件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B73.PNG?raw=true"></p><p>这里就为该工程加载了 3 个插件。一般的插件可以直接使用，但是有的插件可能还需要配置扩展。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B72.PNG?raw=true"></p><p>如上图所示，这是属于  <code>com.android.application</code> 插件的一个 android 扩展。在这里我们就可以配置该扩展的一些属性。</p><p>了解了这些，我们继续。</p><p>Gradle 工作包含三个阶段：</p><ol><li>首先是<code>Initiliazation</code>阶段：对我们前面的 multi-project build 而言，就是执行 settings.gradle。</li><li>然后是 <code>Configration</code> 阶段：<code>Configration</code> 阶段的目标是解析每个 project 中的 build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过 API 来添加的。</li><li><code>Configuration</code> 阶段完了后，整个 build 的 project 以及内部的 Task 关系就确定了。前面说过，一个Project 包含很多 Task，每个 Task 之间有依赖关系。Configuration 会建立一个有向图来描述 Task 之间的依赖关系。所以，我们可以添加一个 HOOK，即当 Task 关系图建立好后，执行一些操作。</li><li>最后一个阶段就是执行任务了。</li></ol><h3 id="Transform-API-为什么可以修改-class-文件"><a href="#Transform-API-为什么可以修改-class-文件" class="headerlink" title="Transform API 为什么可以修改 class 文件"></a>Transform API 为什么可以修改 class 文件</h3><p>我们知道，一个 project 的构建是由很多 task 组成的，而这些 task 是有依赖关系的。我们结合一下 App 的打包流程来看一下，各个 task 是发生在什么时候。</p><p>在 App 打包的时候，首先需要先将 java 文件编译为 class 文件（这里不关心一些其他的 AIDL 之类的），然后将 jar 与 class 文件达成 dex 文件。由于工程是 Gradle 构建的，Gradle 的构建是基于 Task 的，所以这些编译java文件，打包 class 文件都是在 task 中执行的。</p><p>在构建的过程中，这些 Task 都是由 TaskManager 管理的：</p><blockquote><p>com.android.build.gradle.internal.TaskManager#createCompileTask</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCompileTask</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> VariantScope variantScope)</span> </span>&#123;<br>    TaskProvider&lt;? extends JavaCompile&gt; javacTask = createJavacTask(variantScope);<br>    addJavacClassesStream(variantScope);<br>    setJavaCompilerTask(javacTask, variantScope);<br>    createPostCompilationTasks(variantScope);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是先执行了 javac 的编译任务，然后执行 post 编译任务。</p><blockquote><p>com.android.build.gradle.internal.TaskManager#createPostCompilationTasks</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createPostCompilationTasks</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NonNull</span> TaskFactory tasks,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> VariantScope variantScope)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// ----- External Transforms -----</span><br>    <span class="hljs-comment">// 添加自定义的 Transform</span><br>    List&lt;Transform&gt; customTransforms = extension.getTransforms();<br>    List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, count = customTransforms.size() ; i &lt; count ; i++) &#123;<br>        Transform transform = customTransforms.get(i);<br>        AndroidTask&lt;TransformTask&gt; task = transformManager<br>                .addTransform(tasks, variantScope, transform);<br>        ...<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// ----- Minify next -----</span><br>    <span class="hljs-comment">// minifyEnabled 为 true 表示开启混淆</span><br>    <span class="hljs-comment">// 添加 Proguard Transform</span><br>    <span class="hljs-keyword">if</span> (isMinifyEnabled) &#123;<br>        <span class="hljs-keyword">boolean</span> outputToJarFile = isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode;<br>        createMinifyTransform(tasks, variantScope, outputToJarFile);<br>    &#125;<br>    ...<br>    <br>    <span class="hljs-comment">// non Library test are running as native multi-dex</span><br>    <span class="hljs-keyword">if</span> (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123;<br>        ...<br>        <span class="hljs-comment">// 添加 JarMergeTransform</span><br>        <span class="hljs-comment">// create a transform to jar the inputs into a single jar.</span><br>        <span class="hljs-keyword">if</span> (!isMinifyEnabled) &#123;<br>            <span class="hljs-comment">// merge the classes only, no need to package the resources since they are</span><br>            <span class="hljs-comment">// not used during the computation.</span><br>            JarMergingTransform jarMergingTransform = <span class="hljs-keyword">new</span> JarMergingTransform(<br>                    TransformManager.SCOPE_FULL_PROJECT);<br>            variantScope.addColdSwapBuildTask(<br>                    transformManager.addTransform(tasks, variantScope, jarMergingTransform));<br>        &#125;<br><br>        <span class="hljs-comment">// 添加 MultiDex Transform</span><br>        <span class="hljs-comment">// create the transform that&#x27;s going to take the code and the proguard keep list</span><br>        <span class="hljs-comment">// from above and compute the main class list.</span><br>        MultiDexTransform multiDexTransform = <span class="hljs-keyword">new</span> MultiDexTransform(<br>                variantScope,<br>                extension.getDexOptions(),<br>                <span class="hljs-keyword">null</span>);<br>        multiDexClassListTask = transformManager.addTransform(<br>                tasks, variantScope, multiDexTransform);<br>        multiDexClassListTask.optionalDependsOn(tasks, manifestKeepListTask);<br>        variantScope.addColdSwapBuildTask(multiDexClassListTask);<br>    &#125;<br>    ...<br>    <span class="hljs-comment">// 添加 Dex Transform</span><br>    <span class="hljs-comment">// create dex transform</span><br>    DefaultDexOptions dexOptions = DefaultDexOptions.copyOf(extension.getDexOptions());<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法会遍历所有的 Transform，然后一一添加进 TransformManager。 添加完自定义的 Transform 之后，再添加 Proguard, JarMergeTransform, MultiDex, Dex 等 Transform。所以 Transform API 可以接触到 class 文件，这个时机是最好的处理时机。</p><h3 id="Transform-API-的使用"><a href="#Transform-API-的使用" class="headerlink" title="Transform API 的使用"></a>Transform API 的使用</h3><p>根据 Transform API 的 <a href="http://tools.android.com/tech-docs/new-build-system/transform-api">文档</a>，我们先自定义一个 Transform，然后将这个 Transform 注册到 android 扩展中即可。</p><p>自定义 Transform 我们后面会说到，这里我们想说如何注册。文档中对注册的描述只有一句话：</p><blockquote><p>To insert a transform into a build, you simply create a new class implementing one of the Transform interfaces, and register it with android.registerTransform(theTransform) or android.registerTransform(theTransform, dependencies).</p></blockquote><p>但是实际上设计到的问题很多。比如：如何拿到 android 扩展？？？</p><p>要拿到 android 扩展，<strong>一般我们是使用自定义一个插件的方式</strong>。由于 android 扩展中提供了 <code>registerTransform </code> 方法，所以是可以直接在 build.gradle 中调用的，但是它蛋疼的地方是这样搞的话，所有的逻辑都糅合在一起了。</p><p>下面我们介绍如何自定义一个插件，但是我们先来了解一下 Gradle 编程模型会好很多。 </p><h3 id="Gradle-编程模型"><a href="#Gradle-编程模型" class="headerlink" title="Gradle 编程模型"></a>Gradle 编程模型</h3><p>Gradle 基于 Groovy，Groovy 又基于 Java。所以，Gradle 执行的时候和 Groovy 一样，会把脚本转换成 Java对象。Gradle 主要有三种对象，这三种对象和三种不同的脚本文件对应，在 gradle 执行的时候，会将脚本转换成对应的对端：</p><ul><li><p>Gradle 对象：当我们执行 gradle xxx 或者什么的时候，<strong>gradle 会从默认的配置脚本中构造出一个 Gradle对象</strong>。在整个执行过程中，只有这么一个对象。Gradle 对象的数据类型就是 Gradle。我们一般很少去定制这个默认的配置脚本。</p></li><li><p>Project 对象：每一个 build.gradle 会转换成一个 Project 对象。</p></li><li><p>Settings 对象：显然，每一个 <strong>settings.gradle 都会转换成一个 Settings 对象</strong>。</p></li></ul><h3 id="自定义-Gradle-插件"><a href="#自定义-Gradle-插件" class="headerlink" title="自定义 Gradle 插件"></a>自定义 Gradle 插件</h3><h4 id="新建一个-module"><a href="#新建一个-module" class="headerlink" title="新建一个 module"></a>新建一个 module</h4><p>删除其他目录，只留下 src/main 目录与 build.gradle 文件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B74.PNG?raw=true"></p><p>然后在 main 目录下面，新建 groovy 目录 与 resouce 目录。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B75.PNG?raw=true"></p><p><strong>groovy 就是用来放 groovy 文件的，与 java 目录的作用一样</strong>。</p><p>resources 目录是用来配置插件的相关信息的。接着我们在 resources 目录下新建一个 META-INF 目录，再在 META-INF 目录下新建一个 gradle-plugins 目录。然后在 gradle-plugins 新建一个 aaa.bbb.properties 文件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B76.PNG?raw=true"></p><p>需要注意的是，<strong>这个文件的名字很重要，aaa.bbb 是你定义的插件的名字</strong>。什么意思呢？还记得我们是如何加载一个插件的吗？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;log.inject&#x27;</span><br></code></pre></td></tr></table></figure><p>看，这个文件的名字就是加载插件时用到的名字。</p><p>文件的内容，比较简单，由于我们是要自定义一个插件，所以需要在这里声明一下插件的名字。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">implementation-class</span>=<span class="hljs-string">com.aprz.log.LogPlugin</span><br></code></pre></td></tr></table></figure><p>这样，我们的第一步就完成了。</p><h4 id="实现一个插件类"><a href="#实现一个插件类" class="headerlink" title="实现一个插件类"></a>实现一个插件类</h4><p>一般的，我们需要自定义一个东西，都会有一个父类给我们使用，插件也不例外。我们需要实现 Plugin 接口：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Plugin</span>&lt;<span class="hljs-title">Project</span>&gt; &#123;</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> apply(Project project) &#123;<br><br>        println(<span class="hljs-string">&#x27;welcome to log inject plugin...&#x27;</span>)<br><br>        <span class="hljs-comment">// 找到项目中的 某个继承至 BaseExtension 的扩展</span><br>        <span class="hljs-keyword">def</span> ext = project.extensions.getByType(BaseExtension)<br>        <span class="hljs-comment">// 往该扩展中添加 transform</span><br>        <span class="hljs-comment">// 这里其实就是将我们自定义的这个 transform 添加到了集合中</span><br>        <span class="hljs-comment">// 但是这里让我想不明白的是，为什么这个添加 transform 的方法是在 extension 里面</span><br>        <span class="hljs-comment">// 而不是 project 里面，如果像 Java 工程，没有使用有扩展的插件该怎么办</span><br><br>        <span class="hljs-comment">// 查看源码发现了这样的代码：com.android.build.gradle.internal.TaskManager.createPostCompilationTasks</span><br>        <span class="hljs-comment">// AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br>        <span class="hljs-comment">// 它获取到了 android 扩展，然后拿到了其中的所有 transform</span><br>        <span class="hljs-comment">// 嗯，看来这个是针对 Android 构建的</span><br>        ext.registerTransform(<span class="hljs-keyword">new</span> LogsTransform(project))<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当这个插件按被加载（build.gradle 执行到 <code>apply plugin: &#39;xxxx&#39;  </code>）的时候，它的 apply 方法就会被调用，我们在这里可以注册我们的 Transform 了。其实如果不需要注册 transform，我们只想打印一下 log 的话，它也是一个插件，只不过是一个没啥屌用的插件而已。</p><p>要想自定义一个有用的插件，还需要对 Groovy 语法，gradle 文档有相当的了解才行。</p><h4 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h4><p>前面我们自定义了一个插件，但是需要发布之后，自己以及别人的项目才能使用，这里简单的说一下，<strong>如何发布到本地</strong>自己使用，想要发布到 bintray 等网站，可以自行查阅文档。</p><p>为了方便，我是使用了第三方的辅助插件。首先我们在根目录的 build.gradle 中添加依赖：</p><blockquote><p>TransformAPIDemo\build.gradle</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    classpath <span class="hljs-string">&#x27;com.novoda:bintray-release:0.9&#x27;</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Do not place your application dependencies here; they belong</span><br>    <span class="hljs-comment">// in the individual module build.gradle files</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在插件工程的 build.gradle 中添加配置：</p><blockquote><p>TransformAPIDemo\log_transform\build.gradle</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.novoda.bintray-release&#x27;</span><br><br>uploadArchives &#123;<br>    repositories &#123;<br>        mavenDeployer &#123;<br>            pom.groupId = <span class="hljs-string">&#x27;com.aprz.log.inject&#x27;</span><br>            pom.artifactId = <span class="hljs-string">&#x27;log&#x27;</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>            repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;E:/maven/repository&#x27;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br><br>publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;aprz512&#x27;</span><br>    groupId = <span class="hljs-string">&#x27;com.aprz.log.inject&#x27;</span><br>    artifactId = <span class="hljs-string">&#x27;log&#x27;</span><br>    publishVersion = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>    desc = <span class="hljs-string">&#x27;log inject demo&#x27;</span><br>    website = <span class="hljs-string">&#x27;https://github.com/aprz512/Transform-API-demo&#x27;</span><br>    repoName = <span class="hljs-string">&#x27;gradle_plugins&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>groupId</code>,<code>artifactId</code>,<code>version</code>这3个应该经常接触，就不说了，这里看 <code>repository</code> 的配置，是可以配置本地路径的。这里我配置的是 E 盘。执行发布命令：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B77.PNG?raw=true"></p><p>点击这个玩意，查看控制台输出：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B78.PNG?raw=true"></p><p>然后就可以在E盘看到发布的插件了。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/%E6%8D%95%E8%8E%B79.PNG?raw=true"></p><h3 id="自定义-Transform"><a href="#自定义-Transform" class="headerlink" title="自定义 Transform"></a>自定义 Transform</h3><p>上面我们自定义插件时提到了 Transform 的注册，里面创建了一个 Transform，但是我们没有深究，这里会仔细的分析一下。</p><p>自定义 Transform 同样的也需要继承一个父类：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogsTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Transform</span> &#123;</span><br><br>    LogsTransform() &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    String getName() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getClass().getSimpleName()<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.CONTENT_CLASS<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Set&lt;QualifiedContent.Scope&gt; getScopes() &#123;<br>        <span class="hljs-keyword">return</span> TransformManager.SCOPE_FULL_PROJECT<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">boolean</span> isIncremental() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> transform(TransformInvocation transformInvocation) <span class="hljs-keyword">throws</span> TransformException, InterruptedException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.transform(transformInvocation)<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们先用一张图来说明，transform 是如何工作的，然后再细说上面的每个方法是什么意思。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/6965.png?raw=true"></p><p>Transform每次都是将<strong>一个输入进行处理，然后将处理结果输出，而输出的结果将会作为另一个Transform的输入</strong>。每个 Transform 会处理某些特定的资源流，如何指定需要处理的资源流是通过 <code>getInputTypes</code> 与 <code>getScopes</code> 一起决定的。</p><p>下面一一解释上面的几个方法：</p><ul><li><p>getName</p><p>指明本Transform的名字，随意，但是<strong>不能包含某些特殊字符，否则会报错</strong>。</p></li><li><p>getInputTypes</p><p>指明Transform的输入类型，例如，返回 TransformManager.CONTENT_CLASS 表示配置 Transform 的输入类型为 Class。</p></li><li><p>getScopes</p><p>指明Transform的作用域，例如，返回 TransformManager.SCOPE_FULL_PROJECT 表示配置 Transform 的作用域为全工程。</p></li><li><p>isIncremental</p><p>指明是否是增量构建</p></li><li><p>transform</p><p>用于处理具体的输入输出，核心操作都在这里。上例中，配置 Transform 的输入类型为 Class， 作用域为全工程，因此在<code>transform</code>方法中，inputs 会传入工程内所有的 class 文件。</p></li></ul><p>通过 Scope 和 ContentType 可以组成一个资源流。例如，PROJECT 和 CLASSES，表示了主项目中java 编译成的 class 组成的一个资源流。再如，SUB_PROJECTS 和 CLASSES ，表示的是本地子项目中的 java 编译成的 class 组成的一个资源流。Transform 用来处理和转换这些流。</p><p>查看我们的代码中指定的域与类型，表示我们处理的是整个工程的 java 编译成的 class 文件。</p><p>接下来，我们来实现一个实例，自定义一个 Transform，这个 Transform 的作用是可以给所有父类是 <code>androidx.appcompat.app.AppCompatActivity</code>的类的 onCreate 方法都加入一个 log 语句。比如，原来的代码是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>改变 class 之后应该是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;log_inject&quot;</span>, <span class="hljs-string">&quot;onCreate&quot;</span>)<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>废话不多说，我们直接进入正题，由于 Transform 的主要内容都在 com.aprz.log.LogsTransform#transform 方法里面，我们就直接说这个方法：</p><blockquote><p>com.aprz.log.LogsTransform#transform</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(TransformInvocation transformInvocation)</span> <span class="hljs-keyword">throws</span> TransformException, InterruptedException, IOException </span>&#123;<br>    <span class="hljs-keyword">super</span>.transform(transformInvocation)<br><br>    <span class="hljs-comment">// inputs 包含了 jar 包和目录。</span><br>    <span class="hljs-comment">// 子 module 的 java 文件在编译过程中也会生成一个 jar 包然后编译到主工程中。</span><br>    transformInvocation.inputs.each &#123;<br>        input -&gt;<br><br>            <span class="hljs-comment">// 遍历目录</span><br>            <span class="hljs-comment">// 文件夹里面包含的是我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等</span><br>            input.directoryInputs.each &#123;<br>                DirectoryInput directoryInput -&gt;<br>                    directoryInput.file.eachFileRecurse &#123;<br>                        File file -&gt;<br>                            <span class="hljs-keyword">if</span> (checkFileName(file.name)) &#123;<br>                                injectClassFile(file)<br>                            &#125;<br>                    &#125;<br>                    copyDirectory(directoryInput, transformInvocation.outputProvider)<br>            &#125;<br><br><br>            <span class="hljs-comment">// 遍历 jar，我们不需要对 jar 进行处理，所以直接跳过</span><br>            <span class="hljs-comment">// 但是后面的 transform 可能需要处理，所以需要从输入流原封不动的写到输出流</span><br>            input.jarInputs.each &#123;<br>                jarInput -&gt;<br>                    copyJar(jarInput, transformInvocation.outputProvider)<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，inputs 分为两种类型的资源，一种是目录（目录里面都是生成的 class 文件），一种是 jar 包，它们需要分开遍历。由于我们只需要要处理目录，所以只针对目录讲解。</p><p>首先，我们对目录集合进行遍历，在对集合中的每个目录进行递归处理，最终到每个 class 文件，拿到这个 class 文件，我们就可以使用 ASM 修改这个 class 文件了。</p><blockquote><p>com.aprz.log.LogsTransform#injectClassFile</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> injectClassFile(File file) &#123;<br>    ClassReader classReader = <span class="hljs-keyword">new</span> ClassReader(file.bytes)<br>    ClassWriter classWriter = <span class="hljs-keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)<br>    ClassVisitor cv = <span class="hljs-keyword">new</span> LogClassVisitor(classWriter)<br>    <span class="hljs-comment">// 访问者模式</span><br>    classReader.accept(cv, ClassReader.EXPAND_FRAMES)<br>    <span class="hljs-keyword">byte</span>[] code = classWriter.toByteArray()<br>    FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<br>            file.parentFile.absolutePath + File.separator + file.name)<br>    fos.write(code)<br>    fos.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里开始，就是 ASM 的使用了。</p><h3 id="ASM-的使用"><a href="#ASM-的使用" class="headerlink" title="ASM 的使用"></a>ASM 的使用</h3><p>这里不介绍 API 的使用了，网上很多，还有官方文档，哪个都比我写得好。</p><p>这里介绍一下 ASM 的设计思想。</p><p>从上面的代码可以看到，<code>ClassReader</code> 的 <code>accept</code> 方法中传进来了一个参数<code>ClassVisitor</code>。在内部，<code>ClassVisitor</code>会不断的读取<code>ClassReader</code>的二进制byte[]，然后在解析后通过参数<code>classVisitor</code>的抽象<code>visitXXX</code>方法将属性全部转发出去，将其中的<code>visitXXX</code>方法按顺序抽离出来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">classVisitor.visit(readInt(items[<span class="hljs-number">1</span>] - <span class="hljs-number">7</span>), access, name, signature,superClass, interfaces);<br>classVisitor.visitSource(sourceFile, sourceDebug);<br>classVisitor.visitOuterClass(enclosingOwner, enclosingName,enclosingDesc);<br>classVisitor.visitTypeAnnotation(context.typeRef,context.typePath, readUTF8(v, c);<br>classVisitor.visitAttribute(attributes);<br>classVisitor.visitInnerClass(readClass(v, c),readClass(v + <span class="hljs-number">2</span>, c), readUTF8(v + <span class="hljs-number">4</span>, c),readUnsignedShort(v + <span class="hljs-number">6</span>));<br>classVisitor.visitField(access, name, desc,signature, value);<br>classVisitor.visitMethod(context.access,context.name, context.desc, signature, exceptions);<br>classVisitor.visitEnd();<br></code></pre></td></tr></table></figure><p>这里有很多 visit 方法，但是与真正的 class 文件的处理有关的，只有几个，比如：visitMethod，visitField 等。 这些 visit 方法，会创建一个相对应的 Writer 对象。</p><p>Writer 对象是什么呢？？？Writer 对象是 Visitor 的一个实现类。</p><p>ASM 在读取一个 class 文件的时候，会创建出一个 ClassWriter 对象，但是它不会把对元素（字段，方法，注解）的访问放到 ClassWriter 中，而是使用 <strong>访问者模式</strong>，将对这个元素的访问放到了 ClassVisitor 中。为何这样做，可以去看访问者模式。</p><p>当 ClassWriter 处理 class 文件的字节码的时候，比如遇到了一个方法，就会调用 ClassVisitor 的 visitMethod 方法。而 visitor 的实现实际上是 writer 类，所以会调用 writer 类的对应方法。这些方法会将字节码对应的部分给保存起来。而最后 <code>classWriter.toByteArray</code> 就会将所有的 writer 保存的字节码全部合并在一起，生成一个新的 class 文件。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/ASM.png?raw=true"></p><p>如果，我们自定义一个 MethodVisitor 就可以改变字节码。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E9%AB%98%E7%BA%A7/Transform%20API/ASM2.png?raw=true"></p><p>这里，我们覆盖 ClassVisitor 的 visitMethod 方法：</p><blockquote><p>com.aprz.log.asm.LogClassVisitor#visitMethod</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Override</span><br>MethodVisitor visitMethod(<span class="hljs-keyword">int</span> access, String name, String desc, String signature, String[] exceptions) &#123;<br>    <span class="hljs-keyword">if</span> (!checkSuperClass(<span class="hljs-built_in">this</span>.superName)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions)<br>    &#125;<br><br>    <span class="hljs-comment">// 由于是一个例子，我们就只处理 onCreate 方法了，想要深入应该去研究一下一个正规的开源项目</span><br><br>    <span class="hljs-comment">// 我的 demo 是 kotlin，tools里面有工具可以直接查看字节码，就非常方便</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;onCreate(Landroid/os/Bundle;)V&#x27;</span> == (name + desc)) &#123;<br><br>        println <span class="hljs-string">&quot;log &gt;&gt;&gt; method name = $&#123;name + desc&#125;&quot;</span><br><br>        MethodVisitor methodVisitor = <span class="hljs-built_in">this</span>.cv.visitMethod(access, name, desc, signature, exceptions)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogMethodVisitor(methodVisitor, name)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitMethod(access, name, desc, signature, exceptions)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们返回了我们自己定义的 LogMethodVisitor，将原来的 MethodVisitor 作为成员变量保存起来 。当 MethodVisitor 的相关方法被调用的时候，实际上会调用 LogMethodVisitor 的方法。这样，我们就可以搞事情了。比如：在刚进入方法的时候，会触发 visitCode 的调用：</p><blockquote><p>com.aprz.log.asm.LogMethodVisitor#visitCode</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *    L2</span><br><span class="hljs-comment"> *     LINENUMBER 13 L2</span><br><span class="hljs-comment"> *     LDC &quot;log_inject&quot;</span><br><span class="hljs-comment"> *     LDC &quot;onCreate&quot;</span><br><span class="hljs-comment"> *     INVOKESTATIC android/util/Log.e (Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="hljs-comment"> *     POP</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> visitCode() &#123;<br>    <span class="hljs-built_in">super</span>.visitCode()<br>    <span class="hljs-comment">// 在方法之前插入 Log.e(&quot;&quot;, &quot;&quot;)</span><br>    <span class="hljs-comment">// 这两个是参数</span><br>    <span class="hljs-built_in">this</span>.mv.visitLdcInsn(<span class="hljs-string">&#x27;log_inject&#x27;</span>)<br>    <span class="hljs-built_in">this</span>.mv.visitLdcInsn(<span class="hljs-built_in">this</span>.name)<br>    <span class="hljs-built_in">this</span>.mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="hljs-string">&#x27;android/util/Log&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;(Ljava/lang/String;Ljava/lang/String;)I&#x27;</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-comment">// 这里的用法有点奇怪，还需要研究一下</span><br>    <span class="hljs-comment">// visitXXX 实际上会触发 MethodWriter 的方法，这些方法会将我们想要写入的字节码存放起来</span><br>    <span class="hljs-comment">// 最后统一的写入到输出的 class 文件中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们就可以插入我们的字节码了。</p><p>到这里，东西就都介绍完毕了，只说了皮毛，要深入还是要看一个真正的项目才行。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><a href="https://github.com/aprz512/Transform-API-demo/tree/master"><strong>Transform-API-demo</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataBinding 原理分析</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-JetPack/DataBinding%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-JetPack/DataBinding%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>DataBinding 是一个支持库，它可以将布局中的界面组件绑定到数据源上，做到UI与数据的单项或者双向监听。说白一点就是数据发生变化可以直接反映到界面上，不用再次手动操作了。当然它的作用远远不止于此，本文从这个点入手，来略微深入一下它的实现过程。</p><p>首先，DataBinding可以将数据的变化反应到UI上，实际上就是帮助我们更新UI，那么它肯定需要持有（直接或者间接）UI的引用，不然的话，是没法操作UI的。用过DataBinding 的小伙伴应该都知道，DataBinding 会根据布局生成一个类，这个类里会有许多成员变量，每个变量对应着布局里面各个控件。</p><p>PS：<strong>因为每个项目生成的代码不一致，而且我使用了多个项目生成的代码，所以看的时候不要太纠结，尽量理解为主。</strong></p><p>举个例子吧，我们的布局如下：</p><blockquote><p>app\src\main\res\layout\content_main.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">variable</span></span><br><span class="hljs-tag">            <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewModel&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.user&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;android.view.View&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">data</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_name&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;viewModel.name&#125;&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_sex&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;viewModel.sex&#125;&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;50dp&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_class&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;50dp&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;50dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@&#123;viewModel.age&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里面看起来有很多高级的用法，实际上它经过编译之后，是下面这个样子的（因为没有在工程里面找到生成的文件，可能是新版本又换了位置，所以只能看apk里面的资源文件了）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:tag</span>=<span class="hljs-string">&quot;layout/content_main_0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-1&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-1&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@ref/0x7f0800c8&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:tag</span>=<span class="hljs-string">&quot;binding_1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-2&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@ref/0x7f0800c9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:tag</span>=<span class="hljs-string">&quot;binding_2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;dimension(12801)&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;dimension(12801)&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@ref/0x7f0800c7&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;dimension(12801)&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:tag</span>=<span class="hljs-string">&quot;binding_3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;-2&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;dimension(12801)&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>不要在意哪些 dimension/ref 之类的东西，关键点在于它给<strong>使用了 <code>@&#123;&#125;</code> 的控件都生成了一个 tag 属性</strong>。可以看出，tag 是有规律的：</p><blockquote><p>如果是根布局，为xml的名字，跟一个数字0，本例为 content_main_0。</p></blockquote><blockquote><p>如果不是根布局，为binding_x，x是数值，从1开始（根布局把0用了）。</p></blockquote><p>我们手动添加的layout，data，以及 @{viewModel.name} 这些看似高级的东西，其实在编译后都去掉了。那么它为什么要添加一个 tag 呢？？？其实是因为它在内部是使用了这个tag来获取view的引用。</p><p>我们知道，要使用 DataBinding，除了布局需要特殊写法，加载布局的时候，也需要特殊处理。拿 Activity 举例，我们要使用 DataBinding 加载布局，就不能像以前一样直接调用 setContentView，而是要使用 DataBindingUtil.setContentView 这个方法，那么我们就来分析一下这个方法。</p><blockquote><p>androidx.databinding.DataBindingUtil#setContentView(android.app.Activity, int)</p></blockquote><p>这个方法里面调用了其他方法，我们一直追踪下去，发现了它的核心方法是这个：</p><blockquote><p>androidx.databinding.DataBindingUtil#bind(androidx.databinding.DataBindingComponent, android.view.View, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataBinderMapper sMapper = <span class="hljs-keyword">new</span> DataBinderMapperImpl();   <br><br>...<br><br>    <span class="hljs-keyword">static</span> &lt;T extends ViewDataBinding&gt; <span class="hljs-function">T <span class="hljs-title">bind</span><span class="hljs-params">(DataBindingComponent bindingComponent, View root,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">int</span> layoutId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (T) sMapper.getDataBinder(bindingComponent, root, layoutId);<br>    &#125;<br></code></pre></td></tr></table></figure><p>DataBinderMapperImpl 是编译器生成了一个类，它的 getDataBinder 内容大致如下：</p><blockquote><p>com.aprz.snackbardemo.DataBinderMapperImpl#getDataBinder(androidx.databinding.DataBindingComponent, android.view.View, int)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ViewDataBinding <span class="hljs-title">getDataBinder</span><span class="hljs-params">(DataBindingComponent component, View view, <span class="hljs-keyword">int</span> layoutId)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);<br>  <span class="hljs-keyword">if</span>(localizedLayoutId &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">final</span> Object tag = view.getTag();<br>    <span class="hljs-keyword">if</span>(tag == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;view must have a tag&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">switch</span>(localizedLayoutId) &#123;<br>      <span class="hljs-keyword">case</span>  LAYOUT_CONTENTMAIN: &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;layout/content_main_0&quot;</span>.equals(tag)) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ContentMainBindingImpl(component, view);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The tag for content_main is invalid. Received: &quot;</span> + tag);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的 layoutId 就是 R.layout.content_main （我们使用DataBindingUtil#setContentView传入的值 ）。由于编译器自己生成了一个 Map，这个Map储存了所有需要 DataBinding 处理的 layoutId，layoutId 是key，value 是一个整数值。这里是我没有想通的地方，为啥要对应一个整数值，而不是直接使用 layoutId 呢？？？比如像下面这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(layoutId) &#123;<br>  <span class="hljs-keyword">case</span>  R.layout.content_main: &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;layout/content_main_0&quot;</span>.equals(tag)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ContentMainBindingImpl(component, view);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The tag for content_main is invalid. Received: &quot;</span> + tag);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个不影响，我们继续往下看，它最后返回了一个对象，叫做 ContentMainBindingImpl。使用过 DataBinding 的都应该会有点眼熟，因为我们使用的对象是 ContentMainBinding，而 ContentMainBindingImpl 看起来是 ContentMainBinding 的一个实现类。看一下他们的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContentMainBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewDataBinding</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ContentMainBindingImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentMainBinding</span></span><br></code></pre></td></tr></table></figure><p>也就是说，虽然我们使用的是 ContentMainBinding，但是它实际上是一个 ContentMainBindingImpl 对象。</p><p>我们继续，看 ContentMainBindingImpl 的构造方法：</p><blockquote><p>com.aprz.databindingdemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(android.databinding.DataBindingComponent, android.view.View)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContentMainBindingImpl</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> android.databinding.DataBindingComponent bindingComponent, <span class="hljs-meta">@NonNull</span> View root)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(bindingComponent, root, mapBindings(bindingComponent, root, <span class="hljs-number">5</span>, sIncludes, sViewsWithIds));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个叫做 mapBindings 的方法，就是它解析了View的 tag ，然后将view存储到了一个数组中，在将这个数组赋值给成员变量，这样我们就不用 findViewById 了，因为它的方法比较长，所以我不贴代码了，就简单的说一下它的工作过程。</p><blockquote><p>androidx.databinding.ViewDataBinding#mapBindings(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[], androidx.databinding.ViewDataBinding.IncludedLayouts, android.util.SparseIntArray, boolean)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (isRoot &amp;&amp; tag != <span class="hljs-keyword">null</span> &amp;&amp; tag.startsWith(<span class="hljs-string">&quot;layout&quot;</span>)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> underscoreIndex = tag.lastIndexOf(<span class="hljs-string">&#x27;_&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (underscoreIndex &gt; <span class="hljs-number">0</span> &amp;&amp; isNumeric(tag, underscoreIndex + <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-comment">// 这里的 index 就是 content_main_0 的 0</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index = parseTagInt(tag, underscoreIndex + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (bindings[index] == <span class="hljs-keyword">null</span>) &#123;<br>            bindings[index] = view;<br>        &#125;<br>        indexInIncludes = includes == <span class="hljs-keyword">null</span> ? -<span class="hljs-number">1</span> : index;<br>        isBound = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        indexInIncludes = -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是获取到 tag 以 layout 开头的 View，将这个view 放入到 bindings[0] 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag != <span class="hljs-keyword">null</span> &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123;<br>    <span class="hljs-comment">// 这里的 index 是 binding_1 的 1，当然不只是 1，还有 2，3....</span><br>    <span class="hljs-keyword">int</span> tagIndex = parseTagInt(tag, BINDING_NUMBER_START);<br>    <span class="hljs-keyword">if</span> (bindings[tagIndex] == <span class="hljs-keyword">null</span>) &#123;<br>        bindings[tagIndex] = view;<br>    &#125;<br>    isBound = <span class="hljs-keyword">true</span>;<br>    indexInIncludes = includes == <span class="hljs-keyword">null</span> ? -<span class="hljs-number">1</span> : tagIndex;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后获取以 tag 为 binding_ 开头的 View，放入到 bindings[1…n] 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!isBound) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = view.getId();<br>    <span class="hljs-keyword">if</span> (id &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> index;<br>        <span class="hljs-keyword">if</span> (viewsWithIds != <span class="hljs-keyword">null</span> &amp;&amp; (index = viewsWithIds.get(id, -<span class="hljs-number">1</span>)) &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>                bindings[index] == <span class="hljs-keyword">null</span>) &#123;<br>            bindings[index] = view;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果控件没有id，但是使用了 <code>@&#123;&#125;</code> 的用法，也会存入 bindings 数组中，这个index也是接着上面 binding_ 的数字，比如，上面最后一个是 binding_5，这里的 index 就是从 6 开始了，这些数值都是编译器生成好了的。我猜想是在处理 xml 的时候，就需要生成对应的类，然后将index对应好。</p><p>有了这个数组，显然只需要将它赋值给对应的变量就好了。我们可以生成控件的成员变量，然后以驼峰式命名，将数组的值赋值给对应的变量。</p><blockquote><p>com.aprz.snackbardemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[])</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ContentMainBindingImpl</span><span class="hljs-params">(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(bindingComponent, root, <span class="hljs-number">0</span><br>            , (android.widget.TextView) bindings[<span class="hljs-number">4</span>]<br>            , (android.widget.TextView) bindings[<span class="hljs-number">1</span>]<br>            , (android.widget.TextView) bindings[<span class="hljs-number">2</span>]<br>            );<br>        <span class="hljs-keyword">this</span>.mboundView0 = (android.widget.LinearLayout) bindings[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">this</span>.mboundView0.setTag(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.mboundView3 = (android.widget.TextView) bindings[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">this</span>.mboundView3.setTag(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.tvName.setTag(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">this</span>.tvSex.setTag(<span class="hljs-keyword">null</span>);<br>        setRootTag(root);<br>        <span class="hljs-comment">// listeners</span><br>        invalidateAll();<br>    &#125;<br><br>----------------------------------------<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">ContentMainBinding</span><span class="hljs-params">(Object _bindingComponent, View _root, <span class="hljs-keyword">int</span> _localFieldCount,</span></span><br><span class="hljs-params"><span class="hljs-function">      TextView tvClassName, TextView tvName, TextView tvSex)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(_bindingComponent, _root, _localFieldCount);<br>    <span class="hljs-keyword">this</span>.tvClassName = tvClassName;<br>    <span class="hljs-keyword">this</span>.tvName = tvName;<br>    <span class="hljs-keyword">this</span>.tvSex = tvSex;<br>  &#125;<br></code></pre></td></tr></table></figure><p>从代码里面可以看出，它确实是将bindings赋值给了成员变量。没有id的无法外部使用 ，所以是 ContentMainBindingImpl 的成员变量，内部名字叫做 mboundViewXXX。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-JetPack/DataBinding/2.png?raw=true"></p><p> 说了这么多，只是讲了一下它的如何不用 findViewById 的。但是 DataBinding 还有更重要的作用，就是数据绑定，我们接下来分析分析，它是如何将数据绑定到 UI 的，而且数据更新之后，是如何改变 UI 的！！！</p><p>实现数据绑定，我们需要调用binding.setVariable或者binding.setViewModel，两者效果一样，因为setVariable会间接调用setViewModel方法。</p><blockquote><p>com.aprz.databinding.ContentMainBindingImpl</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// variableId 是生成的BR文件中的一个变量，对应于你在 xml 中设置的变量</span><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setVariable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> variableId, <span class="hljs-meta">@Nullable</span> Object variable)</span>  </span>&#123;<br>       <span class="hljs-keyword">boolean</span> variableSet = <span class="hljs-keyword">true</span>;<br>       <span class="hljs-keyword">if</span> (BR.viewModel == variableId) &#123;<br>           setViewModel((com.aprz.snackbardemo.User) variable);<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           variableSet = <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> variableSet;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setViewModel</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> com.aprz.snackbardemo.User ViewModel)</span> </span>&#123;<br>       <span class="hljs-comment">// 这个方法有个坑，后面会说到</span><br>       <span class="hljs-keyword">this</span>.mViewModel = ViewModel;<br>       <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>           mDirtyFlags |= <span class="hljs-number">0x1L</span>;<br>       &#125;<br>       notifyPropertyChanged(BR.viewModel);<br>       <span class="hljs-keyword">super</span>.requestRebind();<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到实际上主要是调用了一下 notifyPropertyChanged 方法。notifyPropertyChanged  内部就是做了一个回调监听的操作，和我们的观察者模式没有区别，但是这里比较搞笑的就是，此时监听是为 null 的，也就是说没有注册观察者。</p><p>它在代码中表现的行为是这样的：我们创建一个对象A，将A通过 binding.setVariable 方法绑定到数据上，是可以正常显示出数据的，但是如果我们改变了对象A的某个属性，这个时候，属性的变化是无法反映到UI上的，我们还需要手动更新UI。</p><p>那么当我们改变了对象A的某个属性时，怎么才能自动更新UI 呢？参考官方文档的一个方法是使用 @Bindable 注解，比如我们的对象长这样：</p><blockquote><p>com.aprz.aboutme.MyName</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyName</span></span>(<span class="hljs-keyword">var</span> name: String) : BaseObservable() &#123;<br><br>    <span class="hljs-meta">@get:Bindable</span><br>    <span class="hljs-keyword">var</span> nickname: String = <span class="hljs-string">&quot;aprz&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = value<br>            notifyPropertyChanged(com.aprz.aboutme.BR.nickname)<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，每当 set 方法调用的时候，我们需要手机调用一下 notifyPropertyChanged 方法，这个时候，我们再看生成的文件，查看 <code>setViewModel</code> 方法：</p><blockquote><p>com.aprz.databinding.ContentMainBindingImpl#setViewModel</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setViewModel</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> com.aprz.snackbardemo.User ViewModel)</span> </span>&#123;<br>    <span class="hljs-comment">// hhh</span><br>    updateRegistration(<span class="hljs-number">0</span>, ViewModel);<br>    <span class="hljs-keyword">this</span>.mViewModel = ViewModel;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>        mDirtyFlags |= <span class="hljs-number">0x1L</span>;<br>    &#125;<br>    notifyPropertyChanged(BR.viewModel);<br>    <span class="hljs-keyword">super</span>.requestRebind();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，第一行多了一行代码：updateRegistration，应该可以猜到，这个方法里面<strong>应该就是注册了观察者</strong>。为了验证我们的想法，查看一下这个方法：</p><blockquote><p>androidx.databinding.ViewDataBinding#updateRegistration(int, androidx.databinding.Observable)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateRegistration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> localFieldId, Observable observable)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> updateRegistration(localFieldId, observable, CREATE_PROPERTY_LISTENER);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的调用链比较深，我们只关心重要的方法，最后发现调用到了如下方法</p><blockquote><p>androidx.databinding.ViewDataBinding.WeakListener#setTarget</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTarget</span><span class="hljs-params">(T object)</span> </span>&#123;<br>    unregister();<br>    mTarget = object;<br>    <span class="hljs-keyword">if</span> (mTarget != <span class="hljs-keyword">null</span>) &#123;<br>        mObservable.addListener(mTarget);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 mTarget 是上面的 viewModel 变量，mObservable 是一个叫做 WeakPropertyListener 的类，因为我们省略了中间的调用过程，所以会有点突兀，但是我们把它当作一个 WeakListener 的一个包装类就好了，它持有 WeakListener 的引用而已。</p><p>再往下最终，会发现调用到了这里：</p><blockquote><p>androidx.databinding.BaseObservable#addOnPropertyChangedCallback</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addOnPropertyChangedCallback</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> OnPropertyChangedCallback callback)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mCallbacks == <span class="hljs-keyword">null</span>) &#123;<br>            mCallbacks = <span class="hljs-keyword">new</span> PropertyChangeRegistry();<br>        &#125;<br>    &#125;<br>    mCallbacks.add(callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就比较熟悉了吧，就是 notifyPropertyChanged 会触发监听回调，而这个监听就是在这里添加（注册）的。</p><p>经过上面的一连串调用，viewModel，WeakPropertyListener ，WeakListener ，就建立这样的一个关系：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-JetPack/DataBinding/1.png?raw=true"></p><p>因为 ViewModel 继承至 BaseObservable，所以它有一个成员变量：mCallbacks，而 <strong>updateRegistration 方法主要是添加了一个观察者</strong>。实际上DataBinding的自动更新UI原理还是观察者，但是它的高明之处是编译器自动生成逻辑代码。</p><p>好的，说完了观察者的注册，还有一步需要完成，就是通知观察者数据发生了变化。应该还记得，我们的 ViewModel 里面，set 方法都调用了一个方法<code>notifyPropertyChanged</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@get:Bindable</span><br><span class="hljs-keyword">var</span> nickname: String = <span class="hljs-string">&quot;aprz&quot;</span><br>    <span class="hljs-keyword">set</span>(value) &#123;<br>        field = value<br>        notifyPropertyChanged(com.aprz.aboutme.BR.nickname)<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个很显然就是通知观察者，我们的数据发生了变化，我们看看源码吧（其实不看都知道，最终触发了 mCallbacks 的回调）。同样的经过多层调用，到了下面的方法：</p><blockquote><p>androidx.databinding.ViewDataBinding#handleFieldChange</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleFieldChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mLocalFieldId, Object object, <span class="hljs-keyword">int</span> fieldId)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mInLiveDataRegisterObserver) &#123;<br>        <span class="hljs-comment">// We&#x27;re in LiveData registration, which always results in a field change</span><br>        <span class="hljs-comment">// that we can ignore. The value will be read immediately after anyway, so</span><br>        <span class="hljs-comment">// there is no need to be dirty.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> result = onFieldChange(mLocalFieldId, object, fieldId);<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        requestRebind();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是两个方法，先看第一个，看名字就应该是字段发生了变化的处理，该方法会调用到下面的方法：</p><blockquote><p>com.aprz.aboutme.databinding.ActivityMainBindingImpl#onChangeMyName</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onChangeViewModel</span><span class="hljs-params">(com.foxlee.testdatabinding.NewsViewModel ViewModel, <span class="hljs-keyword">int</span> fieldId)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (fieldId) &#123;<br>        <span class="hljs-keyword">case</span> BR.name: &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>                    mDirtyFlags |= <span class="hljs-number">0x2L</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> BR.value1: &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>                    mDirtyFlags |= <span class="hljs-number">0x4L</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> BR._all: &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>                    mDirtyFlags |= <span class="hljs-number">0x1L</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实啥都没做，就只给 mDirtyFlags 设置了一个标记位，这里就很灵性了，它不是与我们通常的想法一样，给每个字段分别处理，而是只是设置一个标记。</p><p>再看 requestRebind，从名字也可以看出来，应该是重新绑定，<strong>因为 onChangeMyName 给字段发生了变化的位设置了标记，所以在这个方法里面，应该就是根据标志位来刷新UI了</strong>，好，我们看看：</p><blockquote><p>androidx.databinding.ViewDataBinding#requestRebind</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestRebind</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mContainingBinding != <span class="hljs-keyword">null</span>) &#123;<br>        mContainingBinding.requestRebind();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (USE_CHOREOGRAPHER) &#123;<br>            mChoreographer.postFrameCallback(mFrameCallback);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mUIThreadHandler.post(mRebindRunnable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对View的绘制源码有一点了解的，这里应该很好理解，这里就是刷新UI 了。然后继续往下追踪，它会调用到这个方法：</p><blockquote><p>com.aprz.aboutme.databinding.ActivityMainBindingImpl#executeBindings</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((dirtyFlags &amp; <span class="hljs-number">0xfL</span>) != <span class="hljs-number">0</span>) &#123;<br><br><br>    <span class="hljs-keyword">if</span> ((dirtyFlags &amp; <span class="hljs-number">0xbL</span>) != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (viewModel != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// read viewModel.name</span><br>                viewModelName = viewModel.name;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((dirtyFlags &amp; <span class="hljs-number">0xdL</span>) != <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (viewModel != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// read viewModel.value1</span><br>                viewModelValue1 = viewModel.value1;<br>            &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// batch finished</span><br><span class="hljs-keyword">if</span> ((dirtyFlags &amp; <span class="hljs-number">0xdL</span>) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// api target 1</span><br><br>    com.foxlee.testdatabinding.NewsViewModel.onTestChange(<span class="hljs-keyword">this</span>.mboundView3, viewModelValue1);<br>    com.foxlee.testdatabinding.NewsViewModel.onTestChange(<span class="hljs-keyword">this</span>.tvValue, viewModelValue1);<br>&#125;<br><span class="hljs-keyword">if</span> ((dirtyFlags &amp; <span class="hljs-number">0xbL</span>) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// api target 1</span><br><br>    com.foxlee.testdatabinding.NewsViewModel.onTestChange(<span class="hljs-keyword">this</span>.tvName, viewModelName);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个方法里面就是根据 dirtyFlags 的标志位来更新UI的。这个标志位的算法需要说一下，我们拿 name 的更新举例子：</p><p>在 <code>onChangeViewModel</code> 方法中，name字段更新的时候，给 mDirtyFlags 设置的标志位是 <code>mDirtyFlags |= 0x2L;</code>，而在 <code>executeBindings</code> 方法中，判断 name 字段的更新是使用的 <code>dirtyFlags &amp; 0xbL</code> 来判断的，这是为啥呢？</p><p>这里不去深入研究它的计算规则了，只是简单的说一下：</p><p>0x1，0x2，0x4，0xb，0xd，0xf，他们转换成二进制是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 0001<br>0 0010<br>0 0100<br>0 1000<br>1 0000<br></code></pre></td></tr></table></figure><p>看出规律了没有，这些数只有其中一位为1，其余的都为1，按照这个思路，如果某个数的该位为1，那么应该就是需要更新该位对应的属性。有了这个猜想，我们看看下面的数(023， 0x25， 0x29,，0x31)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">10 0011<br>10 0101 <br>10 1001<br>11 0001<br></code></pre></td></tr></table></figure><p>这些数也是有规律的，他们第一位为1，最后一位为1，中间的数有一位为1。第一位为1，是用来保证更新所有字段的。中间的某位为1是与上面的位对应的，表示某个属性需要更新。第一位我还没搞清楚是用来做什么的（好像是与双向绑定有关系）。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-JetPack/DataBinding/20190714222649924.png?raw=true"></p><p>自动刷新UI我们分析完了，还有一个问题，就是UI变化的时候，是如何改变ViewModel的值的呢？</p><p>其实看上面的图，就可以看出一个大概，因为只有 ActitivyMainBindingImpl 有 ViewModel 的引用，所以肯定是它搞得事情。我们打开这个类就会发现这样的一些监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> android.databinding.InverseBindingListener tvField1androidTextAttrChanged = <span class="hljs-keyword">new</span> android.databinding.InverseBindingListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChange</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Inverse of user.field1</span><br>        <span class="hljs-comment">//         is user.setField1((java.lang.String) callbackArg_0)</span><br>        java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(tvField1);<br>        <span class="hljs-comment">// localize variables for thread safety</span><br>        <span class="hljs-comment">// user != null</span><br>        <span class="hljs-keyword">boolean</span> userJavaLangObjectNull = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">// user</span><br>        com.aprz.databindingdemo.User user = mUser;<br>        <span class="hljs-comment">// user.field1</span><br>        java.lang.String userField1 = <span class="hljs-keyword">null</span>;<br><br>        userJavaLangObjectNull = (user) != (<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (userJavaLangObjectNull) &#123;<br>            user.setField1(((java.lang.String) (callbackArg_0)));<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>嗯，这里的逻辑很简单，首先拿到 TextView 的值，然后设置到 user 变量里面。不用想都知道 InverseBindingListener 是用来监听 TextView 的文字变化的。这里是因为在自动生成的代码里面给 TextView 都添加了一个 TextWatcher。所以当它发生变化的时候，就会回调这个方法。</p><p>需要注意的是，双向绑定容易引起死循环，因为UI导致 ViewModel 发生变化，ViewModel 变化了，又要去刷新 UI，就会不断的重复这个过程，需要自己处理一下，就是在更新UI的时候，判断一下值是否与当前相同，相同的时候再去更新（通知监听变化了）。</p><p>PS：</p><p>坑：不支持merge标签。布局根节点必须是 . 同时layout只能包含一个View标签. 不能直接包含&lt;merge&gt;。</p><h3 id="Databinding-生成的文件之间的关系"><a href="#Databinding-生成的文件之间的关系" class="headerlink" title="Databinding 生成的文件之间的关系"></a>Databinding 生成的文件之间的关系</h3><p> 每一个 xxx.xml 对应着两个文件，一个 xxxBinding 类，一个 xxxBindingImpl 类。</p><h4 id="XXXBinding"><a href="#XXXBinding" class="headerlink" title="XXXBinding"></a>XXXBinding</h4><p>这个类里面存放的是xml里面的一些控件，以及 inflate 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewDataBinding</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ImageView ivClose;<br>  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XXXBinding</span><span class="hljs-params">(Object var1, View var2, <span class="hljs-keyword">int</span> var3, ImageView var4)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(var1, var2, var3);<br>        <span class="hljs-keyword">this</span>.ivClose = var4;<br><br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> XXXBinding <span class="hljs-title">inflate</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> LayoutInflater var0, <span class="hljs-meta">@Nullable</span> ViewGroup var1, <span class="hljs-keyword">boolean</span> var2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> inflate(var0, var1, var2, DataBindingUtil.getDefaultComponent());<br>    &#125;<br><br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="XXXBindingImpl"><a href="#XXXBindingImpl" class="headerlink" title="XXXBindingImpl"></a>XXXBindingImpl</h4><p>xxxBindingImpl 继承了 xxxBinding 类，它主要是给父类的控件变量字段赋值，然后根据一些变量的标志位做控件的更新，上面有说，这里就不展开了。</p><h4 id="DataBinderMapperImpl"><a href="#DataBinderMapperImpl" class="headerlink" title="DataBinderMapperImpl"></a>DataBinderMapperImpl</h4><p>上面说了，一个 xml 对应着两个文件，那么这个对应关系是谁储存的呢？答案就是这个 DataBinderMapperImpl 类。</p><p>我们可以看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ViewDataBinding <span class="hljs-title">getDataBinder</span><span class="hljs-params">(DataBindingComponent var1, View var2, <span class="hljs-keyword">int</span> var3)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> var4;<br>    <span class="hljs-keyword">if</span> ((var4 = a.get(var3)) &gt; <span class="hljs-number">0</span>) &#123;<br>        Object var5;<br>        <span class="hljs-keyword">if</span> ((var5 = var2.getTag()) == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;view must have a tag&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var4 == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;layout/a_common_pay_0&quot;</span>.equals(var5)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ACommonPayBindingImpl(var1, var2);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The tag for a_common_pay is invalid. Received: &quot;</span> + var5);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (var4 == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;layout/a_activity_wallet_pay_0&quot;</span>.equals(var5)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AActivityWalletPayBindingImpl(var1, var2);<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;The tag for a_activity_wallet_pay is invalid. Received: &quot;</span> + var5);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从，这个方法里面可以看出，它们的对应关系是使用字符串对应的，一个 xml 有一个固定的字符串，这个字符串又对应了 xxxBindingImpl 这个类。</p><p>但是，还有一个问题，这个 DataBinderMapperImpl 只是储存了自己 module 的映射关系，那它依赖的工程的映射关系，该怎么获取呢？</p><p>其实这个类还有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;DataBinderMapper&gt; <span class="hljs-title">collectDependencies</span><span class="hljs-params">()</span> </span>&#123;<br>   ArrayList&lt;DataBinderMapper&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;DataBinderMapper&gt;(<span class="hljs-number">18</span>);<br>   result.add(<span class="hljs-keyword">new</span> androidx.databinding.library.baseAdapters.DataBinderMapperImpl());<br>...<br>   <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><p>这个 collectDependencies 会收集各个依赖工程的 DataBinderMapperImpl 将它放到这里（aar的话，会根据里面的 databinding 的 bin 文件生成），最终会形成一个树状结构。</p><p>我们从app看起，app 的话会收集它直接依赖的子工程的 DataBinderMapperImpl，然后子工程也会收集它自己直接依赖的工程的 DataBinderMapperImpl ，这样就形成了一棵树，每个 xml 的对应的关系都被穿起来了，所以使用 DataBindingUtil 就可以获取到对应的实现类。</p><p>以上说到的相关文件，都可以在 build/ap_generated_sources （gradle 3.6.4） 里面找到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Jetpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解 RecyclerView 的缓存机制</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-View/RecyclerView%20%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-View/RecyclerView%20%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以后会尽量写非源码的东西，因为过一段时间之后，发现自己看自己的文章都费劲，而且，源码大部分是在分析方法的调用链，意义不大，需要多写写自己的体悟才行。如果有时候必须要写，也要简化调用链的分析，提供类图，写重点和结论。</p></blockquote><blockquote><p>本文的思路与结论是基于参考文档的<a href="https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-404ba3453714">Anatomy of RecyclerView: a Search for a ViewHolder</a>与 <a href="https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-continued-d81c631a2b91">Anatomy of RecyclerView: a Search for a ViewHolder (continued)</a> 这两篇文章而来。由于这两篇文章的某些观点与其他文章的的不一致，我经过自己的理解与推断调试后，是支持这两篇文章的观点的，所以当你阅读参考文档时，需要自己考量。</p></blockquote><h3 id="RecyclerView-的构成"><a href="#RecyclerView-的构成" class="headerlink" title="RecyclerView 的构成"></a>RecyclerView 的构成</h3><p>首先来从整体上来了解一下 RecyclerView</p><p>RecyclerView 有五虎上将：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>RecyclerView.LayoutManager</td><td>负责Item视图的布局的显示管理</td></tr><tr><td>RecyclerView.ItemDecoration</td><td>给每一项Item视图添加子View,例如可以进行画分隔线之类</td></tr><tr><td>RecyclerView.ItemAnimator</td><td>负责处理数据添加或者删除时候的动画效果</td></tr><tr><td>RecyclerView.Adapter</td><td>为每一项Item创建视图</td></tr><tr><td>RecyclerView.ViewHolder</td><td>承载Item视图的子布局</td></tr><tr><td>RecyclerView.Recycler</td><td>负责处理View的缓存</td></tr></tbody></table><p>RecyclerView的职责就是将Datas中的数据以一定的规则展示在它的上面，但说破天RecyclerView只是一个ViewGroup，它只认识View，不清楚Data数据的具体结构，所以两个陌生人之间想构建通话，<strong>我们很容易想到适配器模式</strong>，因此，RecyclerView需要一个Adapter来与Datas进行交流：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/o_1av9ij8ua17en59k1ahg13d1l7c9.png?raw=true?raw=true"></p><p>如上如所示，RecyclerView表示只会和ViewHolder进行接触，而<strong>Adapter</strong>的工作就是将Data转换为RecyclerView认识的<strong>ViewHolder</strong>，因此RecyclerView就间接地认识了Datas。</p><p>事情虽然进展愉快，但RecyclerView是个很懒惰的人，尽管Adapter已经将Datas转换为RecyclerView所熟知的View，但RecyclerView并不想自己管理些子View，因此，它雇佣了一个叫做<strong>LayoutManager</strong>的大祭司来帮其完成布局，现在，图示变成下面这样：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/o_1av9iv5731k3422htsd14uess1j.png?raw=true"></p><p>如上图所示，LayoutManager协助RecyclerView来完成布局。但LayoutManager这个大祭司也有弱点，就是它只知道如何将一个一个的View布局在RecyclerView上，但它并不懂得如何管理这些View，如果大祭司肆无忌惮的玩弄View的话肯定会出事情，所以，必须有个管理View的护法，它就是<strong>Recycler</strong>，LayoutManager在需要View的时候回向护法进行索取，当LayoutManager不需要View(试图滑出)的时候，就直接将废弃的View丢给Recycler，图示如下：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/o_1av9iujp712ctgik1slp1c7e1cg0e.png?raw=true"></p><p>到了这里，有负责翻译数据的Adapter，有负责布局的LayoutManager，有负责管理View的Recycler，一切都很完美，但RecyclerView乃何等神也，它下令说当子View变动的时候姿态要优雅(动画)，所以用雇佣了一个舞者<strong>ItemAnimator</strong>，因此，舞者也进入了这个图示:</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/o_1av9ji0c01s471j1c5t27vrvcge.png?raw=true"></p><p>如上，我们就是从宏观层面来对RecylerView有个大致的了解，可以看到，RecyclerView作为一个View，它只负责接受用户的各种讯息，然后将信息各司其职的分发出去。</p><p>还有最后一个 ，<strong>ItemDecoration</strong> 是为了显示每个 item 之间分隔样式的。它的本质实际上就是一个 Drawable。当 RecyclerView 执行到 <code>onDraw()</code> 方法的时候，就会调用到他的 <code>onDraw()</code>，这时，如果你重写了这个方法，就相当于是直接在 RecyclerView 上画了一个 Drawable 表现的东西。 而最后，在他的内部还有一个叫<code>getItemOffsets()</code>的方法，从字面就可以理解，他是用来偏移每个 item 视图的。当我们在每个 item 视图之间强行插入绘画了一段 Drawable，那么如果再照着原本的逻辑去绘 item 视图，就会覆盖掉 Decoration 了，所以需要<code>getItemOffsets()</code>这个方法，让每个 item 往后面偏移一点，不要覆盖到之前画上的分隔样式了。</p><p><strong>PS:</strong> </p><blockquote><p>其实 <strong>ItemDecoration</strong> 的宽高是计算在 itemview 中的，只不过 itemview 本身绘制区域没有那么大，留出来的地方正好的透明的，于是就透过 itemview 显示出了 ItemDecoration。那么就很有意思了，如果我故意在 ItemDecoration 的偏移量中写成0，那么 itemview 就会挡住 ItemDecoration，而在 itemview 的增加或删除的时候，会短暂的消失(透明)，这时候就又可以透过 itemview 看到 ItemDecoration 的样子。<strong>使用这种组合还可以做出意想不到的动画效果</strong>。</p></blockquote><p>虽然，Google 尽力的解耦了，但是在源码中有的地方还是会有逻辑混杂在一起的地方，比如：动画的处理。</p><h3 id="pre-layout-与-post-layout"><a href="#pre-layout-与-post-layout" class="headerlink" title="pre-layout 与 post-layout"></a>pre-layout 与 post-layout</h3><p>为了能够更好的理解下面的内容，这里先介绍一下 pre-layout 与 post-layout 是什么。</p><p>有这样的一个场景：我们有3个item【a, b, c】，其中a与b显示在屏幕上，当我们删除b的时候，c会显示出来。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_ZxzTdRCpireBVs4t.png?raw=true"></p><p>我们希望看到的是 c 从底部顺利滑动到它的新位置。</p><p>但这是如何发生呢？</p><p>我们知道新布局中 c 的最终位置，但我们如何知道它应该从何处开始滑动？</p><p>谷歌的解决方案提供如下：</p><p>在adapter发生更改后，RecyclerView会从LayoutManager请求两个布局。</p><p>第一个 —— pre-layout，因为我们可以收到适配器的变化，所以这里我们可以做一些特殊的处理。在我们的例子中，因为我们现在知道b被删除了，所以我们会额外的显示出c，尽管它已经超出界限。</p><p>第二个 ——post-layout，一个正常的布局，对应于更改后的适配器状态。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_8dtqyWtaehYM-7zm_.png?raw=true"></p><p>现在，通过比较pre-layout和post-layout中c的位置，我们可以正确地为其设置动画。</p><p>仔细思考一下这个动画，This kind of animation — when the animated view is not present either in previous layout or in the new one — is called <em>predictive animation</em>。</p><p>再思考一个场景：如果b只是发生了变化，而不是被删除了，那么会怎么样呢？</p><p>![](<a href="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_zzI5wYYr3KdkexZ4">https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_zzI5wYYr3KdkexZ4</a>_ (1).png?raw=true)</p><p>答案是，仍然会在 pre-layout 阶段将 C 放置到后面！为什么呢？因为无法预测C的动画是什么动画，也许动画使b的高度变小了呢，那么c就需要显示出来，如果没有，那么 C 就会被放到缓存里去。</p><h3 id="缓存介绍"><a href="#缓存介绍" class="headerlink" title="缓存介绍"></a>缓存介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recycler</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; mAttachedScrap = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ArrayList&lt;ViewHolder&gt; mChangedScrap = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">final</span> ArrayList&lt;ViewHolder&gt; mCachedViews = <span class="hljs-keyword">new</span> ArrayList&lt;ViewHolder&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ViewHolder&gt;<br>            mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mRequestedCacheMax = DEFAULT_CACHE_SIZE;<br>    <span class="hljs-keyword">int</span> mViewCacheMax = DEFAULT_CACHE_SIZE;<br><br>    RecycledViewPool mRecyclerPool;<br><br>    <span class="hljs-keyword">private</span> ViewCacheExtension mViewCacheExtension;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CACHE_SIZE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="scrap"><a href="#scrap" class="headerlink" title="scrap"></a>scrap</h4><p>scrap 缓存是 recyclerView 最先搜索的缓存，网上有很多缓存调用图，第一个缓存调用就是 scrap。</p><p>scrap 仅仅在 layout 期间不为空。当 LayoutManager 开始 layout 的时候（pre-layout 或 post-layout），会将所有的 viewHolder 都放到 scrap 中。然后一个个在取回来，除非有些 view 发生了变化。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_KgoerRKWCbps5ks-.png?raw=true"></p><p>这里说一个题外话，就是有人可能会问，为啥要先放到 scrap 了之后，再取出来啊，这不是没事找事么？</p><p>我的观点是：layout 的事归 LayoutManager 管，缓存的事归 Recycler 管。LayoutManager 不应该知到哪个 viewHolder 是否有效，这是一种职责分离设计。</p><p><strong>scrap 分为两个集合：mAttachedScrap 和 mChangedScrap</strong>：这两个比较特殊，我跟踪了一下 mAttachScrap 添加的时机，在 LinearLayoutManager 的 onLayoutChildren 方法里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;<br>    ...<br>        onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);<br>    <span class="hljs-comment">// 这里调用了 mAttachedScrap.add(holder);</span><br>    <span class="hljs-comment">// 这里也调用了 mChangedScrap.add(holder);</span><br>        detachAndScrapAttachedViews(recycler);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的调用时机很值得思考，它在布局的时候就放到缓存里面了，这里说明这个缓存针对的是屏幕上显示的View.</p><p>那么问题就来了，屏幕上显示的为什么要缓存起来呢？我的想法倾向于是减少 layout 方法调用带来的影响。</p><blockquote><p>比如说，当我们调用 notifyItemRangeChanged 方法的时候，会触发 requestLayout 方法，就会重新布局，重新布局的话，就会先将 viewHolder 放到 scrap 中（屏幕上变化的放入mChangedScrap 中，其余的放入mAttachedScrap 中），然后 fill 布局的时候，再从 mAttachedScrap 里面取出来直接使用。mChangedScrap  中的 viewHolder 会被移动到 RecycledViewPool 中，所以 mChangedScrap  对应的 item 需要从 pool 中取对应的 viewHolder，然后重新绑定。</p></blockquote><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/RecyclerView.png?raw=true"></p><p>现在再来思考一下，为什么需要 mChangedScrap 与 mAttachedScrap 这两个缓存？</p><p>因为 mChangedScrap 表示 item 变化了，有可能是数据变化，有可能是类型变化，所以它的 viewHolder 无法重用，只能去 RecycledViewPool 中重新取对应的，然后再重新绑定。</p><p>然后一点需要注意：mChangedScrap  只能在 pre-layout 中使用，mAttachedScrap 可以在 pre-layout 与 post-layout 中使用。</p><p>在继续讨论之前，需要先说明几个方法之间的区别：</p><ul><li><code>View</code>中的<code>detach</code>和<code>remove</code></li></ul><ol><li><code>detach</code> 在<code>ViewGroup</code>中的实现很简单，只是将当前<code>View</code>从<code>ParentView</code>的<code>ChildView</code>数组中移除，将当前<code>View</code>的<code>mParent</code>设置为<code>null</code>, 可以理解为轻量级的临时<code>remove</code>。</li><li><code>remove</code> 代表真正的移除，不光从<code>ChildView</code>数组中移除，其他和<code>View树</code>各项联系也会被彻底斩断。</li></ol><ul><li><code>Recycled View</code>中的<code>Scrap View</code></li></ul><ol><li><code>Scrap View</code>指的是在<code>RecyclerView</code>中，经历了<code>detach</code>操作的缓存。<code>RecyclerView</code>源码中部分代码注释的<code>detach</code>其实指代的是<code>remove</code>，此类缓存是通过<code>position</code>匹配的，不需要重新<code>bindView</code>。</li><li><code>Recycled View</code>指代的就是真正的移除操作<code>remove</code>后的缓存，取出时需重新<code>bindView</code>使用。</li></ol><h4 id="cache-与-pool"><a href="#cache-与-pool" class="headerlink" title="cache 与 pool"></a>cache 与 pool</h4><p>cache  与 pool 中储存的均属于 Recycled View ，需要重新 add 到 列表中。</p><p><strong>mCachedViews</strong>，这个比较简单。</p><blockquote><p>它是一个 ArrayList 类型，不区分 viewHolder 的类型，大小限制为2，但是你可以使用 <code>setItemViewCacheSize()</code>这个方法调整它的大小。</p></blockquote><p>由于它不区分 viewHolder 的类型，所以只能根据 position 来获取 viewHolder 。</p><p><strong>RecycledViewPool</strong>，它储存了各个类型的 viewHolder</p><blockquote><p> 最大数量为5，可以通过 setMaxRecycledViews() 方法来设置每个类型储存的容量。</p><p>还有一个重要的点就是，可以多个列表公用一个 RecycledViewPool，使用 setRecycledViewPool() 方法。</p></blockquote><p>这里顺便说一下，各个缓存的使用上的区别，也好对各个缓存池有一个大概的了解：</p><ul><li>如果在所有缓存中都没有找到 viewHolder，那就会调用 create 和 bind 方法。</li><li>如果在 pool （RecycledViewPool ） 中找到了，那么会调用 bind 方法。</li><li>如果在 cache （mCachedViews）中找到了，啥都不用做，直接显示就好了。</li></ul><p>所以，需要注意他们的区别，一个 viewHolder 进入到 cache 与进入到 pool 中是不一样的。</p><p>现在，我们来思考下一个问题：mCachedViews 的大小是有限制的，如果存不下了，怎么办？</p><p>实际上，mCachedViews 虽然是一个 ArrayList ，但是它的工作方式却和链表有点类似。当 mCachedViews 满了之后，它会将最先存入的元素移除，放入到 pool 中，如下图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_JKHlomcG7gdcpA7h_.png?raw=true"></p><p>当我们滑动列表的时候，一旦 item 超出了屏幕，那么就会被放入到 mCachedViews 中，如果满了，就会将“尾部”的元素移动到 pool 中，如果 pool 也满了，那么就会被丢弃，等待回收。</p><p>下面，用几个场景来巩固一下我们学到的知识：</p><p><strong>场景一：</strong></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_loJwYG5qlTLTRiTX_.png?raw=true"></p><p>先看图的左边（此时假设 cache 与 pool 中没有东西），当向下滑动时，3 最先进入 mCachedViews，随后是 4 与 5，5 会将3挤出来，3就会跑到 pool 中去了。</p><p>再看图的右边，继续向下滑动时，4 被 6 挤出来，放到了 pool 中，<strong>同时</strong>，8需要显示，那么就会先从 pool 中取，发现正好有一个 3，那么就会取出来，将 3 重新显示到屏幕上。</p><p><strong>场景二：</strong></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_lcgR2438JvV5g3Sz_.png?raw=true"></p><p>如果，向下滑倒7显示出来之后，不再继续向下，而是往上滑动，那么又会怎么样呢？</p><p>看图的右边，很明显，5 从 cache 中被取出来直接复用，不用重新绑定，7 被放入了 cache 中。</p><p><strong>思考一下，对于这种情况，我们应该如何加以利用呢？</strong></p><p><strong>比如，我们有一个壁纸库的列表，用户经常会上下（左右）滑动，那么我们增加 cache 的容量，就会获得更好得性能。然而对于feed流之类得列表，用户很少返回，所以增加 cache 容量意义不大。</strong></p><p>再深入一下，我们继续向上滑动，那么，6与 7 会放入到 cache 中，3 会从 pool 中取出来，但是，这里需要注意，因为 3 是从 pool 中取出来的，所以它需要重新绑定，但是从逻辑上来说，如果 3 位置的数据没有发生变化，它不需要重新绑定，也是有效的。<strong>所以，你也可以把这里当作一个优化点，在 onBindViewHolder() 方法中，检查一下。</strong></p><p>再再深入一下，在我们滑动的过程中，<strong>一个类型的 viewHolder 在 pool 中应该一直只会存在一个</strong>（除非你使用了 GridLayoutManager），所以，如果你的 pool 中存在多个 viewHolder 的话，<strong>他们在滚动过程中基本上是无用的</strong>。</p><p><strong>场景三：</strong></p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_wywfZF1PM6PCtRoH_.png?raw=true"></p><p>当我们调用 <code>notifyDataSetChanged()</code> 或者 <code>notifyItemRangeChanged(i, c)</code> （c这个范围非常大的时候），那么很多 viewHolder 都会最终被放入到 pool 中，因为 pool 只能放置 5 个，那么多余的就会被丢弃，等待回收。<strong>最重要的是会重新 create 与 bind 对性能影响比较大。如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">recyclerView.getRecycledViewPool().setMaxRecycledViews(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><h4 id="ViewCacheExtension"><a href="#ViewCacheExtension" class="headerlink" title="ViewCacheExtension"></a>ViewCacheExtension</h4><p>这个是需要自定义的，而且使用有很大的限制，所以不深入介绍了。</p><p>因为它需要你自己创建 viewHolder，并将它缓存起来，那么问题就来了。当我们删除或添加一个 item 的时候，AdapterHelper 回调  RecyclerView 通知它需要处理变化。 RecyclerView 会遍历当前显示的 viewHolder 然后移动它们的位置。但是这里有个bug，RecyclerView 根本不知道你创建的 viewHolder，所以它不会管你自己缓存的 viewHolder。</p><p>所以，如果你想使用的话，需要满足一些条件：</p><ul><li>位置固定，比如，广告位。</li><li>不会改变</li><li>数量合理，保存在内存中没啥关系。</li></ul><h4 id="Stable-Ids"><a href="#Stable-Ids" class="headerlink" title="Stable Ids"></a><strong>Stable Ids</strong></h4><p>之前我们说过，当调用 notifyDataSetChanged 的时候，recyclerView 不知道到底发生了什么，所以它只能认为所有的东西都发生了变化，即，将所有的 viewHolder 都放入到 pool 中。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_YxCK81raawU0apDG.png?raw=true"></p><p>但是，如果我们设置了 stable ids，那么就会不一样了：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_rGkt-nbbIBRxNsLu.png?raw=true"></p><p><strong>viewHolder 被放入了 scrap 中，而不是 pool 中</strong>。注意，这里，它的性能提升了很多！</p><ol><li>不用重新绑定，重新创建新的 viewHolder，不用重新 addView。addView会导致重新测量…</li><li>原来我们需要调用 notifyItemMoved(4, 6)，但是现在直接调用 notifyDataSetChanged() 就好了.</li></ol><p>这个方法应该在什么情况下使用呢？</p><p>当你可以为每一个item设置一个唯一的id的时候，注意有些时候直接使用 position 会导致item错乱。因为 position 不会变，但是item是会变的。</p><h3 id="setHasFixedSize"><a href="#setHasFixedSize" class="headerlink" title="setHasFixedSize()"></a>setHasFixedSize()</h3><p>这个方法有很详细的注释：</p><blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">RecyclerView can perform several optimizations <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> can know <span class="hljs-keyword">in</span> advance <span class="hljs-keyword">that</span> RecyclerView&#x27;s size <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> affected <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> adapter <span class="hljs-built_in">contents</span>. RecyclerView can still change <span class="hljs-keyword">its</span> size based <span class="hljs-keyword">on</span> other factors (e.g. <span class="hljs-keyword">its</span> parent&#x27;s size) <span class="hljs-keyword">but</span> this size calculation cannot depend <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> size <span class="hljs-keyword">of</span> <span class="hljs-keyword">its</span> children <span class="hljs-keyword">or</span> <span class="hljs-built_in">contents</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">its</span> adapter (except <span class="hljs-keyword">the</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> items <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> adapter).<br>&lt;p&gt;<br>If your use <span class="hljs-keyword">of</span> RecyclerView falls <span class="hljs-keyword">into</span> this category, <span class="hljs-keyword">set</span> this <span class="hljs-keyword">to</span> &#123;@code <span class="hljs-literal">true</span>&#125;. It will allow RecyclerView <span class="hljs-keyword">to</span> avoid invalidating <span class="hljs-keyword">the</span> whole layout when <span class="hljs-keyword">its</span> adapter <span class="hljs-built_in">contents</span> change.<br></code></pre></td></tr></table></figure></blockquote><p>意思就是说，如果你的 RecyclerView 的尺寸是固定的，那么你应该使用这个方法，因为 RecyclerView 的内部做了优化，在添加与删除等操作的时候，会走自己内部的 layout 方法，而不会走 View 体系的 layout 方法，所以这样就提升了性能。</p><p>我们看看这个字段在代码里面做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onItemsInsertedOrRemoved</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (hasFixedSize) layoutChildren();<br>   <span class="hljs-keyword">else</span> requestLayout();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是需要注意的是，设置了这个方法之后，RecyclerView 的宽高就基本不会变化了（除非它的parent变化了），所以如果你在 XML 里面使用的 wrap_content 的话，不能使用这个方法，其他情况下基本适用，特别是添加与删除特别频繁的。</p><p>到了这里，你应该可以回答下面的问题了：</p><ol><li><p>notifyDataSetChanged 与 notifyItemRangeChanged 的区别？</p></li><li><p>RecyclerView 与 ListView 缓存的区别？这个问题，即使你不知道 ListView 的缓存机制，也应该能说些什么。</p></li><li><p>如何对一个列表进行性能优化？调用 notifyDataSetChanged 时闪烁的原因？</p></li></ol><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.kymjs.com/code/2016/07/10/01/">https://www.kymjs.com/code/2016/07/10/01/</a></p><p><a href="https://juejin.im/post/5b79a0b851882542b13d204b">https://juejin.im/post/5b79a0b851882542b13d204b</a></p><p><a href="https://blog.saymagic.cn/2016/10/21/understand-recycler.html">https://blog.saymagic.cn/2016/10/21/understand-recycler.html</a></p><p><a href="https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-404ba3453714">Anatomy of RecyclerView: a Search for a ViewHolder</a></p><p><a href="https://android.jlelse.eu/anatomy-of-recyclerview-part-1-a-search-for-a-viewholder-continued-d81c631a2b91">Anatomy of RecyclerView: a Search for a ViewHolder (continued)</a></p><p><a href="https://blog.csdn.net/fyfcauc/article/details/54175072">RecyclerView机制解析: ChildHelper</a></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>压缩、混淆、优化你的App</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%B1%89%E5%8C%96/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86%E3%80%81%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84App/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%B1%89%E5%8C%96/%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86%E3%80%81%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84App/</url>
    
    <content type="html"><![CDATA[<p>为了让App的体积尽可能的小，我们在打 release 包的时候，应该开启 shrinking 选项来移除无用代码和资源。当开启 shrinking 后，还会带来一些额外好处，比如混淆，它会缩短App里面类与成员的名字，比如优化，它会采取一些激进的策略来进一步减小App的大小。</p><p>当我们的项目使用的是 <a href="https://developer.android.com/studio/releases/gradle-plugin#3-4-0">Android Gradle plugin 3.4.0</a> 及以上的时候，gradle 插件不再使用 ProGuard 来执行编译时的代码优化，而是使用 R8 编译器来处理下面的编译时任务：</p><ul><li><strong>代码压缩</strong>：检测 App 与依赖的 library 中的无用类，字段，方法，属性并移除它们（可以缓解一下 64K 问题）。比如：如果我们只使用了一个依赖库中的少量方法，代码压缩就可以识别这些使用的代码，并且移除哪些未使用的代码。</li><li><strong>资源压缩</strong>：移除打包App中的未使用的资源，包括library中未使用的资源。它最好与代码压缩一起使用，因为代码被移除之后，这些代码引用的资源也就可以安全移除了。</li><li><strong>混淆</strong>：缩短类与成员的名字的长度，也就可以减少 dex 的大小。</li><li><strong>优化</strong>：检查并重写代码，来进一步减小 dex 的大小。比如：R8发现 <code>else&#123;&#125;</code> 是一段无法到达的代码（永远不会走这个分支），那么它会移除这个 <code>else&#123;&#125;</code>分支。</li></ul><p>当构建 release 版本的时候，R8 会默认执行上面说的任务。你也可以通过 ProGuard 规则文件禁止这些任务的执行。实际上，R8 编译器与 ProGuard 一样，都会受到 ProGuard 规则文件的影响。</p><h2 id="开启压缩，混淆与优化"><a href="#开启压缩，混淆与优化" class="headerlink" title="开启压缩，混淆与优化"></a>开启压缩，混淆与优化</h2><p>当使用Android Studio 3.4或Android Gradle插件3.4.0及更高版本时，将项目的Java字节码转换为在Android平台上运行的DEX文件的默认编译器是 R8。但是，<strong>使用Android Studio创建新项目时</strong>，默认情况下不会启用这些优化。这是因为这些编译时优化会增加项目的构建时间，而且如果你不知道如何去自定义的保留代码，可能会导致运行时错误。</p><p>所以，最好是在准备发布，打包App的最终版本的时候，开启这些选项（module下的 build.gradle）：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    buildTypes &#123;<br>        release &#123;<br>            <span class="hljs-comment">// Enables code shrinking, obfuscation, and optimization for only</span><br>            <span class="hljs-comment">// your project&#x27;s release build type.</span><br>            minifyEnabled <span class="hljs-literal">true</span><br><br>            <span class="hljs-comment">// Enables resource shrinking, which is performed by the</span><br>            <span class="hljs-comment">// Android Gradle plugin.</span><br>            shrinkResources <span class="hljs-literal">true</span><br><br>            <span class="hljs-comment">// Includes the default ProGuard rules files that are packaged with</span><br>            <span class="hljs-comment">// the Android Gradle plugin. To learn more, go to the section about</span><br>            <span class="hljs-comment">// R8 configuration files.</span><br>            proguardFiles getDefaultProguardFile(<br>                    <span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>),<br>                    <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="R8-配置文件"><a href="#R8-配置文件" class="headerlink" title="R8 配置文件"></a>R8 配置文件</h2><p>R8使用 ProGuard 规则文件来修改其默认行为，还可以更好地了解应用程序的结构，例如那些作为应用程序代码入口点的类。尽管这些规则文件可以修改，但是有些规则文件是编译工具自动生成的，比如 AAPT2，还有些是从 library 中继承过来的。</p><p>下面这个表描述了 R8 使用的规则文件的来源：</p><table><thead><tr><th>Source</th><th>Location</th><th>Description</th></tr></thead><tbody><tr><td>Android Studio</td><td>&lt;module-dir&gt;/proguard-rules.pro</td><td>创建一个新的工程的时候，IDE会在 module 目录下生成一个文件，里面默认是没有应用任何规则，但是我们可以添加自定义规则。</td></tr><tr><td>Android Gradle plugin</td><td>Gradle 插件在编译时生成文件</td><td>Android Gradle插件会生成proguard-android-optimize.txt，其中包含对大多数Android项目有用的基本规则，并且还启用了 <code>@Keep</code> 注解。</td></tr><tr><td>Library dependencies</td><td>AAR libraries: <code>&lt;library-dir&gt;/proguard.txt</code> <br/> JAR libraries: <code>&lt;library-dir&gt;/META-INF/proguard/</code></td><td>如果AAR库在发布时使用自己的ProGuard规则文件，当我们的项目依赖该 AAR 时，则R8会在编译项目时自动应用其规则。<br />为AAR库配置打包的规则文件非常有用，因为它意味着——库开发人员已经为我们执行了故障排除步骤。<br />但是，我们应该知道，因为ProGuard规则是附加的，所以AAR库依赖项包含的某些规则无法删除，并且可能会影响应用程序其他部分的编译。例如，如果库包含禁用代码优化的规则，则该规则将禁用整个项目的优化。</td></tr><tr><td>Android Asset Package Tool 2 (AAPT2)</td><td>设置 minifyEnabled 为 true，构建之后，会生成文件 &lt;module-dir&gt;/build/intermediates/proguard-rules/debug/aapt_rules.txt</td><td>AAPT2根据应用程序manifest，布局和其他应用程序资源中的类的引用生成保留规则。例如，AAPT2为应用程序manifest中作为入口点注册的每个Activity都有保留规则。</td></tr><tr><td>自定义配置文件</td><td>与第一个一样，我们可以额外的创建一些文件用来指定规则，创建之后需要在 build.gradle 中配置</td><td>可以包含其他配置，R8会在编译时应用它们。</td></tr></tbody></table><p>将minifyEnabled属性设置为true时，R8会合并上面列出的所有可用来源的规则。当使用R8进行故障排除时，你一定要了解这些，以免出现一些你无法理解的行为，比如 library 中的规则影响到整个工程。</p><p>你可以使用下面的命令来输出一份详细的关于 R8 编译的报告文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">// You can specify any path and filename.<br>-printconfiguration ~/tmp/full-r8-config.txt<br></code></pre></td></tr></table></figure><h2 id="包含其他配置"><a href="#包含其他配置" class="headerlink" title="包含其他配置"></a>包含其他配置</h2><p>使用Android Studio创建新项目或模块时，IDE会创建|<module-dir> /proguard-rules.pro文件，以便我们包含自己的规则。我们还可以通过将其他规则文件添加到模块的build.gradle文件中的proguardFiles属性中来包含其他的规则。</p><p>例如，可以通过在相应的productFlavor块中添加另一个proguardFiles属性来为指定的构建变体添加额外的规则。下面的示例将<code>flavor2-rules.pro</code>添加到<code>flavor2</code>的 <code>product flavor</code>中。现在，<code>flavor2</code> 就有了3个规则文件，因为 release 块中配置的文件也包含在里面。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">true</span><br>            proguardFiles getDefaultProguardFile(<br>              <span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>),<br>              <span class="hljs-comment">// List additional ProGuard rules for the given build type here. By default,</span><br>              <span class="hljs-comment">// Android Studio creates and includes an empty rules file for you (located</span><br>              <span class="hljs-comment">// at the root directory of each module).</span><br>              <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>    flavorDimensions <span class="hljs-string">&quot;version&quot;</span><br>    productFlavors &#123;<br>        flavor1 &#123;<br>          ...<br>        &#125;<br>        flavor2 &#123;<br>            proguardFile <span class="hljs-string">&#x27;flavor2-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><p>将minifyEnabled属性设置为true时，默认情况下会启用使用R8的代码压缩。</p><p>代码压缩是 R8 删除在运行时不需要的代码的过程。整个过程可以极大的减少App的体积，特别是你引入很多库，但是每个库都只使用了少量的功能。</p><p>要压缩应用程序的代码，R8首先根据组合的配置文件集确定应用程序代码中的所有入口点。这些入口点包括Android平台可用于打开应用程序的所有Activity或Service。R8会从每个入口点开始检查应用程序的代码，检测应用程序可能在运行时访问的所有方法，成员变量和其他类，然后构建一个图。未连接到该图的代码被视为无法访问，可能会从应用中删除。如下图所示：</p><p><img src="https://developer.android.com/studio/images/build/r8/tree-shaking.png"></p><p>上图中建立的图结构中，OkayApi 类没有在其中，所以它会被删除。</p><p>R8 通过工程的配置文件集来决定所有入口点，也就是说，keep规则指定R8在缩小应用程序时不应丢弃的类，R8将这些类视为应用程序的可能入口点。Android Gradle插件和AAPT2会自动生成大多数应用项目所需的保留规则，例如应用的activities，views和services。当然，如果又需要，你也可以添加自己的规则。</p><p>或者，您可以将@Keep注释添加到要保留的代码中。在类上添加@Keep会使整个类保持原样。在方法或字段上添加它将保持方法/字段（及其名称）以及类名完整。请注意，此注释仅在使用<code>AndroidX</code>注释库时以及包含随Android Gradle插件打包的ProGuard规则文件时才可用。</p><h2 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h2><p>资源压缩只有配合代码压缩才会起作用。在代码缩减器删除所有未使用的代码之后，资源缩减器可以识别应用程序仍在使用哪些资源。添加包含资源的代码库时尤其如此 - 必须删除未使用的库代码，以便库的资源不会被引用，从而这些资源可以被资源缩减器移除。</p><p>想要开启资源缩减，只需要配置一下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    ...<br>    buildTypes &#123;<br>        release &#123;<br>            shrinkResources <span class="hljs-literal">true</span><br>            minifyEnabled <span class="hljs-literal">true</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>),<br>                    <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义需要保留的资源"><a href="#自定义需要保留的资源" class="headerlink" title="自定义需要保留的资源"></a>自定义需要保留的资源</h2><p>通过配置一个 xml 文件，你可以自定义需要保留或者丢弃的资源。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs groovy">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;<br>&lt;resources xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    tools:keep=<span class="hljs-string">&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;</span><br>    <span class="hljs-symbol">tools:</span>discard=<span class="hljs-string">&quot;@layout/unused2&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><code>tools:keep</code> 与 <code>tools:discard</code>都可以指定多个资源，使用分号隔开。还可以使用 * 号作为通配符。</p><p>将该文件放置到工程的资源目中，比如：<code>res/raw/keep.xml</code>。 该文件不会被打包到 APK 中。</p><p>指定哪些资源需要被删除，看起来没啥屌用，因为我们可以直接的手动删除这个资源。但是如果我们在构建多个 <code>variants</code> 的时候就非常有用了，比如，我们可能将所有资源放在了一个 common 工程中，然后创建了 keep.xml 来为每个 <code>variant</code> 来指定需要保留与丢弃的资源。因为这个时候，资源都在代码里面被引用了，所以资源缩减器不会移除这些资源。还有另外一种情况，构建工具可能无法区别资源id的引用与 int 值的区别，如果刚好某个资源的id与我们代码中int值相等，它也不会移除这个资源。</p><h2 id="开启严格引用检查"><a href="#开启严格引用检查" class="headerlink" title="开启严格引用检查"></a>开启严格引用检查</h2><p>通常情况下，资源缩减器可以正确的识别哪些资源被引用了。但是，如果我们这样引用资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Resources.getIdentifier()<br></code></pre></td></tr></table></figure><p>或者，我们的依赖库中有这样使用的（AppCompat就是）。遇到这种情况，资源缩减器默认情况下会采取<strong>防御措施</strong>，并将所有具有匹配名称格式的资源标记为可能已使用且无法删除。</p><p>举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> name = String.format(<span class="hljs-string">&quot;img_%1d&quot;</span>, angle + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">val</span> res = resources.getIdentifier(name, <span class="hljs-string">&quot;drawable&quot;</span>, packageName)<br></code></pre></td></tr></table></figure><p>这会将具有img_前缀的所有资源标记为已使用。</p><p>资源缩减器还会查看代码中的所有字符串常量以及各种<code>res/ raw/ </code>资源，以及类似于<code>file:///android_res/drawable//ic_plus_anim_016.png</code>的格式的资源URL。如果它发现像这样的字符串或者 url，它就不会移除这些资源。</p><p>这个行为默认是开启的，但是如果想要关闭它，就可以使用 <code>strict</code> 模式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:shrinkMode</span>=<span class="hljs-string">&quot;strict&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>开启了严格模式之后，使用上面的方式引用的资源也会被删除，所以我们需要在 <code>keep.xml</code> 里面保留这些资源。</p><h2 id="移除未使用的可选资源"><a href="#移除未使用的可选资源" class="headerlink" title="移除未使用的可选资源"></a>移除未使用的可选资源</h2><p>Gradle资源缩减器仅删除应用程序代码未引用的资源，这意味着它不会删除不同设备配置的备用资源。</p><p>如有必要，您可以使用Android Gradle插件的resConfigs属性来删除您的应用不需要的备用资源文件。</p><p>例如，如果您使用的是包含语言资源的库（例如AppCompat或Google Play服务），那么您的APK会包含这些库中所有翻译语言的字符串。如果您只想保留应用正式支持的语言，可以使用resConfig属性指定这些语言，删除未指定语言的资源。</p><p>下面的代码就展示了如何只保留两种语言资源：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy">android &#123;<br>    defaultConfig &#123;<br>        ...<br>        resConfigs <span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;fr&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只保留了英语与法语。同样的，我们还可以只保留某一屏幕密度下的资源。</p><h2 id="合并重复资源"><a href="#合并重复资源" class="headerlink" title="合并重复资源"></a>合并重复资源</h2><p>默认情况下，Gradle还会合并具有相同名称的资源，例如可能位于不同资源文件夹中的同名的drawable（这里应该指的是不同library的资源）。<strong>此行为不受shrinkResources属性控制，并且无法禁用</strong>，因为当多个资源与您的代码查找的名称匹配时，必须避免这种情况。</p><p>仅当两个或多个文件共享相同的资源名称，类型和限定符时，才会发生资源合并。 Gradle选择它认为最合适的一个并保留。</p><p>Gradle 从下面的路径来寻找重复的资源：</p><ul><li>src/main/res</li><li>build flavor 与 build type</li><li>依赖库</li></ul><p>资源优先级从低到高：</p><p>依赖库 → Main → Build flavor → Build type</p><p>举个例子：如果<code>Main</code>和<code>build flavor</code>中出现重复的资源，Gradle将选择<code>build flavor</code>中的资源。</p><p>如果重复资源在同一层次出现，比如<code>src/main/res/</code> 和 <code>src/main/res2/</code>，则 gradle 无法完成资源合并，这时会报资源合并错误。</p><h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>混淆的目的是通过缩短APP的类，方法和字段的名称来减少应用程序的大小。以下是使用R8进行混淆处理的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.appcompat.app.ActionBarDrawerToggle$DelegateProvider -&gt; a.a.a.b:<br>androidx.appcompat.app.AlertController -&gt; androidx.appcompat.app.AlertController:<br>    android.content.Context mContext -&gt; a<br>    <span class="hljs-keyword">int</span> mListItemLayout -&gt; O<br>    <span class="hljs-keyword">int</span> mViewSpacingRight -&gt; l<br>    android.widget.Button mButtonNeutral -&gt; w<br>    <span class="hljs-keyword">int</span> mMultiChoiceItemLayout -&gt; M<br>    <span class="hljs-keyword">boolean</span> mShowTitle -&gt; P<br>    <span class="hljs-keyword">int</span> mViewSpacingLeft -&gt; j<br>    <span class="hljs-keyword">int</span> mButtonPanelSideLayout -&gt; K<br></code></pre></td></tr></table></figure><p>虽然混淆不会从程序中删除代码，但是如果你的程序中有许多类，方法和字段，那么节省的大小还是很可观的。但是需要注意是，由于代码进行了混淆，那么运行时发生了错误，打印出来的堆栈，我们就看不懂了，需要一些额外的工具来帮助我们进行还原代码信息。</p><p><strong>另外，如果你写的代码需要依赖原本类或者方法的名字（比如，反射等），那么你就需要在 ProGuard 文件中 keep 你使用到的类或者方法。</strong></p><h2 id="解码混淆后的堆栈信息"><a href="#解码混淆后的堆栈信息" class="headerlink" title="解码混淆后的堆栈信息"></a>解码混淆后的堆栈信息</h2><p>在 R8 混淆了代码之后，阅读堆栈信息几乎是不可能的了，因为方法名类名都换成了很简单的英文字母了。除了重命名，R8 还会改变堆栈信息代码所在的行号。不过还好，我们可以通过 mapping.txt 文件来还原堆栈信息，我们每次构建App的时候，都会生成一个 mapping.txt 文件，里面会包含所有类，方法，字段的混淆前与混淆后的映射关系，当然，里面也有行号的对应关系。该文件一般在 <code>&lt;module- name&gt;/build/outputs/mapping/&lt;build-type&gt;/</code> 目录下面。</p><blockquote><p>R8每次构建项目时都会覆盖生成的mapping.txt文件，因此每次发布新版本时都必须小心保存副本。通过为每个发布版本保留mapping.txt文件的副本，如果用户从旧版本的应用程序提交混淆后的堆栈信息，您将能够追踪调试问题。</p></blockquote><p>在Google Play上发布您的应用时，您可以为每个版本的APK上传mapping.txt文件。然后，Google Play会根据用户报告的问题对传入的堆栈跟踪进行反混淆处理，以便您可以在Google Play控制台中查看这些堆栈信息。有关详细信息，请参阅帮助中心的文章，了解如何对崩溃堆栈跟踪进行反混淆处理。</p><p> 要将混淆的堆栈跟踪转换为可读的堆栈跟踪，请使用 <a href="https://www.guardsquare.com/en/products/proguard/manual/retrace">ReTrace</a> 脚本，在<code>SDK/tools/proguard/bin</code> 目录下。</p><h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h2><p>为了进一步的减小 App 的体积，R8 会在更深的层次上来检查你的代码，然后移除无用代码，甚至有时候会重写我们的代码，让其更简洁。下面举几个例子：</p><ul><li>如果你写了一个 <code>else&#123;&#125;</code> 块，但是任何情况下都不会走这个分支，那么R8可能会将它删除。</li><li>如果某个方法只在唯一一个地方被调用，那么 R8 可能会将方法内联到调用的地方，并将这个方法移除。</li><li>如果某个类只有一个子类，并且该类没有被实例化（举个例子，一个抽象类，只有一个子类），那么 R8 会将这两个类合成一个类。</li><li>更多内容请看大神的博客 <a href="https://jakewharton.com/blog/">R8 optimization blog posts</a></li></ul><p>R8不允许您禁用或启用离散优化，或修改优化的行为。实际上，R8忽略了任何试图修改默认优化的ProGuard规则，例如-optimizations和 - optimizepasses。此限制很重要，因为随着R8的不断改进，维护标准的优化行为有助于Android Studio团队轻松排除故障并解决您可能遇到的任何问题。</p><h2 id="启动更加激进的优化策略"><a href="#启动更加激进的优化策略" class="headerlink" title="启动更加激进的优化策略"></a>启动更加激进的优化策略</h2><p>R8 里面还包含一些默认没有开启的优化行为。你可以开启它们，自需要在 gradle.properties 里面添加：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">android.enableR8.fullMode</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><p>假设您的代码通过Java Reflection API引用了一个类。默认情况下，R8假定您打算在运行时检查和操作该类的对象 - 即使您的代码实际上没有 - 并且它会自动保留该类及其静态初始化程序。</p><p>但是，当使用“<strong>完整模式</strong>”时，R8不会做出这种假设，如果R8断言你的代码在运行时从不使用该类，它会从你应用程序的最终DEX中删除该类。也就是说，如果要保留类及其静态初始化程序，则需要在规则文件中包含保留规则才能执行此操作。</p><p>有问题，查看文档，并报告问题。</p><blockquote><p>If you encounter any issues while using R8’s “full mode”, refer to the <a href="https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md">R8 FAQ page</a> for a possible solution. If you are unable to resolve the issue, please <a href="https://issuetracker.google.com/issues/new?component=326788&template=1025938">report a bug</a>.</p></blockquote><h2 id="使用R8进行故障排除"><a href="#使用R8进行故障排除" class="headerlink" title="使用R8进行故障排除"></a>使用R8进行故障排除</h2><p>当我们开启了代码压缩，资源压缩等选项的时候，可能会遇到一些问题，可以查看帮助文档。</p><blockquote><p>If you do not find a solution to your issue below, also read the <a href="https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md">R8 FAQ page</a> and <a href="https://www.guardsquare.com/en/products/proguard/manual/troubleshooting">ProGuard’s troubleshooting guide</a>.</p></blockquote><h3 id="生成被移除代码报告记录"><a href="#生成被移除代码报告记录" class="headerlink" title="生成被移除代码报告记录"></a>生成被移除代码报告记录</h3><p>为了帮助您解决某些R8带来问题，查看R8从您的应用中删除的所有代码的报告可能会很有用。将<code>-printusage &lt;output-dir&gt; /usage.txt</code>添加到自定义规则文件中，就可以为模块生成报告记录。当您启用R8并构建应用程序时，R8会输出一个包含您指定的路径和文件名的报告。已删除代码的报告类似于以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">androidx.drawerlayout.R$attr<br>androidx.vectordrawable.R<br>androidx.appcompat.app.<span class="hljs-function">AppCompatDelegateImpl</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSupportActionBar</span><span class="hljs-params">(androidx.appcompat.widget.Toolbar)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasWindowFeature</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHandleNativeActionModesEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>)</span></span><br><span class="hljs-function">    android.view.ViewGroup <span class="hljs-title">getSubDecor</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalNightMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">final</span> androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager <span class="hljs-title">getAutoNightModeManager</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> androidx.appcompat.app.ActionBarDrawerToggle$Delegate <span class="hljs-title">getDrawerToggleDelegate</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> DEBUG</span><br><span class="hljs-function">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String KEY_LOCAL_NIGHT_MODE</span><br><span class="hljs-function">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String EXCEPTION_HANDLER_MESSAGE_SUFFIX</span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>如果你想查看，R8保留了哪些类，可以添加 <code>-printseeds &lt;output-dir&gt;/seeds.txt</code> 到自定义规则文件中。文件内容大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">com.example.myapplication.MainActivity<br>androidx.appcompat.R$layout: <span class="hljs-keyword">int</span> abc_action_menu_item_layout<br>androidx.appcompat.R$attr: <span class="hljs-keyword">int</span> activityChooserViewStyle<br>androidx.appcompat.R$styleable: <span class="hljs-keyword">int</span> MenuItem_android_id<br>androidx.appcompat.R$styleable: <span class="hljs-keyword">int</span>[] CoordinatorLayout_Layout<br>androidx.lifecycle.FullLifecycleObserverAdapter<br>...<br></code></pre></td></tr></table></figure><h3 id="资源故障排除"><a href="#资源故障排除" class="headerlink" title="资源故障排除"></a>资源故障排除</h3><p>压缩资源时，“构建”窗口 <img src="https://developer.android.com/studio/images/buttons/window-build-2x.png"> 会显示从APK中删除的资源的摘要。</p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">:android:shrinkDebugResources<br>Removed unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%<br>:android:validateDebugSigning<br></code></pre></td></tr></table></figure><p>Gradle还在<code>&lt;module-name&gt; / build / outputs / mapping / release /</code>（与ProGuard的输出文件相同的文件夹）中创建名为<code>resources.txt</code>的诊断文件。此文件包含详细信息，例如哪些资源引用其他资源以及使用或删除了哪些资源。</p><p>比如，你想知道为啥 <code>@drawable/ic_plus_anim_016</code> 这个文件被打包到了 APK 中，你可以打开 resource.txt 文件，然后搜索这个文件名。你就可以找到谁引用了这个资源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">16:25:48.005 [QUIET] [system.out] &amp;#64;drawable/add_schedule_fab_icon_anim : reachable=true<br>16:25:48.009 [QUIET] [system.out]     &amp;#64;drawable/ic_plus_anim_016<br></code></pre></td></tr></table></figure><p>这个说明了，add_schedule_fab_icon_anim 引用了 ic_plus_anim_016，现在你要找出为什么 add_schedule_fab_icon_anim  是可达的！继续向上搜索，你会发现这个资源在 <code>The root reachable resources are:</code> 下面的列表中。这表示有代码引用了 add_schedule_fab_icon_anim 。</p><p>如果我们没有使用 <code>strict</code> 检查，还有一种情况下资源id也可能被标记为可达的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10</span>:<span class="hljs-number">32</span>:<span class="hljs-number">50.590</span> [QUIET] [system.out] Marking drawable:ic_plus_anim_016:<span class="hljs-number">2130837506</span><br>    used because it format-string matches string pool constant ic_plus_anim_%<span class="hljs-number">1</span>$d.<br></code></pre></td></tr></table></figure><p>这个显然就是使用资源名来动态加载资源的情况。遇到这种情况，你需要手动的指定该资源需要被移除。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android-汉化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（三）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882.5%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882.5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>分析 IoScheduler 类。</p><p>首先要说明的是，RxJava2 中虽然使用到了 Java 的线程池，但是还有很多其他的东西，比如，接下来你就会看到 IoScheduler 中自己实现一个简单的线程池。</p><h3 id="从使用说起"><a href="#从使用说起" class="headerlink" title="从使用说起"></a>从使用说起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RxJava</span><br>Scheduler.Worker worker = Schedulers.io().createWorker();<br>worker.schedule();<br><br><span class="hljs-comment">// Java</span><br>ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>scheduledExecutorService.schedule()<br></code></pre></td></tr></table></figure><p>先不谈运行原理，这里我们比较一下它与我们平时使用的线程池的不同之处。</p><p>一般我们使用的时候，都是先获取线程池的对象，然后传递一个 runnable 给它，让它取执行。</p><p>但是 RxJava 里面，似乎有点不一样。它需要先创建 worker 对象，然后才能将 action 传递给它。与Java方式比较，它多了一个创建 worker 的过程，那么显然本文的核心就是弄清楚，worker 对象是做什么的？为什么设计成需要 worker 对象才能提交任务？</p><p>先说说每个类具体的作用：</p><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>Worker</td><td><strong>抽象类</strong>，提供了执行 action 的几个方法，支持单次执行，定时多次执行。定时多次执行是基于单次执行，默认已经在该类中实现。</td></tr><tr><td>NewThreadWorker</td><td><strong>Worker 的子类</strong>，实现了单次执行方法，使用的是 Executors.newScheduledThreadPool 方法。</td></tr><tr><td>ThreadWorker</td><td>NewThreadWorker 的子类，增强了一下，提供了过期时间的判断方法。</td></tr><tr><td>SequentialDisposable</td><td><strong>一种容器</strong>，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。经过不断的替换引用，从而达到可以支持 Worker 多次执行任务仍然能够 dispose 的功能。</td></tr><tr><td>ScheduledRunnable</td><td>该类是一个集大成的类，它是一个可以<strong>取消任务</strong>，也可以<strong>取消订阅</strong>的 runnable。</td></tr><tr><td>AbstractDirectTask</td><td>这货虽然名字是 task，然是实际上与 ScheduledRunnable 是一路货色，当成 runnable 也可以。</td></tr><tr><td>ScheduledDirectTask</td><td>AbstractDirectTask 的子类</td></tr><tr><td>EventLoopWorker</td><td><strong>Worker 的子类</strong>，使用的是 <strong>NewThreadWorker</strong> 实现了单次执行。</td></tr><tr><td>CachedWorkerPool</td><td>Rxjava自己实现的一个线程池。</td></tr></tbody></table><h3 id="从内部类开始"><a href="#从内部类开始" class="headerlink" title="从内部类开始"></a>从内部类开始</h3><h4 id="IoScheduler"><a href="#IoScheduler" class="headerlink" title="IoScheduler"></a>IoScheduler</h4><p>IoScheduler 源码不长，但是它有3个内部类，我们从内部类开始，因为每个内部类的功能都是比较单一的，分析起来很方便，知道了内部类的作用，外部类的分析就更简单了。</p><blockquote><p>IoScheduler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IoScheduler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>    <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedWorkerPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;...&#125;<br>    <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span>.<span class="hljs-title">Worker</span> </span>&#123;...&#125;<br>    <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NewThreadWorker</span> </span>&#123;...&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="IoScheduler-ThreadWorker"><a href="#IoScheduler-ThreadWorker" class="headerlink" title="IoScheduler.ThreadWorker"></a>IoScheduler.ThreadWorker</h4><p>我们从代码量最少的 ThreadWorker 来开始：</p><blockquote><p>ThreadWorker.java</p><p>可以看出来，ThreadWorker 是对 NewThreadWorker 的一个增强，增加了过期的功能。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NewThreadWorker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> expirationTime;<br><br>    ThreadWorker(ThreadFactory threadFactory) &#123;<br>        <span class="hljs-keyword">super</span>(threadFactory);<br>        <span class="hljs-keyword">this</span>.expirationTime = <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取过期时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpirationTime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> expirationTime;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置过期时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExpirationTime</span><span class="hljs-params">(<span class="hljs-keyword">long</span> expirationTime)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.expirationTime = expirationTime;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadWorker 继承了 NewThreadWorker，那我们就需要看看 NewThreadWorker 是用来做什么的。</p><h4 id="NewThreadWorker"><a href="#NewThreadWorker" class="headerlink" title="NewThreadWorker"></a>NewThreadWorker</h4><blockquote><p>NewThreadWorker.java</p><p>它继承了 Scheduler.Worker。</p><p>从注释上来看，它持有一个单线程的ScheduledExecutorService。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base class that manages a single-threaded ScheduledExecutorService as a</span><br><span class="hljs-comment"> * worker but doesn&#x27;t perform task-tracking operations.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewThreadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span>.<span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>####Scheduler.Worker</p><p>由于 NewThreadWorker 类继承了 Scheduler.Worker，Scheduler.Worker 是一个抽象类，它的核心方法如下：</p><blockquote><p>io.reactivex.Scheduler.Worker.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span> </span>&#123;<br><br>      <span class="hljs-meta">@NonNull</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run)</span> </span>&#123;<br>          <span class="hljs-comment">// 调用了抽象方法</span><br>          <span class="hljs-keyword">return</span> schedule(run, <span class="hljs-number">0L</span>, TimeUnit.NANOSECONDS);<br>      &#125;<br><br><span class="hljs-comment">// 子类需要实现该方法</span><br>      <span class="hljs-meta">@NonNull</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">long</span> delay, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span></span>;<br><br><span class="hljs-comment">// 有一个默认实现周期性的方法，子类如果有特殊需要，可以覆盖该方法</span><br>      <span class="hljs-meta">@NonNull</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodically</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> TimeUnit unit)</span> </span>&#123;<br>...<br>          <span class="hljs-keyword">return</span> sd;<br>      &#125;<br><br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">now</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>          <span class="hljs-keyword">return</span> unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>      &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure><p>所以我们只需要分析两个方法：</p><ol><li>io.reactivex.Scheduler.Worker#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit)</li><li>io.reactivex.Scheduler.Worker#schedulePeriodically</li></ol><p>第一个方法是抽象的，所以我们先放着。</p><p>我们先看 <code>schedulePeriodically</code> 这个方法是如何实现周期性的。</p><blockquote><p>io.reactivex.Scheduler.Worker.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodically</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> SequentialDisposable first = <span class="hljs-keyword">new</span> SequentialDisposable();<br><br>    ...<br><br>    <span class="hljs-keyword">return</span> sd;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一行就出现了一个新的类，SequentialDisposable，这个类比较简单，我们看看：</p><h4 id="SequentialDisposable"><a href="#SequentialDisposable" class="headerlink" title="SequentialDisposable"></a>SequentialDisposable</h4><blockquote><p> SequentialDisposable.java</p><p>该类是一种容器，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SequentialDisposable</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">Disposable</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">754898800686245608L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SequentialDisposable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// nothing to do</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SequentialDisposable</span><span class="hljs-params">(Disposable initial)</span> </span>&#123;<br>        lazySet(initial);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子的：将引用值换成next，会对之前的引用对象调用 dispose</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">update</span><span class="hljs-params">(Disposable next)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DisposableHelper.set(<span class="hljs-keyword">this</span>, next);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 原子的：将引用值换成next，不会对之前的引用对象调用 dispose</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">replace</span><span class="hljs-params">(Disposable next)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DisposableHelper.replace(<span class="hljs-keyword">this</span>, next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;<br>        DisposableHelper.dispose(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDisposed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DisposableHelper.isDisposed(get());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个类很是很简单的，没有什么复杂的代码，我们把它当作一个容器就好了。</p><p>再回到 schedulePeriodically 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodically</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable run, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> period, <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> TimeUnit unit)</span> </span>&#123;<br>         <span class="hljs-comment">// 创建一个容器，引用值为null</span><br>         <span class="hljs-keyword">final</span> SequentialDisposable first = <span class="hljs-keyword">new</span> SequentialDisposable();<br><span class="hljs-comment">// 创建一个容易，引用值为 first</span><br>         <span class="hljs-keyword">final</span> SequentialDisposable sd = <span class="hljs-keyword">new</span> SequentialDisposable(first);<br><br>         <span class="hljs-comment">// 这个暂时没啥作用，当作 decoratedRun = run 理解就好</span><br>         <span class="hljs-keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);<br><br>         <span class="hljs-comment">// 计算时间，我就不细说了，有兴趣自己算一算</span><br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> periodInNanoseconds = unit.toNanos(period);<br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> firstNowNanoseconds = now(TimeUnit.NANOSECONDS);<br>         <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay);<br><br>         <span class="hljs-comment">// 这里调用了 schedule ，它是一个抽象方法</span><br>         <span class="hljs-comment">// 暂时不会去分析 schedule，我们这里可以把它理解为 pool 的 execute 方法</span><br>         <span class="hljs-comment">// 反正它会去执行我们传递的 runnable</span><br>         <span class="hljs-comment">// PeriodicTask 就是一个 runnable</span><br>         <span class="hljs-comment">// 后面的参数，是指定延时长度与单位</span><br>         Disposable d = schedule(<span class="hljs-keyword">new</span> PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,<br>                 periodInNanoseconds), initialDelay, unit);<br><br>         <span class="hljs-keyword">if</span> (d == EmptyDisposable.INSTANCE) &#123;<br>             <span class="hljs-keyword">return</span> d;<br>         &#125;<br>         <span class="hljs-comment">// 将 first 的引用值改为 d</span><br>         <span class="hljs-comment">// 这里之所以要赋值，是因为第一次执行时，如果使用者调用了 dispose，那么我们必须取消订阅</span><br>         <span class="hljs-comment">// 由于返回了 sd，所以 sd 会调用 first 的 dispose，first 会调用 d 的 dispose</span><br>         <span class="hljs-comment">// 这样就取消订阅了</span><br>         first.replace(d);<br><br>         <span class="hljs-keyword">return</span> sd;<br>     &#125;<br></code></pre></td></tr></table></figure><p>上面注释写的比较详细了，下面我们看 PeriodicTask 是如何周期执行的，这里我们可以想一下我们使用 Hander 写一个定时器的做法，其实是一样的。</p><h4 id="Scheduler-Worker-PeriodicTask"><a href="#Scheduler-Worker-PeriodicTask" class="headerlink" title="Scheduler.Worker.PeriodicTask"></a>Scheduler.Worker.PeriodicTask</h4><blockquote><p>io.reactivex.Scheduler.Worker.PeriodicTask</p><p>PeriodicTask 是 Worker 的一个内部类，Worker 是 Scheduler 的内部类。</p><p>该类就是用来实现周期任务的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PeriodicTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>既然是实现了 Runnable，那我们只看 run 方法。</p><blockquote><p>io.reactivex.Scheduler.Worker.PeriodicTask#run</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里就是 run 执行的位置，我们需要执行的 runnable 就是在这里执行的</span><br>    decoratedRun.run();<br><br>    <span class="hljs-comment">// 没有取消订阅</span><br>    <span class="hljs-keyword">if</span> (!sd.isDisposed()) &#123;<br><br>        <span class="hljs-comment">// 下面的一段是计算下一次运行的时间，嗯，自己看看吧</span><br>        <span class="hljs-keyword">long</span> nextTick;<br><br>        <span class="hljs-keyword">long</span> nowNanoseconds = now(TimeUnit.NANOSECONDS);<br>        <span class="hljs-comment">// If the clock moved in a direction quite a bit, rebase the repetition period</span><br>        <span class="hljs-keyword">if</span> (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS &lt; lastNowNanoseconds<br>                || nowNanoseconds &gt;= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) &#123;<br>            nextTick = nowNanoseconds + periodInNanoseconds;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Shift the start point back by the drift as if the whole thing</span><br><span class="hljs-comment">             * started count periods ago.</span><br><span class="hljs-comment">             */</span><br>            startInNanoseconds = nextTick - (periodInNanoseconds * (++count));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextTick = startInNanoseconds + (++count * periodInNanoseconds);<br>        &#125;<br>        lastNowNanoseconds = nowNanoseconds;<br><br>        <span class="hljs-keyword">long</span> delay = nextTick - nowNanoseconds;<br>        <span class="hljs-comment">// 这里将 sd 的引用替换为新的 disposable</span><br>        <span class="hljs-comment">// 因为旧的任务在第一行代码已经执行完了，所以替换掉</span><br>        <span class="hljs-comment">// schedule 方法有安排了下一次的任务，这样就成了一个循环，达到了周期性的目的</span><br>        sd.replace(schedule(<span class="hljs-keyword">this</span>, delay, TimeUnit.NANOSECONDS));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，到了这里，<code>io.reactivex.Scheduler.Worker</code>类就分析完了，下面回到我们的 NewThreadWorker 类中。</p><p>####NewThreadWorker</p><p>看构造方法：</p><blockquote><p>NewThreadWorker.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NewThreadWorker</span><span class="hljs-params">(ThreadFactory threadFactory)</span> </span>&#123;<br>    executor = SchedulerPoolFactory.create(threadFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数中调用 SchedulerPoolFactory 的 create 方法，创建了一个 executor 对象。</p><h4 id="SchedulerPoolFactory"><a href="#SchedulerPoolFactory" class="headerlink" title="SchedulerPoolFactory"></a>SchedulerPoolFactory</h4><p>看看 SchedulerPoolFactory 的 create 方法：</p><blockquote><p>SchedulerPoolFactory .java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">create</span><span class="hljs-params">(ThreadFactory factory)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ScheduledExecutorService exec = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>, factory);<br>    <span class="hljs-comment">// PURGE_ENABLED 的值与系统有关，暂且不提</span><br>    <span class="hljs-keyword">if</span> (PURGE_ENABLED &amp;&amp; exec <span class="hljs-keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;<br>        ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec;<br>        POOLS.put(e, exec);<br>    &#125;<br>    <span class="hljs-keyword">return</span> exec;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们只关注第一行代码，与注释说的一样，它创建了一个单线程的 ScheduledExecutorService 对象。</p><p>####NewThreadWorker</p><p>构造方法与父类，我们都分析完了，现在看看它是怎么实现那个抽象方法的。</p><blockquote><p>NewThreadWorker</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NonNull</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Runnable run)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里它覆盖了原来的默认实现，传递了一个null</span><br>    <span class="hljs-comment">// 没看懂，方法参数不接受 null 啊</span><br>    <span class="hljs-keyword">return</span> schedule(run, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-meta">@NonNull</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Runnable action, <span class="hljs-keyword">long</span> delayTime, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-comment">// disposed 就没啥说的</span><br>    <span class="hljs-keyword">if</span> (disposed) &#123;<br>        <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;<br>    &#125;<br>    <span class="hljs-comment">// 调用了 scheduleActual 方法</span><br>    <span class="hljs-keyword">return</span> scheduleActual(action, delayTime, unit, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将runnnable 包装成 ScheduledRunnable，交给 ScheduledExecutorService 去执行 </span><br><span class="hljs-comment"> * 如果调度被驳回， ScheduledRunnable.wasScheduled 的值为 false。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@NonNull</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ScheduledRunnable <span class="hljs-title">scheduleActual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable run, <span class="hljs-keyword">long</span> delayTime, <span class="hljs-meta">@NonNull</span> TimeUnit unit, <span class="hljs-meta">@Nullable</span> DisposableContainer parent)</span> </span>&#123;<br>    <span class="hljs-comment">// 直接理解成 decoratedRun = run</span><br>    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);<br><br>    <span class="hljs-comment">// 将 decoratedRun 包装一下</span><br>    ScheduledRunnable sr = <span class="hljs-keyword">new</span> ScheduledRunnable(decoratedRun, parent);<br><br>    <span class="hljs-comment">// 传递的参数为 null，这一段跳过</span><br>    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!parent.add(sr)) &#123;<br>            <span class="hljs-keyword">return</span> sr;<br>        &#125;<br>    &#125;<br><br>    Future&lt;?&gt; f;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (delayTime &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 不延迟就直接执行</span><br>            f = executor.submit((Callable&lt;Object&gt;)sr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 延迟执行</span><br>            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);<br>        &#125;<br>        <span class="hljs-comment">// 设置 future，便于获取执行结果</span><br>        sr.setFuture(f);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            parent.remove(sr);<br>        &#125;<br>        RxJavaPlugins.onError(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sr;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，现在，我们需要看看 ScheduledRunnable 到底是个什么，起什么作用。</p><h4 id="ScheduledRunnable"><a href="#ScheduledRunnable" class="headerlink" title="ScheduledRunnable"></a>ScheduledRunnable</h4><blockquote><p>ScheduledRunnable</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledRunnable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReferenceArray</span>&lt;<span class="hljs-title">Object</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Object</span>&gt;, <span class="hljs-title">Disposable</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这个类的源码比较奇特，我就不展开了，我们把它当作一个 Callable 使用就可以了，但是它也支持 Disposable。源码里面都是一些原子性的赋值更新处理。</p><p>回到 NewThreadWorker 类，它的 schedule 方法就是将我们传递的 runnable 包装一下，然后将这个包装好的 ScheduledRunnable 交给 ScheduledExecutorService 去处理。</p><p>因为 ScheduledRunnable 实现了 Disposable，所以直接返回它，可以用于取消订阅。ScheduledRunnable 还实现了 Callable 是因为我们取消订阅的时候，可以用于线程池取消任务（f.cancel(true)）。</p><h4 id="NewThreadWorker-1"><a href="#NewThreadWorker-1" class="headerlink" title="NewThreadWorker"></a>NewThreadWorker</h4><p>到了这里 NewThreadWorker 的一系列 schedule 方法就分析完了，然而，我们发现，它除了 schedule  方法之外，还提供了一些别的public的方法，顺便看了算求。</p><blockquote><p>io.reactivex.internal.schedulers.NewThreadWorker#scheduleDirect</p><p>这个方法也是提交一个 runnable 给线程池执行，然是不是使用了 ScheduledRunnable 来包装，</p><p>而是使用的 ScheduledDirectTask</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">scheduleDirect</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable run, <span class="hljs-keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-comment">// 这里出了一个新类</span><br>    ScheduledDirectTask task = <span class="hljs-keyword">new</span> ScheduledDirectTask(RxJavaPlugins.onSchedule(run));<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 下面的代码与之前分析的一样，就跳过</span><br>        Future&lt;?&gt; f;<br>        <span class="hljs-keyword">if</span> (delayTime &lt;= <span class="hljs-number">0L</span>) &#123;<br>            f = executor.submit(task);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f = executor.schedule(task, delayTime, unit);<br>        &#125;<br>        task.setFuture(f);<br>        <span class="hljs-keyword">return</span> task;<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        RxJavaPlugins.onError(ex);<br>        <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就来分析分析 ScheduledDirectTask 类。</p><h4 id="ScheduledDirectTask"><a href="#ScheduledDirectTask" class="headerlink" title="ScheduledDirectTask"></a>ScheduledDirectTask</h4><blockquote><p>ScheduledDirectTask </p><p>继承了 AbstractDirectTask 类</p><p>主要是实现了 call 方法，给 runner 赋值，调用 runnable 的 run 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledDirectTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDirectTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Void</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1811839108042568751L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledDirectTask</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(runnable);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        runner = Thread.currentThread();<br>        <span class="hljs-keyword">try</span> &#123;<br>            runnable.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 设置为完成状态</span><br>            <span class="hljs-comment">// 还是没有搞太明白，set 与 lazySet 的区别，什么内存屏障啊</span><br>            lazySet(FINISHED);<br>            runner = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AbstractDirectTask"><a href="#AbstractDirectTask" class="headerlink" title="AbstractDirectTask"></a>AbstractDirectTask</h4><blockquote><p>AbstractDirectTask</p><p>源码不长，我就全部贴出来了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDirectTask</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">Future</span>&lt;?&gt;&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">Disposable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1811839108042568751L</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Runnable runnable;<br><br>    <span class="hljs-keyword">protected</span> Thread runner;<br><br><span class="hljs-comment">// 哦，我还不知道有个 Functions.EMPTY_RUNNABLE 可以用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FutureTask&lt;Void&gt; FINISHED = <span class="hljs-keyword">new</span> FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, <span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FutureTask&lt;Void&gt; DISPOSED = <span class="hljs-keyword">new</span> FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, <span class="hljs-keyword">null</span>);<br><br>    AbstractDirectTask(Runnable runnable) &#123;<br>        <span class="hljs-keyword">this</span>.runnable = runnable;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;<br>        Future&lt;?&gt; f = get();<br>        <span class="hljs-keyword">if</span> (f != FINISHED &amp;&amp; f != DISPOSED) &#123;<br>        <span class="hljs-comment">// 将状态设置为取消</span><br>            <span class="hljs-keyword">if</span> (compareAndSet(f, DISPOSED)) &#123;<br>            <span class="hljs-comment">// 取消线程池里的任务</span><br>                <span class="hljs-keyword">if</span> (f != <span class="hljs-keyword">null</span>) &#123;<br>                    f.cancel(runner != Thread.currentThread());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDisposed</span><span class="hljs-params">()</span> </span>&#123;<br>        Future&lt;?&gt; f = get();<br>        <span class="hljs-keyword">return</span> f == FINISHED || f == DISPOSED;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFuture</span><span class="hljs-params">(Future&lt;?&gt; future)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Future&lt;?&gt; f = get();<br>            <span class="hljs-keyword">if</span> (f == FINISHED) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f == DISPOSED) &#123;<br>            <span class="hljs-comment">// 取消线程池里的任务</span><br>                future.cancel(runner != Thread.currentThread());<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 设置引用值为 f</span><br>            <span class="hljs-keyword">if</span> (compareAndSet(f, future)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉，ScheduledDirectTask  这个类的功能与 ScheduledRunnable 的功能差不多啊，ScheduledRunnable 更强力一点。至少在我们分析的这个流程里面，感觉不到区别，嗯，不过想到 <code>scheduleActual</code> 方法比 <code>scheduleDirect</code>多了一个参数，想来，玄机应该在这里，有兴趣的自己再去找找。</p><p>如果实在心里想不通的，把 ScheduledDirectTask  与 ScheduledRunnable  都当成具有解除订阅与取消任务的增强型 Runnable 就好了。</p><h4 id="NewThreadWorker-2"><a href="#NewThreadWorker-2" class="headerlink" title="NewThreadWorker"></a>NewThreadWorker</h4><p>再次回到 NewThreadWorker，还有一个方法没有说到：</p><blockquote><p>io.reactivex.internal.schedulers.NewThreadWorker#schedulePeriodicallyDirect</p><p>该方法用于周期性的执行任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedulePeriodicallyDirect</span><span class="hljs-params">(Runnable run, <span class="hljs-keyword">long</span> initialDelay, <span class="hljs-keyword">long</span> period, TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);<br>    <span class="hljs-comment">// 这里如果周期性设置为0，也就是说没有间隔的重复执行任务</span><br>    <span class="hljs-keyword">if</span> (period &lt;= <span class="hljs-number">0L</span>) &#123;<br><br>        <span class="hljs-comment">// 没有间隔的话，使用 InstantPeriodicTask</span><br>        InstantPeriodicTask periodicWrapper = <span class="hljs-keyword">new</span> InstantPeriodicTask(decoratedRun, executor);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Future&lt;?&gt; f;<br>            <span class="hljs-keyword">if</span> (initialDelay &lt;= <span class="hljs-number">0L</span>) &#123;<br>                f = executor.submit(periodicWrapper);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f = executor.schedule(periodicWrapper, initialDelay, unit);<br>            &#125;<br>            periodicWrapper.setFirst(f);<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>            RxJavaPlugins.onError(ex);<br>            <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> periodicWrapper;<br>    &#125;<br>    <span class="hljs-comment">// 有间隔的话，使用 ScheduledDirectPeriodicTask</span><br>    ScheduledDirectPeriodicTask task = <span class="hljs-keyword">new</span> ScheduledDirectPeriodicTask(decoratedRun);<br>    <span class="hljs-keyword">try</span> &#123;<br>        Future&lt;?&gt; f = executor.scheduleAtFixedRate(task, initialDelay, period, unit);<br>        task.setFuture(f);<br>        <span class="hljs-keyword">return</span> task;<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        RxJavaPlugins.onError(ex);<br>        <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面，线程池的使用，Task 的分析就不展开了，因为之前已经分析过一个 Task，想一想都能知道里面的代码大概长什么样，有兴趣的自己去看看吧。</p><p>好了，到这里，NewThreadWorker 类，我们就分析完了，没想到这么短的一个内部类，里面有这么多东西。不过，总结一下，里面的东西其实并不多。</p><ol><li>schedule 等方法，用于提交任务，内部使用的是 ScheduledExecutorService 线程池</li><li>schedule 等方法返回一个 Disposable，用于解除订阅，解除订阅时，也会取消该任务。</li><li>周期性的实现，有两种方式，一种是自己调用自己实现的，一种是使用 ScheduledExecutorService 的 scheduleAtFixedRate 方法实现的。</li></ol><h4 id="IoScheduler-EventLoopWorker"><a href="#IoScheduler-EventLoopWorker" class="headerlink" title="IoScheduler.EventLoopWorker"></a>IoScheduler.EventLoopWorker</h4><p>接下来，我们趁热打铁，看另外一个继承至 Scheduler.Worker 的内部类。</p><blockquote><p>io.reactivex.internal.schedulers.IoScheduler.EventLoopWorker</p><p>EventLoopWorker 继承至 Scheduler.Worker</p><p>Worker 上面分析过，是用来执行任务的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLoopWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Scheduler</span>.<span class="hljs-title">Worker</span> </span>&#123;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CompositeDisposable tasks;<br>     <span class="hljs-comment">// 这里有一个新东西</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CachedWorkerPool pool;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadWorker threadWorker;<br><br>     <span class="hljs-keyword">final</span> AtomicBoolean once = <span class="hljs-keyword">new</span> AtomicBoolean();<br><br>     EventLoopWorker(CachedWorkerPool pool) &#123;<br>         <span class="hljs-keyword">this</span>.pool = pool;<br>         <span class="hljs-keyword">this</span>.tasks = <span class="hljs-keyword">new</span> CompositeDisposable();<br>         <span class="hljs-keyword">this</span>.threadWorker = pool.get();<br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (once.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br>             tasks.dispose();<br><br>             <span class="hljs-comment">// releasing the pool should be the last action</span><br>             <span class="hljs-comment">// 将线程返回线程池里面去</span><br>             pool.release(threadWorker);<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDisposed</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> once.get();<br>     &#125;<br><br>     <span class="hljs-meta">@NonNull</span><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> Disposable <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable action, <span class="hljs-keyword">long</span> delayTime, <span class="hljs-meta">@NonNull</span> TimeUnit unit)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (tasks.isDisposed()) &#123;<br>             <span class="hljs-comment">// don&#x27;t schedule, we are unsubscribed</span><br>             <span class="hljs-keyword">return</span> EmptyDisposable.INSTANCE;<br>         &#125;<br><span class="hljs-comment">// 让 ThreadWorker 去执行一个 aciton 任务，这里最后一个参数注意一下</span><br>         <span class="hljs-comment">// threadWorker 里面只有一个线程，所以，任务是顺序执行的</span><br>         <span class="hljs-keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>看里面的代码还是非常简单的，它的构造方法接收一个 CachedWorkerPool，这个是 EventLoopWorker 类里面，唯一一个陌生类，看看这个类：</p><h4 id="IoScheduler-CachedWorkerPool"><a href="#IoScheduler-CachedWorkerPool" class="headerlink" title="IoScheduler.CachedWorkerPool"></a>IoScheduler.CachedWorkerPool</h4><p>欸，太好了，这个也是 IoScheduler 的内部类，这样的话，把这个类分析完了之后， IoScheduler 的内部类就分析完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CachedWorkerPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> keepAliveTime;<br>    <span class="hljs-comment">// 队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentLinkedQueue&lt;ThreadWorker&gt; expiringWorkerQueue;<br>    <span class="hljs-keyword">final</span> CompositeDisposable allWorkers;<br>    <span class="hljs-comment">// java 的线程池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService evictorService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Future&lt;?&gt; evictorTask;<br>    <span class="hljs-comment">// 线程工程，一般就 new 一个 Thread，然后给个名字就完事了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br><br>    CachedWorkerPool(<span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) &#123;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = unit != <span class="hljs-keyword">null</span> ? unit.toNanos(keepAliveTime) : <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">this</span>.expiringWorkerQueue = <span class="hljs-keyword">new</span> ConcurrentLinkedQueue&lt;ThreadWorker&gt;();<br>        <span class="hljs-keyword">this</span>.allWorkers = <span class="hljs-keyword">new</span> CompositeDisposable();<br>        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br><br>        ScheduledExecutorService evictor = <span class="hljs-keyword">null</span>;<br>        Future&lt;?&gt; task = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (unit != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 这里也创建了一个单个线程的线程池</span><br>            evictor = Executors.newScheduledThreadPool(<span class="hljs-number">1</span>, EVICTOR_THREAD_FACTORY);<br>            <span class="hljs-comment">// 创建定时任务，runnable 是 this，就是 run 里面的代码</span><br>            task = evictor.scheduleWithFixedDelay(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.keepAliveTime, <span class="hljs-keyword">this</span>.keepAliveTime, TimeUnit.NANOSECONDS);<br>        &#125;<br>        evictorService = evictor;<br>        evictorTask = task;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        evictExpiredWorkers();<br>    &#125;<br><br>    <span class="hljs-function">ThreadWorker <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果线程池关闭了，则返回一个关闭的线程池</span><br>        <span class="hljs-keyword">if</span> (allWorkers.isDisposed()) &#123;<br>            <span class="hljs-keyword">return</span> SHUTDOWN_THREAD_WORKER;<br>        &#125;<br>        <span class="hljs-comment">// 队列不为空，从队列中取一个 worker 出来</span><br>        <span class="hljs-keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;<br>            ThreadWorker threadWorker = expiringWorkerQueue.poll();<br>            <span class="hljs-keyword">if</span> (threadWorker != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> threadWorker;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 队列没有 worker，new 一个出来</span><br>        <span class="hljs-comment">// No cached worker found, so create a new one.</span><br>        ThreadWorker w = <span class="hljs-keyword">new</span> ThreadWorker(threadFactory);<br>        <span class="hljs-comment">// ThreadWorker 继承 NewThreadWorker</span><br>        <span class="hljs-comment">// NewThreadWorker 实现了 Disposable</span><br>        <span class="hljs-comment">// 调用 dispose 会关闭里面的线程池</span><br>        allWorkers.add(w);<br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将 worker 重新放入到线程池（队列）中，将过期时间重置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(ThreadWorker threadWorker)</span> </span>&#123;<br>        <span class="hljs-comment">// Refresh expire time before putting worker back in pool</span><br>        threadWorker.setExpirationTime(now() + keepAliveTime);<br><br>        expiringWorkerQueue.offer(threadWorker);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除过期 worker</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evictExpiredWorkers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!expiringWorkerQueue.isEmpty()) &#123;<br>            <span class="hljs-keyword">long</span> currentTimestamp = now();<br><br>            <span class="hljs-comment">// 遍历队列</span><br>            <span class="hljs-keyword">for</span> (ThreadWorker threadWorker : expiringWorkerQueue) &#123;<br>                <span class="hljs-comment">// 看看 threadWorker 过期了没有</span><br>                <span class="hljs-keyword">if</span> (threadWorker.getExpirationTime() &lt;= currentTimestamp) &#123;<br>                    <span class="hljs-comment">// 过期了就移除</span><br>                    <span class="hljs-keyword">if</span> (expiringWorkerQueue.remove(threadWorker)) &#123;<br>                        <span class="hljs-comment">// 从队列移除成功后，将 Disposable 也移除掉</span><br>                        allWorkers.remove(threadWorker);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 因为队列是按照时间排列的，所以找到第一个没有过期的就可以退出循环了</span><br>                    <span class="hljs-comment">// Queue is ordered with the worker that will expire first in the beginning, so when we</span><br>                    <span class="hljs-comment">// find a non-expired worker we can stop evicting.</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">now</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> System.nanoTime();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭线程池</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        allWorkers.dispose();<br>        <span class="hljs-keyword">if</span> (evictorTask != <span class="hljs-keyword">null</span>) &#123;<br>            evictorTask.cancel(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (evictorService != <span class="hljs-keyword">null</span>) &#123;<br>            evictorService.shutdownNow();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注释很清晰，如果你阅读过Java的线程池源码，会更容易理解，这里就是教我们如果实现一个自己的 CacheThreadPool 线程池啊。只不过这个线程池（ConcurrentLinkedQueue）的每一个 worker 都是一个线程池（NewThreadWorker）。</p><p>嗯，到这里，IoScheduler 的内部类就讲完了，我们看看它的其他方法吧。</p><p>首先，IoScheduler 是继承至 Scheduler 的，所以我们先从它对抽象方法的实现看起。</p><h4 id="IoScheduler-1"><a href="#IoScheduler-1" class="headerlink" title="IoScheduler"></a>IoScheduler</h4><blockquote><p>IoScheduler</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Worker <span class="hljs-title">createWorker</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EventLoopWorker(pool.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>它是直接创建一个 EventLoopWorker 对象并返回。</p><p>根据我们上面的分析，EventLoopWorker 将任务给了 ThreadWorker 去执行，ThreadWorker 又将任务给了一个单个线程的线程池去执行。</p><p>而且，ThreadWorker 是线程池中的线程池，因为它就一个线程，所以可以把它当作单个线程而不是线程池，那么就是说，IoScheduler 的线程池就是一个功能与Java中的<code>Executors.newCachedThreadPool()</code>方法创建出来的线程池功能是差不多的。</p><p>好吧，虽然差不多，但是毕竟这里里面的线程池与线程提供了对 Disposable 接口的支持。</p><p>感觉，EventLoopWorker 的作用，只是一个代理啊，最后还是将任务转给了 CachedWorkerPool。可能为了支持 dispose 操作花费了很多心思。</p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（一）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这是第二次写源码分析，之前的一次已经是一年前了。</p><p>为何要重写？</p><p>主要是由于今天看到了一些关于线程池的东西，我联想到了RxJava2中的线程分类。再想到项目中的线程池相关的地方，感觉很乱，所以有一个整合的想法，想将原来自己创建的线程池替换成RxJava2中的线程池，于是就有了翻看源码的心思。</p><p>择日不如撞日，反正是看源码，顺便把以前的东西再整理一下，还有就是以前写的东西，思路太乱，看着不舒服。</p><p>回想起来，RxJava2的源码有很多套路，只要掌握了这个套路，阅读源码起来就会有一切尽在掌握的感觉，否则，就会觉得源码很绕。</p><p>所以第一篇文章的主要目的，是讲明白这个套路，然后配上图，能够更容易让人理解，如果以后忘记了，再回来看一遍也能迅速跟上思路，不会又要再次撸一遍源码。</p><h3 id="从一个简单的例子开始"><a href="#从一个简单的例子开始" class="headerlink" title="从一个简单的例子开始"></a>从一个简单的例子开始</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 观察者 -- 蝙蝠侠</span><br><span class="hljs-comment">// 这里之所以没有用 Consumer，是怕引起歧义</span><br><span class="hljs-comment">// 毕竟源码利用将我们传递进去的 Consumer， 又封装了一层，封装成了 Observer</span><br><span class="hljs-keyword">val</span> observerBatMan = <span class="hljs-keyword">object</span> : Observer&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNext</span><span class="hljs-params">(t: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        Assert.assertEquals(<span class="hljs-number">1</span>, t)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onError</span><span class="hljs-params">(e: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(d: <span class="hljs-type">Disposable</span>)</span></span> &#123;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 数据源 -- 小丑</span><br><span class="hljs-keyword">val</span> sourceClown = ObservableOnSubscribe&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    it.onNext(<span class="hljs-number">1</span>)<br>    it.onComplete()<br>&#125;<br><br><span class="hljs-comment">// 开始观察</span><br>Observable.create&lt;<span class="hljs-built_in">Int</span>&gt;(sourceClown)<br>    .subscribe(observerBatMan)<br></code></pre></td></tr></table></figure><p>嗯，果然 kotlin 还是看起来舒服。</p><p>这个例子非常简单了，数据源发送一个int值 1，然后接收者判断值是不是1。</p><p>现在开始分析源码了，先看 Observable 的 create 方法：</p><blockquote><p>Observable.java</p><p>该方法创建一个 Observeable 对象。分析完成之后，你就会发现实际上就是创建了一个 ObservableCreate 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;<br>    <span class="hljs-comment">// 这个是判空，嗯，没啥好说的，我一般用注解。</span><br>    ObjectHelper.requireNonNull(source, <span class="hljs-string">&quot;source is null&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> ObservableCreate&lt;T&gt;(source));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="套路一"><a href="#套路一" class="headerlink" title="套路一"></a>套路一</h4><blockquote><p>别看有些人表面上风风光光，背地里却连只大熊猫都没有。</p></blockquote><p>上面的 create 方法中，看起来有两行代码，感觉做了一些了不得的东西，但是实际上只有半行代码在起主要作用。</p><p>第二行代码的前半行：</p><blockquote><p>RxJavaPlugins.java</p><p>该方法在 onObservableAssembly 不会空的情况下会对 source 做一个变换，否则返回 source。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">onAssembly</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Observable&lt;T&gt; source)</span> </span>&#123;<br>    Function&lt;? <span class="hljs-keyword">super</span> Observable, ? extends Observable&gt; f = onObservableAssembly;<br>    <span class="hljs-keyword">if</span> (f != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> apply(f, source);<br>    &#125;<br>    <span class="hljs-keyword">return</span> source;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 onObservableAssembly 绝大部分情况下为空，其实就是返回了传进来的参数。所以该方法基本可以忽略。</p><p><strong>需要注意，这个套路在源码中很常见。</strong></p><p>所以最后，我们可以把 Observeable 的 create 方法理解为：</p><blockquote><p>Observable.java</p><p>create 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Observable&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObservableCreate&lt;T&gt;(source);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看是不是很简单！！！</p><p>继续深入，看看 ObservableCreate 有何德何能！</p><blockquote><p>ObservableCreate .java</p><p>ObservableCreate 继承至 Observable。这个继承还有一个非常重要的作用，就是方便链式调用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObservableCreate</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>别看 Observable 有<strong>1w 多行代码</strong>，但是实际上<strong>只有一个抽象方法</strong>，其他的都是用来做操作符等等。</p><p>下面来看看这个抽象方法，后面会分析到。</p><blockquote><p>Observable.java</p><p>该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx);</p><p>subscribe 就会调用 subscribeActual</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="套路二"><a href="#套路二" class="headerlink" title="套路二"></a>套路二</h4><blockquote><p>遵循模板：</p><ol><li><p>将source封装一下，变成一个 Observable</p></li><li><p>将 observer 封装一下，变成一个Emitter，</p></li><li><p>然后调用 source 的 onSubscribe 方法，</p></li><li><p>然后调用 source 的 subscribe 方法，将 Emitter 传进去。</p></li></ol></blockquote><p><strong>其实只要你知道 observer 是谁，source 是谁，很简单的啦。</strong></p><p>ObservableCreate 的核心代码就在这个被覆盖的抽象方法里面，嗯，一起来看看吧。</p><blockquote><p>ObservableCreate.java</p><p>该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx);</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    observer.onSubscribe(parent);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        source.subscribe(parent);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Exceptions.throwIfFatal(ex);<br>        parent.onError(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看上面的代码，需要搞清楚几个变量，不然绕着绕着就糊涂了。</p><ol><li><p><strong>source 是我们创建并传递进来的</strong>。额，忘记贴构造函数了，里面有赋值，这个 source 就是我们在 create 方法里面创建的对象啦。</p><blockquote><p>ObservableCreate.java</p><p>构造方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObservableCreate</span><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.source = source;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_2.png?raw=true"></p></li><li><p>observer 这里暂时分析不出来，因为是父类调用了这个方法，所以我们去父类看看</p><blockquote><p>Observable.java</p><p>这个方法的主要作用，就是将数据源与观察者关联起来</p><p>它还调用了 subscribeActual 方法，子类必须实现 subscribeActual  方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(observer, <span class="hljs-string">&quot;observer is null&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        observer = RxJavaPlugins.onSubscribe(<span class="hljs-keyword">this</span>, observer);<br>   <br>        ObjectHelper.requireNonNull(observer, <span class="hljs-string">&quot;Plugin returned null Observer&quot;</span>);<br>   <br>        subscribeActual(observer);<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123; <span class="hljs-comment">// NOPMD</span><br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        Exceptions.throwIfFatal(e);<br>        <span class="hljs-comment">// can&#x27;t call onError because no way to know if a Disposable has been set or not</span><br>        <span class="hljs-comment">// can&#x27;t call onSubscribe because the call might have set a Subscription already</span><br>        RxJavaPlugins.onError(e);<br>   <br>        NullPointerException npe = <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;Actually not, but can&#x27;t throw other exceptions due to RS&quot;</span>);<br>        npe.initCause(e);<br>        <span class="hljs-keyword">throw</span> npe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用套路一，我们简化一下代码：</p><blockquote><p>Observable.java </p><p>subscribe 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         observer = RxJavaPlugins.onSubscribe(<span class="hljs-keyword">this</span>, observer);<br>         subscribeActual(observer);<br>     &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123; <span class="hljs-comment">// NOPMD</span><br>         <span class="hljs-keyword">throw</span> e;<br>     &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>         ...<br>         RxJavaPlugins.onError(e);<br>...<br>         <span class="hljs-keyword">throw</span> npe;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>如果，是走正常流程，没有错误，还可以简化（第一次分析主流程，就是要这样简化简化再简化）：</p><blockquote><p>Observable.java </p><p>subscribe 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    observer = RxJavaPlugins.onSubscribe(<span class="hljs-keyword">this</span>, observer);<br>    subscribeActual(observer);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，RxJavaPlugins.onSubscribe 也含有套路一，所以再次简化：</p><blockquote><p>Observable.java </p><p>subscribe 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-comment">// 可以忽略</span><br>    observer = observer;<br>    subscribeActual(observer);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，最终实际上 subscribe 方法，就是调用了 subscribeActual 方法而已，只不过它增加了错误与钩子处理。</p><p>看到这里，<strong>不知道你有没有反应过来，这个 subscribe(observer) 方法是不是很熟悉呢</strong>？</p><p>这个方法，就是我们上面例子中的：</p><blockquote><p>我们写的 demo 的代码</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 开始观察</span><br>Observable.create&lt;<span class="hljs-built_in">Int</span>&gt;(sourceClown)<br><span class="hljs-comment">// 这里就是调用的 subscribe 方法</span><br>    .subscribe(observerBatMan)<br></code></pre></td></tr></table></figure><p>是不是有点恍然大悟的感觉呢！</p><p>所以到这里，心里应该由一个大致框架了。</p><p>同时也会发现，<code>ObservableCreate </code>  的 <code>subscribeActual</code> 方法中<strong>的 <code>observer</code> 参数，也是我们new出来的对象</strong>。</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_3.png?raw=true"></p></li></ol><p>分析到了这里，一个轮廓就出来了!!!</p><p><code>ObservableCreate </code>  的 <code>subscribeActual</code> 方法中的 参数分别对应如下：</p><blockquote><p>ObservableCreate.java</p><p>ObservableCreate 继承至 Observable，所以它必须实现 subscribeActual 方法。</p><p>这个方法也是核心，是链式调用的核心，线程切换的核心</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-comment">// observer 就是 observerBatMan</span><br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    observer.onSubscribe(parent);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// source 就是 sourceClown</span><br>        <span class="hljs-comment">// 这个 subscribe 就将两个包装的观察者与数据源对象关联起来了</span><br>        source.subscribe(parent);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Exceptions.throwIfFatal(ex);<br>        parent.onError(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果，不考虑错误的情况，我们简化一下代码：</p><blockquote><p>ObservableCreate.java</p><p>subscribeActual 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    <span class="hljs-comment">// observer 就是 observerBatMan</span><br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    <span class="hljs-comment">// 调用 observerBatMan 的 onSubscribe 方法，这个是一个钩子方法</span><br>    <span class="hljs-comment">// 一般专门用来告诉 observerBatMan，我，sourceClown，要搞事情了</span><br>    observer.onSubscribe(parent);<br>    <span class="hljs-comment">// source 就是 sourceClown</span><br>    source.subscribe(parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于，onSubscribe 我们暂时也不用，所以去掉，再简化：</p><blockquote><p>ObservableCreate.java</p><p>subscribeActual 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer)</span> </span>&#123;<br>    CreateEmitter&lt;T&gt; parent = <span class="hljs-keyword">new</span> CreateEmitter&lt;T&gt;(observer);<br>    <span class="hljs-comment">// 注意这里 subscribe 传递的是 parent</span><br>    source.subscribe(parent);<br>&#125;<br></code></pre></td></tr></table></figure><p>嘿嘿嘿，这样就舒服多了，就3个变量，两个是我们自己创建的，知根知底，还有一个货，<code>CreateEmitter</code>我们先放一放，为啥呢，因为关于 source 的代码还没有分析完成呢。</p><p>别看  <code>source.subscribe(parent);</code>就一行代码，但是由于 source 对象是我们自己创建的，所以这个方法实际上调用了我们写的代码：</p><blockquote><p>ObservableOnSubscribe.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObservableOnSubscribe</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ObservableEmitter&lt;T&gt; e)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ObservableOnSubscribe</code>是一个接口，所以，我们实际上是创建了一个匿名内部类，传递给了 source，然后 source 又调用了 subscribe 方法，所以也就调用了我们写的代码。</p><p>嗯，用伪代码表示如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 匿名内部类 = new ObservableOnSubscribe()&#123;&#125;<br><br><span class="hljs-bullet">2.</span> oc = Observerable.create(匿名内部类)<br><br><span class="hljs-bullet">3.</span> oc.subscribe(xxx)，这个方法会调用到 -&gt; subscribeActual<br><br><span class="hljs-bullet">4.</span> subscribeActual 会调用到 -&gt; 匿名内部类.subscribe(emiiter)<br><br><span class="hljs-bullet">5.</span> 我们的代码<br></code></pre></td></tr></table></figure><blockquote><p>我们自己写的 demo 代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的 it 是 ObservableEmitter</span><br>it.onNext(<span class="hljs-number">1</span>)<br>it.onComplete()<br></code></pre></td></tr></table></figure><p>那么，当 it.onNext(1) 执行之后，又会发生什么呢？</p><p>这个 it 就是 CreateEmitter，嗯，虽然有点突然，但是这个应该没有疑问吧？！！</p><blockquote><ol><li>我们把 sourceClown 传进去，并且调用了 ObservableEmitter 的 onNext 等方法</li><li>sourceClown 被封装成了 CreateEmitter</li><li>source 的 subscribe 方法接收的是 CreateEmitter，</li></ol><p>所以，ObservableEmitter 在运行时就是 CreateEmitter 对象。</p></blockquote><p>我们先不忙着去看它的 onNext 方法，先看看这个类。</p><h4 id="套路三"><a href="#套路三" class="headerlink" title="套路三"></a>套路三</h4><blockquote><p>由老父亲来替你打理一切</p></blockquote><p>我们知道在<strong>套路二</strong>里面，我们传递的 sourceClown 被封装了一下，变成了一个 <code>CreateEmitter</code> 。</p><p><code>CreateEmitter</code> 这个变量名就很叼，一看就是 observer 的老父亲，那么，可以先猜一猜，为啥它要起这样一个名呢？</p><p>由于<code>ObservableOnSubscribe</code> 的 <code>subscribe</code>方法只接受 <code>ObservableEmitter</code> ，所以  <code>CreateEmitter</code>  必须要实现这个接口。</p><p>好，我们看源代码：</p><blockquote><p>CreateEmitter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateEmitter</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">Disposable</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">ObservableEmitter</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Disposable</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>AtomicReference</code>是java类，就不展开讲了，不知道的人（比如我）这个时候应该打开了文档，开始学习了。</p><p>继续看构造方法：</p><blockquote><p>CreateEmitter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CreateEmitter(Observer&lt;? <span class="hljs-keyword">super</span> T&gt; observer) &#123;<br>    <span class="hljs-keyword">this</span>.observer = observer;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，很好，observer 被保存起来了。</p><p>由于，在 sourceClown 中我们调用了：</p><blockquote><p>我们写的 demo 的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">it.onNext(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>上面说过，it 就是 CreateEmitter，所以 CreateEmitter的 onNext 方法会被调用。</p><p>现在，我们来分析它的 onNext 方法：</p><blockquote><p>CreateEmitter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;<br>        onError(<span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isDisposed()) &#123;<br>        observer.onNext(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RxJava2 中不允许数据源发射的数据为 null，所以我们简化一下：</p><blockquote><p>CreateEmitter.java</p><p>onNext 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isDisposed()) &#123;<br>        observer.onNext(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>isDisposed 方法，就是判断观察者有没有解除订阅，毕竟，蝙蝠侠也会心累。</p><p>这上面做了这么多判断，现在知道为啥起名叫 parent 了不？</p><p>在我们的例子中，我们没有解除订阅，再简化一下，就是：</p><blockquote><p>CreateEmitter.java</p><p>onNext 简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    observer.onNext(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>这下，够直白了吧，直接调用了 observer 的 onNext 方法。</p><p>还记得 observer 是谁吗，就是你，蝙蝠侠，observerBatMan。所以它的 onNext 方法会被调用。</p><blockquote><p>我们写的 demo 的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">override fun <span class="hljs-title">onNext</span><span class="hljs-params">(t: Int)</span> </span>&#123;<br>    Assert.assertEquals(<span class="hljs-number">1</span>, t)<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，整个流程就跑通了。</p><p>至于，onComplete 方法，差不多的啦。</p><p>最后上一张图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_1.png?raw=true"></p><p>最后，还有一个很重要的东西，就是这个小demo 的起始点，并不是 sourceClown，上面的图不是程序执行流程图，而是一种关系图。</p><p>现在我们来看看，程序的起始点在哪？</p><blockquote><p>我们写的 demo 代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开始观察</span><br>Observable.create&lt;Int&gt;(sourceClown)<br>    .subscribe(observerBatMan)<br></code></pre></td></tr></table></figure><p>程序的起始点是 subscribe 方法，这个方法是属于 ObservableCreate 的，<strong>所以程序的起始点在 ObservableCreate 的 subscribe 方法</strong>。</p><p>下面，贴上程序执行流程图：</p><p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/rxjava2_4.png?raw=true"></p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava2 源码分析（六）</title>
    <link href="/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2019/08/18/blog_bak/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/RxJava2/RxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>分析Flowable的相关源码，了解一下背压的知识。</p><h3 id="从例子开始"><a href="#从例子开始" class="headerlink" title="从例子开始"></a>从例子开始</h3><blockquote><p>demo</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Flowable<br>        .create&lt;<span class="hljs-built_in">Int</span>&gt;(&#123;<br>            it.onNext(<span class="hljs-number">1</span>)<br>            it.onNext(<span class="hljs-number">2</span>)<br>            it.onComplete()<br>        &#125;, BackpressureStrategy.BUFFER)<br>        .subscribe &#123;<br>            System.<span class="hljs-keyword">out</span>.println(it)<br>        &#125;<br></code></pre></td></tr></table></figure><p>看看 create 方法创建了一个什么对象：</p><h4 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h4><blockquote><p>io.reactivex.Flowable#create</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Flowable&lt;T&gt; <span class="hljs-title">create</span><span class="hljs-params">(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(source, <span class="hljs-string">&quot;source is null&quot;</span>);<br>    ObjectHelper.requireNonNull(mode, <span class="hljs-string">&quot;mode is null&quot;</span>);<br>    <span class="hljs-keyword">return</span> RxJavaPlugins.onAssembly(<span class="hljs-keyword">new</span> FlowableCreate&lt;T&gt;(source, mode));<br>&#125;<br></code></pre></td></tr></table></figure><p>创建了一个 FlowableCreate 对象，由于 Flowable 与 Observerable 差不多，所以下面我们按照分析 Observerable 的思路来分析 Flowable。</p><p>####FlowableCreate</p><blockquote><p>类结构</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowableCreate&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Flowable&lt;T&gt;</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这个没啥说的，与 Observerable 一样。</p><blockquote><p>构造函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowableCreate</span><span class="hljs-params">(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy backpressure)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.source = source;<br>    <span class="hljs-keyword">this</span>.backpressure = backpressure;<br>&#125;<br></code></pre></td></tr></table></figure><p>也与 Observerable 差不多，就是两套代码吧。一个以 Observerable  开头，一个以 Flowable 开头，嗯，现在我对源码的探究就只到了这个程度，可能还有别的不同，暂时还未发现。</p><blockquote><p>subscribeActual 方法</p><p>demo 中 backpressure 我们传递的是 BackpressureStrategy.BUFFER，所以 emitter 的值是 BufferAsyncEmitter。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeActual</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; t)</span> </span>&#123;<br>    BaseEmitter&lt;T&gt; emitter;<br><br>    <span class="hljs-keyword">switch</span> (backpressure) &#123;<br>    <span class="hljs-keyword">case</span> MISSING: &#123;<br>        emitter = <span class="hljs-keyword">new</span> MissingEmitter&lt;T&gt;(t);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> ERROR: &#123;<br>        emitter = <span class="hljs-keyword">new</span> ErrorAsyncEmitter&lt;T&gt;(t);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> DROP: &#123;<br>        emitter = <span class="hljs-keyword">new</span> DropAsyncEmitter&lt;T&gt;(t);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> LATEST: &#123;<br>        emitter = <span class="hljs-keyword">new</span> LatestAsyncEmitter&lt;T&gt;(t);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-comment">// 走这里</span><br>        emitter = <span class="hljs-keyword">new</span> BufferAsyncEmitter&lt;T&gt;(t, bufferSize());<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的就不分析了，参考前面的文章</span><br>    t.onSubscribe(emitter);<br>    <span class="hljs-keyword">try</span> &#123;<br>        source.subscribe(emitter);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        Exceptions.throwIfFatal(ex);<br>        emitter.onError(ex);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以，我们只需要分析 BufferAsyncEmitter 这个类就好了。</p><p>####FlowableCreate.BufferAsyncEmitter</p><blockquote><p>类结构</p><p>这个类是 FlowableCreate 的内部类，可以想到其他的 Emitter 应该也是内部类</p><p>继承了 BaseEmitter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferAsyncEmitter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseEmitter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>####FlowableCreate.BaseEmitter</p><blockquote><p>类结构</p><p>注意这个类继承至 AtomicLong</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEmitter</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AtomicLong</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">FlowableEmitter</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Subscription</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这个类实现了一些通用的方法，比如 onError，onComplete，cancel等等。</p><p>其中只有一个方法需要看看：</p><blockquote><p>BaseEmitter#request</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 判断 n 是不是正数</span><br>    <span class="hljs-keyword">if</span> (SubscriptionHelper.validate(n)) &#123;<br>        <span class="hljs-comment">// 是正数，将 n 设置给自己</span><br>        <span class="hljs-comment">// 上面有说，这个类继承了 AtomicLong，所以它可以持有一个 Long 型的引用</span><br>        BackpressureHelper.add(<span class="hljs-keyword">this</span>, n);<br>        <span class="hljs-comment">// 钩子方法</span><br>        onRequested();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，到这里 BaseEmitter 的方法就分析的差不多了，这个类只是提供了一些默认的实现方法，没有别的逻辑，把它当成一个普通的父类就好了。</p><p>####FlowableCreate.BufferAsyncEmitter</p><p>再回到 BufferAsyncEmitter 里面，看构造函数</p><blockquote><p>构造函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferAsyncEmitter(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; actual, <span class="hljs-keyword">int</span> capacityHint) &#123;<br>    <span class="hljs-keyword">super</span>(actual);<br>    <span class="hljs-comment">// 这里有一个新类</span><br>    <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> SpscLinkedArrayQueue&lt;T&gt;(capacityHint);<br>    <span class="hljs-keyword">this</span>.wip = <span class="hljs-keyword">new</span> AtomicInteger();<br>&#125;<br></code></pre></td></tr></table></figure><p>SpscLinkedArrayQueue 这个类不展开介绍了，贴一段注释就明白了。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">A single-producer single-consumer<span class="hljs-built_in"> array-backed </span>queue which can allocate<span class="hljs-built_in"> new </span>arrays in case the consumer is slowerthan the producer.<br><br>一个单生产者单消费者数组支持的队列，它可以在消费者比生产者慢的情况下分配新的数组（自动增长）。<br></code></pre></td></tr></table></figure><p>机翻都能看的懂吧，源码就是实现了这样功能的队列，有兴趣的可以看看。</p><p>我们把 SpscLinkedArrayQueue 当成一个队列就好。注意这里的初始容量是 128，但是会自动增长。</p><p>看完构造方法，再看 onNext 方法。</p><blockquote><p>onNext</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-comment">// isCancelled 是父类的方法</span><br>    <span class="hljs-comment">// 当我们调用 setDisposable 方法的时候，父类就会保存这个 Disposable 的引用到 serial 字段</span><br>    <span class="hljs-comment">// 如果该 Disposable 调用了 dispose 方法，那么 isCancelled 会返回 true</span><br>    <span class="hljs-comment">// 调用父类的 cancel 方法，isCancelled 也会返回 true（内部调用了 serial.dispose()）</span><br>    <span class="hljs-comment">// 数据发送完毕或者发生错误，isCancelled 也会返回 true（内部调用了 serial.dispose()）</span><br>    <span class="hljs-comment">// done 只有数据发生完毕或者发生错误才会为true</span><br>    <span class="hljs-keyword">if</span> (done || isCancelled()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 不允许发送的数据为null</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;<br>        onError(<span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先将数据添加到队列里面</span><br>    queue.offer(t);<br>    <span class="hljs-comment">// 调用 drain 方法</span><br>    drain();<br>&#125;<br></code></pre></td></tr></table></figure><p>看来，onNext 的主要目的，就是先将数据加入到队列里面，然后调用 drain 方法。继续看 drain 方法。</p><blockquote><p>drain </p><p>这个方法有点长，变量名也有点蛋疼，但是慢慢分析，不难</p><p>在阅读源码的时候，一定要有耐心。阅读源码的过程其实是一个提升自己理解力的过程。</p><p>既然你需要阅读别人的源代码，那么你的理解力肯定是处于弱势的，不然的话，你一看就懂，那就说明源码的东西在作者写出来之前你都已经掌握了，那么阅读源码对自己没有任何好处。</p><p>所以，阅读源码的过程，就是需要慢慢提升自己的理解力，来达到与作者的理解力一样的程度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// wip 这个变量到后面分析，因为涉及到别的方法，单看这一个方法看不出什么东西来</span><br>    <span class="hljs-keyword">if</span> (wip.getAndIncrement() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> missed = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这两个变量名有点吊</span><br>    <span class="hljs-keyword">final</span> Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; a = actual;<br>    <span class="hljs-keyword">final</span> SpscLinkedArrayQueue&lt;T&gt; q = queue;<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 这里，获取设置的引用值，因为这个类是继承的 AtomicLong</span><br>        <span class="hljs-comment">// 前面我们分析过，只有 request 方法才会设置引用值</span><br>        <span class="hljs-comment">// 至于哪里调用了 request 方法，我们后面分析</span><br>        <span class="hljs-comment">// 这里将这个值当作 Long.MAX_VALUE</span><br>        <span class="hljs-keyword">long</span> r = get();<br>        <span class="hljs-keyword">long</span> e = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-comment">// 进入循环</span><br>        <span class="hljs-keyword">while</span> (e != r) &#123;<br>            <span class="hljs-comment">// 判断是否取消了</span><br>            <span class="hljs-keyword">if</span> (isCancelled()) &#123;<br>                <span class="hljs-comment">// 取消了就清空队列</span><br>                q.clear();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 时候发送完毕了，或者出现了错误</span><br>            <span class="hljs-keyword">boolean</span> d = done;<br><br>            <span class="hljs-comment">// 从队列中取出一个数据</span><br>            T o = q.poll();<br><br>            <span class="hljs-comment">// 队列是否为空</span><br>            <span class="hljs-keyword">boolean</span> empty = o == <span class="hljs-keyword">null</span>;<br><br>            <span class="hljs-comment">// 数据发送完毕了，并且队列为空</span><br>            <span class="hljs-keyword">if</span> (d &amp;&amp; empty) &#123;<br>                Throwable ex = error;<br>                <span class="hljs-keyword">if</span> (ex != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 调用父类 error 方法，会调用 onError</span><br>                    error(ex);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 调用父类 complete 方法，会调用 onComplete</span><br>                    complete();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 队列为空，则跳出循环</span><br>            <span class="hljs-keyword">if</span> (empty) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 调用 onNext 方法，o 是从队列取出来的数据</span><br>            a.onNext(o);<br><br>            <span class="hljs-comment">// e 的值累加</span><br>            e++;<br>        &#125;<br><br>        <span class="hljs-comment">// 这里要判断一下 e 与 r 是否相等，</span><br>        <span class="hljs-comment">// 因为如果队列为空的话，e 是不等于 r 的</span><br>        <span class="hljs-comment">// 相等的话，说明请求的个数刚好等于发送的个数，做一下收尾工作就好了</span><br>        <span class="hljs-keyword">if</span> (e == r) &#123;<br>            <span class="hljs-comment">// 下面的一段与上面的很相似，不一句一句写了</span><br>            <span class="hljs-keyword">if</span> (isCancelled()) &#123;<br>                q.clear();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> d = done;<br><br>            <span class="hljs-keyword">boolean</span> empty = q.isEmpty();<br><br>            <span class="hljs-keyword">if</span> (d &amp;&amp; empty) &#123;<br>                Throwable ex = error;<br>                <span class="hljs-keyword">if</span> (ex != <span class="hljs-keyword">null</span>) &#123;<br>                    error(ex);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    complete();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 因为发送了 e 个数据，所以将引用值更新</span><br>            <span class="hljs-comment">// 内部就是将引用自减少了 e</span><br>            BackpressureHelper.produced(<span class="hljs-keyword">this</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 这个后面分析</span><br>        missed = wip.addAndGet(-missed);<br>        <span class="hljs-keyword">if</span> (missed == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>drain 的主要作用，就是当我们调用 request(num) 请求 num 个数据的时候，这个方法会从队列中取出 num 个数据出来给我们。</p><p>可以思考一下，如果我们没有调用，request 方法，会怎么样？</p><blockquote><p>drain</p><p>简化后的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drain</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">long</span> r = get();<br>        <span class="hljs-keyword">long</span> e = <span class="hljs-number">0L</span>;<br><br>        <span class="hljs-comment">// 没有调用 request，导致 r 为 0，这里进不去</span><br>        <span class="hljs-keyword">while</span> (e != r) &#123;<br>            ...<br>        &#125;<br><br>        <span class="hljs-comment">// 相等</span><br>        <span class="hljs-keyword">if</span> (e == r) &#123;<br>            <span class="hljs-comment">// 没有取消</span><br>            <span class="hljs-keyword">if</span> (isCancelled()) &#123;<br>                ...<br>            &#125;<br><br>            <span class="hljs-keyword">boolean</span> d = done;<br><br>            <span class="hljs-comment">// 队列不为空</span><br>            <span class="hljs-keyword">boolean</span> empty = q.isEmpty();<br><br>            <span class="hljs-comment">// 进不去</span><br>            <span class="hljs-keyword">if</span> (d &amp;&amp; empty) &#123;<br>                ...<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 进不去</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-number">0</span>) &#123;<br>            ...<br>        &#125;<br><br>        missed = wip.addAndGet(-missed);<br>        <span class="hljs-comment">// 满足，跳出循环</span><br>        <span class="hljs-keyword">if</span> (missed == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果我们没有调用 request 方法，虽然 onNext 方法被调用了，将数据加入到了队列中，但是却无法从队列中取出数据，即下游的观察者收不到任何数据。</p><p>还有两个遗留的问题：</p><ol><li>wip 变量的作用？</li><li>request 方法在哪里调用的？</li></ol><p>先看第一个问题：</p><blockquote><p>drain</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drain</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 将值加 1，返回未加 1 之前的值</span><br>        <span class="hljs-comment">// 就是判断 wip 的引用值是否是0，然后加1</span><br>        <span class="hljs-keyword">if</span> (wip.getAndIncrement() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 到了这里 wip 引用的值理论上为1</span><br>        <span class="hljs-comment">// 但是多线程的情况下， onUnsubscribed 会将 wip 加 1</span><br>        <span class="hljs-keyword">int</span> missed = <span class="hljs-number">1</span>;<br>        ...<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            ...<br>                <br>            <span class="hljs-comment">// 将 wip 的值减 - missed</span><br>            <span class="hljs-comment">// 这里处在一个循环中，最终 wip 的值会变成 0，missed 也会变成0，跳出循环</span><br>            missed = wip.addAndGet(-missed);<br>            <span class="hljs-keyword">if</span> (missed == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>onUnsubscribed</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnsubscribed</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 取消的时候，wip 的值为 0 的话，清空队列</span><br>    <span class="hljs-comment">// 就是说，此时，drain 方法运行到了 for 循环的最后几行</span><br>    <span class="hljs-comment">// 这里应该是为了保证，数据从队列里面取出来，一定要发送出去才行</span><br>    <span class="hljs-keyword">if</span> (wip.getAndIncrement() == <span class="hljs-number">0</span>) &#123;<br>        queue.clear();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 BufferAsyncEmitter 这个类中，使用到 wip 这个变量的，只有上面这几个地方。</p><p>onUnsubscribed 会在父类的 cancel 方法中调用，所以我们调用 cancel 就会改变 wip 的值：</p><h4 id="FlowableCreate-BaseEmitter"><a href="#FlowableCreate-BaseEmitter" class="headerlink" title="FlowableCreate.BaseEmitter"></a>FlowableCreate.BaseEmitter</h4><blockquote><p>cancel</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;<br>    serial.dispose();<br>    onUnsubscribed();<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，第一个问题说完了，我们来看看第2个问题：</p><p>首先我们回到 demo 中，既然 create 方法中没有调用 request 的地方，那么我们只能从 subscribe 方法入手了。</p><p>####Flowable</p><blockquote><p>io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;)</p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">Disposable <span class="hljs-title">subscribe</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; onNext)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(onNext, Functions.ON_ERROR_MISSING,</span></span><br><span class="hljs-params"><span class="hljs-function">            Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它调用了名方法：</p><blockquote><p>io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;, io.reactivex.functions.Consumer&lt;? super java.lang.Throwable&gt;, io.reactivex.functions.Action, io.reactivex.functions.Consumer&lt;? super org.reactivestreams.Subscription&gt;)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Disposable <span class="hljs-title">subscribe</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="hljs-keyword">super</span> Throwable&gt; onError,</span></span><br><span class="hljs-params"><span class="hljs-function">        Action onComplete, Consumer&lt;? <span class="hljs-keyword">super</span> Subscription&gt; onSubscribe)</span> </span>&#123;<br>    ObjectHelper.requireNonNull(onNext, <span class="hljs-string">&quot;onNext is null&quot;</span>);<br>    ObjectHelper.requireNonNull(onError, <span class="hljs-string">&quot;onError is null&quot;</span>);<br>    ObjectHelper.requireNonNull(onComplete, <span class="hljs-string">&quot;onComplete is null&quot;</span>);<br>    ObjectHelper.requireNonNull(onSubscribe, <span class="hljs-string">&quot;onSubscribe is null&quot;</span>);<br><br>    LambdaSubscriber&lt;T&gt; ls = <span class="hljs-keyword">new</span> LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);<br><br>    subscribe(ls);<br><br>    <span class="hljs-keyword">return</span> ls;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建了一个 LambdaSubscriber 对象，并调用了 subscribe 方法，将 ls 传递了进去。</p><p>所以这个方法其实就是将我们的 consumer 包装成了 LambdaSubscriber，然后调用真正的 subscribe 方法。</p><h4 id="LambdaSubscriber"><a href="#LambdaSubscriber" class="headerlink" title="LambdaSubscriber"></a>LambdaSubscriber</h4><p>看看 LambdaSubscriber 类：</p><blockquote><p>构造方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LambdaSubscriber</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; onNext, Consumer&lt;? <span class="hljs-keyword">super</span> Throwable&gt; onError,</span></span><br><span class="hljs-params"><span class="hljs-function">        Action onComplete,</span></span><br><span class="hljs-params"><span class="hljs-function">        Consumer&lt;? <span class="hljs-keyword">super</span> Subscription&gt; onSubscribe)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.onNext = onNext;<br>    <span class="hljs-keyword">this</span>.onError = onError;<br>    <span class="hljs-keyword">this</span>.onComplete = onComplete;<br>    <span class="hljs-keyword">this</span>.onSubscribe = onSubscribe;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存了一些变量，onSubscribe 值得注意，因为这个 Consumer 在订阅的时候会回调，是调用 request 的最好时机。</p><p>直接看 onSubscribe 的实现。</p><blockquote><p>onSubscribe</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Subscription s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (SubscriptionHelper.setOnce(<span class="hljs-keyword">this</span>, s)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            onSubscribe.accept(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            Exceptions.throwIfFatal(ex);<br>            s.cancel();<br>            onError(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了 onSubscribe 对象的 accept 方法。我们看看这个对象的实现吧。</p><h4 id="FlowableInternalHelper-RequestMax-INSTANCE"><a href="#FlowableInternalHelper-RequestMax-INSTANCE" class="headerlink" title="FlowableInternalHelper.RequestMax.INSTANCE"></a>FlowableInternalHelper.RequestMax.INSTANCE</h4><p>从前面的代码中（Flowable.subscribe()方法中），我们知道 onSubscribe 对象是 FlowableInternalHelper.RequestMax.INSTANCE。所以看看这个类的代码吧。</p><blockquote><p>FlowableInternalHelper.RequestMax.INSTANCE</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RequestMax</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">Subscription</span>&gt; </span>&#123;<br>    INSTANCE;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Subscription t)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        t.request(Long.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，果然是这里调用了 request 方法。</p><p>到这里，Flowable 的分析就告一段落。</p>]]></content>
    
    
    <categories>
      
      <category>RxJava2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-源码解析-RxJava2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java核心技术（基础知识）笔记</title>
    <link href="/2019/08/18/blog_bak/Blog/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/18/blog_bak/Blog/Java/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章-Java程序设计概述"><a href="#第一章-Java程序设计概述" class="headerlink" title="第一章 Java程序设计概述"></a>第一章 Java程序设计概述</h3><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p>用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。</p><h4 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h4><p>解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。</p><p>字节码可以（在运行时刻）动态的翻译成对应运行这个应用的特定CPU机器码。</p><p>即时编译器还可以消除函数调用（即“内联”）。</p><h3 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h3><p>####一个简单的Java应用程序</p><p>根据Java语言规范，Java虚拟机将从指定类中的main方法开始执行。</p><p>不过，当main方法不是public时，有些版本的Java解释器也可以执行Java应用。这是因为Java虚拟机规范并没有要求main方法一定是public。这个问题已经得到了修复，在Java SE 1.4及以后的版本中强制main方法时public的。</p><p>####整形</p><p>从Java 7开始，加上前缀0B或者0b就可以写二进制数。例如：0b1001就是9。同样，从Java 7开始，还可以为数字字面量加下划线，如用1_000_000表示一百万。</p><p>####浮点类型</p><p>所有”非数值“的值都认为是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (x == Double.NaN) <span class="hljs-comment">// is never true</span><br></code></pre></td></tr></table></figure><p>可以使用 Double.isNaN() 来判断（长得帅的肯定会戳进去看一下源码，很有意思哦）。</p><p>浮点数不适用于无法接受舍入误差的金融计算中。例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> result = <span class="hljs-number">2.0</span> - <span class="hljs-number">1.9</span>; <span class="hljs-comment">// result = 0.10000000000000009</span><br></code></pre></td></tr></table></figure><p>这是因为二进制无法精确的表示 1/10。</p><p>可移植性是Java的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位储存一个数值，而有些处理器使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ddoble w = x * y / z;<br></code></pre></td></tr></table></figure><p>使用严格浮点计算，截断中间数，可以了解一下 strictfp 关键字。</p><p>####char类型</p><p>转义字符\u可以出现在加引号的字符常量或字符串之外（其他的转义字符不行）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String\u005B\u005D args)</span></span><br></code></pre></td></tr></table></figure><p>\u005B\u005D其实就是[]，所以上面的代码就是程序的入口main函数。（可以编译成class文件并运行，但是不被IDE识别）</p><p>Unicode转义字符会在解析代码之前得到处理，举个吓死人的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// file in c:\user</span><br></code></pre></td></tr></table></figure><p>当你在代码里面加上这行注释的时候，点击运行按钮就会发现，编译过不了！！！我的理解是先会将文件里面的转义字符全部处理一下，当处理到这行注释的时候，发现了 <code>\u</code> 会当成转义字符来处理，但是 <code>\u</code> 后面的字符不合法，所以就报错了。</p><p>Unicode的基本平面，辅助平面，码点的概念，可以看维基百科。</p><p>一个字符可能有多个码点，一个char只能表示一个码点。</p><p>####运算符</p><p>整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或者NaN结果。</p><p>####数值类型之间的转换</p><p>两个操作数有一个是 double ，则两个数按照 double 处理，</p><p>否则，有一个是 float，则两个数按照 float 处理，</p><p>否则，有一个是 long，则两个数按照 long 处理，</p><p>否则，两个数按照 int 处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">byte</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">byte</span> c = a + b; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<br>a += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok，因为 += 会自动进行强制转换</span><br></code></pre></td></tr></table></figure><p>####位运算符</p><p>处理整形类型时，可以直接对组成整形数值的各个位完成操作，浮点数不行。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>a &lt;&lt; <span class="hljs-number">1</span><span class="hljs-comment">; // ok</span><br>double b = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>b &lt;&lt; <span class="hljs-number">1</span><span class="hljs-comment">; // error</span><br></code></pre></td></tr></table></figure><p>位移运算符的右操作数要完成模32的运算（如果左操作是long型，则需要模64）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">35</span> 相当于 <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>####字符串</p><p>编译器可以让字符串共享，只有字符串常量是共享的，+或者substring等操作产生的结果并不是共享的。</p><p>####格式化输出：</p><p>使用参数索引来对一个参数进行多次格式化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;%1$s %2$tB %2$te %2$tY&quot;</span>, <span class="hljs-string">&quot;Due date:&quot;</span>, <span class="hljs-keyword">new</span> Date());<br></code></pre></td></tr></table></figure><p>可以看到第二个索引对<code>new Date()</code>参数格式化了多次。使用<code>&lt;</code>标志也可以达到同样的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.print(<span class="hljs-string">&quot;%s %tB %&lt;te %&lt;tY&quot;</span>, <span class="hljs-string">&quot;Due date:&quot;</span>, <span class="hljs-keyword">new</span> Date());<br></code></pre></td></tr></table></figure><p>####数组</p><p>Java中，允许数组长度为0，数组长度为0和null不同。</p><p>####数组排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(a); <span class="hljs-comment">// 这个方法使用了优化的快速排序算法</span><br></code></pre></td></tr></table></figure><p>利用数组写一个抽彩游戏（这个算法还是很有想法的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>    numbers[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++) &#123;<br>    <span class="hljs-keyword">int</span> r = (<span class="hljs-keyword">int</span>)(Math.random() * n);<br>    result[i] = numbers[r];<br>    <span class="hljs-comment">// 最关键的代码，将上面随机出来的数用最后一个数覆盖</span><br>    numbers[r] = numbers[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 将 n 减一，相当于去掉最后一个数</span><br>    n--;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四章-类与对象"><a href="#第四章-类与对象" class="headerlink" title="第四章 类与对象"></a>第四章 类与对象</h3><p>####面向对象程序设计概述</p><p>OOP将数据放在第一位，然后再考虑操作数据的算法。</p><p>####对象</p><p>对象状态的改变必须通过调用方法实现，如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。</p><p>####类之间的关系</p><p>最常见的关系有：</p><ul><li>依赖（“use-a”）</li><li>聚合（“has-a”）</li><li>继承（“is-a”）</li></ul><p>####Java类库中的LocalDate类</p><p>将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。</p><p>####用户自定义类</p><p>在一个源文件中，只能有一个公有类，但可以有任意数目的非共有类。</p><p>第一眼看到这句话我是懵逼的，后来仔细看了代码，发现应该说的是非内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main2</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源文件是Ok的。但是把Main2改成public的就不行。</p><p>####封装的优点</p><p>可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p><p>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</p><p>####静态常量</p><p>我们常使用的System类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PrintStream out = ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道 final 修饰的变量是不允许将别的值赋给它的，但是System类有这样的一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOut</span><span class="hljs-params">(PrintStream out)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>它可以将System.out设置为不同的流，原因是setOut是一个本地方法，它可以绕过Java语言的存取控制机制。</p><p>####方法参数</p><p>Java程序设计语言总是采用按值调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的，下面给出例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Car a, Car b)</span> </span>&#123;<br>    Car temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果Java对对象采用的是按照引用传递，那么这个方法应该够实现交换数据的效果，但是，并没有。参数被初始化为对象引用的拷贝。</p><p>####初始化块</p><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值（0，false或null）。</li><li><strong>按照在类声明中出现的顺序</strong>，依次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    &#123;<br>        a = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Main m = new Main(); 问，m.getA() 的值？</span><br></code></pre></td></tr></table></figure><h4 id="对象析构与-finalize-方法"><a href="#对象析构与-finalize-方法" class="headerlink" title="对象析构与 finalize 方法"></a>对象析构与 finalize 方法</h4><p>在实际应用中，不要依赖使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p><p>我一直觉得，final，finally，finalize有啥区别，这个问题很傻×，因为他们毛关系没有，区别从何谈起。问问 final  与 volitile的区别吧！！！</p><p>####将类放入包中</p><p>假定有一个源文件开头有下列语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aprz;<br></code></pre></td></tr></table></figure><p>编译器在编译源文件的时候不检查目录结构，即使这个源文件没有在子目录 com/aprz 下，也可以进行编译。但是，最终的程序将无法运行。如果包与目录不匹配，虚拟机就找不到类。</p><p>####包作用域</p><p>如果，把一个类文件放置在类路径的某处的 java/awt 子目录下，那么我们就可以访问 java.awt 包的内部了。非常危险！</p><p>从 1.2 版开始，JDK 的实现者修改了类加载器，明确禁止加载用户自定义的、包名以“java”开始的类！</p><p>####类路径</p><p>javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。</p><p>下面看一个类路径示例：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/home/user/<span class="hljs-symbol">classdir:</span>.<span class="hljs-symbol">:/home/user/archives/archive</span>.jar<br></code></pre></td></tr></table></figure><p>假定虚拟机要搜寻 <code>com.horstmann.corejava.Employee</code>类文件。它首先要查看储存在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找一下文件：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/classdir/</span>com<span class="hljs-regexp">/horstmann/</span>corejava/Employee.<span class="hljs-keyword">class</span><br>com<span class="hljs-regexp">/horstmann/</span>corejava/Employee.<span class="hljs-keyword">class</span>从当前目录开始<br>com<span class="hljs-regexp">/horstmann/</span>corejava<span class="hljs-regexp">/Employee.class inside /</span>home<span class="hljs-regexp">/user/</span>archives/archive.jar<br></code></pre></td></tr></table></figure><p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类。例如，假定源文件包含指令:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> com.horstmann.corejava.*;<br></code></pre></td></tr></table></figure><p>并且源代码引用了Employe类。<strong>编译器将试图查找jva.lang.Employee (因为java lang包被默认入）、java.util.Employee、com.hostmann.corejava.Employee和当前包中的Employee。</strong>对这个类路径的所有位置中所列出的每个类进行逐查看。 如果找到了一个以上的类，就会产生编译错误(因为类必须是唯一的， 而import语句的次序却无关紧要)。</p><p>编译器的任务不止这些，它还要查看源文件( Source files) 是否比类文件新。<strong>如果是这样的话，那么源文件就会自动地重新编译</strong>。</p><p>在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，<strong>编译器很容易定位公有类所在的源文件</strong>。当然，也可以从当前包中<strong>导入非公有类</strong>。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，<strong>编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类</strong>。</p><p>这一段很长，我只能说QQ的图片文字识别真的牛逼。</p><h3 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h3><h4 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h4><p>前缀“超”与“子”来源于计算机科学和数学理论中的集合语言的术语。</p><h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>尽管子类对象有父类的私有域，但是却无法在子类中访问这个域。（这句话是我总结的，可能并不严谨）</p><p>有些人（包括我）认为super与this应用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个只是编译器调用超类方法的特殊关键字。</p><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>虚拟机知道一个引用的对象类型，所以能够正确的调用相应的方法。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><br>B[] bs = <span class="hljs-keyword">new</span> B[<span class="hljs-number">8</span>];<br>A[] as = bs;<br></code></pre></td></tr></table></figure><p>但是这样会有一个问题，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">as[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> A();<br></code></pre></td></tr></table></figure><p>编译器是会接纳这个赋值操作的。由于bs与as指向同一个数组，当调用B中特有的方法时，就会出现错误。而且在运行时还会报出 ArrayStoreException 错误。</p><h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><ol><li>编译器查看对象的声明类型和方法名。假设调用 <code>x.f(param)</code>，且隐私参数<code>x</code>声明为<code>C</code>类的对象。编译器会一一列举所有<code>C</code>类中名为<code>f</code>的方法和其超类中访问属性为<code>public</code>且名为<code>f</code>的方法。</li><li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<em>重载解析</em>。</li></ol><p><u>允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A.java</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Father <span class="hljs-title">find</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>--------------------------------<br><span class="hljs-comment">// B.java</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Son <span class="hljs-title">find</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>如果是 private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式就是<em>静态绑定</em>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用的时候，虚拟机仅查找这个表就行了。</li></ol><h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h4><p>在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程为称为<em>内联</em>。例如，内联调用 <code>e.getName()</code>将被替换为访问<code>e.name</code>域。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略。然面，如果<code>getName</code>在另外个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p><p> 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢?优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。</p><h4 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h4><p>所有的数组类型，不管时对象数组还是基本类型的数组都扩展了Object类。</p><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p><h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>如果隐私和显式的参数不属于同一个类，equals方法将如何处理呢？这是一个很有争议的话题！</p><p>许多程序员喜欢使用 instanceof 进行检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(!(otherObject <span class="hljs-keyword">instanceof</span> Person)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做不但没有解决 otherObject 是子类的情况，并且还有可能会招来一些额外的麻烦。</p><p>Java语言规范要求 equals 方法具有下面的特性：</p><ol><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>对于任意非空引用x，x.equals(null)，应该返回false。</li></ol><p>就对称性来说，当参数不属于同一个类的时候需要仔细思考一下。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">e.quals(m)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>e 是父类，m是子类。如果这两个对象的实例域都一样，当使用 instanceof 操作符的时候，会返回 true，那么意味着，m.equals(e)，也会返回true。但是实际上，反过来调用是无法通过 instanceof 操作符的。</p><p>建议的规则：</p><ul><li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass进行检测</li><li>如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。</li></ul><p>一个完美equals方法的编写模板：</p><ol><li><p>显示参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。</p></li><li><p>检测 this 与 otherObject 是否引用同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == otherObject) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>检测otheObject是否为null，如果为null，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(otherObject == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测。如果所有的子类拥有统一的语义，就使用instanceof检测。</p></li><li><p>将otherObject转换为相应类型的变量</p><p>ClassName other = (ClassName) otherObject;</p></li><li><p>开始对所有需要比较的域进行比较，如果在子类中重新定义equals，就要在其中包含调用 super.equals(other)。</p></li></ol><p>一种常见的错误是将equals方法的参数类型改为具体需要比较的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Person p)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>注意上面的方法不是覆盖，因为参数类型不一样，Object类中equal方法的参数是Object。</p><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;ok&quot;</span>);<br>StringBuffer tb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;ok&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意，sb与tb的hashCode不一样，这是因为StringBuffer没有定义自己的hashCode方法。</p><p><u>equals方法相等则hashCode必须一致。</u></p><h4 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h4><p>一旦确定数组列表的大小不再发生变化，就可以调用 trimToSize 方法。这个方法将储存区域的大小调整为当权元素数量所需要的储存空间数目。垃圾回收器将回收多余的储存空间。</p><h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类。</p><p>自动装箱规范要求 boolean、byte、char &lt;= 127，介于-128~127之间的short和int被包装到固定的对象中。这句话乍一看很诡异，其实都是同一个意思。</p><p>char 的范围是从 0 ~ 65535。</p><h4 id="在运行时使用反射分析对象"><a href="#在运行时使用反射分析对象" class="headerlink" title="在运行时使用反射分析对象"></a>在运行时使用反射分析对象</h4><p>setAccessible方法时AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。</p><p>利用get方法可以访问域的值，但是有一个需要解决的问题。如果域是一个String类型，把它当作Object返回没有什么问题，但是，假设这个域是double类型的，而Java中数值类型不是对象，该怎么办呢？其实反射机制会自动地将这个域值打包到相应的对象包装器中。invoke 方法也是如此。</p><h4 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h4><ol><li><p>将公共操作和域放在超类</p></li><li><p>不要使用受保护的域</p><p>protect 在某种程度上破坏了封装，因为同一个包类的代码也可以访问该域。</p><p>子类也可以随便访问超类的protect域。</p></li><li><p>使用继承实现“is-a”关系</p></li><li><p>除非所有继承的方法都有意义，否则不要使用继承</p></li><li><p>在覆盖方法时，不要改变预期的行为</p></li><li><p>使用多态，而非类型信息</p></li><li><p>不要过多的使用反射</p></li></ol><h3 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h3><h4 id="Comparable-lt-T-gt-接口"><a href="#Comparable-lt-T-gt-接口" class="headerlink" title="Comparable&lt;T&gt; 接口"></a>Comparable&lt;T&gt; 接口</h4><ul><li><p>如果子类之间的比较含义不一样，那就属于不同类对象的非法比较。每个compareTo方法都应该在开始时进行下列检测：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (getClass() != other.getClass) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassCastException();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果存在一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。</p></li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在Java SE8中，允许在接口中增加静态方法。只是有违于将接口作为抽象规范的初衷。</p><p>目前为止，通常的做饭都是将静态方法放在伴随类中。Collection/Collections……</p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口提供一个默认方法。必须用default修饰符标记这样的一个方法。</p><p>一般来说，这并没有太大的用处。但是当一个接口的方法特别多是就可以很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Listener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fe</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数情况下，我们只关心其中的一两个方法。在Java SE8 中我们就可以将它声明为默认方法，什么也不做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Listener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fe</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，使用者就只需要覆盖真正关心的方法。</p><p>默认方法的一个重要作用是“接口演化”。以Collection接口为例，假设你有一个类实现了这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bag</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>后来，在Java SE8中，又为这个接口增加了一个stream方法。</p><p>假设steam不是默认方法。那么Bag类将无法编译，因为它没有实现这个方法。<strong>为接口增加一个非默认方法不能保证源代码兼容。</strong></p><p>不过，如果不重新编译这个类，而是使用原来的包含这个类的JAR文件，这个类仍然可以正常加载。<strong>为接口增加方法可以保证二进制兼容。</strong>不过，如果调用了steam方法，就会抛出一个AbstractMethodError。</p><h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况呢？</p><ol><li>超类优先。如果超类提供了具体的方法，会忽略接口的默认方法。可以保证与Java SE7的兼容性。</li><li>接口冲突。如果一个接口提供了默认方法，另一个接口提供了一个同名且参数类型相同的方法（不管是不是默认的），必须覆盖这个方法来解决冲突。</li></ol><p><strong>千万不要让一个默认方法重新定义Object类中方法</strong>！！！</p><h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。</p><p>默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。</p><p>Cloneable接口并没有什么作用，它只是一个标记，指示类设计者了解克隆过程，clone方法是从Object类中继承过来的。</p><p>必须当心子类的克隆。</p><h4 id="为什么引入lambda表达式"><a href="#为什么引入lambda表达式" class="headerlink" title="为什么引入lambda表达式"></a>为什么引入lambda表达式</h4><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p><h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h4><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;String&gt; comp = <br>    (first, second) -&gt; first.length() - second.length();<br></code></pre></td></tr></table></figure><p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。</p><p>如果，一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-keyword">int</span> x) -&gt; &#123; <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="函数式表达式"><a href="#函数式表达式" class="headerlink" title="函数式表达式"></a>函数式表达式</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口成为函数式接口。</p><p>最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</p><p>不过，Java现在对lambda表达式能做的也只是转换为函数式接口。</p><p>Java API 在 java.util.function 包中定义了很多通用的函数式接口。例如：BiFunction&lt;T,U,R&gt;。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, event -&gt; System.out.println(event));<br></code></pre></td></tr></table></figure><p>这样，看起来很简洁了，但是如果能把 println 方法传递到 Timer 的构造器就更好了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, System.out::println);<br></code></pre></td></tr></table></figure><p>表达式 System.out::println 是一个方法引用，它等价于 x-&gt; System.out.println(x);</p><p>方法引用的写法有3中：</p><ul><li>objcet::instanceMethod</li><li>Class::staticMethod</li><li>Class::instanceMethod</li></ul><p>前两种情况，方法引用等价于提供方法参数的lambda表达式。</p><p>对于第三种情况，第一个参数会成为方法的目标。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String::compareToIgnoreCase 等价于<br>(x, y) -&gt; x.compareToIgnoreCase(y);<br></code></pre></td></tr></table></figure><p>可以在方法引用种使用 this 与 super。</p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。但是它具体引用的是哪个构造器与上下文有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; names = ..;<br>Stream&lt;Person&gt; stream = names.steam().map(Person::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><p>map方法会调用Person(String) 构造器。</p><p>可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，<strong>它有一个参数：即数组的长度</strong>。</p><p>Java有一个限制，无法构造泛型类型T的数组。new T[] 会产生错误。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>有时候，我们会在lambda表达式种访问外围方法或类中的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String text = <span class="hljs-string">&quot;ok&quot;</span>;<br>ActionListener listener = event -&gt; &#123;<br>  Sysout.out.println(text);  <br>&#125;;<br><br><span class="hljs-comment">// 1000年之后</span><br><span class="hljs-keyword">new</span> Timer(delay, listener);<br></code></pre></td></tr></table></figure><p>仔细想想，这里会有问题。lambda表达式的代码可能会在很久之后才运行，那个时候，text可能已经不存在了。要了解发生了什么，我们先来了解lambda表达式的组成：</p><ol><li>一个代码块</li><li>参数</li><li>自由变量的值，这是指非参数而且不在代码中定义的变量。</li></ol><p><u>lambda表达式的数据结构必须存储自由变量的值。</u> 关于代码块与自由变量在别的语言里面有一个术语叫闭包。</p><p>lambda表达式引用了自由变量，无法对这个自由变量进行更改，因为会引发多线程问题。</p><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> init &#123;<br>        ActionListener listener = event -&gt; &#123;<br>            Sysout.out.println(<span class="hljs-keyword">this</span>.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>表达式会调用Application的toString，而不是 ActionListener的toString。</p><h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h4><p>如果设计你自己的接口，其中只有一个抽象方法，可以用 @FunctionalInterface 注解来标记这个接口。</p><h4 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h4><p>静态 comparing 方法取一个“键提取器”函数，它将类型T映射为一个可比较的类型。对要比较的对象应用这个函数，然后对返回的键完成比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(people, Comparator.comparing(Person::name));<br></code></pre></td></tr></table></figure><p>还有很多其他的方法，需要自己去戳源码。</p><h4 id="内部类的特殊规则语法"><a href="#内部类的特殊规则语法" class="headerlink" title="内部类的特殊规则语法"></a>内部类的特殊规则语法</h4><p>可以通过显示的命名将外围类引用设置为其他的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Out</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">In</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br>-----------------------------<br>Out o = <span class="hljs-keyword">new</span> Out();<br>Out.In in = o.<span class="hljs-function">new <span class="hljs-title">In</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>非静态内部类的所有静态域都必须是final的。</p><p>非静态内部类不能有static方法。</p><p>非static的内部类，在外部类加载的时候，并不会加载它，所以它里面不能有静态变量或者静态方法。</p><ul><li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li><li>要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。 </li></ul><p>基于以上两点，可以看出，如果一个非static的内部类如果具有static的属性或者方法，那么就会出现一种情况：内部类未加载，但是却试图在内存中创建static的属性和方法，这当然是错误的。原因：类还不存在，但却希望操作它的属性和方法。</p><h4 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h4><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 符号分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。</p><p>内部类是如何访问外部的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Out</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">In</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">// 这是编译器自动生成的方法，我们在内部类中调用a，实际上是使用了这个方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> access$<span class="hljs-number">0</span>(Out);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是将构造参数传递给超类构造器。</p><p>对于静态方法的日志问题，如果我们希望在静态方法中输出当前类的类名，但是静态方法没有this，可以使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Object()&#123;&#125;.getClass().getEnclosingClass();<br></code></pre></td></tr></table></figure><h4 id="代理的特性"><a href="#代理的特性" class="headerlink" title="代理的特性"></a>代理的特性</h4><p>所有的代理类都覆盖了Object类中的方法 toString、equals和hashCode。</p><p>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。如果使用同一个类加载器和接口数组调用两次 newProxyInstance 方法的话，那么只能得到同一个类的两个对象。</p><p>如果代理类实现的所有接口都是public的，那么代理类不属于某个特定的包。否则。所有非公有的接口都必须属于同一个包，代理类也属于这个包。</p><h3 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章 异常、断言和日志"></a>第七章 异常、断言和日志</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p><img src="exception.png"></p><p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。</p><p>Exception分为两个分支：</p><blockquote><p>一个分支派生于RuntimeException，另一个包含其他异常。</p></blockquote><p><strong>划分规则是</strong>：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像IO错误这类问题的异常属于其他异常。</p><h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。</p><p>如果超类方法没有抛出任何受查异常，子类也不能抛出任何异常。</p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续传递。</p><h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><p>在Java SE 7中，同一个catch子句中可以捕获多个异常类型。</p><blockquote><p>只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。</p><p>捕获多个异常类型时，异常变量隐含为final。</p></blockquote><h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (AException a) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BException(<span class="hljs-string">&quot;msg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，有一种更好的处理方法，并且将原始异常设置为新异常的“原因”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (AException a) &#123;<br>    Throwable t = <span class="hljs-keyword">new</span> BException(<span class="hljs-string">&quot;msg&quot;</span>); <br>    t.initCause(a);<br>    <span class="hljs-keyword">throw</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们调用 e.getCause() 就可以拿到原始异常。强烈推荐使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。</p><p>在Java SE 7之前，无法抛出声明异常之外的类型（虽然现在也是，但是编译器的行为不一样了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java SE 7之前，会有一个问题，编译器会指出这个方法可以抛出任何异常，而不仅仅是SQLException。</p><blockquote><p>现在编译器会跟踪到 e 来自 try 块。假设这个try中仅有的已检查异常是 SQLException的实例，另外，e没有被改变，那么这个方法就是合法的。</p></blockquote><h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h4><p>强烈建议解耦 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream in = ...;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ...<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这种设计方式不仅清楚，而且还有一个功能，可以捕获 finally 里面的异常。</p><p>当 finally 子句包含return语句时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">int</span> r = n * n;<br>    <span class="hljs-keyword">return</span> r;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法返回之前，finally 子句的内容将会执行。如果finally子句中也有一个return语句，这返回值将会覆盖原始的返回值。</p><p>finally 子句的异常可能会覆盖try中的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream in = ...;<br><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    in.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>假设try块中抛出了非IOException，而close方法也出了异常，那么最后抛出的是 close 方法的 IOException。一般我们对 try 块中的异常更感兴趣，但是这时异常已经被丢失了，除非给  close 也加上 try 语句，这样就会非常繁琐。</p><h4 id="带资源的-try-语句"><a href="#带资源的-try-语句" class="headerlink" title="带资源的 try 语句"></a>带资源的 try 语句</h4><p>如果资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Resource res = ...) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>try 块退出时，或者存在一个异常，都会自动调用 <code>res.close();</code>，资源会被关闭。</p><p>这种 try 语句自身也可以带 catch 和 finally 语句，但是一般不用。</p><h3 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章 泛型程序设计"></a>第八章 泛型程序设计</h3><h4 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h4><p>泛型类可以看作普通类的工厂。</p><h4 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h4><p>一个类型变量或通配符可以有多个限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T extends Comparable &amp; Serializable<br></code></pre></td></tr></table></figure><p>限定类型用 &amp; 分隔，而逗号用来分隔类型变量。如果用一个类来做限定，它必须是限定列表中的第一个。</p><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>虚拟机没有泛型对象，它会擦除类型变量，并替换为限定类型（无限定类型的变量用Object）。</p><p>如果有多个限定，会怎么样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Interval</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> &amp; <span class="hljs-title">Compareable</span>&gt;</span><br></code></pre></td></tr></table></figure><p>原始类型用 Serialzable 替换 T，编译器会在必要的时候将其强制转换为 Comparable。为了提高效率，应该将标签接口（没有方法的接口）放在边界列表的末尾。</p><p><u>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。</u></p><h4 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h4><p>假设我们有这样的一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T first;<br>    <span class="hljs-keyword">private</span> T second;<br>    <br>    ...<br>        <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(T second)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.second = second;<br>    &#125;<br>    <br>&#125;<br>-----------------------------------<br><span class="hljs-comment">// 擦除之后，这里 T 擦除之后是 Object</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object first;<br>    <span class="hljs-keyword">private</span> Object second;<br>    <br>    ...<br>        <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(Object second)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.second = second;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>使用一个类继承它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span> <span class="hljs-title">extend</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <br>&#125;<br>-----------------------------------------------<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span> <span class="hljs-title">extend</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">LocalDate</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 这里不是重写，只是展示有一个从父类继承过来的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(LocalDate second)</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是问题就来了，假设我使用父类引用子类的变量，然后调用 setSecond 方法，那么它本来应该走到子类的方法里面去，但是由于泛型的擦除，导致子类方法签名不一致了（父类是 Object，子类是 LocalDate）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Date date = <span class="hljs-keyword">new</span> Date();<br>Pare&lt;LocalDate&gt; pair = date;<br><span class="hljs-comment">// 猜猜它会调用那个方法</span><br>pair.setSecond(aDate);<br></code></pre></td></tr></table></figure><p>现在多态与泛型擦除出现了冲突，解决方法是需要编译器在 Date类中生成一个桥方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecond</span><span class="hljs-params">(Object second)</span> </span>&#123;<br>    setSecond((Date)second);<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，桥方法也会引出别的问题！</p><p>假设 Date 类覆盖了 getSecond 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span> <span class="hljs-title">extend</span> <span class="hljs-title">Pair</span> </span>&#123;<br>    <span class="hljs-comment">// 这里是重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getSecond</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，Date 类里面就有两个同名方法了，参数一样，只有返回值不一样。编译器是不允许这样的，但是，在Java虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机可以正确处理这样的情况。</p><p>如果你记忆力比较好的话，前面也提到过在覆盖父类的方法时，可以返回更加严格的类型，这也是利用的桥方法。</p><p>Java泛型转换的事实：</p><ul><li>虚拟机中没有泛型，只有普通的类和方法</li><li>所有的类型参数都用它们的限定类型替换</li><li>桥方法被合成类保持多态</li><li>为保持类型安全性，必要时插入强制类型转换</li></ul><h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>其原因是类型擦除，擦除之后，没有限定类型的使用 Object 代替，而 Object 不能引用基本类型。</p><h4 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Pair&lt;String&gt;)<br></code></pre></td></tr></table></figure><p>这里只是测试了 a 是否时一个 Pair 对象，与 String 毫无关系。</p><p>同样的道理，getClass 也总是返回原始类型。</p><h4 id="Varargs-警告"><a href="#Varargs-警告" class="headerlink" title="Varargs 警告"></a>Varargs 警告</h4><p>Java 不允许创建泛型数组，其原因可以自己研究研究（泛型擦除）。假设我们有这样方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection coll, T... ts)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>ts 实际上时一个数组，考虑一下调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;Pair&lt;String&gt;&gt; table = ...;<br>Pair&lt;String&gt; p1 = ...;<br>Pair&lt;String&gt; p2 = ...;<br>addAll(table, p1, p2);<br></code></pre></td></tr></table></figure><p>所以，Java虚拟机必须建立一个Pair&lt;String&gt; 数组，这就违反了不循序创建泛型数组的规定。不过对于这种情况，只是会显示一个警告。</p><h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><p>最好让用户提供一个数组构造器的表达式。</p><h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态域中引用类型变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T singleInstance; <span class="hljs-comment">// ERROR</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为如果能使用的话，不同的实例会有不同的类型。</p><h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>泛型类扩展 Throwable 都是不合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;&#125; <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><p>在异常规范中使用类型变量是合法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Throwable&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T </span>&#123;&#125; <span class="hljs-comment">// OK </span><br></code></pre></td></tr></table></figure><h4 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Throwable&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwAs</span><span class="hljs-params">(Throwable t)</span> <span class="hljs-keyword">throws</span> T </span>&#123;<br>    <span class="hljs-keyword">throw</span> (T)t;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译器会认为t是一个非受查异常。</strong></p><p>再利用下面的代码就会把所有异常转换为编译器所认为的非受查异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">do</span> work<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>    throwAs(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，在某些不允许抛出任何受查异常的方法中，就可以使用这个方法来抛出受查异常。</p><h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>擦除之后，就是 <code>public boolean equals(Object t);</code> 与 Object 的方法重复了，会引发错误。</p><h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(? extends Person)</span> </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这个 set 方法不能传递任何参数，因为编译器只知道需要某个 Person 的子类，但是不知道具体是什么类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs :arrow_double_down:">void set(? super Person) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>该方法只能传递Person或者Person的子对象。</p><p>直观的讲，带有超类型限定的通配符可以向泛型写入，带有子类型限定的通配符可以从泛型对象读取。</p><p>举一个 super 限定符的应用：</p><blockquote><p>LocalDate 实现了 ChronoLocalDate，而 ChronoLocalDate 扩展了 Comparable&lt;ChronoLocalDate&gt;。</p></blockquote><blockquote><p>因此，LocalDate 实现的是 Comparable&lt;ChronoLocalDate&gt;，而不是 Comparable&lt;LocalDate&gt;。</p></blockquote><p>在这种情况下，可以使用超类限定符来救助（要注意泛型的 extends 与类的 extends 的不同意义）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs :arrow_double_down:">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>上个图来意思意思：</p><p><img src="super.png"></p><h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs :arrow_double_down:">? getFirst()<br><br>void setFirst(?)<br></code></pre></td></tr></table></figure><p>getFirst 的返回值只能赋值给 Object。setFirst不能被调用，Object 也不行。</p><h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs :arrow_double_down:">public static void swap(Pair&lt;?&gt; p)<br><br>public staic &lt;T&gt; void swapHelper(Pair&lt;T&gt; p)<br></code></pre></td></tr></table></figure><p>比较有趣的是，可以在 swap 里面调用 swapHelper。这种情况下，参数 T 捕获通配符。</p><p><u>通配符捕获只有在有许多限制的情况下才是合法的，编译器必须能够确信通配符表达的是单个、确定的类型。</u></p><h3 id="第九章-集合"><a href="#第九章-集合" class="headerlink" title="第九章 集合"></a>第九章 集合</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>对 next 方法和 remove 方法的调用具有互相依赖性。</p><h4 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h4><p>List接口定义了多个用于随机访问的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function">E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span></span>;<br></code></pre></td></tr></table></figure><p>坦率的讲，集合框架的这个方面设计的很不好。</p><blockquote><p>集合框架中有两种类型的集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。而链表尽管也是有序的，但是随机访问会很慢，所以最好使用迭代器来遍历。所以如果原先就提供了两个接口就会容易理解些了。</p></blockquote><p>为了避免对链表完成随机访问操作，Java SE 1.4 引入了一个<u>标记</u>接口 RandomAccess。用来测试一个特定的集合是否支持高效的随机访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (c <span class="hljs-keyword">instanceof</span> RandomAccess) &#123;<br>    <span class="hljs-comment">// 支持</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 不支持</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。</p><ul><li>add 方法不允许增加重复的元素</li><li>equals 方法：只要两个集合包含相同的元素就认为是相等的，而不要求这些元素有相同的顺序</li><li>hashCode 方法：要保证含相同元素的两个集会得到相同的散列码</li></ul><p>既然两个接口的方法签名是一样的，为什么还要建立一个单独的接口呢？</p><blockquote><p>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接收集的方法。</p></blockquote><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>在 Java 程序设计语言中，所有链表实际上都是双向链接的。</p><p>ListIterator 是 Iterator 的一个子接口，它新增了一些方法。LinkedList 的 listIterator 方法会返回一个 ListIterator 的实例。注意，在使用 ListIterator 的 remove 方法时需要谨慎。</p><p>在调用 next 之后，remove 方法会删除迭代器左侧的元素，但是，如果调用 previous 会删除迭代器右侧的元素。</p><p>ConcurrentModificationException 异常的检测有一个特例：</p><p>链表只负责跟踪对列表的结构性修改，例如，添加元素，删除元素。set方法<u>不被视为</u>结构性修改。<strong>可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有的结点的内容进行修改。</strong></p><p><strong>不要使用</strong>下面的方法来遍历链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++) &#123;<br>    Element e = get(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然 get 方法做了微小的优化（如果 i 大于 size()/2，会从后面开始遍历），但是这样写每次循环都要遍历一次。</p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>在 Java中，散列表用链表数组实现。</p><h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p>Java SE 8 中使用的是红黑树。</p><p>将一个元素添加到树中要比添加到散列表中慢，不过与检查数组或链表中重复元素相比还是快很多。</p><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>优先级队列并没有对所有的元素进行排序。它使用了一个优雅且高效的数据结构——堆。</p><h4 id="映射-（Map）"><a href="#映射-（Map）" class="headerlink" title="映射 （Map）"></a>映射 （Map）</h4><p>总感觉翻译有点奇怪！！！</p><h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>看一个例子，统计单词出现的频率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">counts.put(word, counts.get(word) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这会有一个问题，就是 get 可能会返回 null。于是可以这样写，给一个默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">counts.put(word, counts.getOrDefault(word, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>另一种方法就是先调用 putIfAbsent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">counts.putIfAbsent(word, <span class="hljs-number">0</span>);<br>counts.put(word, counts.get(word) + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>不过，还可以有更简单的方式，使用 merge 方法，可以简化这个常见的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">counts.merge(word, <span class="hljs-number">1</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p>如果键值不存在，则将 word 置为 1，否则使用 Integer::sum 函数组合原值和 1。</p><h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为Map本身是一个集合。</p><p>Map提供了方法用来获取映射视图，映射视图是实现了Collection接口或某个子接口的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span></span>;<br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();<br></code></pre></td></tr></table></figure><p>这3个方法会分别返回3个视图。要注意这些视图并不是 TreeSet 或者 HashSet 的实例，而是实现了 Set 接口的另外某个类的实例。</p><h4 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h4><p>再来说说 keySet 方法。初看起来，好像这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet 方法返回一个实现 Set 接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</p><h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);<br></code></pre></td></tr></table></figure><p>asList 返回的并不是一个 ArrayList。它是一个视图对象，带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个 UnsupportedOperationException 异常。</p><h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List group2 = staff.subList(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>group2.clear();<br></code></pre></td></tr></table></figure><p>元素自动的从 staff 列表中清除，并且 group2 为空。</p><h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p>简而言之，就是对所有更改器方法直接抛出一个异常。</p><p><u>由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</u></p><p>注意，视图并没有重新定义 Object 的 equals 和 hashCode 方法（内容是否相等的检测在分层结构的这一层上没有定义妥当）。</p><h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p>“受查”视图用来对泛型类型发生问题时提供调试支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>ArrayList rawList = strings;<br>rawList.add(<span class="hljs-keyword">new</span> Date());<br></code></pre></td></tr></table></figure><p>这个错误在 add 的时候检测不到。相反，只有在调用 get 方法的时候才会抛出异常。受查视图可以探测这类问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; safeStrings = Collections.checkList(strings, String.class);<br>ArrayList rawList = safeStrings;<br>rawList.add(<span class="hljs-keyword">new</span> Date()); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>虚拟机在运行到 add 方法时，就会抛出异常。</p><h4 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h4><p>可以使用归并排序对链表进行高效的排序。但是Java中不是这样做的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制会链表。</p><p>集合类库中使用的排序算法比快速排序要慢一些，快速排序时通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>只有采用随机访问，二分查找才有意义。</p><h3 id="第十四章-并发"><a href="#第十四章-并发" class="headerlink" title="第十四章 并发"></a>第十四章 并发</h3><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>没有可以强制线程终止的方法。然而，interrupt 方法可以用来请求线程终止。</p><p>但是，如果线程被阻塞，就无法检测中断状态。</p><p>当在一个被阻塞的线程（sleep或者wait）上调用 interrupt 方法时，阻塞调用将会被 Interrupted Exception 异常中断。</p><p>如果在每次工作迭代之后都调用 sleep 方法（或者其他可中断方法），isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并抛出InterruptedException。</p><p>不要将 InterruptedException 捕获在低层次上！</p><blockquote><p>要么捕获然后再次设置中断状态，要么直接抛出。</p></blockquote><h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>在任何给定时刻，一个可运行的线程可能在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行）。</p><h4 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h4><p>被阻塞状态与等待状态是有很大不同的。其实这句话我还不太能够理解，是本质上不同，还是Java行为上不同？</p><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程应该永远不去访问固有资源，如文件，数据库，<u>因为它会在任何时候甚至在一个操作的中间发生中断。</u></p><p>setDaemon 必须在线程启动之前调用。</p><h4 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h4><p>线程的 run 方法不会抛出任何受查异常，非受查异常会导致线程终止。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p><blockquote><p>setUncaughtExceptionHandler 方法会未任何线程安装一个默认的处理器。</p><p>也可以用Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有的线程安装一个默认的处理器。</p></blockquote><p>如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。</p><p>ThreadGroup 类实现 Thread.UncaughtExceptionHanlder 接口。它的 uncaughtException 方法做如下操作：</p><ol><li>如果该线程组有父线程组，那么父线程组的 uncaughtException 方法被调用。</li><li>否则，如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器，则调用该处理器。</li><li>否则，如果 Throwable 是 ThreadDeath 的一个实例，什么都不做。</li><li>否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。</li></ol><h4 id="锁对象-（ReentrantLock）"><a href="#锁对象-（ReentrantLock）" class="headerlink" title="锁对象 （ReentrantLock）"></a>锁对象 （ReentrantLock）</h4><p>如果使用锁，就不能使用带资源的 try 语句。</p><blockquote><p>一是无法释放锁，二是会新创建一个变量。</p></blockquote><p> 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。</p><h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p><p>一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。</p><p>signalAll 方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p><p>每一个对象有一个内部锁，并且该锁有一个内部条件。初学者常常对条件感到困惑，推荐先学习ReentrantLock 的 Condition。</p><p>wait、nofity、notifyAll 方法都需要当前线程持有锁，否则会抛出异常。</p><h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>举一个有趣的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> Map&lt;String, Person&gt; pList = Collections.synchronizedList(<span class="hljs-keyword">new</span> HashMap&lt;&gt;());<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putIfAbsent</span><span class="hljs-params">(String key, Person p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pList.contains(p)) &#123;<br>            pList.put(p);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        pList.get(key);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>先不管这个程序有什么意义，只问一个问题，这个类是线程安全的吗？</p><p>虽然看起来很像是线程安全的，但是实际上不是，因为 Collections.synchronizedList 使用的锁，肯定不是 Sync 的实例。</p><h4 id="Volatile-域"><a href="#Volatile-域" class="headerlink" title="Volatile 域"></a>Volatile 域</h4><p>仅仅为了读写一个或两个实例域就使用同步，显得开销过大了。Volatile 可以帮助我们在这种情况下避免使用锁。</p><p>先来看看多个线程为什么会出现值不一致的原因：</p><ul><li>多处理器的计算机能够暂时在寄存器或本地内存缓存区中保存内存的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。</li><li>编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显示的修改指令时才会改变。然而，内存的值可以被另一个线程改变！</li></ul><p>早期的CPU使用的是总线锁的方式来保证 Volatile 域的一致性，现在都使用的是缓存一致性。</p><h4 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h4><p>如果在某个类中，将一个域声明为 final 类型，那么会起到这样的一个效果：</p><blockquote><p>其他的线程会在该类的构造函数执行完毕之后才能看到这个 final 域的值。</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 volatile。</p><p>java.util.concurrent.atomic 包中有很多类使用了<u>很高级的机器级指令（不是使用锁）</u>来保证其他操作的原子性。</p><p>稍微提一下，使用 compareAndSet 实现乐观锁的常用写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>    oldValue = largest.get();<br>    newValue = Math.max(oldValue, observed);<br>&#125; <span class="hljs-keyword">while</span> (!largest.compareAndSet(oldValue, newValue));<br></code></pre></td></tr></table></figure><p>compareAndSet 的工作原理：期望内存中的值是 oldValue，是则用 newValue 替换它，返回 true，不是则返回 false。</p><p>如果有大量线程要访问相同的原子值，函数性能会大幅下降，因为乐观更新需要太多次重试。</p><h4 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h4><p><u>lock 方法不能被中断，在获得锁之前会一直阻塞</u>，如果出现死锁，则 lock 方法无法终止。可以使用 tryLock 来响应中断。</p><p>tryLock 还有一个隐藏特性：这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此。</p><h4 id="为什么弃用-stop-和-suspend-方法"><a href="#为什么弃用-stop-和-suspend-方法" class="headerlink" title="为什么弃用 stop 和 suspend 方法"></a>为什么弃用 stop 和 suspend 方法</h4><p>stop 方法：该方法终止所有未结束的方法，包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。</p><p>例如：从 A 转账到 B，线程突然被终止，钱已经转出去了，却没有进入 B 账户，那么 Bank 对象就被破坏了。</p><p>suspend 方法：如果用该方法挂起一个持有锁的线程，那么该锁在恢复之前是不可用的。如果调用 suspend 方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// map 是 ConcurrentHashMap 的实例</span><br>Long oldValue = map.get(word);<br>Long newValue = oldValue == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : oldValue + <span class="hljs-number">1</span>;<br>map.put(word, newValue);<br></code></pre></td></tr></table></figure><p>在上面的例子中，由于操作不是原子的，所以最终的结果不可预料。但是，要理解 ConcurrentHashMap 与 HashMap 的区别，这里的 get 与 put 都是原子操作，在多线程情况下不会破坏 map 的结构，而 HashMap 在多线程情况下会出现循环链表等问题。</p><p>ConcurrentHashMap 返回的迭代器具有弱一致性。这意味着迭代器不一定能反映出它们被构造之后的所有的修改（可以认为是某一特定时刻的快照），它们不会将同一个值返回两次，不会抛出 ConcurrentModificationException。</p><h4 id="CopyOnWriteArrayList-和-CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList-和-CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList 和 CopyOnWriteArraySet"></a>CopyOnWriteArrayList 和 CopyOnWriteArraySet</h4><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>调用 shutdown 方法，该线程池不再接收新任务。当所有任务完成后，线程池死亡。</p><p>调用 shutdownNow 方法，该线程池取消尚未开始的所有任务，并视图中断正在运行的线程。</p><h4 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h4><p>如果有大量的 Callable 要执行，可以使用这个类。</p><h4 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork-Join 框架"></a>Fork-Join 框架</h4><p>这个框架用来分解子任务，提高线程利用率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTasks</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (to - from &lt; THRESHOLD) &#123;<br>            <span class="hljs-comment">// .....</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = (from + to) / <span class="hljs-number">2</span>;<br>            Counter first = <span class="hljs-keyword">new</span> Counter(values, from, mid, filter);<br>            Counter second = <span class="hljs-keyword">new</span> Counter(values, mid, to, filter);<br>            <span class="hljs-comment">// 阻塞</span><br>            invokeAll(first, second);<br>            <span class="hljs-comment">// 合并</span><br>            <span class="hljs-keyword">return</span> first.join() + second.join();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>任何线程可以释放任何数量的许可，这可能会增加许可数目以至于超出初始数目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
