<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分查找法中的坑]]></title>
    <url>%2F2020%2F09%2F25%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E4%B8%AD%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一个笑话：有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。 二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：思路很简单，细节是魔鬼。 它的框架很简单，但是在细节的处理上，写起来总让人有点玄学编程的感觉。到底这里我应不应该加上等号，这里应不应该加一，这里要不要减一。 看下面的这个框架： 123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; // 注意 while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意 else if (nums[mid] &gt; target) right = mid - 1; // 注意 &#125; return -1;&#125; 先看第一个需要注意的地方： 这里我们搜索的区间是从 0 ~ length-1，它意味者区间值为 [left, right]。因为 nums.length - 1是有效索引，所以 while 的的判断条件是 left &lt;= right。我们从区间的角度理解一下，就是 [left, right]，此时 left == right，即 [right, right]，又因为区间里面的值都是有效的，所以 right 是存在的，即判断条件必须要带等号。 如果写成 right = nums.length 会发生什么？？？ [left, right) ，条件可以写成 left &lt; right。 再看下面两个需要注意的地方： 其实只要理解了上面的区间，这里就好理解了，因为区间是包含 left 与 right 的，所以表示 left 与 right 已经查找过了，折半的时候就 +/- 1 即可。 如果是半区间的话，就不能 +/- 1了。这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。 另外，还有一个坑： 计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。 还有一个拓展题目：寻找左侧边界的二分搜索 同样的有多种写法，我们先看这种： 12345678910111213141516171819int left_bound(int[] nums, int target) &#123; if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left &lt; right) &#123; // 注意 int mid = (left + right) / 2; if (nums[mid] == target) &#123; // 找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right， // 在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 right = mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; // 注意 &#125; &#125; return left;&#125; 这段代码并不难，我觉得比较蛋疼的地方在于最后的返回值，为啥是 left 呢？能不能写 right？ 其实都是一样的，因为 while 终止的条件是 left == right。 再看另一种： 123456789101112131415161718192021int left_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; // 搜索区间为 [left, right] while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; // 搜索区间变为 [mid+1, right] left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; // 搜索区间变为 [left, mid-1] right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 收缩右侧边界 right = mid - 1; &#125; &#125; // 检查出界情况 if (left &gt;= nums.length || nums[left] != target) return -1; return left;&#125; 这个就比上面的写法麻烦多了，是由于两个地方。 第一个： 由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界： 所以，最后要检查边界！ 第二个是这里可以返回 right 吗？ 不可以，因为 right 是不可能指向要找的数字的（指向了会收缩右侧边界），所以只能是 left 指向。]]></content>
      <categories>
        <category>算法思考</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于凑硬币问题的思考]]></title>
    <url>%2F2020%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[关于 dp 的套路，这篇文章已经写的非常清楚了，这里知识补充一下自己对里面 for 循环的一个理解。给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下： 12// coins 中是可选硬币面值，amount 是目标金额int coinChange(int[] coins, int amount); 我们先假设有你有一个超级电脑，它告诉你了一个函数 f，可以解决这个问题，那么就是 y = f(x)。y 是硬币的数量，x 是金额。 那么，我们推理一下，f(17) 与 f(10) + f(7)，它们有啥关系呢？ 首先，f(17) 表示的是当金额为 17 的时候，硬币最少的数。 f(10) + f(7) 也是表示金额为 17，但是它的值是硬币最少的数量吗？可能是，也可能不是，但是我们可以肯定的是 f(17) &lt;= f(10) + f(7) .不然的话，f(17) 的意义的不存在了。 那么，我们再进一步，如何才能求出 f(17) 的值呢？显然可以使用遍历： 计算出 f(1) + 1，f(2) +1， … … ，f(15) + 1, f(16) + 1，f(17) 就是当中值最小的那个，为啥是 + 1呢，因为最好的情况就是，只需要加一个硬币，就刚好凑成金额是 17，如果都没有，那就是无解了。 当然这里我们是使用了整数，而题目中提供的是 c1, c2，我们转换一下： f(c1) +1, f(c2) + 1… 这样的逻辑，用代码表示就是： 12for coin in coins: min = Math.min(f(coin) + 1, min); 就是将所有组合遍历一下，记录最小值。 我们再看看正规的代码逻辑： 1234567891011121314151617def coinChange(coins: List[int], amount: int): def dp(n): # base case if n == 0: return 0 if n &lt; 0: return -1 # 求最小值，所以初始化为正无穷 res = float('INF') for coin in coins: subproblem = dp(n - coin) # 子问题无解，跳过 if subproblem == -1: continue res = min(res, 1 + subproblem) return res if res != float('INF') else -1 return dp(amount) 可以看到，它也是将大问题简化为小问题，里面也是有一个遍历，它的作用就是用来求出当前问题的最优解。这样不断的递归下去，就可能将问题化为基本问题，啥是基本问题，dp[0] = 0 , 就是基本问题，也就是我们所说的递归终止条件。 与上面的数学表达式不同的是，这里我们遍历的时候，因为不能按照自然数遍历，所以就采用了 n-coin 这种遍历方式。但是道理是一样的。 比如，我们的金额是 5，硬币有两种，1块与5块的，所以 dp[5] 最终为 dp[0] + 1。 当然，这个代码还是可以优化的，因为子问题有好多都重复了，借图一用： 所以，可以使用缓存将子问题的结果缓存起来。]]></content>
      <categories>
        <category>算法思考</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[逆向实战]]></title>
    <url>%2F2020%2F09%2F16%2Fblog_bak%2FBlog%2F%E9%80%86%E5%90%91%2F%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[因为我在Github上单独开了一个仓库，用来搞这个，所以这里就放一个链接好了。 https://github.com/aprz512/Android-Crack]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Frida环境搭建]]></title>
    <url>%2F2020%2F09%2F09%2Fblog_bak%2FBlog%2F%E9%80%86%E5%90%91%2FFrida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[AnacondaAnaconda 是一个用于科学计算的 Python 发行版，支持 Linux, Mac, Windows, 包含了众多流行的科学计算、数据分析的 Python 包。可以立即为它就是Python，但是它集成了很多东西，用起来很方便。https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ 根据自己的系统，下载完对应的安装包之后，安装就好了。 我的是 Windows，记得安装的时候勾上添加环境变量，不然还得自己加。 安装完毕输入： 1conda list 查看安装结果。 依赖包Anaconda 安装好了之后，再安装两个依赖包： frida frida-tools 12pip install fridapip install frida-tools frida 默认安装的是最新的版本，你可以指定版本号。这里假设你的版本是 12.3.6，那么 python 必须要是 3.7 的。这是 Python 唯一蛋疼的地方，版本不兼容。 安装完成后输入： 1python 进入python环境，导入个包试试： 1import frida 如果没报错，就ok了。 frida-server下载地址：https://github.com/frida/frida/releases 选择 frida-server 开头的，然后选择你自己的环境，我做 Android 逆向，就选 Android。然后选择手机版本，我的手机是 arm64 的。 查看自己手机CPU类型： 1adb shell getprop ro.product.cpu.abi 我下载的是：frida-server-12.11.12-android-arm64.xz 模拟器，一般选择 x86 的。 下载完server程序后，解压缩，然后推送到手机内部存储路径： 1adb push frida-server-12.11.12-android-arm64 /data/local/tmp/fs 这里顺便做了一个重命名，改成了 fs。 然后，修改文件执行权限： 1chmod 777 fs 然后，运行文件，记得授予shell root 权限，否则可能会报权限拒绝错误： 1./fs 然后，做一个端口转发，默认使用27042端口与frida-server通信： 1adb forward tcp:27042 tcp:27042 上面命令的意思：即把PC电脑端TCP端口27042的数据转发到与电脑通过adb连接的Android设备的TCP端口27042上。]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EdXposed框架使用]]></title>
    <url>%2F2020%2F09%2F08%2Fblog_bak%2FBlog%2F%E9%80%86%E5%90%91%2FEdXposed%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境搭建刷机手机：Pixel镜像：8.1.0 (OPM4.171019.021.P1, Jul 2018)，使用 10.0.0 失败了，EdXposed 不完善。下载刷机包：Link下载完成后，直接解压，运行 flash-all 即可（需要解锁 bootloader，并进入 bootloader 模式）。 进入 bootloader 模式，使用命令： adb reboot bootloader twrp刷机完成之后（如果之前root过的话，最好重新刷机一下，不然可能会无限重启…），再 root。 先安装 twrp，具体过程参考 https://twrp.me/google/googlepixel.html，**每个手机都不一样**。 实践： 下载 twrp，https://dl.twrp.me/sailfish/ 然后进入 bootloader： adb reboot bootloader 然后，进入 twrp，将 twrp.img 改成你下载的文件的全路径，最好直接拖到cmd里面 fastboot boot twrp.img 然后，手机会出现如下画面，如果手机有密码，记得在弹出的窗口输入密码，不然文件乱码： magisk下载 magiskmanager，https://magiskmanager.com/downloading-magisk-manager 安装完成后，发现里面一直检查更新，点击菜单-&gt;设置-&gt;更新通道-&gt;自定义，输入：https://gitee.com/QingFeiDeiYi/Magisk/raw/master/stable.json 这个地址，然后返回刷新界面，就好了。 下载 magisk，https://github.com/topjohnwu/Magisk/releases 然后将文件 push 到手机，进入 twrp，安装，重启，即可，手机就 root 了。 EdXposed 安装下载3个文件： Riru-Core – Download EDXposed Magisk Module – Download (YAHFA and SandHook are two variants available – try both and adopt stable variant which is best for your device) EDXP Manager APK – Download 将前面两个压缩文件 push 到手机上，打开 magisk manager，点击 菜单 模块 ，将上面两个 zip 文件刷入就好了。 安装 EDXP Manager APK，重启，这样 EdXposed 框架就安装好了，打开 EdXposed Manager 会提示你是否安装好了。 EdXposed 使用这个玩意的使用有点蛋疼，首先需要安装一个 app：https://github.com/PAGalaxyLab/VirtualHook 安装好之后，编写 hook 代码，例子：https://github.com/PAGalaxyLab/YAHFA 编写好 hook 代码之后，打包成 apk，然后 push 到手机 sdcard 根目录。 打开安装的 VirtualHook app，里面有个 添加 按钮，点击它，出现一个页面，这个页面有两个 tab，切换到 APPS IN SDCARD 这个 tab（第二个）。 然后，选择 hook apk，即可。 测试的 Android 10 ，会报错：https://github.com/PAGalaxyLab/YAHFA/issues/129 测试的 Android 8，会报错：https://github.com/PAGalaxyLab/VirtualHook/issues/100 暂时放弃，搞 Frida 去了… wifi 叉号问题https://support.google.com/pixelphone/forum/AAAAb4-OgUsK_o4E4r67dY 直接运行 adb shell “settings put global captive_portal_https_url https://developers.google.cn/generate_204&quot;]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[右值引用]]></title>
    <url>%2F2020%2F09%2F02%2Fblog_bak%2FBlog%2FC%2B%2B%2F002-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身。1int a = 10; // a是左值，10是右值左值引用很好理解，就是我们常见的引用。12int&amp; x = a; // okint&amp; y = 10; // error, 10 是右值右值引用也是引用，但是它只能且必须绑定在右值上。 1234int&amp;&amp; w = 42; int&amp;&amp; z = a--; // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上int&amp;&amp; t = a * 1; // OK: a * 1 的结果是一个右值，将它绑定在右值引用上int&amp;&amp; v = a; // Err: a 可以是左值，所以不能将它绑定在右值引用上 右值引用有啥用？C++中右值可以被赋值给左值或者绑定到引用。 类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃。 于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。 右值中的数据可以被安全移走。 右值引用的使用对于左值，如果我们明确放弃对其资源的所有权，则可以通过std::move()来将其转为右值引用。std::move()实际上是static_cast&lt;T&amp;&amp;&gt;()的简单封装。 https://www.zhihu.com/question/22111546]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[017-Matrix源码分析：监测SQL语句中的问题]]></title>
    <url>%2F2020%2F09%2F02%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F017-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BSQL%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[该库可以在 APP 运行时对 sql 语句、执行序列、表信息等进行分析检测。其主要代码在 matrix-sqlite-lint-android-sdk下。虽然名带 “lint ” ，但并不是代码的静态检查。这里主要介绍一下 SQLiteLint 的思路，因为需要检测出来哪些 SQL 是可以优化的，所以你就必须要了解 SQL 语句，而我对 SQL 语句的熟悉程度还达不到这一点，所以就很难看懂里面的一些算法。故算法部分就不深入分析了，有兴趣可以看源码以及官方文档。 检测流程 可以看到，基本流程与 IO 的检测是差不多的，实际上确实如此，源码部分也有很多类似的地方。 我们看下里面的几个流程： 收集 APP 运行时的 sql 执行信息 包括执行语句、创建的表信息等。其中表相关信息可以通过 pragma 命令得到。对于执行语句，有两种情况： a）DB 框架提供了回调接口。比如微信使用的是 WCDB ，很容易就可以通过MMDataBase.setSQLiteTrace 注册回调拿到这些信息。 b） 若使用 Android 默认的 DB 框架，SQLiteLint 提供了一种无侵入的获取到执行的sql语句及耗时等信息的方式。通过hook的技巧，向 SQLite3 C 层的 api sqlite3_profile 方法注册回调，也能拿到分析所需的信息，从而无需开发者额外的打点统计代码。 预处理包括生成对应的 sql 语法树，生成不带实参的 sql ，判断是否 select* 语句等，为后面的分析做准备。预处理和后面的算法调度都在一个单独的处理线程。 调度具体检测算法执行checker 就是各种检测算法，也支持扩展。并且检测算法都是以 C++ 实现，方便支持多平台。而调度的时机包括：最近未分析 sql 语句调度，抽样调度，初始化调度，每条 sql 语句调度。 发布问题上报问题或者弹框提示。 可以看到重点在第 3 步，而这一步本文暂不分析。第2步也只简单的说一下。 收集App运行时的 SQL 执行信息该库提供了两种方式，一种是 hook，一种是通过回调接口。至于使用哪种，需要我们执行设置： 12345678910111213private static SQLiteLintConfig initSQLiteLintConfig() &#123; try &#123; /** * HOOK模式下，SQLiteLint会自己去获取所有已执行的sql语句及其耗时(by hooking sqlite3_profile) * @see 而另一个模式：SQLiteLint.SqlExecutionCallbackMode.CUSTOM_NOTIFY , 则需要调用 &#123;@link SQLiteLint#notifySqlExecution(String, String, int)&#125;来通知 * SQLiteLint 需要分析的、已执行的sql语句及其耗时 * @see TestSQLiteLintActivity#doTest() */ return new SQLiteLintConfig(SQLiteLint.SqlExecutionCallbackMode.HOOK); &#125; catch (Throwable t) &#123; return new SQLiteLintConfig(SQLiteLint.SqlExecutionCallbackMode.HOOK); &#125;&#125; 使用 hook 在高版本可能会有兼容问题，如果遇到后不要慌。 hook我们看看 hook 实现的相关代码，可以回想一下 IO 的 hook，想必是差不多的。 1xhook_register(".*/libandroid_runtime\\.so$", "sqlite3_profile", (void*)hooked_sqlite3_profile, (void**)&amp;original_sqlite3_profile); hook 的是 sqlite3_profile 函数。 1234void* hooked_sqlite3_profile(sqlite3* db, void(*xProfile)(void*, const char*, sqlite_uint64), void* p) &#123; LOGI("hooked_sqlite3_profile call"); return original_sqlite3_profile(db, SQLiteLintSqlite3ProfileCallback, p);&#125; hook 函数也没干啥，就是直接调用了原函数，不过传递了一个 callback 进去。 123456789101112131415161718static void SQLiteLintSqlite3ProfileCallback(void *data, const char *sql, sqlite_uint64 tm) &#123; if (kStop) &#123; return; &#125; JNIEnv*env = getJNIEnv(); if (env != nullptr) &#123; SQLiteConnection* connection = static_cast&lt;SQLiteConnection*&gt;(data); jstring extInfo = (jstring)env-&gt;CallStaticObjectMethod(kUtilClass, kMethodIDGetThrowableStack); char *ext_info = jstringToChars(env, extInfo); NotifySqlExecution(connection-&gt;label, sql, tm/1000000, ext_info); free(ext_info); &#125; else &#123; LOGW("SQLiteLintSqlite3ProfileCallback env null"); &#125;&#125; 该回调会在 sql 执行后触发，这样我们就可以拿到该 sql 的相关信息。然后调用 NotifySqlExecution 通知 sql 执行了，实际上就是放入队列里面。 里面会有一个生产者-消费者模型，与 IO 是一样的，所以这里扮演的是生产者角色。 手动通知当我们不使用 hook 的时候，就需要开发者自己在 sql 执行后手动调用了。 12345678public void notifySqlExecution(String concernedDbPath, String sql, int timeCost) &#123; if (!isPluginStarted()) &#123; SLog.i(TAG, "notifySqlExecution isPluginStarted not"); return; &#125; SQLiteLint.notifySqlExecution(concernedDbPath, sql, timeCost);&#125; 调用这行代码之后，最终也会进入到 NotifySqlExecution 这行语句中，与 hook 方式是一样的，这样有点类似打点。 我们看看 NotifySqlExecution 最终会调用到如下代码： 1234567891011121314151617181920212223 void Lint::NotifySqlExecution(const char *sql, const long time_cost, const char* ext_info) &#123; if (sql == nullptr)&#123; sError("Lint::NotifySqlExecution sql NULL"); return; &#125; if (env_.IsReserveSql(sql)) &#123; sDebug("Lint::NotifySqlExecution a reserved sql"); return; &#125; SqlInfo *sql_info = new SqlInfo(); sql_info-&gt;sql_ = sql;sql_info-&gt;execution_time_ = GetSysTimeMillisecond(); sql_info-&gt;ext_info_ = ext_info; sql_info-&gt;time_cost_ = time_cost; sql_info-&gt;is_in_main_thread_ = IsInMainThread(); std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_); queue_.push_back(std::unique_ptr&lt;SqlInfo&gt;(sql_info)); queue_cv_.notify_one(); lock.unlock(); &#125; 可以看到，这里给 sql_info 赋值了很多字段，就是收集相关信息了，然后就放到 queue_ 里面，然后通知消费者线程。 预处理sql 信心收集完成之后，需要进行处理，我们看源码，直接看消费者线程的逻辑。 12345678910111213141516171819202122232425262728293031323334 ... // 从队列中取一个 int ret = TakeSqlInfo(sql_info);... // 记录sql数量，用于抽样 env_.IncSqlCnt(); // 将 sql 语句进行预处理，去除前后空格，全转小写 PreProcessSqlString(sql_info-&gt;sql_);... // 真正的预处理逻辑 if (!PreProcessSqlInfo(sql_info.get())) &#123; sWarn("Lint::Check PreProcessSqlInfo failed"); env_.AddToSqlHistory(*sql_info); sql_info = nullptr; continue; &#125;... // 这里是抽样检测 ScheduleCheckers(CheckScene::kSample, *sql_info, published_issues);... if (!checked_sql_cache_.Get(wildcard_sql, checked)) &#123; // 这里是避免重复检测，与上面的抽象可能会重复 ScheduleCheckers(CheckScene::kUncheckedSql, *sql_info, published_issues); checked_sql_cache_.Put(wildcard_sql, true); &#125; 看看 ScheduleCheckers ： 12345678910111213141516171819202122void Lint::ScheduleCheckers(const CheckScene check_scene, const SqlInfo&amp; sql_info, std::vector&lt;Issue&gt; *published_issues) &#123; // 检测场景不符，就直接返回 // 每个 Checker 有自己的检测场景 std::map&lt;CheckScene, std::vector&lt;Checker*&gt;&gt;::iterator it = checkers_.find(check_scene); if (it == checkers_.end()) &#123; return; &#125; std::vector&lt;Checker*&gt; scene_checkers = it-&gt;second; size_t scene_checkers_cnt = scene_checkers.size(); for (size_t i=0;i &lt; scene_checkers_cnt;i++) &#123; Checker* checker = scene_checkers[i]; // 如果是抽样检测（kSample），则需要满足隔 30 个取一个 if (check_scene != CheckScene::kSample || (env_.GetSqlCnt() % checker-&gt;GetSqlCntToSample() == 0)) &#123; checker-&gt;Check(env_, sql_info, published_issues); &#125; &#125;&#125; 主要就是调用了各个 Checker 的 Check 函数。Checker 有很多，里面具体做了啥，这里就不分析了，涉及到语法语义。 上报上报的逻辑与IO差不多。具体逻辑在 sqlitelint::OnIssuePublish 参考文档https://mp.weixin.qq.com/s/laUgOmAcMiZIOfM2sWrQgw]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写入放大]]></title>
    <url>%2F2020%2F09%2F01%2Fblog_bak%2FBlog%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E5%86%99%E5%85%A5%E6%94%BE%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[闪存基本构成是由：页page（4K）→块block（通常64个page组成一个block，有的是128个）→面plane（多个blcok组成）→die（plane就是一个die）→闪存片（多个die组成）→SSD（多颗闪存片组成）一个块block是由128个页page组成，一个页page是大小是4KB ↑↑↑↑一个面Plane由1024个块block组成 △▼△▼△▼△▼△▼分割线▼△▼▽▼△▼△▼△ 其实写入放大很好理解，而造成写入的元凶是GC垃圾回收。 说之前先说下操作系统当删除一个数据时，他不会立马删除，而是把这个要删除的数据上标记一个“删”的标签，实际上没有真正删除，就是因为如此硬盘上数据纯在可恢复的原因。 而机械硬盘与固态硬盘工作原理不同，当机械硬盘要写入新数据时可以直接覆盖那些已经被标记“删”标签的数据，而固态硬盘不行，只能先擦除旧的数据才能写入新数据。 NAND闪存工作原理是以4K页（page）为一个单元写入的，但擦除只能以块block（64个page）为单位。 如果一个块block上有32个page有效数据和32个被标记“删”标签的无效数据，那要在这个块block上重新写入数据，那必须要擦除整个块block，那还有一半有效数据怎么办了？那只有把那32page的有效数据就要搬到另一个有空位置的块block中，这个这就是GC垃圾回收技术，那把那有效的数据搬到另一个块block中，原本就已经写入过一次了再加上这次搬迁不就又多了一次写入吗，这就是所谓的写入放大。]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[016-Matrix源码分析：监测IO情况]]></title>
    <url>%2F2020%2F08%2F31%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F016-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%9B%91%E6%B5%8BIO%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[IO的监测功能由以下3个库实现：123matrix-io-canarymatrix-android-libmatrix-android-commonsmatrix-io-canary 里面的是核心代码。这个库里面提供了一下几个功能： 主线程IO，设定了一些阈值，超过就报警（最大读写时间超过 13ms，一次连续读写时间超过 500ms） 重复读IO（这个感觉有点鸡肋，可能是我没搞懂使用场景） buffer太小的IO行为 在分析这些功能是如何实现的之前，我们想一下，该如何监测应用中的的IO呢？ 我们通常读取文件，都是通过 FileInputStream 等类来实现的，他们的内部是调用了 native 函数，最终会调用到 libjavacore.so 中的 read/write 方法，所以，我们只需要 hook 这俩个函数就好了。所以，最终的问题转化为如何hook 指定 .so 中的函数？？？ 解决上面的问题需要用到 elf 文件格式的知识，以及 .so 的加载与链接知识。这些在《程序员的自我修养-链接、装载与库》中都有详细的描述，可以看看，我花了几天时间差不多看明白了。这里就简单的说一下这个过程。 .so相关 没有阅读 《程序员的自我修养-链接、装载与库》 这本书的相关章节的话，这段内容几乎看不懂。 .so 是一个 ELF 文件格式的文件。 .so 是共享库，也就是说它加载到内存后，是可以多个进程共享的。但是这个文件的加载比较特殊，并不是与普通文件一样，一股脑的全部放到内存就行了。 简单的来说，它里面有多个段，指令（就是存放函数代码，它是只读的）放在一个段，这个是可以共享的。而有些段不是共享的，它是每个进程各自一份，比如全局偏移表（.got），这个里面存放的就是变量函数的地址，因为每个进程都有自己的虚拟内存，所以共享库函数的地址也是不一样的。 与 .got 相关的还有一个 .plt，它是用来懒绑定的，就是说函数到真正使用的时候，才会绑定地址，因为有的函数根本就不会被调用。 hook 函数这里的 hook 有两种选择，一种是 java 层，一种是 native 层。 但是 java 层有些缺点： 兼容性差。Java Hook 需要每个 Android 版本去兼容，特别是 Android P 增加对非公开 API 限制。 无法监控 Native 代码。 I/O 操作调用非常频繁，因为使用动态代理和 Java 的大量字符串操作，导致性能比较差，无法达到线上使用的标准。 所以，采用的是 native 的方式。最终是从 libc.so 中的这几个函数中选定 Hook 的目标函数（当然，遍历所有已经加载的 library，全部替换更好）。 1234int open(const char *pathname, int flags, mode_t mode);ssize_t read(int fd, void *buf, size_t size);ssize_t write(int fd, const void *buf, size_t size); write_cukint close(int fd); 不同版本的 Android 系统实现有所不同，在 Android 7.0 之后，我们还需要替换下面这三个方法。 123open64__read_chk__write_chk 爱奇艺开源的 xhook 可以 hook .so 中的函数，Github 上有相关信息，有兴趣的可以去看源码。 这里我们看一下使用方式。 open iocanary::Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook 123456789101112131415161718JNIEXPORT jboolean JNICALL Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook(JNIEnv *env, jclass type) &#123; for (int i = 0; i &lt; TARGET_MODULE_COUNT; ++i) &#123; const char* so_name = TARGET_MODULES[i]; void* soinfo = xhook_elf_open(so_name); // 从 .so 里面 找到 open 函数，将open函数的地址指向 ProxyOpen，原来的函数地址保存到 original_open // void** 相当于一个泛型 xhook_hook_symbol(soinfo, "open", (void*)ProxyOpen, (void**)&amp;original_open); ... xhook_elf_close(soinfo); &#125; return JNI_TRUE;&#125; 可以看到，使用还是挺简单的，先打开 .so 文件，然后传递需要hook的函数名，以及俩个二级函数指针就好了，我们看看 ProxyOpen 函数： iocanary::ProxyOpen 12345678910111213int ProxyOpen(const char *pathname, int flags, mode_t mode) &#123; if(!IsMainThread()) &#123; return original_open(pathname, flags, mode); &#125; int ret = original_open(pathname, flags, mode); if (ret != -1) &#123; DoProxyOpenLogic(pathname, flags, mode, ret); &#125; return ret;&#125; 这里，它只监测了主线程的IO（其他的代理方法都有这个逻辑，可能是其他线程有bug还是什么）。然后调用原来的 open 函数打开文件，拿到返回的文件描述符后，执行插入的代理逻辑： iocanary::DoProxyOpenLogic 12345678910111213141516171819202122232425262728293031static void DoProxyOpenLogic(const char *pathname, int flags, mode_t mode, int ret) &#123; JNIEnv* env = NULL; kJvm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6); if (env == NULL || !kInitSuc) &#123; __android_log_print(ANDROID_LOG_ERROR, kTag, "ProxyOpen env null or kInitSuc:%d", kInitSuc); &#125; else &#123; // 获取 java 层的 JavaContext 对象 jobject java_context_obj = env-&gt;CallStaticObjectMethod(kJavaBridgeClass, kMethodIDGetJavaContext); if (NULL == java_context_obj) &#123; return; &#125; // 获取java层堆栈信息 jstring j_stack = (jstring) env-&gt;GetObjectField(java_context_obj, kFieldIDStack); // 线程名 jstring j_thread_name = (jstring) env-&gt;GetObjectField(java_context_obj, kFieldIDThreadName); char* thread_name = jstringToChars(env, j_thread_name); char* stack = jstringToChars(env, j_stack); // 创建 C++ 层的 JavaContex 对象 JavaContext java_context(GetCurrentThreadId(), thread_name == NULL ? "" : thread_name, stack == NULL ? "" : stack); free(stack); free(thread_name); iocanary::IOCanary::Get().OnOpen(pathname, flags, mode, ret, java_context); env-&gt;DeleteLocalRef(java_context_obj); env-&gt;DeleteLocalRef(j_stack); env-&gt;DeleteLocalRef(j_thread_name); &#125;&#125; kJavaBridgeClass 等变量在 JNI_OnLoad 的时候就已经初始化好了。这些都是用来创建 java 层的对象的。 该函数就是创建出了一些必要的参数，然后调用了 OnOpen 方法，最终调用到 IOInfoCollector::OnOpen 12345678910111213141516171819202122void IOInfoCollector::OnOpen(const char *pathname, int flags, mode_t mode, int open_ret, const JavaContext &amp;java_context) &#123; //__android_log_print(ANDROID_LOG_DEBUG, kTag, "OnOpen fd:%d; path:%s", open_ret, pathname); // 文件打开失败 if (open_ret == -1) &#123; return; &#125; // 这里很奇怪啊，为啥要使用 返回值作为key？？？open_ret 是文件的描述符 // 文件已经被记录了 if (info_map_.find(open_ret) != info_map_.end()) &#123; //__android_log_print(ANDROID_LOG_WARN, kTag, "OnOpen fd:%d already in info_map_", open_ret); return; &#125; // make_shared 会在堆上创建对象，返回一个智能指针 std::shared_ptr&lt;IOInfo&gt; info = std::make_shared&lt;IOInfo&gt;(pathname, java_context); // 记录 info_map_.insert(std::make_pair(open_ret, info));&#125; 可以看到，每次打开一个文件的时候，都会将其记录到 map 中，key 是文件的路径，value 是一个IOInfo类型的指针。 read/write我们使用同样的方式，可以追踪到 read/write 的相关hook逻辑： IOInfoCollector::CountRWInfo 123456789101112131415161718192021222324252627282930313233343536373839404142voidIOInfoCollector::CountRWInfo(int fd, const FileOpType &amp;fileOpType, long op_size, long rw_cost) &#123; if (info_map_.find(fd) == info_map_.end()) &#123; return; &#125; const int64_t now = GetSysTimeMicros(); info_map_[fd]-&gt;op_cnt_++; info_map_[fd]-&gt;op_size_ += op_size; info_map_[fd]-&gt;rw_cost_us_ += rw_cost; // 记录单次最大的读写时间 if (rw_cost &gt; info_map_[fd]-&gt;max_once_rw_cost_time_μs_) &#123; info_map_[fd]-&gt;max_once_rw_cost_time_μs_ = rw_cost; &#125; // 如果连续读写间隔小于 kContinualThreshold（8ms） if (info_map_[fd]-&gt;last_rw_time_μs_ &gt; 0 &amp;&amp; (now - info_map_[fd]-&gt;last_rw_time_μs_) &lt; kContinualThreshold) &#123; // 本次连续读写时间 info_map_[fd]-&gt;current_continual_rw_time_μs_ += rw_cost; &#125; else &#123; info_map_[fd]-&gt;current_continual_rw_time_μs_ = rw_cost; &#125; if (info_map_[fd]-&gt;current_continual_rw_time_μs_ &gt; info_map_[fd]-&gt;max_continual_rw_cost_time_μs_) &#123; info_map_[fd]-&gt;max_continual_rw_cost_time_μs_ = info_map_[fd]-&gt;current_continual_rw_time_μs_; &#125; // 记录读写时刻 info_map_[fd]-&gt;last_rw_time_μs_ = now; // 记录操作的 buffer 大小，这里是记录的最大值 if (info_map_[fd]-&gt;buffer_size_ &lt; op_size) &#123; info_map_[fd]-&gt;buffer_size_ = op_size; &#125; // 如果对一个文件又读又写，记录第一次的读写类型？？？ if (info_map_[fd]-&gt;op_type_ == FileOpType::kInit) &#123; info_map_[fd]-&gt;op_type_ = fileOpType; &#125;&#125; 这里面是记录了一些读写的数据。 close IOInfoCollector::OnClose 1234567891011121314151617181920/** * 返回 fd 对应的文件信息，在 info_map_ 中 */std::shared_ptr&lt;IOInfo&gt; IOInfoCollector::OnClose(int fd, int close_ret) &#123; if (info_map_.find(fd) == info_map_.end()) &#123; //__android_log_print(ANDROID_LOG_DEBUG, kTag, "OnClose fd:%d not in info_map_", fd); return nullptr; &#125; // 从打开到关闭的耗时 info_map_[fd]-&gt;total_cost_μs_ = GetSysTimeMicros() - info_map_[fd]-&gt;start_time_μs_; // 文件大小 info_map_[fd]-&gt;file_size_ = GetFileSize(info_map_[fd]-&gt;path_.c_str()); // 其他信息在读写时记录了 std::shared_ptr&lt;IOInfo&gt; info = info_map_[fd]; info_map_.erase(fd); return info;&#125; 这里也记录了一些信息，注意，这里返回了指针，然后 map 里面的键值对被擦除了。 主线程IO经过上面对几个函数的hook，我们可以获取到读写文件时的详细信息。拿到这些信息之后，我们就可以进行相应的处理，判断该IO行为是否正常。 我们从 plugin 的 start 开始分析整个流程。 com.tencent.matrix.iocanary.core.IOCanaryCore#initDetectorsAndHookers 12345678910111213141516private void initDetectorsAndHookers(IOConfig ioConfig) &#123; assert ioConfig != null; if (ioConfig.isDetectFileIOInMainThread() || ioConfig.isDetectFileIOBufferTooSmall() || ioConfig.isDetectFileIORepeatReadSameFile()) &#123; IOCanaryJniBridge.install(ioConfig, this); &#125; // 监测 io 是否关闭了 //if only detect io closeable leak use CloseGuardHooker is Better if (ioConfig.isDetectIOClosableLeak()) &#123; mCloseGuardHooker = new CloseGuardHooker(this); mCloseGuardHooker.hook(); &#125;&#125; 我们这里只分析第一个 if 里面的东西，第二个 if 里面的东西最后分析。 在第一个 if 里面，就是判断了是否开启某些监测，开启了才调用相应代码。 install 函数里面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void install(IOConfig config, OnJniIssuePublishListener listener) &#123; MatrixLog.v(TAG, "install sIsTryInstall:%b", sIsTryInstall); if (sIsTryInstall) &#123; return; &#125; // 加载 .so 文件 //load lib if (!loadJni()) &#123; MatrixLog.e(TAG, "install loadJni failed"); return; &#125; //set listener sOnIssuePublishListener = listener; try &#123; //set config if (config != null) &#123; if (config.isDetectFileIOInMainThread()) &#123; // 调用 native 方法 enableDetector(DetectorType.MAIN_THREAD_IO); // ms to μs setConfig(ConfigKey.MAIN_THREAD_THRESHOLD, config.getFileMainThreadTriggerThreshold() * 1000L); &#125; if (config.isDetectFileIOBufferTooSmall()) &#123; enableDetector(DetectorType.SMALL_BUFFER); setConfig(ConfigKey.SMALL_BUFFER_THRESHOLD, config.getFileBufferSmallThreshold()); &#125; if (config.isDetectFileIORepeatReadSameFile()) &#123; enableDetector(DetectorType.REPEAT_READ); setConfig(ConfigKey.REPEAT_READ_THRESHOLD, config.getFileRepeatReadThreshold()); &#125; &#125; //hook doHook(); sIsTryInstall = true; &#125; catch (Error e) &#123; MatrixLog.printErrStackTrace(TAG, e, "call jni method error"); &#125;&#125; 该函数做了这些事： 先加载对应的 .so 库 根据 config 设置对应的监听，enableDetector 是一个native 代码，最终会调用到 123456789void IOCanary::RegisterDetector(DetectorType type) &#123; switch (type) &#123; case DetectorType::kDetectorMainThreadIO: // 添加到detector容器集合 detectors_.push_back(new FileIOMainThreadDetector()); break; ... &#125;&#125; 进行 hook，这里的 hook 就是上面说的 hook 函数部分了。 这里，我们知道，监听设置了，但是监听什么时候被调用呢？我们看 IOCanary 的构造函数： 1234567IOCanary::IOCanary() &#123; exit_ = false; // 创建一个线程，detect 是被调用的函数，其参数是 this（隐式参数） std::thread detect_thread(&amp;IOCanary::Detect, this); // 分离线程，线程单独运行 detect_thread.detach();&#125; 这里，它开启了一个线程，该线程运行的是 Detect 函数。 12345678910111213141516171819202122232425262728293031323334void IOCanary::Detect() &#123; std::vector&lt;Issue&gt; published_issues; // 只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”， // 就不必担心在哪里写delete p语句——实际上根本不需要编写这条语句， // 托管 p 的 shared_ptr 对象在消亡时会自动执行delete p。 // 有点 java 的味道了 std::shared_ptr&lt;IOInfo&gt; file_io_info; while (true) &#123; published_issues.clear(); int ret = TakeFileIOInfo(file_io_info); // exit_ 为0， 就跳出了 if (ret != 0) &#123; break; &#125; // detectors_ 是监听集合 // 具体可见 IOCanary::RegisterDetector 方法 // 在对一个文件操作完毕之后，open -&gt; read/write -&gt; close，才会回调 for (auto detector : detectors_) &#123; detector-&gt;Detect(env_, *file_io_info, published_issues); &#125; // 调用回调方法 // 该监听是在 iocanary::JNI_OnLoad 里面设置的 if (issued_callback_ &amp;&amp; !published_issues.empty()) &#123; issued_callback_(published_issues); &#125; // 释放指针 file_io_info = nullptr; &#125;&#125; 这里面是一个生产者-消费者模式，Detect 扮演的是消费者的角色，它调用 TakeFileIOInfo 函数获取一个 IOInfo 的指针，然后对它进行处理，我们可以看到，在 for 里面，它将这个指针传递到了我们之前设置的监听函数的回调参数里面。这样，在监听的回调函数里面，我们就可以拿到本次IO的各种信息了。 这里是生产者-消费者模式，所以我们还要搞清楚，谁是生产者。搜索，queue_cv_ 变量，我们可以发现如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void IOCanary::OnClose(int fd, int close_ret) &#123; std::shared_ptr&lt;IOInfo&gt; info = collector_.OnClose(fd, close_ret); if (info == nullptr) &#123; return; &#125; OfferFileIOInfo(info);&#125;void IOCanary::OfferFileIOInfo(std::shared_ptr&lt;IOInfo&gt; file_io_info) &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_); queue_.push_back(file_io_info); // 通知等待线程，添加进去了一个元素 queue_cv_.notify_one(); lock.unlock();&#125;/** * 从 queue_ 里面获取队头的 file_io_info 对象 */int IOCanary::TakeFileIOInfo(std::shared_ptr&lt;IOInfo&gt; &amp;file_io_info) &#123; // std::unique_lock对象以独占所有权的方式(unique owership)管理mutex对象的上锁和解锁操作， // 即在unique_lock对象的声明周期内，它所管理的锁对象会一直保持上锁状态； // 而unique_lock的生命周期结束之后，它所管理的锁对象会被解锁。 std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_); // 如果队列为空，那就一直等待，开起来像是一个生产者-消费者模式 while (queue_.empty()) &#123; // wait 会释放锁 queue_cv_.wait(lock); if (exit_) &#123; return -1; &#125; &#125; // 因为参数是引用，所以这里会改变传递进来的实参值 file_io_info = queue_.front(); // pop 居然没有返回 pop 出来的值，难怪要多加一句 queue_.pop_front(); return 0;&#125; OnClose 是我们的 hook 函数的代码，它在文件关闭的时候会被调用，所以结论就是文件关闭的时候，会返回（上面提到过）一个 IOInfo 的指针，然后将它放到队列中，通知等待线程开始执行，最后就回调到了我们的监听代码中。 我们看看主线程IO的监听代码： 123456789101112131415161718192021void FileIOMainThreadDetector::Detect(const IOCanaryEnv &amp;env, const IOInfo &amp;file_io_info, std::vector&lt;Issue&gt;&amp; issues) &#123; if (GetMainThreadId() == file_io_info.java_context_.thread_id_) &#123; int type = 0; // 最大读写时间超过 13ms if (file_io_info.max_once_rw_cost_time_μs_ &gt; IOCanaryEnv::kPossibleNegativeThreshold) &#123; type = 1; &#125; // 一次连续读写时间超过 500ms if(file_io_info.max_continual_rw_cost_time_μs_ &gt; env.GetMainThreadThreshold()) &#123; type |= 2; &#125; if (type != 0) &#123; Issue issue(kType, file_io_info); issue.repeat_read_cnt_ = type; //use repeat to record type PublishIssue(issue, issues); &#125; &#125;&#125; 没啥好说的，就是判断一些阈值而已。如果你想监测别的数据，可以自己设置一些监听。 重复读这个监听我就不贴代码了，感觉它现在有点鸡肋，我的 note 分支里面有详细注释，有兴趣可以查看。 其实，我觉得可以统计一下App在一次运行过程中，每个文件被读取的次数。反正你可以获取到每次IO的所有信息，像做什么就做什么。 小 Buffer 的io我们知道，对于文件系统是以block为单位读写，对于磁盘是以page 为单位读写，看起来即使我们在应用程序上面使用很小的Buffer，在底层应该差别不大，那是不是这样呢？[](https://aheadsnail.github.io/uploads/Matrix Trace分析/Io文件Buff使用.png) 虽然后面俩次系统调用的时间的确会少一些，但是也会有一定的耗时，如果我们的Buffer太小，会导致多次无用的系统调用和内存拷贝，导致read/write的次数增多，从而影响性能，那多大的Buff Size合适呢，一般为4KB,在实际应用中，ObjectOutputStream 就是一个很好的例子，ObjectOutputStream使用的buff size非常小，如果我们使用BufferInputStream或者ByteArrayOutputStream后整体的性能,会有非常明显的提升,下面是检测的结果。 所以检测读写Buff过小是非常重要的。 123456789101112131415void FileIOSmallBufferDetector::Detect(const IOCanaryEnv &amp;env, const IOInfo &amp;file_io_info, std::vector&lt;Issue&gt; &amp;issues) &#123; //__android_log_print(ANDROID_LOG_ERROR, "FileIOSmallBufferDetector", "Detect buffer_size:%d threshold:%d op_cnt:%d rw_cost:%d", // file_io_info.buffer_size_, env.GetSmallBufferThreshold(), file_io_info.op_cnt_, file_io_info.max_continual_rw_cost_time_μs_); // 读写次数 &gt; 20 // 读写总数量 / 读写次数 &lt; 4096 // 最大连续读写耗时 &gt;= 13ms if (file_io_info.op_cnt_ &gt; env.kSmallBufferOpTimesThreshold &amp;&amp; (file_io_info.op_size_ / file_io_info.op_cnt_) &lt; env.GetSmallBufferThreshold() &amp;&amp; file_io_info.max_continual_rw_cost_time_μs_ &gt;= env.kPossibleNegativeThreshold) &#123; PublishIssue(Issue(kType, file_io_info), issues); &#125;&#125; 未关闭的文件除了上面监测主线程的各种问题之外，该库还提供了一个特殊的功能，监测未关闭的文件操作。 其大致原理是使用了 CloseGuard 类，这个类的用法如下： 1234567891011121314151617181920212223242526272829303132333435363738 private final CloseGuard mCloseGuard = CloseGuard.get();... public InputQueue() &#123; mPtr = nativeInit(new WeakReference&lt;InputQueue&gt;(this), Looper.myQueue()); mCloseGuard.open("dispose"); &#125;... @Override protected void finalize() throws Throwable &#123; try &#123; dispose(true); &#125; finally &#123; super.finalize(); &#125; &#125; public void dispose() &#123; dispose(false); &#125; public void dispose(boolean finalized) &#123; if (mCloseGuard != null) &#123; if (finalized) &#123; mCloseGuard.warnIfOpen(); &#125; mCloseGuard.close(); &#125; if (mPtr != 0) &#123; nativeDispose(mPtr); mPtr = 0; &#125; &#125; 用法还是挺简单的，就是利用了 finalize 方法。 它先在构造方法里面，调用了 CloseGuard 的 open 方法，open方法里面记录了一个标识。假设，我们使用完该类后，没有调用该类的 dispose 方法，那么 CloseGuard 里面的标识就还存在，那么当该类被回收的时候，会触发 finalize 方法，然后执行到 CloseGuard.warnIfOpen 方法，这样就会弹出警告。 所以它的原理，其实就是利用了 finalize 来监测我们是否成对的调用了某些方法。 我们可以利用这个类，因为系统的很多类都使用了 CloseGuard ，我们开启严格模式后能监测一些问题，就是利用的这个原理。 所以，我们需要 hook 这个类，监测到未关闭的文件，就提出警告。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536private boolean tryHook() &#123; try &#123; // hook 系统的 CloseGuard 类，该类是用于监测某些类是否正常关闭的，比如 cursor // 具体是先看一下 android.view.InputQueue 的源码就好了，几十行 // 大致原理就是依赖 finalize 方法来监测是否有调用对应的 close 方法 // 所以，我们使用反射开启这个类的功能，然后 hook 它，在里面做我们的逻辑 Class&lt;?&gt; closeGuardCls = Class.forName("dalvik.system.CloseGuard"); Class&lt;?&gt; closeGuardReporterCls = Class.forName("dalvik.system.CloseGuard$Reporter"); Method methodGetReporter = closeGuardCls.getDeclaredMethod("getReporter"); Method methodSetReporter = closeGuardCls.getDeclaredMethod("setReporter", closeGuardReporterCls); Method methodSetEnabled = closeGuardCls.getDeclaredMethod("setEnabled", boolean.class); sOriginalReporter = methodGetReporter.invoke(null); methodSetEnabled.invoke(null, true); // open matrix close guard also MatrixCloseGuard.setEnabled(true); ClassLoader classLoader = closeGuardReporterCls.getClassLoader(); if (classLoader == null) &#123; return false; &#125; methodSetReporter.invoke(null, Proxy.newProxyInstance(classLoader, new Class&lt;?&gt;[]&#123;closeGuardReporterCls&#125;, // hook 类 new IOCloseLeakDetector(issueListener, sOriginalReporter))); return true; &#125; catch (Throwable e) &#123; MatrixLog.e(TAG, "tryHook exp=%s", e); &#125; return false;&#125; 这样，我们在 IOCloseLeakDetector 里面，就可以处理问题了： 123456789101112131415161718192021222324252627282930 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; MatrixLog.i(TAG, "invoke method: %s", method.getName()); if (method.getName().equals("report")) &#123; ... if (isPublished(stackKey)) &#123; ... &#125; else &#123; // 这里处理 issue Issue ioIssue = new Issue(SharePluginInfo.IssueType.ISSUE_IO_CLOSABLE_LEAK); ioIssue.setKey(stackKey); JSONObject content = new JSONObject(); try &#123; content.put(SharePluginInfo.ISSUE_FILE_STACK, stackKey); &#125; catch (JSONException e) &#123;// e.printStackTrace(); MatrixLog.e(TAG, "json content error: %s", e); &#125; ioIssue.setContent(content); publishIssue(ioIssue); MatrixLog.i(TAG, "close leak issue publish, key:%s", stackKey); markPublished(stackKey); &#125; return null; &#125; return method.invoke(originalReporter, args); &#125; 这里，就触发了 publishIssue 方法。 有一点需要注意，这里是开启了 CloseGuard，所以使用了 CloseGuard 的类都可以监测到，比如： 123456789101112131415161718192021try &#123; Class&lt;?&gt; aClass = Class.forName("android.view.InputQueue"); Object o = aClass.newInstance();&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; catch (IllegalAccessException e) &#123; e.printStackTrace();&#125; catch (InstantiationException e) &#123; e.printStackTrace();&#125;//need to trigger gc to detect leaknew Thread(new Runnable() &#123; @Override public void run() &#123; Runtime.getRuntime().gc(); Runtime.getRuntime().runFinalization(); Runtime.getRuntime().gc(); &#125;&#125;).start(); 这里我们使用了，InputQueue，它里面使用了 CloseGuard，而我们没有调用其 dispose 方法，所以这个函数会被检测出来使用有问题。 处理issue上面检测出来的问题，最终都会汇总到 com.tencent.matrix.plugin.Plugin#onDetectIssue 这个方法里面，然后对 Issue 进行处理，其实就是转为json，用于可视化展示。 123456789101112131415161718192021222324252627@Overridepublic void onDetectIssue(Issue issue) &#123; if (issue.getTag() == null) &#123; // set default tag issue.setTag(getTag()); &#125; issue.setPlugin(this); JSONObject content = issue.getContent(); // add tag and type for default try &#123; if (issue.getTag() != null) &#123; content.put(Issue.ISSUE_REPORT_TAG, issue.getTag()); &#125; if (issue.getType() != 0) &#123; content.put(Issue.ISSUE_REPORT_TYPE, issue.getType()); &#125; content.put(Issue.ISSUE_REPORT_PROCESS, MatrixUtil.getProcessName(application)); content.put(Issue.ISSUE_REPORT_TIME, System.currentTimeMillis()); &#125; catch (JSONException e) &#123; MatrixLog.e(TAG, "json error", e); &#125; // 这里的回调是整个 matrix 的一个回调，我们可以在这个回调里面进行个性化处理，比如上报后台之类的 //MatrixLog.e(TAG, "detect issue:%s", issue); pluginListener.onReportIssue(issue);&#125; 参考文档https://zhuanlan.zhihu.com/p/36426206]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[番外篇：重定位]]></title>
    <url>%2F2020%2F08%2F27%2Fblog_bak%2FBlog%2FC%2B%2B%2F%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E9%87%8D%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[很久很久以前，在一个非常遥远的银河系……在最开始的时候，程序员需要先将程序写在纸上。当程序要被运行的时候，程序员人工的将它写的程序写到储存设备上，最原始的储存设备是纸带，即在纸上打孔。假设有一种计算机，它的每条指令是1个字节，也就是8位。我们假设有一种跳转指令，它的高4位是 0001，表示这是一种跳转指令。低4位存放的是跳转目的的绝对地址。 1234560 0001 01001 ...2 ...3 ...4 1000 01115 ... 看上面的例子，这个程序的第一条指令是一个跳转指令，它的目的地址是第 5 跳指令（注意，第 5 条指令的绝对地址是 4）。 现在问题来了，程序写好了之后，并不是永远不变的。比如，我们想在第1条指令之后，第5条指令之前加入某些指令，那么第5条指令及后面的指令需要相应的往后移动，且第1条指令的目的地址也需要调整。在这个过程中程序员需要人工的重新计算每个子程序或跳转的目标地址。当程序修改的时候，这些位置都要重新计算，非常容易出错，而且又耗时。这样重新计算各个目标的地址的过程就叫做重定位。 如果，某个程序需要多个纸带储存，那么就会出现跨纸带跳转的情况，那么重定位就更加复杂了。 这个时候，汇编语言就出现了。汇编语言使用符号与标记来解决这些问题。举个例子，在前面的程序中，我们将第5条指令开始的子程序叫做 foo，那么第1条汇编就可以写成： 1jmp foo 使用了符号命令的子程序之后，不管 foo 之前插入或删除了多少指令，汇编器在每次汇编程序的时候，都会重新计算 foo 子程序的地址。然后将所有引用 foo 的指令修改位这个正确的地址。 符号，表示一个地址，这个地址可能是一段子程序的地址地址，也可能是一个变量的起始地址。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机捡漏]]></title>
    <url>%2F2020%2F08%2F25%2Fblog_bak%2FBlog%2FJava%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8D%A1%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[之前在看《深入理解虚拟机》的时候，有点东西一直没懂，这里主要是做一些补充，避免后面自己又忘记了。符号引用符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。这个是啥意思呢？看下面：在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。 比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。 然后等 Class 加载到内存中之后，会将符号引用替换为具体的 Class 地址。 直接引用直接引用可以是（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）（3）一个能间接定位到目标的句柄直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[015-Matrix源码分析：检测内存中重复的Bitmap]]></title>
    <url>%2F2020%2F08%2F19%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F015-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8B%E5%86%85%E5%AD%98%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84Bitmap%2F</url>
    <content type="text"><![CDATA[在分析activity的引用链的时候，我们还可以顺便分析一下，内存中有没有重复的Bitmap，如果有的话，就可以看看是什么原因导致的，这样对优化内存有帮助。分析该任务的类是 DuplicatedBitmapAnalyzer。用过 as 的都知道它有一个 profiler功能，里面可以对CPU/网络/内存做分析。而内存分析的话，它也提供了 dump 与分析 hprof 文件的功能。 所以，我们查看这个模块的相关源码的话，就可以找到这个类： https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib/heap/memoryanalyzer/DuplicatedBitmapAnalyzerTask.java 里面是使用了一个算法来分析内存中的相同的bitmap。 先看看上面链接的这个类，然后再看 matrix 的这个类，会更好一点，因为 matrix 的这个类加了不少东西，导致方法很长，看起来就不好懂。 那我们就先分析 google 的那个类，它的逻辑很纯粹，好理解这个算法。 先说一下这个算法是如何做的： 首先，要判断两个 Bitmap 是否是一样的，只需要判断它的 mBuffer 字段是不是一样的，所以就归结为比较两个 byte 数组是否一样。 内存中的 Bitmap 对象那么多，怎么才能列举出所有相等的 mBuffer 呢？ 第一步，将 mBuffer 按照 mBuffer[0] 的值进行分组。假设，得到了 8 组。 第二部，遍历上面得到的 8 组内容，对每组按照 mBuffer[1] 的值再进行分组。 重复上面的过程。一直到有 mBuffer 已经被遍历完了，就检查一下被遍历完成的集合大小，是否大于1。如果大于1，则说明这个集合里面的 mBuffer 是一样的。所以就找到了所有的相同的 mBuffer。下面是具体的实现代码： DuplicatedBitmapAnalyzerTask#analyze 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int columnIndex = 0;while (!commonPrefixSets.isEmpty()) &#123; for (Set&lt;ArrayInstance&gt; commonPrefixArrays : commonPrefixSets) &#123; Map&lt;Object, Set&lt;ArrayInstance&gt;&gt; entryClassifier = new HashMap&lt;&gt;( commonPrefixArrays.size()); for (ArrayInstance arrayInstance : commonPrefixArrays) &#123; Object element = cachedValues.get(arrayInstance)[columnIndex]; if (entryClassifier.containsKey(element)) &#123; entryClassifier.get(element).add(arrayInstance); &#125; else &#123; Set&lt;ArrayInstance&gt; instanceSet = new HashSet&lt;&gt;(); instanceSet.add(arrayInstance); entryClassifier.put(element, instanceSet); &#125; &#125; for (Set&lt;ArrayInstance&gt; branch : entryClassifier.values()) &#123; if (branch.size() &lt;= 1) &#123; // Unique branch, ignore it and it won't be counted towards duplication. continue; &#125; Set&lt;ArrayInstance&gt; terminatedArrays = new HashSet&lt;&gt;(); // Move all ArrayInstance that we have hit the end of to the candidate result list. for (ArrayInstance instance : branch) &#123; if (instance.getLength() == columnIndex + 1) &#123; terminatedArrays.add(instance); &#125; &#125; branch.removeAll(terminatedArrays); // Exact duplicated arrays found. if (terminatedArrays.size() &gt; 1) &#123; int byteArraySize = -1; ArrayList&lt;Instance&gt; duplicateBitmaps = new ArrayList&lt;&gt;(); for (ArrayInstance terminatedArray : terminatedArrays) &#123; duplicateBitmaps.add(byteArrayToBitmapMap.get(terminatedArray)); byteArraySize = terminatedArray.getLength(); &#125; results.add( new DuplicatedBitmapEntry(new ArrayList&lt;&gt;(duplicateBitmaps), byteArraySize)); &#125; // If there are ArrayInstances that have identical prefixes and haven't hit the // end, add it back for the next iteration. if (branch.size() &gt; 1) &#123; reducedPrefixSets.add(branch); &#125; &#125; &#125; commonPrefixSets.clear(); commonPrefixSets.addAll(reducedPrefixSets); reducedPrefixSets.clear(); columnIndex++;&#125; 其实还有一种找出重复 mBuffer 的方式，比较简单，就是对 mBuffer 进行 md5或者hash。比如下面的代码： 123456789101112131415161718192021222324252627/** * 处理 heap，找出有相同 buffer 的 bitmap 的 instance，存放在 map 中。 * @param objMap 存放相同 buffer 的 instance 的map * @param heap 待处理的 heap * @param classObj 这里是 bitmap 的封装对象 */private static void analyzeHeapForSameBuffer(Map&lt;String, ArrayList&lt;ObjNode&gt;&gt; objMap, Heap heap, ClassObj classObj)&#123; List&lt;Instance&gt; instances = classObj.getHeapInstances(heap.getId()); for (Instance instance : instances)&#123; ArrayInstance buffer = HahaHelper.fieldValue(HahaHelper.classInstanceValues(instance), "mBuffer"); byte[] bytes = HahaHelper.getByteArray(buffer); try &#123; String md5String = Md5Helper.getMd5(bytes); if(objMap.containsKey(md5String))&#123; objMap.get(md5String).add(getObjNode(instance)); &#125;else &#123; ArrayList&lt;ObjNode&gt; objNodes = new ArrayList&lt;&gt;(); objNodes.add(getObjNode(instance)); objMap.put(md5String, objNodes); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 重复的图片找到之后，再找到引用链（与分析 activity 的引用链一样），然后将这些信息保存起来。这里还保存了 mBuffer，用于还原图片，便于开发者寻找问题。 com.tencent.matrix.resource.analyzer.CLIMain#analyzeAndStoreResult 12345678910111213141516171819202122// 使用 bitmap 的 buffer 还原成图片// Store bitmap buffer.final List&lt;DuplicatedBitmapEntry&gt; duplicatedBmpEntries = duplicatedBmpResult.getDuplicatedBitmapEntries();final int duplicatedBmpEntryCount = duplicatedBmpEntries.size();for (int i = 0; i &lt; duplicatedBmpEntryCount; ++i) &#123; final DuplicatedBitmapEntry entry = duplicatedBmpEntries.get(i); final BufferedImage img = BitmapDecoder.getBitmap( new HprofBitmapProvider(entry.getBuffer(), entry.getWidth(), entry.getHeight())); // Since bmp format is not compatible with alpha channel, we export buffer as png instead. final String pngName = bufferContentsRootDirName + "/" + entry.getBufferHash() + ".png"; try &#123; zos.putNextEntry(new ZipEntry(pngName)); ImageIO.write(img, "png", zos); zos.flush(); &#125; finally &#123; try &#123; zos.closeEntry(); &#125; catch (Throwable ignored) &#123; // Ignored. &#125; &#125;&#125; 最后就是输出 json 信息： 12final JSONObject duplicatedBmpResultJson = new JSONObject();duplicatedBmpResult.encodeToJSON(duplicatedBmpResultJson);]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[001-语法捡漏]]></title>
    <url>%2F2020%2F08%2F19%2Fblog_bak%2FBlog%2FC%2B%2B%2F001-%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[指针常量与常量指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 C++ primer 中的就近原则：const 里 * 近，就是指针不可变，离 int 近，就是值不可变。 12345678910111213141516171819202122232425int main() &#123; int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system("pause"); return 0;&#125; 常量指针的用处之一： 12345678910111213141516171819202122232425262728struct Student&#123; /* data */ int age; string name;&#125;;/* * 这里的参数是值传递，不是 java 的引用传递，相当于是将 student 拷贝了一份 * 所以，如果结构体很重，那么我们一般传递地址 */void printStudentBad(Student s)&#123; cout &lt;&lt; s.age &lt;&lt; s.name;&#125;/* * 这里虽然使用了指针，但是对结构体的控制就减弱了，因为可以随便修改，而且会影响到原结构体变量 * 解决办法是使用 const 修饰 */void printStudentGood(const Student *s)&#123; // Student const *s; // const Student *s; cout &lt;&lt; s-&gt;age &lt;&lt; s-&gt;name;&#125; new 关键字C++ 中有4个区，其中局部变量在栈区： 12345678910111213int main()&#123; Student stu; stu.age = 10; stu.name = "xiao li"; int b = 100; cout &lt;&lt; &amp;stu &lt;&lt; endl; cout &lt;&lt; &amp;b &lt;&lt; endl; return 0;&#125; 输出结果会发现，stu 与 b 的地址端很近，说明他们都在栈区，注意与java的区别。想要让对象分配在堆区，需要使用 new 关键字。 12Student * stu2 = new Student(&#123;10, "xiao mao"&#125;);cout &lt;&lt; stu2 &lt;&lt; endl; 这样，stu2 就分配到了堆区，打印发现地址段离栈区很远。 使用 new 关键字，还有一个需要注意的地方，看如下例子： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class A&#123;public: //A()&#123;a=1;&#125;public: int a;&#125;;int main()&#123; A *a1 = new A; A *a2 = new A(); cout &lt;&lt; a1-&gt;a &lt;&lt; endl; //输出:-842150451 cout &lt;&lt; a2-&gt;a &lt;&lt; endl; //输出0 return 0;&#125; 原因看下面链接： https://www.zhihu.com/question/35843839 引用的本质引用的本质在c++内部实现是一个指针常量. 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 一个奇怪的问题： error: cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’ 123int &amp;r = 10; // 这行代码会报错// 不過，加上 const 的話倒是可以：const int &amp;r = 10; 这是因为：10是一个常量，常量是記憶體中臨時的資料，無法對常量取址。而加上 const 之后，編譯器會將以上轉換為像是： 12const int _n = 10;const int &amp;r = _n; 類似地，以下會編譯失敗： 123int a = 10;int b = 20;int &amp;r = a + b; // error: cannot bind non-const lvalue reference of type &apos;int&amp;&apos; to an rvalue of type &apos;int&apos; 這是因為 a + b 運算出的結果，會是在臨時的記憶體空間中，無法取址；類似地，若想通過編譯，必須加上 const。 struct 与 class 的区别struct 中的成员默认是公共的，class中的成员默认是私有的。 pragma once防止文头件重复包含。 将头文件与实现拆开后，类的实现方法需要指定所属类，比如： 头文件中 123class P&#123; void setX(); &#125;; 实现中： 123void P::setX() &#123; // 加上 :: ...&#125; 构造函数的调用123456789101112131415161718void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); // 这相当于 Person p6; Person (p6);&#125; 拷贝构造函数的写法： 1234Person(const Person&amp; p) &#123; // const + &amp; cout &lt;&lt; "拷贝构造函数!" &lt;&lt; endl; mAge = p.mAge;&#125; 静态成员静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 常函数与常对象常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 1234567891011121314151617181920212223242526class Person &#123;public: Person() &#123; m_A = 0; m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; &#125; void MyFunc() const &#123; //mA = 10000; &#125;public: int m_A; mutable int m_B; //可修改 可变的&#125;; 友元函数在类的最上面加上 friend 即可。 12345678//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容friend void goodGay(Building * building);//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容friend class goodGay;//告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容friend void goodGay::visit(); 操作符重载1234// 函数名改为 operator+ 即可Person operator+(const Person&amp; p) &#123; ...&#125; 1234567//后置++，注意这里使用了占位符MyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp;&#125; 一个匿名对象的使用案例 12345678910111213141516171819class MyAdd&#123;public: // 重载了函数调用符 int operator()(int v1, int v2) &#123; return v1 + v2; &#125;&#125;;void test02()&#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; "ret = " &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; "MyAdd()(100,100) = " &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125; 继承方式继承有三种方式： private protected public 这3个其实很好理解，就是子类对父类继承的东西的一种限制方式。拿 private 继承来说，父类的 public 属性，到了子类也变成 private 了。 对象模型结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 访问父类同名(静态)成员 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中所有同名成员函数（包括重载），加作用域可以访问到父类中同名函数 1s.Base::func(); 虚继承可以使用开发人员工具查看一下对象模型，了解一下虚基类指针与虚基类表。 用来解决菱形继承数据重复的问题。 虚函数12345678910class Animal&#123;public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; "动物在说话" &lt;&lt; endl; &#125;&#125;; 子类继承 Animal 之后，如果重写了 speak 方法，那么可以正常多态行为，如果 Animal 的 speak 方法没有 virtual 修饰，那么多态行为就不正常，这点需要与 Java 区分开来。 其原理是虚方法表，java的多态也是类似的，子类有自己的方法表，父类有自己的方法表，在调用方法的时候，会判断 this 的指向，然后调用对应的方法表的方法。 纯虚函数在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为==抽象类== 123456789101112131415161718class Base&#123;public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;public: virtual void func() &#123; cout &lt;&lt; "func调用" &lt;&lt; endl; &#125;;&#125;; 虚析构与纯虚析构1234567891011void test01()&#123; Animal *animal = new Cat("Tom"); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 // 这里是只调用了父类的析构函数，没有调用子类的 delete animal;&#125; 需要给父类析构函数加上 virtual： 12345//析构函数加上virtual关键字，变成虚析构函数virtual ~Animal()&#123; cout &lt;&lt; "Animal虚析构函数调用！" &lt;&lt; endl;&#125; 模板模板的通用性并不是万能的 例如： 12345template&lt;class T&gt;void f(T a, T b)&#123; a = b; &#125; 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了。 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板。 123456789101112131415161718192021222324252627282930//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板// 对上面的一个补充template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123; if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123; return true; &#125; else &#123; return false; &#125;&#125; 类模板1234567891011121314151617181920212223242526//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;// 与普通实现相比：需要声明模板，需要写尖括号//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; "姓名: " &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 一个问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到（这个不是很明白，为啥直接包含了cpp文件，就能链接到？？？） 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[000-序言]]></title>
    <url>%2F2020%2F08%2F19%2Fblog_bak%2FBlog%2FC%2B%2B%2F000-%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[学习C++纯粹就是因为想看懂Matrix里面的所有东西，而且对我之后的逆向学习计划有很大帮助。以前我学东西一般都是撸书，虽然确实可以学的很全，但是真的是太慢了，直到学 Flutter 的时候，同事推荐了一个视频，发现很不错，讲的是源码，体验下来的感觉真的是有人讲与自己琢磨的效率是天差地别。所以，以后学东西，尽量先撸视频，然后查漏补缺再去撸书。 而且，我看书有个最大的问题就是会一开始就找一些特别经典的书籍开始看。但是实际上，我自认为已经精通java了，但是看一些经典的书籍（核心技术一二册），还是会学到很多东西。这样导致的问题就是，作为一个初学者，看这些书很慢很慢，抓不到重点，容易半途而废。 如果没有其他事情中断的话，预计耗时1-2周。 学习视频地址： https://www.bilibili.com/video/av41559729/ 讲义： https://github.com/AnkerLeng/Cpp-0-1-Resource]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[014-Matrix源码分析：使用haha库找出泄漏的引用链]]></title>
    <url>%2F2020%2F08%2F18%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F014-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8haha%E5%BA%93%E6%89%BE%E5%87%BA%E6%B3%84%E6%BC%8F%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE%2F</url>
    <content type="text"><![CDATA[听说现在 LeakCanary 改用 shark 这个库来分析 hprof 了。前面讲到，当检测到 Activity 泄漏之后，会将裁剪之后的 hprof 文件打包，然后储存到某个位置（这个过程自行实现），这里假设我们储存到了app的目录中，然后我们导出这个文件，使用 matrix-resource-canary-analyzer 来分析这个压缩文件。 matrix-resource-canary-analyzer 是一个命令行工具，我们从 main 方法入手，这里同样省略到命令参数的处理过程。 首先，肯定是要将压缩文件里面的 hprof 文件释放出来： com.tencent.matrix.resource.analyzer.CLIMain#doAnalyze 1234// 将裁剪后的 hprof copy 到一个临时文件// We would extract hprof entry into a temporary file.tempHprofFile = new File(new File("").getAbsoluteFile(), "temp_" + System.currentTimeMillis() + ".hprof");StreamUtil.extractZipEntry(zf, hprofEntry, tempHprofFile); 接下来，就需要使用 haha 来分析这个文件了。在开始之前，我们先说一个预备知识，如果你看过 LeakCanary 的部分源码，那么你应该知道这个类AndroidExcludedRefs，它的作用就是用来排除一些由 Android Sdk 自身（或者制造商）引起的一些泄漏。 我们看一个例子： com.tencent.matrix.resource.analyzer.model.AndroidExcludedRefs 123456789101112131415ACTIVITY_CLIENT_RECORD__NEXT_IDLE() &#123; @Override boolean accept(int sdkVersion, String manufacturer) &#123; // 需要满足的条件 return sdkVersion &gt;= VersionCodes.KITKAT &amp;&amp; sdkVersion &lt;= VersionCodes.LOLLIPOP; &#125; @Override void add(ExcludedRefs.Builder excluded) &#123; excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle") .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a" + " nextIdle client record in the android.app.ActivityThread.mActivities map." + " Not sure what's going on there, input welcome."); &#125;&#125;, 可以看到，ActivityThread$ActivityClientRecord 这个字段有可能会导致误报，reason 里面是原因。还有些其他的，可以自行查看，对后面分析源码有较大帮助。 我们现在开始分析 hprof 文件： com.tencent.matrix.resource.analyzer.CLIMain#analyzeAndStoreResult 1234567final HeapSnapshot heapSnapshot = new HeapSnapshot(hprofFile);// 添加需要排除的引用，主要是由Android的SDK引起的，在AndroidExcludedRefs这个类中final ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults(sdkVersion, manufacturer).build();// 拿到泄漏的分析结果，根据 leakedActivityKey 找到了对象，就说明泄漏了，则返回引用链// 没有找到对象（或者排除了），则返回 com.tencent.matrix.resource.analyzer.model.ActivityLeakResult.noLeakfinal ActivityLeakResult activityLeakResult = new ActivityLeakAnalyzer(leakedActivityKey, excludedRefs).analyze(heapSnapshot); 就这几行代码，我们就拿到了 activity 的引用链（如果真的泄漏了，会在 hprof 里面找到该实例对象）。所有的分析代码，都是在 ActivityLeakAnalyzer 的 analyze 方法中，我们追踪下去，会发现下面这个方法： com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#findPath(com.squareup.haha.perflib.Snapshot, java.util.Collection&lt;com.squareup.haha.perflib.Instance&gt;) ShortestPathFinder 就是专门用来分析引用链的，对象的引用关系与图是一样的，所以里面用到的分析方法就是广度遍历。 广度优先遍历-入队 gc roots我们看一下大致的逻辑，由于是遍历，肯定需要先入队一些元素，这里肯定就是 gcRoots 了： com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#enqueueGcRoots 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void enqueueGcRoots(Snapshot snapshot) &#123; for (RootObj rootObj : snapshot.getGCRoots()) &#123; switch (rootObj.getRootType()) &#123; case JAVA_LOCAL: // Java棧幀中的局部變量 Instance thread = HahaSpy.allocatingThread(rootObj); // 拿到线程名字 String threadName = threadName(thread); // 如果线程在排除范围内，那么就不考虑 // 比如 main 线程，主线程堆栈一直在变化，所以局部变量不太可能长时间保存引用。 // 如果是真的泄漏，一定会有另外一条路径 Exclusion params = excludedRefs.threadNames.get(threadName); if (params == null || !params.alwaysExclude) &#123; enqueue(params, null, rootObj, null, null); &#125; break; case INTERNED_STRING: case DEBUGGER: case INVALID_TYPE: // An object that is unreachable from any other root, but not a root itself. case UNREACHABLE: case UNKNOWN: // An object that is in a queue, waiting for a finalizer to run. case FINALIZING: break; case SYSTEM_CLASS: case VM_INTERNAL: // A local variable in native code. case NATIVE_LOCAL: // A global variable in native code. case NATIVE_STATIC: // An object that was referenced from an active thread block. case THREAD_BLOCK: // Everything that called the wait() or notify() methods, or that is synchronized. case BUSY_MONITOR: case NATIVE_MONITOR: case REFERENCE_CLEANUP: // Input or output parameters in native code. case NATIVE_STACK: case JAVA_STATIC: // 其他情况，直接入队列 enqueue(null, null, rootObj, null, null); break; default: throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType()); &#125; &#125;&#125; 方法虽然有点长，但是还是挺简单的，就是将 gc roots 分为两部分了，对于 java_local 来说，有些字段是需要排除（参见AndroidExcludedRefs，只有 gc root 才这样处理），所以 Exclusion 可能会有值。其他的 gc roots ，Exclusion 都没有值，即不会排除，即使 AndroidExcludedRefs 设置了。 广度优先遍历-处理队列中的元素入队之后，就需要对这个引用对象做处理了，处理这个元素的时候，还会往队列继续添加元素： 1234如果是 RootObj，那么将它引用的对象入队如果是 ClassInstance，遍历该对象字段以及父类字段，然后入队如果是 ClassObj，那么需要将它的静态字段入队如果是 ArrayInstance，就将元素入队 具体的逻辑可以看代码，这里就贴一个 visitClassObj 的逻辑： com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#visitClassObj 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void visitClassObj(ReferenceNode node) &#123; ClassObj classObj = (ClassObj) node.instance; Map&lt;String, Exclusion&gt; ignoredStaticFields = excludedRefs.staticFieldNameByClassName.get(classObj.getClassName()); // 遍历静态字段 for (Map.Entry&lt;Field, Object&gt; entry : classObj.getStaticFieldValues().entrySet()) &#123; Field field = entry.getKey(); // 不是 object（ref），就忽略 if (field.getType() != Type.OBJECT) &#123; continue; &#125; /* 一个Instance的field大致有这些： $staticOverhead 不知道是啥，猜测是静态类的大小？？？ 参考：https://android.googlesource.com/platform/dalvik.git/+/android-4.2.2_r1/vm/hprof/HprofHeap.cpp The static field-name for the synthetic object generated to account for class Static overhead. #define STATIC_OVERHEAD_NAME "$staticOverhead" 04-25 10:20:46.793 D/LeakCanary: * Class com.xiao.memoryleakexample.app.App 04-25 10:20:46.793 D/LeakCanary: | static $staticOverhead = byte[24]@314667009 (0x12c17001) 04-25 10:20:46.793 D/LeakCanary: | static sActivities = java.util.ArrayList@315492800 (0x12ce09c0) 04-25 10:20:46.793 D/LeakCanary: | static serialVersionUID = -920324649544707127 04-25 10:20:46.793 D/LeakCanary: | static $change = null */ String fieldName = field.getName(); if ("$staticOverhead".equals(fieldName)) &#123; continue; &#125; Instance child = (Instance) entry.getValue(); boolean visit = true; // 排除某些静态字段 if (ignoredStaticFields != null) &#123; Exclusion params = ignoredStaticFields.get(fieldName); if (params != null) &#123; visit = false; // 看了下AndroidExcludedRefs，现在的静态字段里面都没有设置alwaysExclude if (!params.alwaysExclude) &#123; enqueue(params, node, child, fieldName, STATIC_FIELD); &#125; &#125; &#125; if (visit) &#123; enqueue(null, node, child, fieldName, STATIC_FIELD); &#125; &#125;&#125; 这里也是让我有点疑惑的位置，为啥要遍历 Class 对象的静态字段，是因为我们写的静态字段是属于 Class 的吗？ 按照上面的规则，遍历完之后，如果有泄漏了，是肯定可以找到泄漏的对象的。当然不要忘记记录已经遍历过的对象。 广度优先遍历-防止重复遍历 com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#findPath(com.squareup.haha.perflib.Snapshot, java.util.Collection&lt;com.squareup.haha.perflib.Instance&gt;) 1234567891011121314// 找到了，跳出循环// Terminationif (targetRefSet.contains(node.instance)) &#123; results.put(node.instance, new Result(node, node.exclusion != null)); targetRefSet.remove(node.instance); if (targetRefSet.isEmpty()) &#123; break; &#125;&#125;// 该节点被 visit 过了，跳过，像图的广度遍历if (checkSeen(node)) &#123; continue;&#125; 找到泄漏的对象之后，还需要找到引用链，这个就比较简单了，由于在入队的过程中，我们给每个对象都封装了一下： com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder#enqueue 1ReferenceNode childNode = new ReferenceNode(exclusion, child, parent, referenceName, referenceType); 里面记录了，child 与 parent。所以我们向上遍历 parent 直到 gc root 既可获取引用链。 com.tencent.matrix.resource.analyzer.utils.ShortestPathFinder.Result#buildReferenceChain 12345678910111213141516public ReferenceChain buildReferenceChain() &#123; List&lt;ReferenceTraceElement&gt; elements = new ArrayList&lt;&gt;(); // We iterate from the leak to the GC root ReferenceNode node = new ReferenceNode(null, null, referenceChainHead, null, null); // 不断的从 泄漏的对象 向上遍历，直到 gcRoots while (node != null) &#123; ReferenceTraceElement element = buildReferenceTraceElement(node); if (element != null) &#123; elements.add(0, element); &#125; node = node.parent; &#125; // 就生成了一个引用链 return new ReferenceChain(elements);&#125; 这样，泄漏对象的引用链就找到了。 假设有两条泄漏路径的话，这里找到的是最短的那一条，因为是广度优先，所以最短的肯定先找完，然后就结束寻找了。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[013-Matrix源码分析：检测Activity内存泄漏]]></title>
    <url>%2F2020%2F08%2F17%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F013-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%A3%80%E6%B5%8BActivity%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Matrix的框架抽象了一个 Plugin 类。我们可以继承这个类来实现我们想做的功能。使用的时候只需要：12TracePlugin tracePlugin = (new TracePlugin(traceConfig));builder.plugin(tracePlugin);matrix-resource-canary-android这个module里面就提供了一个 ResourcePlugin。其主要作用就是检测 APP 中的 activity 泄漏，然后 dump 出 hprof 文件，再裁剪 hprof 文件，最后上传。 检测 activity 泄漏，通常会想到 leakcanary，这个module 也是在 leakcanary 的基础上进行了二次开发，我们看看源码。 核心代码在 ActivityRefWatcher 里面。 startplugin 里面分别调用了 watcher 的 start stop等方法，这些方法属于 plugin 的生命周期，从这里入手逻辑会更清晰。 首先既然要检测泄漏，那么必然要监听 activity 的 destroy 方法，老一套，使用了 ActivityLifecycleCallbacks： 123456789 @Override public void onActivityDestroyed(Activity activity) &#123; // 该方法里面的逻辑也很简单，就是将activity的信息添加到一个集合中 // 后面会开启扫描任务扫描这个集合 pushDestroyedActivityInfo(activity);/* synchronized (mDestroyedActivityInfos) &#123; mDestroyedActivityInfos.notifyAll(); &#125;*/ &#125; 在 LeakCanary 里面，我们判断是否泄漏是延迟了 5S，而且还加上了 gc，再去判断对象是否还存在。 Matrix的判断方式有点不一样，往下看。 RetryableTask在start的时候，也开启了一个task，这个task是运行在 HandlerThread 中，也就是一个线程了。 我们分析看这个 task 做了啥： 12345678// 创建一个 weak 引用，触发 gc，看有没有被回收，触发 gc，系统不一定会叼你final WeakReference&lt;Object&gt; sentinelRef = new WeakReference&lt;&gt;(new Object());triggerGc();if (sentinelRef.get() != null) &#123; // System ignored our gc request, we will retry later. MatrixLog.d(TAG, "system ignore our gc request, wait for next detection."); return Status.RETRY;&#125; 这个 task 做了很多处理，减少泄漏误判情况，比如，这里它创建了一个弱引用，用来判断 gc 是否真的执行了。需要注意一下，这个 task 是有返回值的，Status.RETRY 表示这个 task 会再次执行。 接下来就是扫描上面说的那个集合： 12345678910111213141516171819// activity 已经被回收了if (destroyedActivityInfo.mActivityRef.get() == null) &#123; // The activity was recycled by a gc triggered outside. MatrixLog.v(TAG, "activity with key [%s] was already recycled.", destroyedActivityInfo.mKey); infoIt.remove(); continue;&#125;++destroyedActivityInfo.mDetectedCount;// 泄露检测测试超过一定次数才认为是真的泄露了if (destroyedActivityInfo.mDetectedCount &lt; mMaxRedetectTimes || !mResourcePlugin.getConfig().getDetectDebugger()) &#123; // Although the sentinel tell us the activity should have been recycled, // system may still ignore it, so try again until we reach max retry times. MatrixLog.i(TAG, "activity with key [%s] should be recycled but actually still \n" + "exists in %s times, wait for next detection to confirm.", destroyedActivityInfo.mKey, destroyedActivityInfo.mDetectedCount); continue;&#125; 这里也是减少误判，只有当一个 activity 泄漏到了一定次数后，才会认为它是真的泄漏了。 后面的逻辑，就是根据不同的模式来进行不同的逻辑处理，这个插件支持的模式如下： 123public enum DumpMode &#123; NO_DUMP, AUTO_DUMP, MANUAL_DUMP, SILENCE_DUMP&#125; 这里只介绍 AUTO_DUMP 模式。 1234567891011121314// 如果是 AUTO_DUMP 模式，那么就去自动分析 heap 文件了，与 LeakCanary 类似final File hprofFile = mHeapDumper.dumpHeap();if (hprofFile != null) &#123; markPublished(destroyedActivityInfo.mActivityName); // dump hprof 文件 final HeapDump heapDump = new HeapDump(hprofFile, destroyedActivityInfo.mKey, destroyedActivityInfo.mActivityName); // 处理 dump 出来的 hprof 文件 mHeapDumpHandler.process(heapDump); infoIt.remove();&#125; else &#123; MatrixLog.i(TAG, "heap dump for further analyzing activity with key [%s] was failed, just ignore.", destroyedActivityInfo.mKey); infoIt.remove();&#125; 我们看看它是怎么处理 hprof 文件的，我之前以为这个模式会与 LeakCanary一样会使用 haha 库来分析泄漏引用链，但是看了源码后，发现没有，这里只是做了 hprof 文件的裁剪。 123456public static void shrinkHprofAndReport(Context context, HeapDump heapDump) &#123; final Intent intent = new Intent(context, CanaryWorkerService.class); intent.setAction(ACTION_SHRINK_HPROF); intent.putExtra(EXTRA_PARAM_HEAPDUMP, heapDump); enqueueWork(context, CanaryWorkerService.class, JOB_ID, intent);&#125; 将裁剪任务交给了 JobIntentService。虽然里面有个 MatrixJobIntentService，但是基本上是拷贝的 JobIntentService，在里面做了一些 try catch 操作。 接下来，分析它具体的裁剪代码： 123456789101112is = new FileInputStream(hprofIn);os = new BufferedOutputStream(new FileOutputStream(hprofOut));final HprofReader reader = new HprofReader(new BufferedInputStream(is));// 这里是做了一个访问者模式，所以，核心代码都在 visitor 里面// 不了解 hprof 的结构。里面的代码没法看reader.accept(new HprofInfoCollectVisitor());// Reset.is.getChannel().position(0);reader.accept(new HprofKeptBufferCollectVisitor());// Reset.is.getChannel().position(0);reader.accept(new HprofBufferShrinkVisitor(new HprofWriter(os))); 由于我对 hprof 结构也不熟悉，查了些文档也收获不大，所以就不细说了。 里面的逻辑大致分为几步： 收集 hprof 文件的 bitmap 与 string 对象（索引id） 12345678910111213141516171819202122@Overridepublic void visitStringRecord(ID id, String text, int timestamp, long length) &#123; // 主要是处理了 Bitmap 与 String 这两个类 // Bitmap 有个 mBuffer 字段与 mRecycled 字段 // Bitmap在android sdk &lt; 26之前（&gt; 2.3），存儲像素的byte數組是放在Java層的，26之後是放在native層的。 // String 有个 value 字段 // String在android sdk &lt; 23之前，存儲字符的byte數組是放在Java層的，23之後是放在native層的。 if (mBitmapClassNameStringId == null &amp;&amp; "android.graphics.Bitmap".equals(text)) &#123; mBitmapClassNameStringId = id; &#125; else if (mMBufferFieldNameStringId == null &amp;&amp; "mBuffer".equals(text)) &#123; mMBufferFieldNameStringId = id; &#125; else if (mMRecycledFieldNameStringId == null &amp;&amp; "mRecycled".equals(text)) &#123; mMRecycledFieldNameStringId = id; &#125; else if (mStringClassNameStringId == null &amp;&amp; "java.lang.String".equals(text)) &#123; mStringClassNameStringId = id; &#125; else if (mValueFieldNameStringId == null &amp;&amp; "value".equals(text)) &#123; mValueFieldNameStringId = id; &#125;&#125; 收集 string 与 bitmap 的字段（索引id），重要的是 bitmap 的 mBuffer 的索引 1234567891011121314151617181920212223242526272829303132// 找到Bitmap實例if (mBmpClassId != null &amp;&amp; mBmpClassId.equals(typeId)) &#123; ID bufferId = null; Boolean isRecycled = null; final ByteArrayInputStream bais = new ByteArrayInputStream(instanceData); for (Field field : mBmpClassInstanceFields) &#123; final ID fieldNameStringId = field.nameId; final Type fieldType = Type.getType(field.typeId); if (fieldType == null) &#123; throw new IllegalStateException("visit bmp instance failed, lost type def of typeId: " + field.typeId); &#125; // 找到這個實例mBuffer字段的索引id if (mMBufferFieldNameStringId.equals(fieldNameStringId)) &#123; bufferId = (ID) IOUtil.readValue(bais, fieldType, mIdSize); &#125; // 找到這個實例mRecycled的boolean值(基礎數據類型，沒有引用關係) else if (mMRecycledFieldNameStringId.equals(fieldNameStringId)) &#123; isRecycled = (Boolean) IOUtil.readValue(bais, fieldType, mIdSize); &#125; else if (bufferId == null || isRecycled == null) &#123; IOUtil.skipValue(bais, fieldType, mIdSize); &#125; else &#123; break; &#125; &#125; bais.close(); // 確認Bitmap沒有被回收 final boolean reguardAsNotRecycledBmp = (isRecycled == null || !isRecycled); if (bufferId != null &amp;&amp; reguardAsNotRecycledBmp &amp;&amp; !bufferId.equals(mNullBufferId)) &#123; // 將mBuffer對應的byte數組索引id加入集合 mBmpBufferIds.add(bufferId); &#125;&#125; 去除非 bitmap 的 buffer与重复的bitmap的buffer（String 的除外） 1234if (deduplicatedId != null &amp;&amp; !bufferId.equals(deduplicatedId) &amp;&amp; !bufferId.equals(mNullBufferId)) &#123; // 让重复的 buf 指向同一个 modifyIdInBuffer(instanceData, bufferIdPos, deduplicatedId);&#125; 123456789101112131415// 重複的byte數組索引 重定向之後的 索引idfinal ID deduplicatedID = mBmpBufferIdToDeduplicatedIdMap.get(id);// Discard non-bitmap or duplicated bitmap buffer but keep reference key.// 将非 bitmap 数组也给裁了if (deduplicatedID == null || !id.equals(deduplicatedID)) &#123; // 这里判断了 string // 也就是说，Hprof文件裁剪的過程主要是裁剪了重複Bitmap的byte[]數據，String 是用来判断的 if (!mStringValueIds.contains(id)) &#123; // 这里直接 return，没有调用 super 方法， // 即没有调用 `com.tencent.matrix.resource.hproflib.HprofWriter.HprofHeapDumpWriter.visitHeapDumpPrimitiveArray` 的方法， // 所以不会写入数组信息 return; &#125;&#125;super.visitHeapDumpPrimitiveArray(tag, id, stackId, numElements, typeId, elements); 经过这些步骤之后，hprof 文件就裁剪完成了。 裁剪完成之后，会执行 CanaryResultService，回调到： 12345678910111213141516 private void doReportHprofResult(String resultPath, String activityName) &#123; try &#123; final JSONObject resultJson = new JSONObject();// resultJson = DeviceUtil.getDeviceInfo(resultJson, getApplication()); // resultPath 裁剪后的hprof压缩文件路径 resultJson.put(SharePluginInfo.ISSUE_RESULT_PATH, resultPath); resultJson.put(SharePluginInfo.ISSUE_ACTIVITY_NAME, activityName); Plugin plugin = Matrix.with().getPluginByClass(ResourcePlugin.class); if (plugin != null) &#123; plugin.onDetectIssue(new Issue(resultJson)); &#125; &#125; catch (Throwable thr) &#123; MatrixLog.printErrStackTrace(TAG, thr, "unexpected exception, skip reporting."); &#125; &#125; 最终会调用，plugin 的 onDetectIssue 方法，这里我们可以进行对应的处理。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[012-Matrix源码分析：使用插件来删除ApkChecker查出的无用资源]]></title>
    <url>%2F2020%2F08%2F12%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F012-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E6%9D%A5%E5%88%A0%E9%99%A4ApkChecker%E6%9F%A5%E5%87%BA%E7%9A%84%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[在第 010 篇文章中，我们说过了 ApkChecker 是如何查找 apk 中的无用资源的，那么找到之后，如果你不想手动删除资源，然后重新打包的话，该怎么办？Matrix 也提供了一个插件来做这个事情，也是在 matrix-gradle-plugin 中，我们介绍方法插桩的时候分析过其中一个插件，还有一个没有介绍，就留到现在说，串起来舒服些。 里面有个 RemoveUnusedResourcesTask，它就是用来删除无用资源的。 直接上源码部分： com.tencent.matrix.plugin.task.RemoveUnusedResourcesTask#removeResources 123456// 获取未签名的 apk 路径，这些都是 gradle 的 api，就不介绍了，需要自己看文档String unsignedApkPath = output.outputFile.getAbsolutePath();Log.i(RemoveUnusedResourcesTask.TAG, "original apk file %s", unsignedApkPath);long startTime = System.currentTimeMillis();// 获取 R.txt 文件路径，已经签名信息removeUnusedResources(unsignedApkPath, project.getBuildDir().getAbsolutePath() + "/intermediates/symbols/$&#123;variant.name&#125;/R.txt", variant.variantData.variantConfiguration.signingConfig); 上面就是获取必要的信息。 com.tencent.matrix.plugin.task.RemoveUnusedResourcesTask#removeUnusedResources removeUnusedResources 还是比较长的，只截取部分代码，主要流程有就行，其他的可以自行拉我 fork 库的 note 分支查看。 12345678910File inputFile = new File(originalApk);Set&lt;String&gt; ignoreRes = project.extensions.matrix.removeUnusedResources.ignoreResources;// 加载配置的应该忽略的资源for (String res : ignoreRes) &#123; // 通配符转转正则表达式 // 配置的语法应该支持 * 啥的吧 ignoreResources.add(Util.globToRegexp(res));&#125;// 加载配置的 未使用的资源，这个就是 ApkChecker 分析出来的资源Set&lt;String&gt; unusedResources = project.extensions.matrix.removeUnusedResources.unusedResources; 这里是从我们的 build.gradle 文件中，读取配置信息，配置信息长这样： build.gradle 12345678910111213141516171819apply plugin: 'com.tencent.matrix-plugin'matrix &#123; trace &#123; enable = true baseMethodMapFile = "$&#123;project.projectDir&#125;/matrixTrace/methodMapping.txt" blackListFile = "$&#123;project.projectDir&#125;/matrixTrace/blackMethodList.txt" &#125; removeUnusedResources &#123; enable true variant = "debug" needSign true shrinkArsc true //Notice: You need to modify the value of $apksignerPath on different platform. the value below only suitable for Mac Platform, //if on Windows, you may have to replace apksigner with apksigner.bat. apksignerPath = "$&#123;android.getSdkDirectory().getAbsolutePath()&#125;/build-tools/$&#123;android.getBuildToolsVersion()&#125;/apksigner.bat" unusedResources = project.ext.unusedResourcesSet ignoreResources = ["R.id.*", "R.bool.*"] &#125;&#125; 看上面的removeUnusedResources部分，里面有个 unusedResources，这里就应该填上 ApkChecker 分析出来的资源，我们直到 ApkChecker 分析出来的结果是一个 json 文件，那么应该怎么与它关联起来呢？ 官方的 Sample 里面，有一个用法是这样的。 首先，我们定义一个 ext 属性： 1ext.unusedResourcesSet = new HashSet&lt;String&gt;(); 然后，在打包的时候，插入如下动作： 12345678910111213141516171819202122232425262728293031323334353637applicationVariants.all &#123; variant -&gt; // 只对 debug 包做处理 if (variant.name.equalsIgnoreCase("debug")) &#123; // packageDebug 是一个内置属性 packageDebug.doLast &#123; // 打包完成之后，使用 apkchecker 分析这个包 ProcessBuilder processBuilder = new ProcessBuilder(); println configurations.apkCheckerDependency.getAt(0).getAbsolutePath() processBuilder.command("java", "-jar", configurations.apkCheckerDependency.getAt(0).getAbsolutePath(), "--apk", variant.outputs.first().outputFile.getAbsolutePath(), "--output", project.getProjectDir().getAbsolutePath() + "/unused_resources", "--format", "json", "-unusedResources", "--rTxt", project.getBuildDir().getAbsolutePath() + "/intermediates/symbols/$&#123;variant.name&#125;/R.txt"); Process process = processBuilder.start(); // 等待程序执行完成 process.waitFor(); File outputFile = new File(project.getProjectDir().getAbsolutePath() + "/unused_resources.json"); // 读取 json 文件到 unusedResourcesSet 里面 if (outputFile.exists()) &#123; Gson gson = new Gson(); JsonArray jsonArray = gson.fromJson(outputFile.text, JsonArray.class); for (int i = 0; i &lt; jsonArray.size(); i++) &#123; if (jsonArray.get(i).asJsonObject.get("taskType").asInt == 12) &#123; JsonArray resList = jsonArray.get(i).asJsonObject.get("unused-resources").asJsonArray; for (int j = 0; j &lt; resList.size(); j++) &#123; project.ext.unusedResourcesSet.add(resList.get(j).asString); &#125; println "find unused resources:\n" + unusedResourcesSet break; &#125; &#125; outputFile.delete(); &#125; &#125; &#125;&#125; 这样，我们就拿到了 ApkChecker 里面分析出来的结果，而且还是一步到位。回到源码部分，接着是读取 rTxt 文件： 1readResourceTxtFile(resTxtFile, resourceMap, styleableMap); 就是将 R.txt 中的符号表内存读到map里面。 比如： 12int attr layout_editor_absoluteY 0x7f0200c5 就会变成 &#123;&quot;R.attr.layout_editor_absoluteY&quot;:0x7f0200c5&#125; 12int[] styleable ViewStubCompat &#123; 0x010100d0, 0x010100f2, 0x010100f3 &#125; 会变成 &#123;&quot;R.styleable.ViewStubCompat&quot; : [Pair(&quot;R.styleable.ViewStubCompat&quot;, 0x010100d0)]&#125; 接下来是，拷贝apk里面的文件，针对 res 文件做如下处理： 12345678910111213141516if (zipEntry.name.startsWith("res/")) &#123; // zipEntry.name --&gt; res/mipmap-hdpi-v4/ic_launcher_round.png // resourceName --&gt; R.mipmap.ic_launcher_round.png String resourceName = entryToResouceName(zipEntry.name); if (!Util.isNullOrNil(resourceName)) &#123; // 如果有配置了 unusedResources，这里就不拷贝这个资源到新的 apk 里面了 if (removeResources.containsKey(resourceName)) &#123; Log.i(TAG, "remove unused resource %s", resourceName); continue; &#125; else &#123; addZipEntry(zipOutputStream, zipEntry, zipInputFile); &#125; &#125; else &#123; addZipEntry(zipOutputStream, zipEntry, zipInputFile); &#125;&#125; 因为 unusedResources 里面的资源是需要移除的，所以这里只拷贝不在该集合中的资源。 拷贝文件，针对非 res 文件做如下处理： 123456789101112131415161718192021222324252627282930313233// 为啥 META-INF/ 下的文件也不拷贝// 里面的几个签名文件可以不用管，因为后面会重新签名，但是还有别的文件呢if (needSign &amp;&amp; zipEntry.name.startsWith("META-INF/")) &#123; continue;&#125; else &#123; // shrinkArsc 需要精简 arsc 文件，这是大头 if (shrinkArsc &amp;&amp; zipEntry.name.equalsIgnoreCase("resources.arsc") &amp;&amp; unusedResources.size() &gt; 0) &#123; File srcArscFile = new File(inputFile.getParentFile().getAbsolutePath() + "/resources.arsc"); File destArscFile = new File(inputFile.getParentFile().getAbsolutePath() + "/resources_shrinked.arsc"); if (srcArscFile.exists()) &#123; srcArscFile.delete(); srcArscFile.createNewFile(); &#125; // 将 zip 文件中的 .asrs 文件解压出来 unzipEntry(zipInputFile, zipEntry, srcArscFile); // 分析 .arsc 文件，需要一张图配合看 // https://user-gold-cdn.xitu.io/2019/5/24/16ae9b85b2f4e918?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 // 或者使用 010 打开看看（推荐） ArscReader reader = new ArscReader(srcArscFile.getAbsolutePath()); ResTable resTable = reader.readResourceTable(); for (String resName : removeResources.keySet()) &#123; ArscUtil.removeResource(resTable, removeResources.get(resName), resName); &#125; // 重新生成 .arsc 文件 ArscWriter writer = new ArscWriter(destArscFile.getAbsolutePath()); writer.writeResTable(resTable); Log.i(TAG, "shrink resources.arsc size %f KB", (srcArscFile.length() - destArscFile.length()) / 1024.0); addZipEntry(zipOutputStream, zipEntry, destArscFile); &#125; else &#123; addZipEntry(zipOutputStream, zipEntry, zipInputFile); &#125;&#125; 里面主要是针对 arsc 文件做了处理，其他的文件原封不动的拷贝就好了。对于 arsc 文件结构，番外篇已经介绍了一部分，这里就只说说它处理了什么吧。 使用 010 Editor 打开 arsc 文件，会发现如下结构： 123456TablePackageType ... --ResTable_typeSpec --ResTable_type --ResTable_entry --Res_value 当我们从apk中删除了一些资源后，比如，我们删除了一个 drawable 资源（因为 values 下面的资源都在一个文件中，比如 string.xml 等，所以拷贝时无法删除其中的某一项），那么它的 ResTable_type 这个结构就需要改一下，需要将这个资源对应的 ResTable_entry 与 Res_value 删除才行。这里还要考虑文件的格式，删除还是挺麻烦的，具体可以看代码。 需要注意的时，删除的时候，需要保证原来的索引不变。比如，有两个 String，A 与 B，假设他们生成的 id 为 （A）0x01 与 （B）0x02，A是个无用资源，当你删除之后，仍然要保证 arsc 文件中，B的id是0X02，而 id 是与该 entry 在数组中的index有关。 文件都拷贝完成之后，就需要进行签名： 123456789101112// 调用 apksigner 程序，进行签名Log.i(TAG, "resign apk...");ProcessBuilder processBuilder = new ProcessBuilder();processBuilder.command(apksigner, "sign", "-v", "--ks", signingConfig.storeFile.getAbsolutePath(), "--ks-pass", "pass:" + signingConfig.storePassword, "--key-pass", "pass:" + signingConfig.keyPassword, "--ks-key-alias", signingConfig.keyAlias, outputFile.getAbsolutePath());//Log.i(TAG, "%s", processBuilder.command());Process process = processBuilder.start();process.waitFor(); 直接调用了 apksigner 来做这件事。 然后是移除 styleable，上面的逻辑只处理了非 styleable 资源： 123456789101112131415Iterator&lt;String&gt; styleableItera = styleableMap.keySet().iterator();while (styleableItera.hasNext()) &#123; String styleable = styleableItera.next(); Pair&lt;String, Integer&gt;[] attrs = styleableMap.get(styleable); int i = 0; for (i = 0; i &lt; attrs.length; i++) &#123; if (!removeResources.containsValue(attrs[i].right)) &#123; break &#125; &#125; if (attrs.length &gt; 0 &amp;&amp; i == attrs.length) &#123; Log.i(TAG, "removed styleable " + styleable); styleableItera.remove(); &#125;&#125; 最后，压缩 R.txt，因为删除了些资源： 1shrinkResourceTxtFile(newResTxtFile, resourceMap, styleableMap); 这样，整个流程就完毕了。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Matrix源码分析番外篇：Dex文件结构]]></title>
    <url>%2F2020%2F08%2F12%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2FMatrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9ADex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[构造DEX文件首先，我们编写一个简单的程序，如下：1234567891011121314151617public class HelloWorld &#123; int a = 0; static String b = "HelloDalvik"; public int getNumber(int i, int j) &#123; int e = 3; return e + i + j; &#125; public static void main(String[] args) &#123; int c = 1; int d = 2; HelloWorld helloWorld = new HelloWorld(); String sayNumber = String.valueOf(helloWorld.getNumber(c, d)); System.out.println("HelloDex!" + sayNumber); &#125; &#125; 使用命令行编译成 dex 文件。不想使用命令的直接拖到 Android studio 里面，打个apk也行，不过后面的 dex 文件内容分析就对不上了。 拿到 dex 文件后，我们使用 010 editor 打开它，可以看到如下内容： 下面的表格就是 dex 的大致结构。点开各个entry，里面又有很多东西，我们慢慢道来，其实这个与 class 文件结构很像，如果你读过 《深入理解Java虚拟机》就很容易上手。 dex_header magic[8]；它代表dex中的文件标识，一般被称为魔数。是用来识别dex这种文件的，它可以判断当前的dex文件是否有效，可以看到它用了8个1字节的无符号数来表示，我们在010Editor中可以看到也就是“64 65 78 0A 30 33 35 00 ”这8个字节，这些字节都是用16进制表示的，用16进制表示的话，两个数代表一个字节（一个字节等于8位，一个16进制的数能表示4位）。这8个字节用ASCII码表转化一下可以转化为：dex 035。 checksum; 它是dex文件的校验和，通过它可以判断dex文件是否被损坏或者被篡改。它占用4个字节，也就是“5D 9D F9 59”。这里提醒一下，在010Editor中，其实可以分别识别我们在DexHeader中看到的这些字段的，你可以点一下这里： 你可以看到这个header列表展开了，其实我们分析下来就和它这个结构是一样的，你可以先看下，我们现在分析到了checksum中了，你可以看到后面对应的值是“59 F9 9D 5D”。咦？这好像和上面的字节不是一一对应的啊。对的，你可以发现它是反着写的。这是由于dex文件中采用的是小字节序的编码方式，也就是低位上存储的就是低字节内容，所以它们应该要反一下。 signature[kSHA1DigestLen]，signature字段用于检验dex文件，其实就是把整个dex文件用SHA-1签名得到的一个值。这里占用20个字节，你可以自己点010Editor看一看。 fileSize;表示整个文件的大小，占用4个字节。 headerSize;表示DexHeader头结构的大小，占用4个字节。这里可以看到它一共占用了112个字节，112对应的16进制数为70h，你可以选中头文件看看010Editor是不是真的占用了这么多： endianTag;代表 字节序标记，用于指定dex运行环境的cpu，预设值为0x12345678，对应在101Editor中为“78 56 34 12”（小字节序）。 接下来两个分别是linkSize;和u4 linkOff;这两个字段，它们分别指定了链接段的大小和文件偏移，通常情况下它们都为0。linkSize为0的话表示静态链接。 再下来就是mapOff字段了，它指定了DexMapList的文件偏移，这里我们先不过多介绍它，你可以看一下它的值为“14 04 00 00”，它其实对应的16进制数就是414h（别忘了小字节序），我们可以在414h的位置看一下它在哪里： ​ 其实就是dex文件最后一部分内容。关于这部分内容里面是什么，我们先不说，继续往下看。 stringIdsSize 和 stringIdsOff字段：这两个字段指定了dex文件中所有用到的字符串的个数和位置偏移，我们先看stringIdsSize，它的值为：“1C 00 00 00”，16进制的1C也就是十进制的28，也就是说我们这个dex文件中一共有28个字符串，然后stringIdsOff为：“70 00 00 00”，代表字符串的偏移位置为70h。 typeIdsSize和typeIdsOff。它们代表什么呢？它们代表的是类的类型的数量和位置偏移，也是都占4个字节。 这下到了protoIdsSize和protoIdsOff了，它们代表的是dex文件中方法原型的个数和位置偏移。 fieldIdsSize和fieldIdsOff字段。这两个字段指向的是dex文件中字段名的信息。 methodIdsSize和methodIdsOff字段。这俩字段指明了方法所在的类、方法的声明以及方法名。 classDefsSize和classDefsOff字段。这两个字段指明的是dex文件中类的定义的相关信息。 下面，详细的解释一下上面 9-14的内容。 dex_string_ids这个里面描述的是字符串。 我们就先介绍一下DexStringId这个结构，图中从70h开始， 所有被选中的都是DexStringId这种数据结构的内容，DexStringId代表的是字符串的位置偏移，每个DexStringId占用4个字节，也就是说它里面存的还不是真正的字符串，它们只是存储了真正字符串的偏移位置（偏移位置从0开始算起）。 下面我们先分析几个看看： 取第一个“B2 02 00 00”，它代表的位置偏移是2B2h，我们先找到这个位置： 可以发现我一共选中了10个字节，这10个字节就表示了一个字符串。下面我们看一下dex文件中的字符串是如何表示的。dex中的字符串采用了一种叫做MUTF-8这样的编码，它是经过传统的UTF-8编码修改的。在MTUF-8中，它的头部存放的是由uleb128编码的字符的个数。 也就是说在“08 3C 63 6C 69 6E 69 74 3E 00”这些字节中，第一个08指定的是后面需要用到的编码的个数，也就是8个，即“ 3C 63 6C 69 6E 69 74 3E”这8个，但是我们为什么一共选中了10个字节呢，因为最后一个空字符“0”表示的是字符串的结尾，字符个数没有把它算进去。下面我们来看看“ 3C 63 6C 69 6E 69 74 3E”这8个字符代表了什么字符串： （要说明的一点是，这里凑巧这几个uleb128编码的字符都用了1个字节，所以我们可以这样进行查询，uleb128编码标准用的是1~5个字节， 这里只是恰好都是一个字节）。也就是说上面的70h开始的第一个DexStringId指向的其实是字符串“”（但是貌似我们的代码中没有用到这个字符串啊，先不用管，我们接着分析）。再看到这里： 刚刚我们分析到“B2 02 00 00”所指向的真实字符串了，下面我们接着再分析一个，我们直接分析第三个，不分析第二个了。第三个为“C4 02 00 00”，对应的位置也就是2C4h，我们找到它： 看这里，这就是2C4h的位置了。我们首先看第一个字符，它的值为0Bh，也就是十进制的11，也就是说接下来的11个字符代表了它的字符串，我们依旧是查看接下来11个字符代表的是什么，经过查询整理： 上面就是“HelloDalvik”这个字符串，可以看看我们的代码，我们确实用了一个这样的字符串，bingo。 下面剩下的字符串就不分析了。其实直接使用 010 editor 会更直观一些。 我们这半天分析的stringIdsSize 和 stringIdsOff字段指向的位置就是上面那个箭头指向的位置，它们里面存储的是真实字符串的位置偏移，它们都存储在data区域。（先透露一下，后面我们要分析的几个也和stringIdsSize 与stringIdsOff字段类似，它们里面存储的基本都是位置偏移，并不是真正的数据，真正的数据都在data区域） dex_type_ids这个里面描述的是类型（基本类型，类类型）。 typeIdsSize的值为9h，也就是我们dex文件中用到的类的类型一共有9个，位置偏移在E0h位置，下面我们找到这个位置 这里我们又得介绍一种数据结构了，因为这里的数据也是一种数据结构的数据组成的。 123struct DexTypeId&#123; u4 descriptorIdx; /*指向DexStringId列表的索引*/&#125; 它里面只有一个数据descriptorIdx，它的值的内容是DexStringId列表的索引。 我们直接去 010 中的 dex_string_ids 中展开这个索引，就可以知道这个字符串是啥了。 先看第一个“05 00 00 00”，也就是05h，即十进位的5。然后我们在上面所有整理出的字符串看看5索引的是什么？翻上去可以看到是“I”。 dex_proto_ids这个里面描述的是方法签名。 protoIdsSize的值为十进制的7，说明有7个方法原型，然后位置偏移为104h，我们找到这个位置 下面又有新的数据结构了。 12345struct DexProtoId&#123; u4 shortyIdx; /*指向DexStringId列表的索引*/ u4 returnTypeIdx; /*指向DexTypeId列表的索引*/ u4 parametersOff; /*指向DexTypeList的位置偏移*/&#125; 这个数据结构由三个变量组成。 第一个shortyIdx它指向的是我们上面分析的DexStringId列表的索引，代表的是方法声明字符串。 第二个returnTypeIdx它指向的是 我们上边分析的DexTypeId列表的索引，代表的是方法返回类型字符串。 第三个parametersOff指向的是DexTypeList的位置索引，这又是一个新的数据结构了，先说一下这里面 存储的是方法的参数列表。可以看到这三个参数，有方法声明字符串，有返回类型，有方法的参数列表，这基本上就确定了我们一个方法的大体内容。 我们接着看看DexTypeList这个数据结构，看看参数列表是如何存储的。 1234struct DexTypeList&#123; u4 size; /*DexTypeItem的个数*/ DexTypeItem list[1]; /*DexTypeItem结构*/&#125; 它有两个参数，其中第一个size说的是DexTypeItem的个数，那DexTypeItem又是啥咧？它又是一种数据结构。我们继续看看 123struct DexTypeItem&#123; u2 typeIdx; /*指向DexTypeId列表的索引*/&#125; 就是一个指向DexTypeId列表的索引，也就是代表参数列表中某一个具体的参数的位置。 下面我们具体地分析一个类吧。 一个DexProtoId一共占用12个字节。所以，我们取前12个字节进行分析。“06 00 00 00，00 00 00 00，94 02 00 00”，这就是那12个字节了。 首先“06 00 00 00”代表的是shortyIdx，它的值是指向DexStringId列表的索引，我们找到DexStringId列表中第6个对应的值，也就是III，说明这个方法中声明字符串为三个int。 接着，“00 00 00 00”代表的是returnTypeIdx，它的值指向的是DexTypeId列表的索引，我们找到对应的值，也就是I，说明这个方法的返回值是int类型的。 最后，我们看“94 02 00 00”，它代表的是DexTypeList的位置偏移，它的值为294h，我们找到这个位置： 这里是DexTypeList结构，首先看前4个字节，代表的是DexTypeItem的个数，“02 00 00 00 ”也就是2，说明接下来有2个DexTypeItem的数据，每个DexTypeItem占用2个字节，也就是两个都是“00 00”，它们的值是DexTypeId列表的索引，我们去找一下，发现0对应的是I，也就是说它的两个参数都是int型的。因此这个方法的声明我们也就确定了，也就是int(int,int)。 dex_field_ids fieldIdsSize为3h，说明共有3个字段。fieldIdsOff为158h，说明偏移为158h，我们继续看到158h这里： 接下来的数据结构是DexFieldId，我们看下 12345struct DexFieldId&#123; u2 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u2 typeIdx; /*字段类型，指向DexTypeId列表的索引*/ u4 nameIdx; /*字段名，指向DexStringId列表的索引*/&#125; 我们依旧是分析一下第一个字段，“01 00 ，00 00，13 00 00 00”，类的类型为DexTypeId列表的索引1，也就是HelloWorld。 字段的类型为DexTypeId列表中的索引0，也就是int。 字段名为DexStringId列表中的索引13h，即十进制的19，找一下，是a，也就是说我们这个字段就确认了，即int HelloWorld.a。这不就是我们在HelloWorld.java文件里定义的变量a嘛。 dex_method_ids methodIdsSize，为Ah，即十进制的10，说明共有10个方法。methodIdsOff，为170h，说明它们的位置偏移在170h。我们看到这里 请看DexMethodId 12345struct DexMethodId&#123; u2 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u2 protoIdx; /*声明类型，指向DexProtoId列表的索引*/ u4 nameIdx; /*方法名，指向DexStringId列表的索引*/&#125; 我们直接分析一下第一个数据，“01 00, 04 00， 00 00 00 00”， 首先，classIdx，为1，对应DexTypeId列表的索引1，也就是HelloWorld； 其次，protoIdx，为4，对应DexProtoId列表中的索引4，也就是void()； 最后，nameIdx，为0，对应DexStringId列表中的索引0，也就是。 因此，第一个数据就出来了，即void HelloWorld.&lt;clinit&gt;() 。 dex_class_defs classDefsSize字段，为1，也就是只有一个类定义，classDefsOff，为1C0h，我们找到它的偏移位置。 接下来的数据结构是DexClassDef，请看 12345678910struct DexClassDef&#123; u4 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u4 accessFlags; /*访问标志*/ u4 superclassIdx; /*父类类型，指向DexTypeId列表的索引*/ u4 interfacesOff; /*接口，指向DexTypeList的偏移*/ u4 sourceFileIdx; /*源文件名，指向DexStringId列表的索引*/ u4 annotationsOff; /*注解，指向DexAnnotationsDirectoryItem结构*/ u4 classDataOff; /*指向DexClassData结构的偏移*/ u4 staticValuesOff; /*指向DexEncodedArray结构的偏移*/&#125; 我们直接根据结构开始分析吧。 classIdx为1，对应DexTypeId列表的索引1，找到是HelloWorld，确实是我们源程序中的类的类型。 accessFlags为1，它是类的访问标志，对应的值是一个以ACC_开头的枚举值，1对应的是 ACC_PUBLIC，你可以在010Editor中看一下，说明我们的类是public的。 superclassIdx的值为3，找到DexTypeId列表中的索引3，对应的是java.lang.object，说明我们的类的父类类型是Object的。 interfaceOff指向的是DexTypeList结构，我们这里是0说明没有接口。如果有接口的话直接对应到DexTypeList，就和之前我们分析的一样了，这里不多解释，有兴趣的可以写一个有接口的类验证下。 再下来sourceFileIdx指向的是DexStringId列表的索引，代表源文件名，我们这里位4，找一下对应到了字符串”HelloWorld.java”，说明我们类程序的源文件名为HelloWorld.java。 annotationsOff字段指向注解目录接口，根据类型不同会有注解类、注解方法、注解字段与注解参数，我们这里的值为0，说明没有注解，这里也不过多解释，有兴趣可以自己试试。 接下来是classDataOff了，它指向的是DexClassData结构的位置偏移，DexClassData中存储的是类的数据部分，我们开始详细分析一下它，首先，还是先找到偏移位置3F8h： 我们看看DexClassData数据结构： 1234567struct DexClassData&#123; DexClassDataHeader header; /*指定字段与方法的个数*/ DexField* staticFields; /*静态字段，DexField结构*/ DexField* instanceFields； /*实例字段，DexField结构*/ DexMethod* directMethods; /*直接方法，DexMethod结构*/ DexMethod* virtualMethods; /*虚方法，DexMethod结构*/&#125; 12345678910111213141516struct DexClassDataHeader&#123; u4 staticFieldsSize; /*静态字段个数*/ u4 instanceFieldsSize; /*实例字段个数*/ u4 directMethodsSize; /*直接方法个数*/ u4 virtualMethodsSize; /*虚方法个数*/&#125; struct DexField&#123; u4 fieldIdx; /*指向DexFieldId的索引*/ u4 accessFlags; /*访问标志*/&#125; struct DexMethod&#123; u4 methodIdx; /*指向DexMethodId的索引*/ u4 accessFlags; /*访问标志*/ u4 codeOff; /*指向DexCode结构的偏移*/ 注意，在这些结构中的u4不是指的占用4个字节，而是指它们是uleb128类型（占用1~5个字节）的数据。 这里面就不具体分析了，可以自己打开 010 就知道里面的字段是什么意思了。就是描述这个类的静态字段，实例字段，各种方法。字段的访问表示等等。在方法的描述中，有个 dexCode，里面描述的方法的指令集。 参考文档一篇文章带你搞懂DEX文件的结构]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[004-Flutter的Widget渲染]]></title>
    <url>%2F2020%2F08%2F11%2Fblog_bak%2FBlog%2Fflutter%2F004-Flutter%E7%9A%84Widget%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[事情要从Flutter-你还在滥用StatefulWidget吗 说起。看了这篇文章之后，我还是以为很有道理的，直到我看了 fish-redux 的大致结构，发现根本就没必要。而且这样做会带来很多麻烦，比如：组件的抽取，又要考虑不能多次 build，又要考虑复用，这两者几乎是冲突的，写出来的代码很难看。但是话说回来，能减少 build 的控件当然最好了，这样创建销毁的对象也少些。 fish-redux 里面将 page 作为一个整体来 build，每次 state 发生变化的时候，重新 build 一次就好了。即使只有一个 text 发生了变化，也要重新 build 一次。虽然看起来，build 了很多无用的东西，实际上渲染的时候，只渲染了变化的 text 部分。 为啥呢？这就要从 3 棵树说起。 Widget tree第一个是 Widget 树，它的里面没有渲染相关的的东西，只负责描述 Widget 的大小与位置。我们把它当作普通类理解就好了。 Element tree第二个是 Element 树，Element 是啥呢？每个 Widget 都有 build 方法（之类会在这个基础上再改变一下）： 12// 这个是 StatefulWidget 的 build 方法Widget build(BuildContext context); 这个 context 实际上就是一个 Element。 Element 可以理解为一个中间人，每个 Widget 都有一个对应的 Element 对象。我们对 Widget 树的更改会反应到 Element 树上。但是 Element 有一个 diff 机制，就是说它会复用之前的 Element 对象。 demo1比如，屏幕上有3个 widget： 12345678910111213141516171819@overrideWidget build(BuildContext context) &#123; if (map.containsKey(widget.name)) &#123; print('isSame = $&#123;context == map[widget.name]&#125;, time = $&#123;DateTime.now()&#125;'); print('old context = $&#123;map[widget.name].toString()&#125;, time = $&#123;DateTime.now()&#125;'); print('context = $&#123;context.toString()&#125;, time = $&#123;DateTime.now()&#125;'); &#125; map[widget.name] = context; return Container( child: Text( widget.name, style: TextStyle(color: Colors.white, fontSize: 30), ), height: 80, color: randColor, );&#125; 我们，每次 build 的时候，会生成新的 widget 对象，是肯定的，但是 context 却是复用的。打印下 log： 123456789I/flutter ( 8694): isSame = true, time = 2020-08-06 23:08:50.033290I/flutter ( 8694): old context = ListItemFul-[&lt;&apos;aaaa&apos;&gt;](dirty, state: _ListItemFulState#58614), time = 2020-08-06 23:08:50.033968I/flutter ( 8694): context = ListItemFul-[&lt;&apos;aaaa&apos;&gt;](dirty, state: _ListItemFulState#58614), time = 2020-08-06 23:08:50.034196I/flutter ( 8694): isSame = true, time = 2020-08-06 23:08:50.035217I/flutter ( 8694): old context = ListItemFul-[&lt;&apos;bbbb&apos;&gt;](dirty, state: _ListItemFulState#7d32b), time = 2020-08-06 23:08:50.035636I/flutter ( 8694): context = ListItemFul-[&lt;&apos;bbbb&apos;&gt;](dirty, state: _ListItemFulState#7d32b), time = 2020-08-06 23:08:50.035891I/flutter ( 8694): isSame = true, time = 2020-08-06 23:08:50.037472I/flutter ( 8694): old context = ListItemFul-[&lt;&apos;cccc&apos;&gt;](dirty, state: _ListItemFulState#cd85b), time = 2020-08-06 23:08:50.037819I/flutter ( 8694): context = ListItemFul-[&lt;&apos;cccc&apos;&gt;](dirty, state: _ListItemFulState#cd85b), time = 2020-08-06 23:08:50.038083 无论，每次 build 多少次，发现都是复用的同一个 element 对象。这是因为它满足了复用规则： 1234static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;&#125; demo2我们接下来，改一下这个例子： 1234567891011121314151617181920212223242526 final List&lt;String&gt; names = ["aaaa", "bbbb", "cccc"]; Widget buildPage() &#123; return Scaffold( appBar: AppBar( title: Text("列表测试"), ), body: ListView( children: names.map((item) &#123; return ListItemFul( item,// key: ValueKey(item), ); &#125;).toList(), ), floatingActionButton: FloatingActionButton( child: Icon(Icons.delete), onPressed: () &#123; setState(() &#123; names.removeAt(0); names.add('aaaa'); &#125;); &#125;, ), ); &#125; 我们加了一个 button，点击这个 button，将第一个与第3个 widget 换个位置。看看打印的是什么信息： 123456789I/flutter ( 8694): isSame = false, time = 2020-08-06 23:45:17.885164I/flutter ( 8694): old context = ListItemFul(state: _ListItemFulState#93a82), time = 2020-08-06 23:45:17.886470I/flutter ( 8694): context = ListItemFul(dirty, state: _ListItemFulState#65e5d), time = 2020-08-06 23:45:17.886706I/flutter ( 8694): isSame = false, time = 2020-08-06 23:45:17.888019I/flutter ( 8694): old context = ListItemFul(state: _ListItemFulState#5f8fd), time = 2020-08-06 23:45:17.888226I/flutter ( 8694): context = ListItemFul(dirty, state: _ListItemFulState#93a82), time = 2020-08-06 23:45:17.888521I/flutter ( 8694): isSame = false, time = 2020-08-06 23:45:17.889172I/flutter ( 8694): old context = ListItemFul(state: _ListItemFulState#65e5d), time = 2020-08-06 23:45:17.889322I/flutter ( 8694): context = ListItemFul(dirty, state: _ListItemFulState#5f8fd), time = 2020-08-06 23:45:17.889634 我们发现，element 不一样了，但是仔细看一下，会发现其实是，widget 1 复用了 widget 3 的 element，widget 2 复用了 widget 1 的 element，widget 3 复用了 widget 2 的 element。 这是因为，我们没传递 key，所以只要 runtimeType 一样，就可以复用。大致过程如下： 12345build 执行，需要先 build &apos;bbbb&apos; 控件发现位置上有一个 &apos;aaaa&apos; 的 element判断该 element 是否可用，发现可用，则直接使用。重复上面的过程 demo3再对该例子做点改动，将 key: ValueKey(item), 这行代码的注释去掉，再点击 button，打印结果如下： 123456789I/flutter ( 8694): isSame = true, time = 2020-08-07 01:53:35.103764I/flutter ( 8694): old context = ListItemFul-[&lt;'aaaa'&gt;](dirty, state: _ListItemFulState#28e81), time = 2020-08-07 01:53:35.104217I/flutter ( 8694): context = ListItemFul-[&lt;'aaaa'&gt;](dirty, state: _ListItemFulState#28e81), time = 2020-08-07 01:53:35.104387I/flutter ( 8694): isSame = true, time = 2020-08-07 01:53:35.104683I/flutter ( 8694): old context = ListItemFul-[&lt;'bbbb'&gt;](dirty, state: _ListItemFulState#6e7c6), time = 2020-08-07 01:53:35.104839I/flutter ( 8694): context = ListItemFul-[&lt;'bbbb'&gt;](dirty, state: _ListItemFulState#6e7c6), time = 2020-08-07 01:53:35.105229I/flutter ( 8694): isSame = true, time = 2020-08-07 01:53:35.106242I/flutter ( 8694): old context = ListItemFul-[&lt;'cccc'&gt;](dirty, state: _ListItemFulState#ab41f), time = 2020-08-07 01:53:35.106712I/flutter ( 8694): context = ListItemFul-[&lt;'cccc'&gt;](dirty, state: _ListItemFulState#ab41f), time = 2020-08-07 01:53:35.106977 发现，每个 widget 都复用了自己原来的 element。这是为什么呢？是因为 ValueKey 是一个 LocalKey。它在源码里面有这样的一个注释： 1Keys must be unique amongst the [Element]s with the same parent. 这句话就是说一个 parent 的所有 child 的 element 的 key 应该是唯一的，这样的话，方便复用。它会在 RenderObjectElement.updateChildren 里进行 diff 算法，计算 old 与 new 的可复用关系。因为，我们只是交换位置，所以 element 完全可以复用，设置一个 LocalKey就可以做到 parent 级别的复用。 RenderObject它才是真正负责 widget 渲染的树。每当 Widget 重新 build 后，element 会计算出哪些可复用的，拿到可复用的之后，就会开始更新 renderObject： 1void updateRenderObject(BuildContext context, covariant RenderObject renderObject) &#123; &#125; 我们拿 RichText 举例： 12345678910111213141516@overridevoid updateRenderObject(BuildContext context, RenderParagraph renderObject) &#123; assert(textDirection != null || debugCheckHasDirectionality(context)); renderObject ..text = text ..textAlign = textAlign ..textDirection = textDirection ?? Directionality.of(context) ..softWrap = softWrap ..overflow = overflow ..textScaleFactor = textScaleFactor ..maxLines = maxLines ..strutStyle = strutStyle ..textWidthBasis = textWidthBasis ..textHeightBehavior = textHeightBehavior ..locale = locale ?? Localizations.localeOf(context, nullOk: true);&#125; 可以看到，它就是重新设置了一下属性值而已。但是 RenderObject 在下一帧绘制的时候，就绘制的是改变之后的值。需要注意的是 RenderObject 数也正是重新渲染了变化的节点。 参考文档https://www.youtube.com/watch?v=996ZgFRENMs]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0007-Flutter的主题]]></title>
    <url>%2F2020%2F08%2F10%2Fblog_bak%2FBlog%2Fflutter%2F007-Flutter%E7%9A%84%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Theme分为：全局Theme和局部Theme主题有两个作用： 设置了主题之后，某些Widget会自动使用主题的样式（比如AppBar的颜色） 将某些样式放到主题中统一管理，在应用程序的其它地方直接引用 全局Theme全局Theme会影响整个app的颜色和字体样式。使用起来非常简单，只需要向MaterialApp构造器传入 ThemeData 即可。 如果没有设置Theme，Flutter将会使用预设的样式。 当然，我们可以对它进行定制。 12345678910111213141516171819202122232425262728293031323334353637class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData( // 1.亮度: light-dark brightness: Brightness.light, // 2.primarySwatch: primaryColor/accentColor的结合体 primarySwatch: Colors.red, // 3.主要颜色: 导航/底部TabBar primaryColor: Colors.pink, // 4.次要颜色: FloatingActionButton/按钮颜色 accentColor: Colors.orange, // 5.卡片主题 cardTheme: CardTheme( color: Colors.greenAccent, elevation: 10, shape: Border.all(width: 3, color: Colors.red), margin: EdgeInsets.all(10) ), // 6.按钮主题 buttonTheme: ButtonThemeData( minWidth: 0, height: 25 ), // 7.文本主题 textTheme: TextTheme( title: TextStyle(fontSize: 30, color: Colors.blue), display1: TextStyle(fontSize: 10), ) ), home: HYHomePage(), ); &#125;&#125; 局部Theme如果某个具体的Widget不希望直接使用全局的Theme，而希望自己来定义，应该如何做呢？ 非常简单，只需要在Widget的父节点包裹一下Theme即可 创建另外一个新的页面，页面中使用新的主题： 在新的页面的Scaffold外，包裹了一个Theme，并且设置data为一个新的ThemeData 12345678910class HYSecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Theme( data: ThemeData(), child: Scaffold( ), ); &#125;&#125; 但是，我们很多时候并不是想完全使用一个新的主题，而且在之前的主题基础之上进行修改： 123456789101112class HYSecondPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Theme( data: Theme.of(context).copyWith( primaryColor: Colors.greenAccent ), child: Scaffold( ), ); &#125;&#125; darkTheme目前很多应用程序都需要适配暗黑模式，Flutter中如何做到暗黑模式的适配呢？ 事实上，MaterialApp中有theme和dartTheme两个参数： 按照下面的写法，我们已经默认适配了暗黑主题 123456789101112class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;Flutter Demo&apos;, theme: ThemeData.light(), darkTheme: ThemeData.dark(), home: HYHomePage(), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[006-Flutter的状态管理]]></title>
    <url>%2F2020%2F08%2F10%2Fblog_bak%2FBlog%2Fflutter%2F006-Flutter%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[InheritedWidget可以实现跨组件数据的传递。需要 Widget 之间有同一个 Parent。12345678910111213141516class HYDataWidget extends InheritedWidget &#123; finalint counter; HYDataWidget(&#123;this.counter, Widget child&#125;): super(child: child); // 该方法通过context开始去查找祖先的HYDataWidget static HYDataWidget of(BuildContext context) &#123; return context.dependOnInheritedWidgetOfExactType(); &#125; // 对比新旧HYDataWidget，是否需要对更新相关依赖的Widget @override bool updateShouldNotify(HYDataWidget oldWidget) &#123; returnthis.counter != oldWidget.counter; &#125;&#125; ProviderProvider是目前官方推荐的全局状态管理工具。 在使用Provider的时候，我们主要关心三个概念： ChangeNotifier：真正数据（状态）存放的地方 ChangeNotifierProvider：Widget树中提供数据（状态）的地方，会在其中创建对应的ChangeNotifier Consumer：Widget树中需要使用数据（状态）的地方 第一步：创建自己的ChangeNotifier 12345678910class CounterProvider extends ChangeNotifier &#123; int _counter = 100; int get counter &#123; return _counter; &#125; set counter(int value) &#123; _counter = value; notifyListeners(); &#125;&#125; 第二步：在Widget Tree中插入ChangeNotifierProvider 我们需要在Widget Tree中插入ChangeNotifierProvider，以便Consumer可以获取到数据： 123456void main() &#123; runApp(ChangeNotifierProvider( create: (context) =&gt; CounterProvider(), child: MyApp(), ));&#125; 第三步：在接收处处理事件 1234567body: Center( child: Consumer&lt;CounterProvider&gt;( builder: (ctx, counterPro, child) &#123; return Text("当前计数:$&#123;counterPro.counter&#125;", style: TextStyle(fontSize: 20, color: Colors.red),); &#125; ),), 第四步：在按钮处，发送事件 123456789101112131415floatingActionButton: Selector&lt;CounterProvider, CounterProvider&gt;( selector: (ctx, provider) =&gt; provider.count, shouldRebuild: (pre, next) =&gt; false, builder: (ctx, counterPro, child) &#123; print("floatingActionButton展示的位置builder被调用"); return FloatingActionButton( child: child, onPressed: () &#123; // 调用 set counter 方法，发送通知 counterPro.counter += 1; &#125;, ); &#125;, child: Icon(Icons.add),), MultiProvider在开发中，我们需要共享的数据肯定不止一个，并且数据之间我们需要组织到一起，所以一个Provider必然是不够的。 1234567runApp(MultiProvider( providers: [ ChangeNotifierProvider(create: (ctx) =&gt; CounterProvider()), ChangeNotifierProvider(create: (ctx) =&gt; UserProvider()), ], child: MyApp(),)); Selector 与 ConsumerSelector控制的粒度比Consumer更细，Consumer是监听一个Provider中所有数据的变化，Selector则是监听某一个/多个值的变化。 Selector相当于Cosumer，但是可以在某些值不变的情况下，防止rebuild。 selector方法：Selector使用 Provider.of获取共享的数据。数据作为selector方法的入参A，执行selector方法，返回build需要的数据S，返回的数据要尽可能少，能满足build就好。 shouldRebuild：默认判断前后两次S相等性，来决定是否rebuild。并且也提供了自定义的shouldRebuild方法来判断,参数是前后两次S。 S：selector的数据，必须是immutable(不可变)的.因此 selector通常返回集合或覆盖了”==”的类。 参考文档https://blog.csdn.net/u013894711/article/details/102785532]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[008-Flutter的适配]]></title>
    <url>%2F2020%2F08%2F10%2Fblog_bak%2FBlog%2Fflutter%2F008-Flutter%E7%9A%84%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[这里只说一个适配，rpx 适配。rpx可以理解为自适应的 px。啥意思呢？就是我们以 UI 给出的图为基准，将屏幕宽度分成固定的份数。假如，UI是按照 500*800 出的设计图，那么我们将屏幕的宽度分为 500 份，那么每一份的宽度就是一个 rpx。这样适配的话，就相当于是按照比例在适配，比如，界面上有一个 250 * 300 的正方形，那么它在 400 * 600 的屏幕上，应该显示的宽度是 ： 1250 / 500 = x / 400 所以说，rpx 是自适应的，它在不同的屏幕上会有不同的大小。 其实，在Android中，这样的适配方式还是很常见的，我们拿一个举例： 1234567891011121314151617public static float (int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; Android中的控件都是使用的 dp，dp 会让所有设备的表现尽量一致，但是显然这就会引出很多问题，一个400dp的控件，在小屏手机就显示不下，所以使用比例适配是一种更加好的方案。 但是如果控件全部改成使用 px，那改动太大，然而我们分析系统源码，就可以发现使用dp也可以做到按照比例适配，其原因就是dp最终仍然被转成了px，所以我们需要做的就是干涉 dp 转 px 的这个过程。 上面的代码，已经将 dp 转 px 的过程贴出来了，我们只需要将 density 的值改一下就好了： 1public float density; 是 public 的，还不是 final 的，太好了！！！ 比如，UI 出的图是按照 320 * 480 的，一个 32 * 32 的控件，那么在 1080 * 1920 的屏幕上就是 108 * 108，那么我们需要将 density 的值改成： 132 * density = 32 / 320 * 1080 =&gt; density = 1080 / 320 可以看出，其实就是让 density 维持了这个比例。 下面，给出一些常用的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142import 'dart:ui';class SizeFit &#123; // 1.基本信息 static double physicalWidth; static double physicalHeight; static double screenWidth; static double screenHeight; static double dpr; static double statusHeight; static double rpx; static double px; static void initialize(&#123;double standardSize = 750&#125;) &#123; // 1.手机的物理分辨率 physicalWidth = window.physicalSize.width; physicalHeight = window.physicalSize.height; // 2.获取dpr dpr = window.devicePixelRatio; // 3.宽度和高度 screenWidth = physicalWidth / dpr; screenHeight = physicalHeight / dpr; // 4.状态栏高度 statusHeight = window.padding.top / dpr; // 5.计算rpx的大小 rpx = screenWidth / standardSize; px = screenWidth / standardSize * 2; &#125; static double setRpx(double size) &#123; return rpx * size; &#125; static double setPx(double size) &#123; return px * size; &#125;&#125; 做适配的时候，可以使用 setPx 方法。setRpx用于 web 端。 当然，这样写很麻烦，可以使用新出的扩展函数语法，与 kotlin 的扩展函数一样。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[005-Flutter的动画]]></title>
    <url>%2F2020%2F08%2F10%2Fblog_bak%2FBlog%2Fflutter%2F005-Flutter%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Animation addListener方法 每当动画的状态值发生变化时，动画都会通知所有通过 addListener 添加的监听器。（我们可以调用 setState 来更新动画效果） addStatusListener 当动画的状态发生变化时，会通知所有通过 addStatusListener 添加的监听器。（我们可以在这里做些逻辑处理，比如：反转，重新开始等 ） AnimationControllerAnimation是一个抽象类，并不能用来直接创建对象实现动画的使用。 AnimationController是Animation的一个子类，实现动画通常我们需要创建AnimationController对象。 AnimationController会生成一系列的值，默认情况下值是0.0到1.0区间的值 AnimationController有一个必传的参数vsync（开发中比较常见的是将SingleTickerProviderStateMixin混入到State的定义中）。 CurvedAnimation它的目的是为了给AnimationController增加动画曲线。 Tween默认情况下，AnimationController动画生成的值所在区间是0.0到1.0，如果希望使用这个以外的值，或者其他的数据类型，就需要使用Tween。一个 AnimationController 可以使用多个 Tween，类似 Android的动画集合，一个动画集合可以包含透明度变化、大小变化、颜色变化、旋转动画等； AnimatedWidget我们必须监听动画值的改变，并且改变后需要调用setState，这会带来两个问题： 执行动画必须包含这部分代码，代码比较冗余 调用setState意味着整个State类中的build方法就会被重新build AnimatedWidget可以优化上面的操作。 AnimatedBuilderAnimatedWidget 是不是最佳的解决方案呢？ 我们每次都要新建一个类来继承自AnimatedWidget 如果我们的动画Widget有子Widget，那么意味着它的子Widget也会重新build AnimatedBuilder可以优化上面的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243class _AnimationDemo01State extends State&lt;AnimationDemo01&gt; with SingleTickerProviderStateMixin &#123; AnimationController controller; Animation&lt;double&gt; animation; @override void initState() &#123; super.initState(); // 1.创建AnimationController controller = AnimationController(duration: Duration(seconds: 1), vsync: this); // 2.动画添加Curve效果 animation = CurvedAnimation(parent: controller, curve: Curves.elasticInOut, reverseCurve: Curves.easeOut); // 3.监听动画 // 4.控制动画的翻转 animation.addStatusListener((status) &#123; if (status == AnimationStatus.completed) &#123; controller.reverse(); &#125; elseif (status == AnimationStatus.dismissed) &#123; controller.forward(); &#125; &#125;); // 5.设置值的范围 animation = Tween(begin: 50.0, end: 120.0).animate(controller); &#125; @override Widget build(BuildContext context) &#123; return Center( child: AnimatedBuilder( animation: animation, builder: (ctx, child) &#123; return Icon(Icons.favorite, color: Colors.red, size: animation.value,); &#125;, ), ); &#125; @override void dispose() &#123; controller.dispose(); super.dispose(); &#125;&#125; 享元动画在Flutter中，有一个专门的Widget可以来实现这种动画效果：Hero 实现Hero动画，需要如下步骤： 1.在第一个Page1中，定义一个起始的Hero Widget，被称之为source hero，并且绑定一个tag； 2.在第二个Page2中，定义一个终点的Hero Widget，被称之为 destination hero，并且绑定相同的tag； 3.可以通过Navigator来实现第一个页面Page1到第二个页面Page2的跳转过程； Flutter会设置Tween来界定Hero从起点到终端的大小和位置，并且在图层上执行动画效果。 首页Page代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import'dart:math';import'package:flutter/material.dart';import'package:testflutter001/animation/image_detail.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, splashColor: Colors.transparent), home: HYHomePage(), ); &#125;&#125;class HYHomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text("Hero动画"), ), body: HYHomeContent(), ); &#125;&#125;class HYHomeContent extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, crossAxisSpacing: 8, mainAxisSpacing: 8, childAspectRatio: 2 ), children: List.generate(20, (index) &#123; String imageURL = "https://picsum.photos/id/$index/400/200"; return GestureDetector( onTap: () &#123; Navigator.of(context).push(PageRouteBuilder( pageBuilder: (ctx, animation, animation2) &#123; return FadeTransition( opacity: animation, child: HYImageDetail(imageURL), ); &#125; )); &#125;, child: Hero( tag: imageURL, child: Image.network(imageURL) ), ); &#125;), ); &#125;&#125;------------------------------------------------- import'package:flutter/material.dart';class HYImageDetail extends StatelessWidget &#123; finalString imageURL; HYImageDetail(this.imageURL); @override Widget build(BuildContext context) &#123; return Scaffold( backgroundColor: Colors.black, body: Center( child: GestureDetector( onTap: () &#123; Navigator.of(context).pop(); &#125;, child: Hero( tag: imageURL, child: Image.network( this.imageURL, width: double.infinity, fit: BoxFit.cover, ), )), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[009-Flutter的路由]]></title>
    <url>%2F2020%2F08%2F10%2Fblog_bak%2FBlog%2Fflutter%2F009-Flutter%E7%9A%84%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[RouteRoute：一个页面要想被路由统一管理，必须包装为一个RouteNavigatorNavigator：管理所有的Route的Widget，通过一个Stack来进行管理的基本的跳转还是比较简单的，看如下例子。demo1点击按钮跳转到详情页面1234567_onPushTap(BuildContext context) &#123; Navigator.of(context).push(MaterialPageRoute( builder: (ctx) &#123; return DetailPage(); &#125; ));&#125; demo2详情页返回 123_onBackTap(BuildContext context) &#123; Navigator.of(context).pop("a detail message");&#125; demo3跳跳详细页，传递一个参数，参数在 page 的构造函数中接收。 123456789101112131415_onPushTap(BuildContext context) &#123; // 1.跳转代码 final future = Navigator.of(context).push(MaterialPageRoute( builder: (ctx) &#123; return DetailPage("a home message"); &#125; )); // 2.获取结果 future.then((res) &#123; setState(() &#123; _message = res; &#125;); &#125;);&#125; 返回细节监听返回按钮的点击（给Scaffold包裹一个WillPopScope） WillPopScope有一个onWillPop的回调函数，当我们点击返回按钮时会执行 这个函数要求有一个Future的返回值： true：那么系统会自动帮我们执行pop操作 false：系统不再执行pop操作，需要我们自己来执行 命名路由 命名路由是将名字和路由的映射关系，在一个地方进行统一的管理 有了命名路由，我们可以通过Navigator.pushNamed() 方法来跳转到新的页面 命名路由在哪里管理呢？可以放在MaterialApp的 initialRoute 和 routes 中 initialRoute：设置应用程序从哪一个路由开始启动，设置了该属性，就不需要再设置home属性了 routes：定义名称和路由之间的映射关系，类型为Map&lt;String, WidgetBuilder&gt; 看如下例子： 1234567891011return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, splashColor: Colors.transparent ), initialRoute: "/", routes: &#123; "/home": (ctx) =&gt; HYHomePage(), "/detail": (ctx) =&gt; HYDetailPage() &#125;,); 现在跳转可以使用如下方法： 123_onPushTap(BuildContext context) &#123; Navigator.of(context).pushNamed("/detail");&#125; 命名路由参数传递pushNamed时，如何传递参数： 123_onPushTap(BuildContext context) &#123; Navigator.of(context).pushNamed(HYDetailPage.routeName, arguments: "a home message of naned route");&#125; 在HYDetailPage中，如何获取到参数呢？在build方法中ModalRoute.of(context)可以获取到传递的参数，由于只能在 build 方法中获取参数，所以一般不这样传递参数。 1234Widget build(BuildContext context) &#123; // 1.获取数据 final message = ModalRoute.of(context).settings.arguments;&#125; onGenerateRouteonGenerateRoute的钩子函数： 当我们通过pushNamed进行跳转，但是对应的name没有在routes中有映射关系，那么就会执行onGenerateRoute钩子函数； 我们可以在该函数中，手动创建对应的Route进行返回； 该函数有一个参数RouteSettings，该类有两个常用的属性： name: 跳转的路径名称 arguments：跳转时携带的参数 12345678910onGenerateRoute: (settings) &#123; if (settings.name == "/about") &#123; return MaterialPageRoute( builder: (ctx) &#123; return HYAboutPage(settings.arguments); &#125; ); &#125; return null;&#125;, onUnknownRoute如果我们打开的一个路由名称是根本不存在，这个时候我们希望跳转到一个统一的错误页面。 1234567onUnknownRoute: (settings) &#123; return MaterialPageRoute( builder: (ctx) &#123; return UnknownPage(); &#125; );&#125;,]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[002-Flutter控件捡漏]]></title>
    <url>%2F2020%2F08%2F05%2Fblog_bak%2FBlog%2Fflutter%2F002-Flutter%E6%8E%A7%E4%BB%B6%E6%8D%A1%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Text.rich123456789101112131415 @override Widget build(BuildContext context) &#123; return Text.rich( TextSpan(// text: "Hello World",// style: TextStyle(color: Colors.red, fontSize: 20) children: [ TextSpan(text: "Hello World", style: TextStyle(color: Colors.red)), TextSpan(text: "Hello flutter", style: TextStyle(color: Colors.green)), WidgetSpan(child: Icon(Icons.favorite, color: Colors.red,)), TextSpan(text: "Hello dart", style: TextStyle(color: Colors.blue)), ] ) ); &#125; 富文本，可以进行图文混排，以 span 为单位。 FadeInImage123456789101112131415161718192021222324252627class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final title = 'Fade in images'; return new MaterialApp( title: title, home: new Scaffold( appBar: new AppBar( title: new Text(title), ), body: new Stack( children: &lt;Widget&gt;[ new Center(child: new CircularProgressIndicator()), new Center( child: new FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: 'https://github.com/flutter/website/blob/master/_includes/code/layout/lakes/images/lake.jpg?raw=true', ), ), ], ), ), ); &#125;&#125; 显示一个占位符，然后在图像加载完显示时淡入。 Align组件可以调整子组件的位置，并且可以根据子组件的宽高来确定自身的的宽高。 1234567891011Container( height: 120.0, width: 120.0, color: Colors.blue[50], child: Align( alignment: Alignment.topRight, child: FlutterLogo( size: 60, ), ),) Alignment 会以矩形的中心点作为坐标原点。上面的例子，就是以 Container 的中心为坐标原点 （0, 0），左上角是 （-1，-1），右下角是（1，1）。 Align 还有两个参数：widthFactor和heightFactor是用于确定Align 组件本身宽高的属性；它们是两个缩放因子，会分别乘以子元素的宽、高。比如，child 的高是 100，heightFactor 设置为 2，则 Align 的高度是 200。 Center 继承自 Align。 Container - BoxShadowContainer 有个 BoxDecoration 参数，可以用于实现一些背景装饰。 BoxDecoration 里面有个 boxShadow 参数，它可以用于实现阴影效果。 1234567decoration: new BoxDecoration( border: new Border.all(color: Color(0xFFFF0000), width: 0.5), // 边色与边宽度// 生成俩层阴影，一层绿，一层黄， 阴影位置由offset决定,阴影模糊层度由blurRadius大小决定（大就更透明更扩散），阴影模糊大小由spreadRadius决定 boxShadow: [ BoxShadow(color: Color(0x99FFFF00), offset: Offset(5.0, 5.0), blurRadius: 10.0, spreadRadius: 2.0), BoxShadow(color: Color(0x9900FF00), offset: Offset(1.0, 1.0)), BoxShadow(color: Color(0xFF0000FF)) ], Widget的大小是如何约束的熟记这些规则： 首先，上层 widget 向下层 widget 传递约束条件。 然后，下层 widget 向上层 widget 传递大小信息。 最后，上层 widget 决定下层 widget 的位置。 更多细节： Widget 会通过它的 父级 获得自身的约束。 约束实际上就是 4 个浮点类型的集合： 最大/最小宽度，以及最大/最小高度。 然后，这个 widget 将会逐个遍历它的 children 列表。向子级传递 约束（子级之间的约束可能会有所不同），然后询问它的每一个子级需要用于布局的大小。 然后，这个 widget 就会对它子级的 children 逐个进行布局。 （水平方向是 x 轴，竖直是 y 轴） 最后，widget 将会把它的大小信息向上传递至父 widget（包括其原始约束条件）。 看链接：https://juejin.im/post/6846687593745088526 Container - Text 为何没居中？我们在 Container 里面套一个 Text，你会发现，Text 的文字不是居中的。这是因为，Text 的布局被强制为与 Container 的大小一样大了，也就是说，上层 widget 向下层 widget 传递约束条件，其中 最大/最小宽度，以及最大/最小高度都是最大值。 而，我们设置了 alignment 之后，发现，Text 居中了，这是因为 alignment 内部创建了一个 Align 控件，将 Text 包裹起来了，而 Align 不会强制 Text 的大小与自己一样，Container 强制 Align 大小与自己一样，所以就有了 Text 居中的效果。 123456789ConstrainedBox( constraints: BoxConstraints( minWidth: 70, minHeight: 70, maxWidth: 150, maxHeight: 150, ), child: Container(color: Colors.red, width: 10, height: 10),) 但我们在 homePage 里面传递这个参数的时候，发现，结果如下： 这个我还没搞懂，官方文档说参数被忽略了，但是我没搞清楚为啥被忽略。 看了下源码，是因为这里的约束时附加约束，它还是要结合父布局传过来的约束进行处理。 比如，我们传递的 minWidth 是 70，那么它需要进行计算，这里假设父布局的高度约束是 [400, 400]。 那么，新计算出来的约束实际上是将 70 clamp 到 [400, 400] 这个范围，得出结果是 400，所以相当于忽略了。 如果 父布局的高度约束是 [0, 400]，那么 clamp 出来的结果就是 70，则使用了约束的高度。 Expand 的空间分配问题1234567891011121314children: &lt;Widget&gt;[ /** * Flexible中的属性: * - flex * Expanded(更多) -&gt; Flexible(fit: FlexFit.tight) * 空间分配问题 */ Expanded(flex: 1, child: Container(height: 60, color: Colors.red)), Expanded( flex: 2, child: Container(width: 1000, height: 100, color: Colors.green)), Container(width: 90, height: 80, color: Colors.blue), Container(width: 50, height: 120, color: Colors.orange),], 两个 expand 的宽度比例为 1：2，就是 flex 的比例。 还有一个 Flexible，它的空间分配可以参考：严格约束或宽松约束。 一个宽松约束换句话来说就是设置了最大宽度/高度， 但是让允许其子 widget 获得比它更小的任意大小。 换句话来说，宽松约束的最小宽度/高度为 0。 严格约束给你了一种获得确切大小的选择。 换句话来说就是，它的最大/最小宽度是一致的，高度也一样。 SafeArea 与 SliverSafeArea现在的手机出现了刘海屏，当你的界面没有 appbar 的时候，那么刘海的位置可能会导致界面的部分内容不可见。使用安全区域可以避免这个问题。 SafeArea 就是说只让界面在刘海屏下面的位置展示，不使用刘海的位置。 而 SliverSafeArea 有点不一样，它是刚开始显示的时候，不使用刘海的位置，但是如果你的布局可以滚动，它还是会滚动到刘海位置。这样的话体验会稍微好点。 SliverPaddingSliverPadding 与 SliverSafeArea 的行为有点类似。 通常我们会遇到这样的ui：在GridView 的顶部需要与 AppBar 有一定距离，我们通常会给 GridView 设置一个 Padding，但是这样会导致 GridView 滑动起来，始终与 AppBar 都有一段距离，而 SliverPadding 就可以解决这个问题，它刚开始的时候，与 AppBar 都有一段距离，但是滑动后，与 AppBar 没有距离。 NotificationListener这个是一个 Widget，可以监听可控件的一些通知，比如：可以监听可滚动 Widget 什么时候开始滚动，什么时候结束滚动等。 12345678910111213141516171819202122232425262728293031323334353637class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: NotificationListener&lt;ScrollNotification&gt;( onNotification: (ScrollNotification notification)&#123; ScrollMetrics metrics = notification.metrics; print(metrics.pixels);// 当前位置 print(metrics.atEdge);//是否在顶部或底部 print(metrics.axis);//垂直或水平滚动 print(metrics.axisDirection);// 滚动方向是down还是up print(metrics.extentAfter);//视口底部距离列表底部有多大 print(metrics.extentBefore);//视口顶部距离列表顶部有多大 print(metrics.extentInside);//视口范围内的列表长度 print(metrics.maxScrollExtent);//最大滚动距离，列表长度-视口长度 print(metrics.minScrollExtent);//最小滚动距离 print(metrics.viewportDimension);//视口长度 print(metrics.outOfRange);//是否越过边界 print('------------------------'); return true; &#125;, child: ListView.builder( itemExtent: 50, itemCount: 50, itemBuilder: (BuildContext context,int index)&#123; return ListTile(title: Text(index.toString()),); &#125;, ), ), ); &#125;&#125; ScrollNotification 有很多子类，我们可以在里面判断： 12345if (notification is ScrollUpdateNotification)if (notification is ScrollStartNotification)if (notification is ScrollEndNotification) CustomClipper可以裁剪区域。比如，要做一个评分控件，有时候需要显示半颗星，那么需要对星星裁剪。 1234567891011121314151617181920212223class StarPath extends CustomClipper&lt;Path&gt; &#123; StarPath(&#123;this.scale = 2.5&#125;); final double scale; double perDegree = 36; /// 角度转弧度公式 double degree2Radian(double degree) &#123; return (pi * degree / 180); &#125; @override Path getClip(Size size) &#123; ... return path; &#125; @override bool shouldReclip(StarPath oldClipper) &#123; return oldClipper.scale != this.scale; &#125;&#125; getClip 是生成我们想要的裁剪的区域的 path。 shouldReclip 表示是否需要重新裁剪。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[003-Flutter的异步操作]]></title>
    <url>%2F2020%2F08%2F05%2Fblog_bak%2FBlog%2Fflutter%2F003-Flutter%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[如何catch error？12345678void testFuture()&#123; Future future = new Future(() =&gt; null); future.then((_)&#123; print("then"); &#125;).catchError((_)&#123; print("catchError"); &#125;);&#125; 这是比较常见的一种捕获异常的方式，但是 then 里面也有一个 onError 参数，是可选命名参数。 那么 它 与 catchError 有啥区别呢？ then 里面的 onError 只会捕获当前 future.then 创建的新的 Future 里面的异常。 catchError 会捕获所有异常，除非你设置的 test 条件。 12345678910111213141516171819// 代码捕获了异常Future future = new Future(() =&gt; null);future.then((_)&#123; throw Exception('1');&#125;).then((e)&#123; throw Exception('2');&#125;).catchError((_)&#123; print("catchError");&#125;);// 代码未完全捕获异常Future future = new Future(() =&gt; null);future.then((_)&#123; throw Exception('1');&#125;, onError: (e) &#123; print("catchError");&#125;).then((e)&#123; throw Exception('2');&#125;); error 指定参数会出错在 catchError 里面需要参入一个参数，是一个函数，函数也有一个参数。 一般的我们都这样写： 123catchError((e)&#123; print("catchError");&#125;); 如果，我们确定了 e 的类型是 Exception，那么可能想这样写： 123catchError((Exception e)&#123; print("catchError");&#125;); 但是运行会报错，是因为 catchError 指定了函数的参数必须要是 dynamic 的，所以我们不能强制指定类型，只能判断后处理。 奇怪的阻塞行为看如下代码： 1234Futurn&lt;String&gt; network() async &#123; await sleep(Duration(seconds: 3)); return "123";&#125; 在 main 里面直接调用这个函数，发现 main 还是阻塞了，是为什么呢？ 是因为该函数的 return 语句没有立刻执行，它调用了 sleep，没有立刻返回一个 future，所以 main 就阻塞了。 async * / sync *先看一个例子： 1234567foo1 ()&#123; print('foo1 start'); for(int i = 0; i &lt; 3; i++)&#123; print(i); &#125; print('foo1 stop'); &#125; 运行这个函数，输出： 12345foo1 start0 1 2foo1 stop 我们对上面的例子使用 sync *，如下： 123456789Iterable&lt;int&gt; foo2() sync*&#123; print('foo2 start'); for(int i = 0; i &lt; 3; i++)&#123; print('运行了foo2，当前index：$&#123;i&#125;'); yield i; &#125; print('foo2 stop'); &#125; 这回我们在 main 函数里运行 foo2()，会出现什么效果？ 答案是什么也不会发生，print也没有打印。这是为什么呢？！！ 当我们调用 foo2()的时候，这里会马上返回一个 Iterable，就像网络请求会马上返回一个 Future一样。在我们没有调用 Iterable 的 moveNext 的时候，当前函数体是不会执行的。而当我们调用了 moveNext 方法后，代码会执行到 yield 关键字的位置，并且在这里停住。当我们再一次调用 moveNext 后，会再恢复执行，然后再次停到 yield 关键字的位置，依次循环，当没有下一个值得时候，函数会隐式的调用 return方法来终止函数。 看看运行输出： 12345678var b = foo2().iterator; print('还没开始调用 moveNext'); b.moveNext(); print('第$&#123;b.current&#125;次moveNext'); b.moveNext(); print('第$&#123;b.current&#125;次moveNext'); b.moveNext(); print('第$&#123;b.current&#125;次moveNext'); 结果为： 12345678还没开始调用 moveNext foo2 start 运行了foo2，当前index：0 第0次moveNext 运行了foo2，当前index：1 第1次moveNext 运行了foo2，当前index：2 第2次moveNext 说异步生成器之前，先来说一下普通的异步调用。 现在有一个这样的需求，我想每隔一秒钟请求一下数据，一共请求10次，看看有没有人关注我等等， 如果使用原始的 async，该怎么做？ 12345678910getData() async &#123; for (int i = 0; i &lt; 10; i++)&#123; await Future.delayed(Duration(seconds: 1), ()async &#123; Data data = await getXXX(); setState()&#123; //业务逻辑 &#125;; &#125;); &#125; &#125; 这里使用循环，然后每一秒钟请求依次接口，返回数据后 setState(); 这样肯定不行，因为你不可能一两秒钟就 setState()一次， 这个时候 async* 就派上用场了： 123456Stream&lt;Data&gt; getData() async* &#123; for (int i = 0; i &lt; 10; i++)&#123; await Future.delayed(Duration(seconds: 1)); yield await getXXX(); &#125; &#125; 在页面上，我们可以用 StreamBuilder 来包住，这样每次返回数据就不用 setState() 了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[001-数组中重复的数字]]></title>
    <url>%2F2020%2F08%2F05%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%89%91%E6%8C%87offer%2F%E6%95%B0%E7%BB%84%2F001-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[找出数组中重复的数字。123456789101112在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。示例 1：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;= n &lt;= 100000 解法一在排序的算法中，有一个桶排序，我们采用同样的思路。 分配一个空数组 arr，大小为 n（ n &lt;= 100000，所以是可以接受的），由于所有的数组在 0～n-1 的范围内，所以我们可以这样： 将 nums 里面的每个元素“放到” arr 的下标位置，即，如果元素为 5，则储存到 arr[5] 里面，但是这里并不需要真的储存，只需要储存的时候，判断一下是否已经有值，如果有值，则说明有重复的元素。 12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int[] temp = new int[nums.length]; for(int i=0; i&lt;nums.length;i++) &#123; temp[nums[i]]++; if (temp[nums[i]] &gt;=2) &#123; return nums[i]; &#125; &#125; return -1; &#125;&#125; 这样的解法，空间为 O(n)。 提交结果一般： 12执行用时：2 ms, 在所有 Java 提交中击败了69.93% 的用户内存消耗：47.6 MB, 在所有 Java 提交中击败了74.99% 的用户 解法二大佬的解法：原地置换。这个思路是对题目真的理解透了。 我们假设 nums 中没有重复的数字，那么会怎么样呢？nums 就是由 0 ~ n-1 这 n 个数字组成。 我们可以利用这个特性，将元素值与角标对应起来，啥意思呢？ 就是说从第 0 个位置开始，假如它的值是 3，那么就将 0 位置与 3 位置的元素互换，则位置 3 就搞定了，那么位置 0 的元素又变成了别的数字，假如是 9，则再将位置 0 与 9 互换，这样一直重复下去。 如果说 nums 中没有重复的数字，我们是不会遇到相等的数字的，遇到了，则说明有重复的。 12345678910111213141516class Solution &#123; public int findRepeatNumber(int[] nums) &#123; int temp; for(int i=0;i&lt;nums.length;i++)&#123; while (nums[i]!=i)&#123; if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; temp=nums[i]; nums[i]=nums[temp]; nums[temp]=temp; &#125; &#125; return -1; &#125;&#125; 这样的解法，空间为 O(1)。 提交结果： 12执行用时：1 ms, 在所有 Java 提交中击败了91.42%的用户内存消耗：47.2 MB, 在所有 Java 提交中击败了97.58%的用户]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[001-Dart语法捡漏]]></title>
    <url>%2F2020%2F08%2F04%2Fblog_bak%2FBlog%2Fflutter%2F001-Dart%E8%AF%AD%E6%B3%95%E6%8D%A1%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Object 与 dynamicDart 中所有的类都继承于 Object，所以我们可以这样写：1Object x = '123';dynamic 是动态类型，会自己做类型推断，所以也可以这样写：1dynamic x = '123';他们之间的区别是：1234void main(List&lt;String&gt; args) &#123; dynamic x = '123'; print(x.substring(1));&#125; 在这种情况下，由于 x 被推断为 String 类型，所以可以调用 String 的方法，但是换成 Object 就不行了。 final 与 constfinal和const都是用于定义常量的, 也就是定义之后值都不可以修改 123final name = &apos;coderwhy&apos;;name = &apos;kobe&apos;; // 错误做法const age = 18;age = 20; // 错误做法 final和const有什么区别呢? const在赋值时, 赋值的内容必须是在编译期间就确定下来的 final在赋值时, 可以动态获取, 比如赋值一个函数 12345678String getName() &#123; return 'coderwhy';&#125;main(List&lt;String&gt; args) &#123; const name = getName(); // 错误的做法, 因为要执行函数才能获取到值 final name = getName(); // 正确的做法&#125; 另外，const 还可以修饰构造函数。可以让同样字段值的构造函数返回同样的对象。 命名可选参数 和 位置可选参数定义方式: 12命名可选参数: &#123;param1, param2, ...&#125;位置可选参数: [param1, param2, ...] 位置可选参数是有顺序的，命名可选参数没有。 ??=赋值操作 当变量为null时，使用后面的内容进行赋值。 当变量有值时，使用自己原来的值。 初始化列表12345678910111213class Point &#123; final num x; final num y; final num distance; // 错误写法 // Point(this.x, this.y) &#123; // distance = sqrt(x * x + y * y); // &#125; // 正确的写法 Point(this.x, this.y) : distance = sqrt(x * x + y * y);&#125; 初始化列表相对于命令可选参数来说，它更灵活，可以使用表达式，而可选参数的值需要是 const。 const 构造方法1234567891011main(List&lt;String&gt; args) &#123; var p1 = const Person('why'); var p2 = const Person('why'); print(identical(p1, p2)); // true&#125;class Person &#123; final String name; const Person(this.name);&#125; 将构造方法前加const进行修饰，那么可以保证同一个参数，创建出来的对象是相同的。 注意一：拥有常量构造方法的类中，所有的成员变量必须是final修饰的. 注意二: 为了可以通过常量构造方法，创建出相同的对象，不再使用 new关键字，而是使用const关键字 工厂构造方法1234567891011121314151617181920212223main(List&lt;String&gt; args) &#123; var p1 = Person('why'); var p2 = Person('why'); print(identical(p1, p2)); // true&#125;class Person &#123; String name; static final Map&lt;String, Person&gt; _cache = &lt;String, Person&gt;&#123;&#125;; factory Person(String name) &#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125; else &#123; final p = Person._internal(name); _cache[name] = p; return p; &#125; &#125; Person._internal(this.name);&#125; 工厂构造函数就是需要自己手动的返回一个对象。 Mixin混入123456789101112131415161718192021222324main(List&lt;String&gt; args) &#123; var superMan = SuperMain(); superMan.run(); superMan.fly();&#125;mixin Runner &#123; run() &#123; print('在奔跑'); &#125;&#125;mixin Flyer &#123; fly() &#123; print('在飞翔'); &#125;&#125;// implements的方式要求必须对其中的方法进行重新实现// class SuperMan implements Runner, Flyer &#123;&#125;class SuperMain with Runner, Flyer &#123;&#125; 这种写法有点像是对接口的使用简化。用接口来实现一些行为，然后可以直接被使用。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[011-Matrix源码分析：ApkChecker的其他小工具]]></title>
    <url>%2F2020%2F08%2F03%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F011-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E7%9A%84%E5%85%B6%E4%BB%96%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[本篇介绍一下 ApkChecker 里面的一些其他小工具，因为都比较简单，所以就合成一篇算了。CountClassTask用于计算 apk 里面所有 dex 文件包含的的 class 的数量。init 方法1234567891011121314151617181920212223242526272829303132333435@Overridepublic void init() throws TaskInitException &#123; super.init(); String inputPath = config.getUnzipPath(); ... inputFile = new File(inputPath); ... File[] files = inputFile.listFiles(); try &#123; if (files != null) &#123; for (File file : files) &#123; if (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.DEX_FILE_SUFFIX)) &#123; dexFileNameList.add(file.getName()); RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw"); dexFileList.add(randomAccessFile); &#125; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; throw new TaskInitException(e.getMessage(), e); &#125; // 命令支持 GROUP-BY 参数，将结果分组 if (params.containsKey(JobConstants.PARAM_GROUP)) &#123; if (JobConstants.GROUP_PACKAGE.equals(params.get(JobConstants.PARAM_GROUP))) &#123; group = JobConstants.GROUP_PACKAGE; &#125; else &#123; Log.e(TAG, "GROUP-BY '" + params.get(JobConstants.PARAM_GROUP) + "' is not correct!"); &#125; &#125;&#125; init 方法里面，就是获取了所有 .dex 文件。注意，它使用了 RandomAccessFile。为啥呢？因为它读取的是 .dex 文件，它是有一定的结构的，所以读取的时候肯定需要跳来跳去。贴一张 dex 结构图，番外篇专门介绍，其实它与 class 文件的结构很像。 上图比较简单，有详细点的： 还有更详细点的，就不贴了，贴了也看不懂。 call 方法12345678910111213141516171819202122232425262728293031323334353637383940/** * 读取dex文件， * 获取dex文件中的所有类 * 进行分组 * 然后输出 * */@Overridepublic TaskResult call() throws TaskExecuteException &#123; try &#123; ... for (int i = 0; i &lt; dexFileList.size(); i++) &#123; RandomAccessFile dexFile = dexFileList.get(i); DexData dexData = new DexData(dexFile); dexData.load(); dexFile.close(); // 获取 dex 中定义的 class // 注意 dex 中可能会有其他 dex 中的 class 的引用，这里是不包含的 ClassRef[] defClassRefs = dexData.getInternalReferences(); Set&lt;String&gt; classNameSet = new HashSet&lt;&gt;(); for (ClassRef classRef : defClassRefs) &#123; // 将 "Ljava/lang/String;" 变成 "java.lang.String", String className = ApkUtil.getNormalClassName(classRef.getName()); if (classProguardMap.containsKey(className)) &#123; // 获取混淆前的类名 // classProguardMap 是解压 task 中生成的 map className = classProguardMap.get(className); &#125; if (className.indexOf('.') == -1) &#123; continue; &#125; classNameSet.add(className); &#125; ... return taskResult; &#125; catch (Exception e) &#123; throw new TaskExecuteException(e.getMessage(), e); &#125;&#125; for 循环里面的 DexData 是核心类，但是需要了解 dex 文件结构才能将解，会专门起一篇留到番外。 直接看输出的json，然后理解代码： 12345678910111213141516171819202122&#123; "taskType": 15, "taskDescription": "Count classes in dex file, output results group by package name.", "start-time": "2020-08-03 21:34:37:539", "end-time": "2020-08-03 21:34:39:381", "total-classes": 1423, "groups": [ &#123; "name": "android.support.v7.widget", "class-count": 187 &#125;, &#123; "name": "android.support.v4.app", "class-count": 175 &#125;, &#123; "name": "android.support.v4.view", "class-count": 92 &#125;, ... ]&#125; 这里是将所有 dex 中的 class 按照包名分组，然后统计其数量。 那么，这个有什么用处呢？我个人的想法，其实是可以生成一个历史记录，看看每个版本各个包下的类的数量变化。 CountRTask这个 task 是用于计算所有 R 文件的字段数量。 如果没有特意的 keep R文件的话，由于 proguard 会将 R 文件的字段内联到代码里面，所以 release 版就不会有 R 文件。当然某些情况下需要keep R 文件，那么 最好的处理是只 keep 住需要的字段。 call 方法12345678910111213141516171819202122232425262728293031for (RandomAccessFile dexFile : dexFileList) &#123; DexData dexData = new DexData(dexFile); dexData.load(); dexFile.close(); ClassRef[] defClassRefs = dexData.getInternalReferences(); // 遍历dex中的类 for (ClassRef classRef : defClassRefs) &#123; // 获取类名 String className = ApkUtil.getNormalClassName(classRef.getName()); if (classProguardMap.containsKey(className)) &#123; // 根据混淆文件，获取未混淆类名 className = classProguardMap.get(className); &#125; // 去除内部类的后半部分 // com.example.sample.R$styleable -&gt; com.example.sample.R String pureClassName = getOuterClassName(className); // 一个光 R 是个什么鬼？？？ // 连包名都没有，java可以运行吗？ if (pureClassName.endsWith(".R") || "R".equals(pureClassName)) &#123; // 获取该类的字段长度 if (!classesMap.containsKey(pureClassName)) &#123; classesMap.put(pureClassName, classRef.getFieldArray().length); &#125; else &#123; // 累加内部类 // com.example.sample.R$string // com.example.sample.R$layout classesMap.put(pureClassName, classesMap.get(pureClassName) + classRef.getFieldArray().length); &#125; &#125; &#125;&#125; 计算 R 文件的字段数量与计算 dex 中 class 数量是差不多的。主要是如何找到 R 文件。 输出结果如下： 12345678910111213141516171819&#123; &quot;taskType&quot;: 9, &quot;taskDescription&quot;: &quot;Count the R class.&quot;, &quot;R-count&quot;: 27, &quot;Field-counts&quot;: 5449, &quot;start-time&quot;: &quot;2020-08-03 22:16:14:524&quot;, &quot;end-time&quot;: &quot;2020-08-03 22:16:16:318&quot;, &quot;R-classes&quot;: [ &#123; &quot;name&quot;: &quot;com.example.resapk.R&quot;, &quot;field-count&quot;: 1839 &#125;, &#123; &quot;name&quot;: &quot;android.support.v7.appcompat.R&quot;, &quot;field-count&quot;: 1577 &#125;, ... ]&#125; DuplicateFileTask找出重复的文件。这个 task 还是很有用的，特别是对于一些资源文件。apk 解压后文件并不多，所以重复文件都是针对的 res 下的图片之类的。 call123456789101112@Overridepublic TaskResult call() throws TaskExecuteException &#123; TaskResult taskResult = null; try &#123; ... computeMD5(inputFile); ... &#125; catch (Exception e) &#123; throw new TaskExecuteException(e.getMessage(), e); &#125; return taskResult;&#125; 为文件生成 md5 值，然后比较。 1234567891011121314151617181920// 计算出文件的 md5final String md5 = Util.byteArrayToHex(msgDigest.digest());String filename = file.getAbsolutePath().substring(inputFile.getAbsolutePath().length() + 1);// 获取混淆之前的名字if (entryNameMap.containsKey(filename)) &#123; filename = entryNameMap.get(filename);&#125;if (!md5Map.containsKey(md5)) &#123; md5Map.put(md5, new ArrayList&lt;String&gt;()); // 统计文件大小 if (entrySizeMap.containsKey(filename)) &#123; // 文件重复就使用之前的数据 fileSizeList.add(Pair.of(md5, entrySizeMap.get(filename).getFirst())); &#125; else &#123; fileSizeList.add(Pair.of(md5, totalRead)); &#125;&#125;// 统计所有文件的 md5// 一个 md5 对应一个 listmd5Map.get(md5).add(filename); 就是使用一个map记录所有文件的 md5，发现有重复的则添加到 list 里面。 看看输出格式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; &quot;taskType&quot;: 10, &quot;taskDescription&quot;: &quot;Find out the duplicated files.&quot;, &quot;files&quot;: [ &#123; &quot;md5&quot;: &quot;02aca4b1e0a80c3cf29ebefc103a506a&quot;, &quot;size&quot;: 340, &quot;files&quot;: [ &quot;res\\drawable-xxhdpi-v4\\bg_shadow_top.png&quot;, &quot;res\\drawable-xxhdpi-v4\\bg_shadow_top_copy.png&quot; ] &#125;, &#123; &quot;md5&quot;: &quot;c9e47dbb0e1927076ed7b2e1ec157be7&quot;, &quot;size&quot;: 6, &quot;files&quot;: [ &quot;META-INF\\androidx.appcompat_appcompat.version&quot;, &quot;META-INF\\androidx.asynclayoutinflater_asynclayoutinflater.version&quot;, &quot;META-INF\\androidx.coordinatorlayout_coordinatorlayout.version&quot;, &quot;META-INF\\androidx.core_core.version&quot;, &quot;META-INF\\androidx.cursoradapter_cursoradapter.version&quot;, &quot;META-INF\\androidx.customview_customview.version&quot;, &quot;META-INF\\androidx.documentfile_documentfile.version&quot;, &quot;META-INF\\androidx.drawerlayout_drawerlayout.version&quot;, &quot;META-INF\\androidx.fragment_fragment.version&quot;, &quot;META-INF\\androidx.interpolator_interpolator.version&quot;, &quot;META-INF\\androidx.legacy_legacy-support-core-ui.version&quot;, &quot;META-INF\\androidx.legacy_legacy-support-core-utils.version&quot;, &quot;META-INF\\androidx.loader_loader.version&quot;, &quot;META-INF\\androidx.localbroadcastmanager_localbroadcastmanager.version&quot;, &quot;META-INF\\androidx.print_print.version&quot;, &quot;META-INF\\androidx.slidingpanelayout_slidingpanelayout.version&quot;, &quot;META-INF\\androidx.swiperefreshlayout_swiperefreshlayout.version&quot;, &quot;META-INF\\androidx.vectordrawable_vectordrawable-animated.version&quot;, &quot;META-INF\\androidx.vectordrawable_vectordrawable.version&quot;, &quot;META-INF\\androidx.versionedparcelable_versionedparcelable.version&quot;, &quot;META-INF\\androidx.viewpager_viewpager.version&quot; ] &#125; ... ], &quot;start-time&quot;: &quot;2020-08-03 22:29:58:809&quot;, &quot;end-time&quot;: &quot;2020-08-03 22:29:58:910&quot;&#125; FindNonAlphaPngTask找出不带透明通道的 png 图片，因为没有透明通道，png 就是浪费，可以使用 jpg 等别的格式。 1234567891011121314151617181920212223242526272829303132private void findNonAlphaPng(File file) throws IOException &#123; if (file != null) &#123; if (file.isDirectory()) &#123; File[] files = file.listFiles(); for (File tempFile : files) &#123; findNonAlphaPng(tempFile); &#125; &#125; else if (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.PNG_FILE_SUFFIX) &amp;&amp; !file.getName().endsWith(ApkConstants.NINE_PNG)) &#123; // png 文件，但是不是 .9 // .9 图片需要透明度，所以直接跳过 BufferedImage bufferedImage = ImageIO.read(file); // 如果 没有 alpha 通道 if (bufferedImage != null &amp;&amp; bufferedImage.getColorModel() != null &amp;&amp; !bufferedImage.getColorModel().hasAlpha()) &#123; // 获取文件名 String filename = file.getAbsolutePath().substring(inputFile.getAbsolutePath().length() + 1); // 获取混淆前的文件名 if (entryNameMap.containsKey(filename)) &#123; filename = entryNameMap.get(filename); &#125; long size = file.length(); if (entrySizeMap.containsKey(filename)) &#123; // 获取文件大小 size = entrySizeMap.get(filename).getFirst(); &#125; // 大于阈值，记录下来 if (size &gt;= downLimitSize * ApkConstants.K1024) &#123; nonAlphaPngList.add(Pair.of(filename, file.length())); &#125; &#125; &#125; &#125;&#125; 是一个递归函数，直接看 else if 的逻辑就好了。 我还是第一个次见到 BufferedImage 这个 API，学到了。 ManifestAnalyzeTask分析 manifest 文件。这里有个有意思的东西，在 eclipse 年代，我们的版本号都是写在 manifest 中的，现在写在了 gradle 中，那么问题来了，当编译之后，可以从 manifest 获取到版本号吗？ 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0" android:compileSdkVersion="29" android:compileSdkVersionCodename="10" package="com.example.resapk" platformBuildVersionCode="1" platformBuildVersionName="1065353216.000000"&gt; &lt;uses-sdk android:minSdkVersion="19" android:targetSdkVersion="29" /&gt; 上面的 xml 是我从 apk 里面解压出来，拖到 as 里面展示的信息，里面是可以获取到版本号的。 而且，我们也可以在 intermediates 中看最终的 manifest 文件： 12345678&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.resapk" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="19" android:targetSdkVersion="29" /&gt; 解析代码其实就是一个 xml 解析器，就不贴代码了，不过有一个疑问，就是这个解析器还使用到了 arsc 文件，很奇怪，肯能与 api 的关系。 123456public ManifestParser(File manifestFile, File arscFile) throws IOException, AndrolibException &#123; if (manifestFile != null) &#123; this.manifestFile = manifestFile; &#125; resourceParser = ApkResourceDecoder.createAXmlParser(arscFile);&#125; 输出如下： 12345678910111213&#123; &quot;taskType&quot;: 2, &quot;taskDescription&quot;: &quot;Read package info from the AndroidManifest.xml.&quot;, &quot;start-time&quot;: &quot;2020-08-03 22:29:55:208&quot;, &quot;end-time&quot;: &quot;2020-08-03 22:29:55:217&quot;, &quot;manifest&quot;: &#123; &quot;package&quot;: &quot;com.example.resapk&quot;, &quot;android:minSdkVersion&quot;: &quot;19&quot;, &quot;android:targetSdkVersion&quot;: &quot;29&quot;, &quot;android:versionCode&quot;: &quot;1&quot;, &quot;android:versionName&quot;: &quot;1.0&quot; &#125;&#125; MethodCountTask统计 apk 中的方法数量，可以分组。这个task的逻辑与 CountClassTask 很像。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private void countDex(RandomAccessFile dexFile) throws IOException &#123; classInternalMethod.clear(); classExternalMethod.clear(); pkgInternalRefMethod.clear(); pkgExternalMethod.clear(); DexData dexData = new DexData(dexFile); dexData.load(); // 获取 dex 中的方法，在 struct method_id_list dex_method_ids 中储存 MethodRef[] methodRefs = dexData.getMethodRefs(); // 获取不属于该 dex 的类 ClassRef[] externalClassRefs = dexData.getExternalReferences(); Map&lt;String, String&gt; proguardClassMap = config.getProguardClassMap(); String className = null; for (ClassRef classRef : externalClassRefs) &#123; className = ApkUtil.getNormalClassName(classRef.getName()); if (proguardClassMap.containsKey(className)) &#123; className = proguardClassMap.get(className); &#125; if (className.indexOf('.') == -1) &#123; continue; &#125; // 将外部类的方法数置为0 classExternalMethod.put(className, 0); &#125; for (MethodRef methodRef : methodRefs) &#123; // 该方法所属的类 className = ApkUtil.getNormalClassName(methodRef.getDeclClassName()); if (proguardClassMap.containsKey(className)) &#123; className = proguardClassMap.get(className); &#125; if (!Util.isNullOrNil(className)) &#123; if (className.indexOf('.') == -1) &#123; continue; &#125; // 将dex内部方法放到 classInternalMethod // 将dex外部方法方法 classExternalMethod if (classExternalMethod.containsKey(className)) &#123; classExternalMethod.put(className, classExternalMethod.get(className) + 1); &#125; else if (classInternalMethod.containsKey(className)) &#123; classInternalMethod.put(className, classInternalMethod.get(className) + 1); &#125; else &#123; classInternalMethod.put(className, 1); &#125; &#125; &#125; // 移除外部类（引用的方法为0的） //remove 0-method referenced class Iterator&lt;String&gt; iterator = classExternalMethod.keySet().iterator(); while (iterator.hasNext()) &#123; if (classExternalMethod.get(iterator.next()) == 0) &#123; iterator.remove(); &#125; &#125;&#125; 统计 dex 中的方法数量，这里由于 class 分为两种，一种是 dex 中定义的，一种是引用的别的 dex 的。所以这里区分了一下，这个指标可以作为分包的一个指标，因为如果一个dex里面引用的别的 dex 的 class 非常多的话，说明分包没分好，会导致 dex 体积变大，从而导致 apk 变大。 看看输出结果： 123456789101112131415161718192021222324252627282930313233343536[ &#123; "dex-file":"classes.dex", "internal-packages":[ &#123; "name":"android.support.v7.widget", "methods":2390 &#125;, ... &#123; "name":"com.example.resapk", "methods":24 &#125;, ... ], "total-internal-classes":1316, "total-internal-methods":12459, "external-packages":[ &#123; "name":"android.view", "methods":692 &#125;, &#123; "name":"android.widget", "methods":563 &#125;, &#123; "name":"android.app", "methods":271 &#125;, ... ], "total-external-classes":481, "total-external-methods":3598 &#125;] 可以看出我们的 dex 中，使用 framework 的方法有 3598 个。 这里原始的输出，但是经过格式化之后，只能看到这样的信息，不太清楚为啥要减少字段： 123456789101112131415161718192021&#123; "taskType": 4, "taskDescription": "Count methods in dex file, output results group by class name or package name.", "start-time": "2020-08-03 23:19:26:927", "end-time": "2020-08-03 23:19:28:421", "total-methods": 16057, "groups": [ &#123; "name": "Android System", "method-count": 15486 &#125;, &#123; "name": "java system", "method-count": 531 &#125;, &#123; "name": "[others]", "method-count": 40 &#125; ]&#125; 关于 dex 的 class 的信息没有了。 MultiSTLCheckTask这个检测是与 so 有关，但是这方面我不熟，里面的检测主要是使用 nm 工具的输出信息，所以我就不介绍了。 1234567891011121314151617181920212223242526// 这里不熟悉 nm 工具。所以不太清楚在做什么// 使用 arm-linux-androideabi-nm 分析指定的 so 文件，-D -C 参数// 参数意义：https://manned.org/arm-linux-androideabi-nm/07ad85eb// 判断输出的每一行内容// 0001df70 T std::get_unexpected()// 0001df50 T std::set_unexpected(void (*)())// 00016780 T std::get_new_handler()// 00016760 T std::set_new_handler(void (*)())// 0001dd90 T std::current_exception()private boolean isStlLinked(File libFile) throws IOException, InterruptedException &#123; ProcessBuilder processBuilder = new ProcessBuilder(toolnmPath, "-D", "-C", libFile.getAbsolutePath()); Process process = processBuilder.start(); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream())); String line = reader.readLine(); while (line != null) &#123; String[] columns = line.split(" "); Log.d(TAG, "%s", line); if (columns.length &gt;= 3 &amp;&amp; columns[1].equals("T") &amp;&amp; columns[2].startsWith("std::")) &#123; return true; &#125; line = reader.readLine(); &#125; reader.close(); process.waitFor(); return false;&#125; MultiLibCheckTask这个很简单，就是判断 libs 下是否有超过1个目录，很简单，就不贴代码了。 1234567891011// 这个 task 很简单，就是输出 lib 下的各个目录// "lib-dirs": [// "arm64-v8a",// "armeabi",// "armeabi-v7a",// "mips",// "mips64",// "x86",// "x86_64"// ],// "multi-lib": true, ResProguardCheckTask这个task是判断apk的资源是否被混淆了。 咋判断呢？ 第一种情况，如果存在 r 目录，则肯定是被混淆了，因为是配合的 AndResGuard 使用的。 第二种情况，如果存在 res 目录，需要判断厘米的各个目录是否被混淆了： 1234567fileNamePattern = Pattern.compile("[a-z_0-9]&#123;1,3&#125;");if (dir.isDirectory() &amp;&amp; !fileNamePattern.matcher(dir.getName()).matches()) &#123; hasProguard = false; Log.i(TAG, "directory " + dir.getName() + " has a non-proguard name!"); break;&#125; 判断方法很简单，看看混淆后的目录名字是否超过了3个即可。 ShowFileSizeTask这个 task 是用来找出超过一定大小的文件的。这个还是挺有用，可以找出ui切的大图。 123456789101112131415161718192021222324&#123; "taskType": 3, "taskDescription": "Show files whose size exceed limit size in order.", "files": [ &#123; "entry-name": "resources.arsc", "entry-size": 265548 &#125;, &#123; "entry-name": "res/mipmap-xxxhdpi-v4/ic_launcher_round.png", "entry-size": 16570 &#125;, &#123; "entry-name": "res/mipmap-xxhdpi-v4/ic_launcher_round.png", "entry-size": 11873 &#125;, &#123; "entry-name": "res/mipmap-xxxhdpi-v4/ic_launcher.png", "entry-size": 10652 &#125; ], "start-time": "2020-08-03 23:22:35:851", "end-time": "2020-08-03 23:22:35:863"&#125; 因为，解压的时候记录了每个文件的大小，所以直接进行分组就好了。这里是因为过滤了指定后缀文件，所以才这么少。 123456789101112131415161718for (Map.Entry&lt;String, Pair&lt;Long, Long&gt;&gt; entry : entrySizeMap.entrySet()) &#123; // 文件后缀 final String suffix = getSuffix(entry.getKey()); Pair&lt;Long, Long&gt; size = entry.getValue(); // 文件大小超过下限 if (size.getFirst() &gt;= downLimit * ApkConstants.K1024) &#123; // 有在参数指定该后缀，则统计 // 没有指定任何后缀，也统计 // 否则，忽略 if (filterSuffix.isEmpty() || filterSuffix.contains(suffix)) &#123; entryList.add(Pair.of(entry.getKey(), size.getFirst())); &#125; else &#123; Log.d(TAG, "file: %s, filter by suffix.", entry.getKey()); &#125; &#125; else &#123; Log.d(TAG, "file:%s, size:%d B, downlimit:%d KB", entry.getKey(), size.getFirst(), downLimit); &#125;&#125; UncompressedFileTask该任务是输出压缩前后大小仍然相等的文件，apk 实质上是一个压缩文件，所以里面的文件都是经过压缩的才对。 1234567891011121314151617181920for (Map.Entry&lt;String, Pair&lt;Long, Long&gt;&gt; entry : entrySizeMap.entrySet()) &#123; final String suffix = getSuffix(entry.getKey()); Pair&lt;Long, Long&gt; size = entry.getValue(); // 将压缩前的文件放入 uncompressSizeMap // 将压缩后的文件放入 compressSizeMap if (filterSuffix.isEmpty() || filterSuffix.contains(suffix)) &#123; if (!uncompressSizeMap.containsKey(suffix)) &#123; uncompressSizeMap.put(suffix, size.getFirst()); &#125; else &#123; uncompressSizeMap.put(suffix, uncompressSizeMap.get(suffix) + size.getFirst()); &#125; if (!compressSizeMap.containsKey(suffix)) &#123; compressSizeMap.put(suffix, size.getSecond()); &#125; else &#123; compressSizeMap.put(suffix, compressSizeMap.get(suffix) + size.getSecond()); &#125; &#125; else &#123; Log.d(TAG, "file: %s, filter by suffix.", entry.getKey()); &#125;&#125; 1234// 判断压缩前后的文件大小是否相等if (uncompressSizeMap.get(suffix).equals(compressSizeMap.get(suffix))) &#123; ...&#125; 是因为解压apk的时候，统计了每个文件的大小，压缩前后的大小，所以可以直接使用。 UnStrippedSoCheckTask这个任务，同样使用到了 nm 工具，所以我不熟。因为使用到了 nm 工具，所以，需要配置该工具的路径。 1234567891011121314151617181920private boolean isSoStripped(File libFile) throws IOException, InterruptedException &#123; // 使用 arm-linux-androideabi-nm 分析指定的 so 文件，不带参数 ProcessBuilder processBuilder = new ProcessBuilder(toolnmPath, libFile.getAbsolutePath()); Process process = processBuilder.start(); BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream())); String line = reader.readLine(); boolean result = false; // aarch64-linux-android-nm: libcrashlytics.so: no symbols // 如果输出上面的信息，则通过，当然这里我是不太懂到底是个啥 if (!Util.isNullOrNil(line)) &#123; Log.d(TAG, "%s", line); String[] columns = line.split(":"); if (columns.length == 3 &amp;&amp; columns[2].trim().equalsIgnoreCase("no symbols")) &#123; result = true; &#125; &#125; reader.close(); process.waitFor(); return result;&#125;]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[009-Matrix源码分析：ApkChecker解压apk.md]]></title>
    <url>%2F2020%2F08%2F02%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F009-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E8%A7%A3%E5%8E%8Bapk%2F</url>
    <content type="text"><![CDATA[这篇本来无甚难度，之所以单独一篇，是因为它输出的一些结果，后面的 task 都会用上。init 函数1234567891011@Overridepublic void init() throws TaskInitException &#123; super.init(); inputFile = new File(config.getApkPath()); outputFile = new File(config.getUnzipPath()); mappingTxt = new File(config.getMappingFilePath()); resMappingTxt = new File(config.getResMappingFilePath());&#125; inputFile 是 apk 的路径。 outputFile 是 apk 解压后的输出路径。ApkChecker运行完成之后，会删除该目录。 mappingTxt 是 mapping 文件，因为 R.string 等类可能会被混淆。 resMappingTxt 是使用了 AndResGuard 的工程会有这个，是因为资源名会被混淆，比如 res/layout/activity_main 混淆成了 r/l/a，输出混淆后的名称出来，根本看不懂。 call 函数12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic TaskResult call() throws TaskExecuteException &#123; try &#123; ... // 读 mappping 文件 readMappingTxtFile(); config.setProguardClassMap(proguardClassMap); // 读 resource_mapping 文件 readResMappingTxtFile(); config.setResguardMap(resguardMap); Enumeration entries = zipFile.entries(); JsonArray jsonArray = new JsonArray(); String outEntryName = ""; while (entries.hasMoreElements()) &#123; ZipEntry entry = (ZipEntry) entries.nextElement(); // writeEntry 里面只是将文件解压出来了 // 返回的 outEntryName 是资源未混淆之前的名字 outEntryName = writeEntry(zipFile, entry); if (!Util.isNullOrNil(outEntryName)) &#123; JsonObject fileItem = new JsonObject(); fileItem.addProperty("entry-name", outEntryName); fileItem.addProperty("entry-size", entry.getCompressedSize()); jsonArray.add(fileItem); // key：文件未混淆时名字 // value： &lt;文件大小，文件压缩后大小&gt; entrySizeMap.put(outEntryName, Pair.of(entry.getSize(), entry.getCompressedSize())); // key： 文件混淆时名字 // value：文件未混淆时名字 entryNameMap.put(entry.getName(), outEntryName); &#125; &#125; config.setEntrySizeMap(entrySizeMap); config.setEntryNameMap(entryNameMap); ... return taskResult; &#125; catch (Exception e) &#123; throw new TaskExecuteException(e.getMessage(), e); &#125;&#125; 核心代码还是比较简单的。 先读取 mapping 文件，好还原 R$xxx.class 是啥。读取的代码就不分析了，对着 mapping 文件的格式来看还是很好理解的。 config.setProguardClassMap(proguardClassMap); 这行代码比较重要，因为 proguardClassMap 这个 map 后面的 task 会常常用到，可以用于还原类名。 在读取，resMapping 文件，好还原资源名。读取代码也不分析了，生成 resMapping 需要接入 AndResGuard，可以试试，会长不少见识。也是对着生成的文件看代码，没啥好说的。 config.setResguardMap(resguardMap);，这个resguardMap后面的task也是会用到的。 entrySizeMap 与 entryNameMap ，后面的 task 也会用到。 总结，这个 task 里面做了如下动作： mapping resMapping 文件名字（混淆前后，主要针对资源文件），文件大小（压缩前后） 更详细的注释，查看 github 的 note 分支。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[010-Matrix源码分析：ApkChecker检查无用资源]]></title>
    <url>%2F2020%2F07%2F30%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F010-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AApkChecker%E6%A3%80%E6%9F%A5%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[分析无用资源，Android studio 本身就提供了lint工具。但是有个缺点就是无法配合proguard使用，无用代码引用的资源是不会被计算出来的。ApkChecker里面提供了两个小工具，可以直接分析apk包里面的无用资源（res目录与asset目录）。UnusedAssetsTask我们先看简单一些的 UnusedAssetsTask 类，该类用于寻找出没有使用的 asset 资源。 1public class UnusedAssetsTask extends ApkTask &#123;...&#125; ApkChecker里面提供了十来个小工具，都是继承于 ApkTask，但是 ApkTask 里面啥都没有，只是做了输入参数处理，与提供一个统一处理核心逻辑的地方。 Task 的分析，主要是3部分 第一部分是构造函数，里面有个 type 比较重要，输出 task 分析的结果会用到，后面会有展示。 第二部分是 init 函数，用于初始化一些变量。 第三部分是 call 函数，里面是 task 的核心逻辑。 后面的 task 都会按照这个模板来分析。 构造函数123456789101112public class UnusedAssetsTask extends ApkTask &#123; private static final String TAG = "Matrix.UnusedAssetsTask"; public UnusedAssetsTask(JobConfig config, Map&lt;String, String&gt; params) &#123; super(config, params); type = TaskFactory.TASK_TYPE_UNUSED_ASSETS; dexFileNameList = new ArrayList&lt;&gt;(); ignoreSet = new HashSet&lt;&gt;(); assetsPathSet = new HashSet&lt;&gt;(); assetRefSet = new HashSet&lt;&gt;(); &#125; JobConfig 是从命令行输入读取的配置信息解析而成的对象。ApkChecker 除了提供了十几个小工具用于分析与优化APK，由于它是一个命令行工具，所以还有一部分代码都是与读取参数有关，就比如我们平时使用的 ls -l 命令，会带些参数，还是一套比较完整的解析代码，而且对于结果输出，也有json与html两个格式，这也涉及到些设计模式，与重构还是代码大全的某个例子有点类似，有兴趣的可以研究研究。 init 函数123456789101112131415161718@Overridepublic void init() throws TaskInitException &#123; super.init(); String inputPath = config.getUnzipPath(); inputFile = new File(inputPath); ... // 收集 dex 文件 File[] files = inputFile.listFiles(); if (files != null) &#123; for (File file : files) &#123; if (file.isFile() &amp;&amp; file.getName().endsWith(ApkConstants.DEX_FILE_SUFFIX)) &#123; dexFileNameList.add(file.getName()); &#125; &#125; &#125;&#125; config.getUnzipPath是获取解压的路径，09 篇说了 UnzipTask 任务，它将需要分析的 apk 解压，这里的路径就是解压目录路径。 这个函数主要是获取所有 .dex 文件。 call 函数123456789101112131415161718192021222324@Overridepublic TaskResult call() throws TaskExecuteException &#123; try &#123; ... // 收集 asset 目录下文件 findAssetsFile(assetDir); // 收集相对路径，里面去除了配置的忽略文件 // 因为写忽略配置文件，肯定是相对 assets 目录的 // --ignoreAssets // assetsPathSet 里面存放的是 asset 目录下的所有文件 generateAssetsSet(assetDir.getAbsolutePath()); Log.i(TAG, &quot;find all assets count: %d&quot;, assetsPathSet.size()); decodeCode(); // assetRefSet 里面存放的是 配置的忽略的资源 + smali 中引用到的资源 Log.i(TAG, &quot;find reference assets count: %d&quot;, assetRefSet.size()); assetsPathSet.removeAll(assetRefSet); ... &#125; catch (Exception e) &#123; throw new TaskExecuteException(e.getMessage(), e); &#125;&#125; 可以自己先想一下，如何才能找出 assets 目录下的未使用的资源？ 访问 asset 资源的方法： 12webView.loadUrl("file:///android_asset/win8_Demo/index.html");getAssets().open("wpics/0ZR424L-0.jpg"); 可以看到，我们都是使用的字符串来表示 assets 目录下的某一特定资源。 当 .dex 反编译为 .smail 代码的时候，对于常量字符串，都是以 const-string 开头的。 123// const-string 的语法：// const-string v0, &quot;LOG&quot; # 将v0寄存器赋值为字符串常量&quot;LOG&quot;// 这算是一种简单的分析方式 所以，以这种方式，我们可以得出一个大致正确的结果。 所以思路就是：以读取文件的方式，遍历 smali 代码文件，找到所有使用常量字符串的地方。 需要先反编译 .dex 文件： 1234567891011121314151617181920private void decodeCode() throws IOException &#123; for (String dexFileName : dexFileNameList) &#123; // 使用 apktool 加载 dex 文件 DexBackedDexFile dexFile = DexFileFactory.loadDexFile(new File(inputFile, dexFileName), Opcodes.forApi(15)); BaksmaliOptions options = new BaksmaliOptions(); // class 类按自然排序 List&lt;? extends ClassDef&gt; classDefs = Ordering.natural().sortedCopy(dexFile.getClasses()); for (ClassDef classDef : classDefs) &#123; // 从 ClassDef 中获取该 class 对应的 smali 代码 String[] lines = ApkUtil.disassembleClass(classDef, options); if (lines != null) &#123; // 分析 smali 代码 readSmaliLines(lines); &#125; &#125; &#125;&#125; 使用的是 APKTOOL 的 api，就不介绍了，我也不熟。 1234567891011121314151617181920212223242526272829303132private void readSmaliLines(String[] lines) &#123; if (lines == null) &#123; return; &#125; for (String line : lines) &#123; line = line.trim(); // 找 常量字符串，因为使用 assets 中的资源文件，方式是很单一的，需要制定文件的名字 // 所以遍历 smali 代码，找到所有使用常量字符串的地方 // const-string 的语法： // const-string v0, "LOG" # 将v0寄存器赋值为字符串常量"LOG" // 这算是一种简单的分析方式 if (!Util.isNullOrNil(line) &amp;&amp; line.startsWith("const-string")) &#123; String[] columns = line.split(","); if (columns.length == 2) &#123; // 获取 , 后面的 String assetFileName = columns[1].trim(); // 去除双引号 assetFileName = assetFileName.substring(1, assetFileName.length() - 1); if (!Util.isNullOrNil(assetFileName)) &#123; // 遍历之前收集的所有资源文件的路径 for (String path : assetsPathSet) &#123; // 如果包含该文件 if (assetFileName.endsWith(path)) &#123; // 存放到 assetRefSet 里面 assetRefSet.add(path); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 这里就是判断，const-string 的字符串里面有没有与 asset 目录下资源名一样的，有的话就算这个资源文件被使用了。 当然，如果恰好你的字符串与资源名相同，那就会误判。 如何分析 asset 资源文件有没有被使用，ApkChecker 提供了一个简单的判断方式，虽然不完全准确，但是对我们应该也有启发。 那么，可以思考一下，如何判断 libs 文件夹下的 jar 包有没有被引用？这个 ApkChecker 中并没有实现，如果有思路可以提pr。 下面再介绍一下，如何分析res中的资源有没有被引用？ UnusedResourcesTask分析 res 下无用资源与 assets 下无用资源是相似的，但是需要弄清楚一件事： 当我们在 layout 等xml资源中使用了 values 文件中的资源，这个在代码中是无法找到的，所以需要理清思路，分析各个资源的引用关系。 思路ApkChecker 里面提供的思路如下： 12首先，代码里面引用的资源肯定需要标记为已使用。比如：R.layout.activity_main，其次，R.layout.activity_main 文件引用的资源，也需要标记为已使用。所以，我们需要想办法收集到 res 目录下资源的相互引用关系。 ApkChecker 将 res 下的资源分为两部分： 12345678910111213141516171819for (ResPackage pkg : resTable.listMainPackages()) &#123; aXmlResourceParser.getAttrDecoder().setCurrentPackage(pkg); // layout // drawable // anim // menu // animator // color // 等等 .xml 文件 for (ResResource resSource : pkg.listFiles()) &#123; decodeResResource(resSource, resDir, aXmlResourceParser, nonValueReferences); &#125; // 这里直接读取的 values 下的文件 for (ResValuesFile valuesFile : pkg.listValuesFiles()) &#123; Log.e("ResValuesFile", "path = " + valuesFile.getPath()); decodeResValues(valuesFile, xmlPullParser, serializer, valueReferences); &#125;&#125; nonValueReferences 最后储存的是 非values 下资源文件的引用关系，比如，R.layout.activity_main 引用了哪些资源。 valueReferences 储存的是 values 下资源的引用关系，比如，R.string.app_namex 引用了哪些资源。 获取了 res 下资源的相互引用关系之后，就可以开始标记有用资源了。 12345678910111213141516171819private void readChildReference(String resource) throws IllegalStateException &#123; if (nonValueReferences.containsKey(resource)) &#123; visitPath.push(resource); // 获取该资源引用的其他资源 Set&lt;String&gt; childReference = nonValueReferences.get(resource); // 资源有被引用则从 unusedResSet 里面移除 // 验证一下，如果 a 引用 b，a没有用到，b会被发现吗？ unusedResSet.removeAll(childReference); for (String reference : childReference) &#123; if (!visitPath.contains(reference)) &#123; readChildReference(reference); &#125; else &#123; visitPath.push(reference); throw new IllegalStateException("Found resource cycle! " + visitPath.toString()); &#125; &#125; visitPath.pop(); &#125;&#125; 这是一个深度遍历。 resource参数是代码中引用的资源 + valueReferences 集合中的元素。 这里有个疑问，看如下代码： 1234567891011121314// values 有 n 个文件夹 ： values-pl values-v24 等等// 判断里面的 item 有没有使用 @ 或者 attr 方式的，有就添加进来for (String resource : valuesReferences) &#123; if (resguardMap.containsKey(resource)) &#123; resourceRefSet.add(resguardMap.get(resource)); &#125; else &#123; resourceRefSet.add(resource); &#125;&#125;// resourceRefSet 现在储存的是 values 里面的引用的资源 + 代码中使用的资源for (String resource : resourceRefSet) &#123; readChildReference(resource);&#125; resourceRefSet 里面本来就有代码中引用的资源集合，这里是先添加了 valuesReferences 集合中的元素，然后才去做深度遍历。那么问题是，nonValueReferences 根本就不会包含 valuesReferences，在这之前添加有什么用处吗？？？ 我们继续分析上面的深度遍历代码，假设resource 是一个 layout 资源，按照上面的逻辑，该 layout 引用的所有 string，dimen， drawable 都会从 unusedResSet 集合中移除。这也就是说明它们被人引用过了，即判断它是有用资源。 这显然是一个有bug的逻辑，当一个无用资源A引用了无用资源B，那无用资源B岂不是被标记为有用，确实！！！ 所以，有必要的话可以删除一批无用资源后，再次重新运行该工具，直到资源无变化。 这里非 values 资源的逻辑是处理完了，那么 values 资源的逻辑呢，除了被 layout 等 xml 资源引用，代码中直接引用的情况有没有处理呢？ 其实是有的，我们看 call 方法： 12345678910@Overridepublic TaskResult call() throws TaskExecuteException &#123; try &#123; ... unusedResSet.removeAll(resourceRefSet); ... &#125; catch (Exception e) &#123; throw new TaskExecuteException(e.getMessage(), e); &#125;&#125; 在最后，它将 resourceRefSet 里面的所有资源都标记为引用了。从这里可以看出，resourceRefSet 里面的元素，都是根。 所以，总结一下：是以代码为根（不准确，values的引用也是根，不知道为啥要这么设计），然后深度遍历所有引用的资源。 smali 引用方式分析我们接下来，看看，如何从代码中找到资源的引用。有四种情况 123456789101112131415161718192021221. constconst v6, 0x7f0c00612. sget// app 生成的是 static int 的，所以直接转换为了数值// 但是 lib 里面不是 final 的，所以会是引用的方式sget v6, Lcom/tencent/mm/R$string;-&gt;chatting_long_click_menu_revoke_msg:Isget v1, Lcom/tencent/mm/libmmui/R$id;-&gt;property_anim:I3. sputsput-object v0, Lcom/tencent/mm/plugin_welab_api/R$styleable;-&gt;ActionBar:[I //define resource in R.java4. array-data:array_0.array-data 4 0x7f0a0022 0x7f0a0023.end array-data 第一种最简单，直接是以 R.layout.xxx 的方式。 第二种稍微绕一点，也是以 R.layout.xxx 的方式，但是不知在 app 中，而是在 modules 中，因为 modules 生成的资源不是 final 的（因为如果是 final 的，那资源id 就固定了，而 app 引用modules 的时候，是需要一起计算 id 的，id 是按顺序的）。 由于不是 final 的，所以就不是 const 语法，而是 sget 语法。 第三种，是 R.styleable，它的 R.java 是这样的： 123456public static final int[] SwitchCompat=&#123; 0x01010124, 0x01010125, 0x01010142, 0x7f020101, 0x7f020107, 0x7f020112, 0x7f020113, 0x7f020115, 0x7f020123, 0x7f020124, 0x7f020125, 0x7f02013a, 0x7f02013b, 0x7f02013c&#125;; 对应的 smali 就是 sput 了。 第四种，就是 array 了。 123int[] arr = new int[]&#123; R.layout.activity_main, R.string.app_name&#125;; 注意 3 4 的区别。 以上，就是所有资源的引用分析了，具体代码就不贴了，无非就是如何根据 smali 语法分割出我们想要的资源id，然后从 build/intermediates/symbols/debug/R.txt 中，根据资源id找出对应的资源名（如果资源做了混淆，还要处理一下 resMapping）。 还有一个问题，就是使用 android.content.res.Resources#getIdentifier这种方式引用的资源是无法分析出来的。 我们看一下反编译的 smali 代码： 1invoke-virtual &#123;v0, v1, v2, v3&#125;, Landroid/content/res/Resources;-&gt;getIdentifier(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I v1-v3是参数。 如果都是直接传递的字符串常量，那么ok，勉强是可以分析出来的，但是如果使用了局部变量，而且不是紧邻 getIdentifier 代码，那么可能连资源id都拿不到，就算拿到了资源id，也几乎分析不出来它的资源类型是啥。 而且，有时候还会使用动态拼接资源名的方式，这就更没法搞了。 所以，ApkChecker 里面是没有支持这种引用方式的，这个暂时无思路，可能的话，只能从侧面入手，比如写个插件，遇到 getIdentifier 就提醒一下，让开发者把资源添加到白名单里面去。 xml文件资源引用分析这个 task 里面涉及到的东西还是比较多的，比如分析 .xml 文件的资源引用： 12345678910111213141516String value = mParser.getAttributeValue(i);String attributeName = mParser.getAttributeName(i);if (!Util.isNullOrNil(value)) &#123; if (value.startsWith("@")) &#123; int index = value.indexOf('/'); if (index &gt; 1) &#123; String type = value.substring(1, index); resourceRefSet.add(ApkConstants.R_PREFIX + type + "." + value.substring(index + 1).replace('.', '_')); &#125; &#125; else if (value.startsWith("?")) &#123; int index = value.indexOf('/'); if (index &gt; 1) &#123; resourceRefSet.add(ApkConstants.R_ATTR_PREFIX + "." + value.substring(index + 1).replace('.', '_')); &#125; &#125;&#125; 我们在 xml 中引用资源，都会使用 @ 方式，而 xml 编译之后，@还是存在的，所以以 @ 为标识来添加资源引用关系。 这里有个疑问，不知道是不是 bug。我们引用属性，通常会使用 ?attr/xxx的方式，但是 xml 编译之后，会变成 ?xxx ，所以 else if 里面的 if 条件是进不去的。这里我没搞懂，else if 是干啥的。 如下： 123&lt;vector android:tint=&quot;?colorControlNormal&quot; &lt;size android:height=&quot;@dimen/abc_progress_bar_height_material&quot;]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0052-2-3树]]></title>
    <url>%2F2020%2F07%2F15%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0052-2-3%E6%A0%91%2F</url>
    <content type="text"><![CDATA[对于平衡二叉树来说，它的查询速度是没什么问题的，但是却有一个问题，每次插入元素之后，都需要保证树的平衡，而维持平衡的代价有点过于昂贵。 而为了解决查询效率同时有兼顾插入效率，于是提出了2-3树。 2-3树的定义2-3树的每个节点可以保存1个和2个元素值。保存1个元素值的就叫 2 节点，保存2个元素值的就叫3节点。 2节点的只能有0个或2个孩子，3节点只能有0个或者3个孩子。 上图中，红色为2节点，绿色为3节点。 2-3树所有的叶子节点在同一层。这个特性比较关键。 2-3树也是排序树。2节点不用说，3节点的左子树小于节点左边元素值，中间子树介于节点两个元素之间，右子树大于节点右边的元素值。 2-3树之插入节点我们从一个空树讲起。 可以看到，一个2节点变成了3节点，再升级为4节点，但是由于节点限制，必须要将4节点分裂成2节点。有没有像生命的循环一样。 这个过程与上面的其实差不多，只不过上面的一开始是一个空树，所以可以直接分裂，但是这里不是空树，直接分裂是不可行的，需要将一个元素往父节点浮动，如果父节点也是一个3节点，那就继续往上浮动。 再看一个例子： 这几个图看懂了之后，插入应该就没问题了（要用4节点做辅助思考，会更容易理解，也不容易忘记）。 2-3树之删除节点2-3树的删除很麻烦，就没找到一个能说的清除的，都是有多少中情况，一个一个的给你列出来，让你自己去体会去。 维基百科上也只说了插入与查找。 在一个网站上找了有删除逻辑的，用文字描述的，但是没看懂： https://pages.cs.wisc.edu/~deppeler/cs400/readings/23Trees/ 似乎是以待删除节点的父节点为参考对象，分几种情况。 B树的性质 B-tree树即B树，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是另一种树。而事实上是，B-树就是指的B树。特此说明。 下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 根结点至少有两个子女。 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 所有的叶子结点都位于同一层。 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B树的高度 一棵含有n个关键字数的m阶的B树的最大高度是多少? 有 n 个关键字的B树，有n+1个叶子节点（可以回想一下二叉树的性质）。 由于我们计算的是最坏情况，所以让每个节点的关键字最少即可，这样B树的高度会更大。 第一层只有一个根节点。 第二层最少可以只有两个节点。 第三层最少可以有 $2 * \frac{m}{2} $ 个节点（B树的性质，除根节点外，每个分支节点至少有m/2个子树）。 第 k 层最少可以有 $ 2 * (\frac{m}{2})^{k - 2}$ 个节点。 第 k+1 层 （叶子节点层，在原来的B树上再扩展一层，即为叶子节点） 即 n +1 = $ 2 * (\frac{m}{2})^{k - 1}$， 所，k = $log_{\frac{m}{2}} (\frac{n+1}{2}) + 1 $ B+树的性质 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 B+树介绍 B+树看起来很奇怪： 它的节点之间有重复的元素 它的叶子节点之间还有指针 看它的重复元素的规律： 每个父节点的元素都出现在子节点中。 我们拿数据库来距离说明它的作用：假设上图中的数字是数据库中的行号（行中有我们想要查询的数据）。 当我们想要查询第 5 行的数据时，查询过程是这样的： 第一次磁盘IO： 第二次磁盘IO： 这里虽然，我们查询到了 5，但是这里只有一个索引记录，没有行中的数据，想要行中的数据，我们需要找到叶子节点，所以继续往下查询。 第三次磁盘IO： 这里，我们才能可以从这个节点中拿到卫星数据，卫星数据就是该行号对应的行数据。 除了随机查询外，B+树最大的优势在于范围查询，也就是子节点的要用指针链接起来的原因。 比如，我想查第 5-11行的数据，如果是B树的话，需要先查到5，然后使用中序遍历到6到11。而B+树的话，先查询到5之后，直接在指针上往后查询就好了，非常的方便。 参考链接： 漫画：什么是B-树？ 漫画：什么是b+树 https://www.youtube.com/watch?v=qlH4-oHnBb8]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix源码分析番外篇：arsc文件结构]]></title>
    <url>%2F2020%2F07%2F15%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2FMatrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9Aarsc%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[在 gradle 中，配置如下代码可以将无用的资源移除：123456789android &#123; ... buildTypes &#123; release &#123; shrinkResources true minifyEnabled true &#125; &#125;&#125; “shrinkResources”资源压缩功能，它需要配合ProGurad的“minifyEnabled”功能同时使用。 如果ProGuard把部分无用代码移除，这些代码所引用的资源也会被标记为无用资源，然后通过资源压缩功能将它们移除。 这个看起来很不错，但是实际上却有些待改进的地方。 对于一些无用的 String、ID、Attr、Dimen 等资源，实际上还存在于 .arsc 文件中。 对于Drawable、Layout这些无用资源，shrinkResources也没有真正把它们删掉，而是仅仅替换为一个空文件。 还是用例子说话吧，我们写一个初始demo（为了减少资源，这里连一个依赖库都不引入，appcompat 也不要），里面有些无用的资源： strings.xml 1234&lt;resources&gt; ... &lt;string name="unused_string"&gt;这是个无用的字符串&lt;/string&gt;&lt;/resources&gt; activity_old_main.xml 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:text="old main activity" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; build.gradle 12345678910buildTypes &#123; debug &#123; proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125;&#125; 我们这里，有一个无用的字符串：unused_string，有一个无用布局文件：activity_old_main，可以打 debug 与 release 包，release 包配置了混淆，先使用 010Editor 分析一下 debug 包的 .arsc 文件，看看这两个文件的信息是否存在。 字符串池 可以看到，这个无用文件的路径是存在的。路径存在字符串池中，这里储存了资源路径与strings.xml中定义的字符串等等一些资源。 资源名称字符串池 在package中，也是有这两个资源的数据，它们也是在字符串池中，注意与上面的字符串池的区别。 资源类型字符串池这里的字符串池储存的是资源的 类型 与 名称。我们展开 typeStrings 可以看到类型： ResTable_type注意到，string 是 strdata 数组第 6+1 个元素，所以，我们展开 ResTable_typeSpec typeSpec[6] 后面的 typeType，可以看到： 这里可以看到，我们定义的 app_name，unused_string，但是他们的值却看不到，我刚开始以为是模板出错了，后来想了一下，可能是因为不好判断资源的类型，解析出正确的结果是很麻烦的，这里的 value 是指向的第一个字符串池，里面储存的是资源路径，拿到资源路径后再去加载资源。理论上值就是上面字符串池中的索引引用，但是还要根据不同资源类型做不同的逻辑处理。 layout 也是一样的，这里就不贴图了。 有的 typeType 会有多个，是因为不同配置的原因： 可以看到，这里 mipmap 有6个，是因为我们的 res 目录里面就有 6 个 mipmap 文件夹，其作用就是用作适配的。不同的手机会从不同的结构体中读取资源。 ResTable_entry 与 Res_value还是要重点说一下， ResTable_entry 与 Res_value，最简单的理解就是： 1&lt;bool name="abc_action_bar_embed_tabs"&gt;false&lt;/bool&gt; ResTable_entry 里面存了 abc_action_bar_embed_tabs，但是不是直接存的，存的是上面字符串池的字符索引。 Res_value 里面存的就是StringPoolType常量池中 ResStringPool_string 的数组索引，但是还要根据不同资源类型做不同的逻辑处理。 我们拿，app_name 来说明一下，arsc 是如何根据 resourceId 来获取资源的。 我们可以看到，该资源的类型 id 为 7。其 entry 的偏移为 0（它是 entry 数组的第 1 项）。 所以它的 resourceId 为 0x7F070000。 那么这个是怎么的出来的呢？ 12345首先，7F 是 packageId，包的命名空间，取值范围为[0x01, 0x7F]，一般第三方应用均为7F，系统的为 01。07 是资源类型id，这里代表的是 string。0000 就是在 entry 中的偏移。 它的data为0，指向的是第一个字符串池中的第1项，其内容是 Sample。 OK，这里我们对 arsc 应该有一定的了解了，再回到主题，看看 release 包有哪些变化呢？ 这里，我就不贴图了，结果就是 .arsc 文件是一样的，连大小都一样。但是我们去 res 目录里面发现，activity_old_main.xml 文件变了。debug 包里面的文件，有 540 个字节，但是 release 包里面的文件只有 104 个字节，使用编辑器打开，发现 release 包里面的文件数据都是 null，与上面的提到的类似，变成了一个空文件。 所以，shrinkResources 并没有我们想的那么美好。 ResTable_map_entry还有，对于 style 与 attr 来说，他们的储存方式又不一样，为啥呢？从写法就可以看出来： 1234567891011121314&lt;attr name="buttonTintMode"&gt; &lt;enum name="src_over" value="3"/&gt; &lt;enum name="src_in" value="5"/&gt; &lt;enum name="src_atop" value="9"/&gt; &lt;enum name="multiply" value="14"/&gt; &lt;enum name="screen" value="15"/&gt; &lt;enum name="add" value="16"/&gt;&lt;/attr&gt;&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 这种写法，显然不能像 string drawable 一样，搞个键值对，只能使用 map： 这个map 里面没啥东西，是因为我把 AppTheme 里面的东西都删了。 最后，再贴一张 .arsc 的结构图 有了上面的经验，再看这张图应该会清晰一点吧。 其实，我这里讲的很粗，但是我研究了几天这个文件结构，发现比较重要的东西就是这些了，除非你想对 arsc 做自定义处理，否则的话了解上面的东西也就够了。再深入的话，需要去查看对应的 C 结构，然后搞懂每个字段的意义。 老罗的文章讲这个讲的很细，但是对于现在的我来说，看完就忘，因为用不到，所以我暂时只深入到这里吧… 有个额外的东西需要说一下，我特么还在 stackoverflow 上提了问题。 关于字符串常量头的结构： 123456789101112131415161718192021222324252627282930struct ResStringPool_header&#123; struct ResChunk_header header; // Number of strings in this pool (number of uint32_t indices that follow // in the data). uint32_t stringCount; // Number of style span arrays in the pool (number of uint32_t indices // follow the string indices). uint32_t styleCount; // Flags. enum &#123; // If set, the string index is sorted by the string values (based // on strcmp16()). SORTED_FLAG = 1&lt;&lt;0, // String pool is encoded in UTF-8 UTF8_FLAG = 1&lt;&lt;8 &#125;; uint32_t flags; // Index from header of the string data. uint32_t stringsStart; // Index from header of the style data. uint32_t stylesStart;&#125; string 与 stringStart 都好理解，style 是个啥，字符串还有样式？？？ 老罗的文章中说，&lt;b&gt;man&lt;/b&gt;&lt;i&gt;go&lt;/i&gt; b 与 i 就是字符串样式。 1注意到第四个字符串“&lt;b&gt;man&lt;/b&gt;&lt;i&gt;go&lt;/i&gt;”，它实际表示的是一个字符串“mango”，不过它的前三个字符“man”通过b标签来描述为粗体的，而后两个字符通过i标签来描述为斜体的。字符串“mango”来有两个sytle，第一个style表示第1到第3个字符是粗体的，第二个style表示第4到第5个字符是斜体的。 我使用 010Editor 打开后，发现 styleCount 为 1。 这里我没有搞懂读取带标签的 string 的时候，是怎么一个流程。 参考文档http://blog.islinjw.cn/2019/05/18/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%B8%80/ http://blog.islinjw.cn/2019/05/21/%E5%8F%AF%E8%83%BD%E6%98%AF%E5%85%A8%E7%BD%91%E8%AE%B2%E6%9C%80%E7%BB%86%E7%9A%84%E5%AE%89%E5%8D%93resources-arsc%E8%A7%A3%E6%9E%90%E6%95%99%E7%A8%8B-%E4%BA%8C/ https://juejin.im/post/5d4e60c15188255d2a78b86d https://blog.csdn.net/luoshengyang/article/details/8744683]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[008-Matrix源码分析：插桩逻辑]]></title>
    <url>%2F2020%2F07%2F12%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F008-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%8F%92%E6%A1%A9%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[前面几篇基本上将 matrix-trace-canary 的功能分析完毕了，只剩下插桩部分没有说，这里就来分析一下。先上个图，了解一下流程。正式开始之前，需要了解的预备知识：Transform。不清楚的这个的，看着会很蛋疼，天赋异禀除外。从插件的配置开始，要使用这个插件，我们需要引用它：12345678910classpath ("com.tencent:matrix:1.0.1")&#123;changing = true&#125;-------------------------------------------------------apply plugin: 'com.tencent.matrix-plugin'matrix &#123; trace &#123; enable = true baseMethodMapFile = "$&#123;project.projectDir&#125;/matrixTrace/methodMapping.txt" blackListFile = "$&#123;project.projectDir&#125;/matrixTrace/blackMethodList.txt" &#125;&#125; trace 里面有几个选项可以配置，就不说了，就是定义了一个 Extension。 123456public class MatrixTraceExtension &#123; boolean enable; String baseMethodMapFile; String blackListFile; String customDexTransformName;&#125; 然后，插件运行的时候，会读取这里值。 我们从源头看起： 123456789101112131415161718192021222324252627class MatrixPlugin implements Plugin&lt;Project&gt; &#123; private static final String TAG = "Matrix.MatrixPlugin" @Override void apply(Project project) &#123; ... // 创建 Extension project.matrix.extensions.create("trace", MatrixTraceExtension) project.afterEvaluate &#123; def android = project.extensions.android def configuration = project.matrix android.applicationVariants.all &#123; variant -&gt; if (configuration.trace.enable) &#123; // trace 处理 // 读取 Extension 配置的值 com.tencent.matrix.trace.transform.MatrixTraceTransform.inject(project, configuration.trace, variant.getVariantData().getScope()) &#125; ... &#125; &#125; &#125;&#125; 直接是调用了com.tencent.matrix.trace.transform.MatrixTraceTransform#inject 方法。 project.afterEvaluate算是一个回调，它表示所有的模块都已经配置完了，可以准备执行task了。这个时机可以 Hook 我们想要的 transform。 inject 方法较长，只展示重要的一段： 12345678910111213141516171819202122232425public static void inject(Project project, MatrixTraceExtension extension, VariantScope variantScope) &#123; ... try &#123; String[] hardTask = getTransformTaskName(extension.getCustomDexTransformName(), variant.getName()); for (Task task : project.getTasks()) &#123; for (String str : hardTask) &#123; // 找到指定的任务名 if (task.getName().equalsIgnoreCase(str) &amp;&amp; task instanceof TransformTask) &#123; TransformTask transformTask = (TransformTask) task; Log.i(TAG, "successfully inject task:" + transformTask.getName()); Field field = TransformTask.class.getDeclaredField("transform"); field.setAccessible(true); // 替换为自己的 MatrixTraceTransform，对该task进行增强 field.set(task, new MatrixTraceTransform(config, transformTask.getTransform())); break; &#125; &#125; &#125; &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125;&#125; 这里就是做了一件事：将指定的 transform 替换为我们自己的 transform。 extension.getCustomDexTransformName()， 说明我们自己也可以配置想要 hook 的 transform，因为 gradle 版本问题，transform 的名字会不一样。默认的两个 transform 是： transformClassesWithDexBuilderFor 与 transformClassesWithDexFor，都是在打 dex 的时候。 MatrixTraceTransform它只处理 CLASS，整个工程的，支持增量。 看它 transform 的逻辑，可以先大致猜猜： 1234567891011 @Override public void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation);... doTransform(transformInvocation); // hack... // 进行原来的处理逻辑 origTransform.transform(transformInvocation); &#125; 就是插入了一段自己的逻辑。 doTransform 分为3步，我们一步一步介绍。 第一步：12345678910111213141516171819202122futures.add(executor.submit(new ParseMappingTask(mappingCollector, collectedMethodMap, methodId)));// 储存 class 输入输出关系的Map&lt;File, File&gt; dirInputOutMap = new ConcurrentHashMap&lt;&gt;();// 储存 jar 输入输出关系的Map&lt;File, File&gt; jarInputOutMap = new ConcurrentHashMap&lt;&gt;();Collection&lt;TransformInput&gt; inputs = transformInvocation.getInputs();// 处理输入// 主要是将输入类的字段替换掉，替换到指定的输出位置// 里面做了增量的处理for (TransformInput input : inputs) &#123; for (DirectoryInput directoryInput : input.getDirectoryInputs()) &#123; futures.add(executor.submit(new CollectDirectoryInputTask(dirInputOutMap, directoryInput, isIncremental))); &#125; for (JarInput inputJar : input.getJarInputs()) &#123; futures.add(executor.submit(new CollectJarInputTask(inputJar, isIncremental, jarInputOutMap, dirInputOutMap))); &#125;&#125; 创建 ParseMappingTask，读取 mapping 文件，因为这个时候 class 已经被混淆了，之所以选在混淆后，是因为避免插桩导致某些编译器优化失效，等编译器优化完了再插桩。读取 mapping 文件有几个用处，第一，需要输出某些信息，肯定不能输出混淆后的class信息。第二，配置文件的类是没有混淆过的，读取进来需要能够转换为混淆后的，才能处理。 创建了两个 map，储存 class jar 文件的输入输出位置。 创建 CollectDirectoryInputTask，收集 class 文件到 map。 创建 CollectJarInputTask，收集 jar 文件到 map。 CollectDirectoryInputTask 与 CollectJarInputTask 里面还用到了反射，更改了其输出目录到 build/output/traceClassout。所以我们可以在这里看到插桩后的类。这两个类就做了这些事，就不贴代码了。 后面就是调用 future 的 get 方法，等待这里 task 执行完成，再进行下一步。 第二步：12MethodCollector methodCollector = new MethodCollector(executor, mappingCollector, methodId, config, collectedMethodMap);methodCollector.collect(dirInputOutMap.keySet(), jarInputOutMap.keySet()); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void collect(Set&lt;File&gt; srcFolderList, Set&lt;File&gt; dependencyJarList) throws ExecutionException, InterruptedException &#123; List&lt;Future&gt; futures = new LinkedList&lt;&gt;(); for (File srcFile : srcFolderList) &#123; // 将 文件/目录下 class ，全部放到 list 中 ArrayList&lt;File&gt; classFileList = new ArrayList&lt;&gt;(); if (srcFile.isDirectory()) &#123; listClassFiles(classFileList, srcFile); &#125; else &#123; classFileList.add(srcFile); &#125; // 每个 class 都分配一个 CollectSrcTask for (File classFile : classFileList) &#123; futures.add(executor.submit(new CollectSrcTask(classFile))); &#125; &#125; // 每个 jar 分配一个 CollectJarTask for (File jarFile : dependencyJarList) &#123; futures.add(executor.submit(new CollectJarTask(jarFile))); &#125; // 等待任务完成 for (Future future : futures) &#123; future.get(); &#125; futures.clear(); futures.add(executor.submit(new Runnable() &#123; @Override public void run() &#123; // 将被忽略的 方法名 存入 ignoreMethodMapping.txt 中 saveIgnoreCollectedMethod(mappingCollector); &#125; &#125;)); futures.add(executor.submit(new Runnable() &#123; @Override public void run() &#123; // 将被插桩的 方法名 存入 methodMapping.txt 中 saveCollectedMethod(mappingCollector); &#125; &#125;)); for (Future future : futures) &#123; future.get(); &#125; futures.clear();&#125; collect 方法里面又开了两个任务： CollectSrcTask CollectJarTask 它们的逻辑差不多，就介绍一个： 12345678910111213141516@Overridepublic void run() &#123; ... is = new FileInputStream(classFile); // ASM 的使用 // 访问者模式，就是将对数据结构访问的操作分离出去 // 代价就是需要将数据结构本身传递进来 ClassReader classReader = new ClassReader(is); // 修改字节码，有时候需要改动本地变量数与stack大小，自己计算麻烦，可以直接使用这个自动计算 ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); // ASM5 api版本 ClassVisitor visitor = new TraceClassAdapter(Opcodes.ASM5, classWriter); classReader.accept(visitor, 0); ...&#125; 最后走到，TraceClassAdapter： 1234567891011121314151617181920212223242526@Overridepublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access, name, signature, superName, interfaces); this.className = name; // 是否抽象类 if ((access &amp; Opcodes.ACC_ABSTRACT) &gt; 0 || (access &amp; Opcodes.ACC_INTERFACE) &gt; 0) &#123; this.isABSClass = true; &#125; // 保存父类，便于分析继承关系 collectedClassExtendMap.put(className, superName);&#125;@Overridepublic MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; // 跳过抽象类，接口 if (isABSClass) &#123; return super.visitMethod(access, name, desc, signature, exceptions); &#125; else &#123; if (!hasWindowFocusMethod) &#123; // 是否有 onWindowFocusChanged 方法，针对 activity 的 hasWindowFocusMethod = isWindowFocusChangeMethod(name, desc); &#125; return new CollectMethodNode(className, access, name, desc, signature, exceptions); &#125;&#125; 这里面没有主要逻辑，主要逻辑在 CollectMethodNode： 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void visitEnd() &#123; super.visitEnd(); TraceMethod traceMethod = TraceMethod.create(0, access, className, name, desc); // 是否构造方法 if ("&lt;init&gt;".equals(name)) &#123; isConstructor = true; &#125; // 判断类是否 被配置在了 黑名单中 boolean isNeedTrace = isNeedTrace(configuration, traceMethod.className, mappingCollector); // filter simple methods // 跳过 空方法，get/set 方法，没有调用其他方法的方法，可以理解为叶子方法 if ((isEmptyMethod() || isGetSetMethod() || isSingleMethod()) &amp;&amp; isNeedTrace) &#123; ignoreCount.incrementAndGet(); // 存入 ignore map collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod); return; &#125; // 不在黑名单中 if (isNeedTrace &amp;&amp; !collectedMethodMap.containsKey(traceMethod.getMethodName())) &#123; traceMethod.id = methodId.incrementAndGet(); // 存入 map collectedMethodMap.put(traceMethod.getMethodName(), traceMethod); incrementCount.incrementAndGet(); &#125; else if (!isNeedTrace &amp;&amp; !collectedIgnoreMethodMap.containsKey(traceMethod.className)) &#123; ignoreCount.incrementAndGet(); // 存入 ignore map collectedIgnoreMethodMap.put(traceMethod.getMethodName(), traceMethod); &#125;&#125; 可以看到，最终是将 class 中满足条件的方法，都存入到了 collectedMethodMap，忽略的方法存入了 collectedIgnoreMethodMap。 第三步：12MethodTracer methodTracer = new MethodTracer(executor, mappingCollector, config, methodCollector.getCollectedMethodMap(), methodCollector.getCollectedClassExtendMap());methodTracer.trace(dirInputOutMap, jarInputOutMap); 调用 trace 方法，trace 方法调用层次较深，最终会调用到 TraceClassAdapter，这个 TraceClassAdapter 与 第二步的 TraceClassAdapter 逻辑差不多，有一点点不一样，主要是它们关系的逻辑不同，这个 TraceClassAdapter 也是没有主要逻辑，主要逻辑在 TraceMethodAdapter 中： 12345678910111213141516171819202122232425262728293031@Overrideprotected void onMethodEnter() &#123; TraceMethod traceMethod = collectedMethodMap.get(methodName); if (traceMethod != null) &#123; traceMethodCount.incrementAndGet(); mv.visitLdcInsn(traceMethod.id); // 插入 i 方法 mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, "i", "(I)V", false); &#125;&#125;@Overrideprotected void onMethodExit(int opcode) &#123; TraceMethod traceMethod = collectedMethodMap.get(methodName); if (traceMethod != null) &#123; // 如果该方法是 onWindowFocusChanged 方法 // 还需要插桩 at 方法 if (hasWindowFocusMethod &amp;&amp; isActivityOrSubClass &amp;&amp; isNeedTrace) &#123; TraceMethod windowFocusChangeMethod = TraceMethod.create(-1, Opcodes.ACC_PUBLIC, className, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD, TraceBuildConstants.MATRIX_TRACE_ON_WINDOW_FOCUS_METHOD_ARGS); if (windowFocusChangeMethod.equals(traceMethod)) &#123; traceWindowFocusChangeMethod(mv, className); &#125; &#125; // 插入 o 方法 traceMethodCount.incrementAndGet(); mv.visitLdcInsn(traceMethod.id); mv.visitMethodInsn(INVOKESTATIC, TraceBuildConstants.MATRIX_TRACE_CLASS, "o", "(I)V", false); &#125;&#125; 这样，就完成了插桩了。 更加详细的注释，我放在了 GitHub 上： https://github.com/aprz512/matrix/tree/note 注意，这是 note 分支。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[007-Matrix源码分析：StartupTracer 监控冷启动时间]]></title>
    <url>%2F2020%2F07%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F007-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AStartupTracer%20%E7%9B%91%E6%8E%A7%E5%86%B7%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[StartupTracer 也继承了 Tracer，但是由于它监控的是冷启动，所以它需要知道第一个 activity 是什么时候启动的，故它也实现了 ActivityLifecycleCallbacks 接口。我们先看它是如何判断冷启动还是温启动的：123456789101112131415 private boolean isColdStartup() &#123; return coldCost == 0; &#125; private boolean isWarmStartUp() &#123; return isWarmStartUp; &#125;@Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; if (activeActivityCount == 0 &amp;&amp; coldCost &gt; 0) &#123; isWarmStartUp = true; &#125; activeActivityCount++; &#125; 冷启动直接是使用的 coldCost 是否为0，因为后面会有改变该值的逻辑，所以就相当于一个boolean变量的用法。 温启动是activity没有了，但是进程还在，StartupTracer 还在运行，所以 coldCost 的值也还在，这是就会认为是温启动。 我们看一下该类的注释： 12345678910* &lt;p&gt;* firstMethod.i LAUNCH_ACTIVITY onWindowFocusChange LAUNCH_ACTIVITY onWindowFocusChange* ^ ^ ^ ^ ^* | | | | |* |---------app---------|---|---firstActivity---|---------...---------|---careActivity---|* |&lt;--applicationCost--&gt;|* |&lt;--------------firstScreenCost--------------&gt;|* |&lt;---------------------------------------coldCost-------------------------------------&gt;|* . |&lt;-----warmCost----&gt;|* 这个图还是挺清楚的。 我们继续看该类的一些方法，该类的 onActivityFocused 会在activity的onWindowFocusChanged方法执行的时候调用（使用的是插桩，这部分后面再讲）： 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic void onActivityFocused(String activity) &#123; // 冷启动 if (isColdStartup()) &#123; if (firstScreenCost == 0) &#123; // 从 application 创建到第一个activity 回调 onActivityFocused 的时间 // ActivityThreadHacker.getEggBrokenTime() 是 application 创建的时间，不知道为啥要起这么个蛋疼的名字 this.firstScreenCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime(); &#125; if (hasShowSplashActivity) &#123; // coldCost 还算上了 splash 显示的时间，从 application 创建到 "mainActivity" coldCost = uptimeMillis() - ActivityThreadHacker.getEggBrokenTime(); &#125; else &#123; if (splashActivities.contains(activity)) &#123; hasShowSplashActivity = true; &#125; else if (splashActivities.isEmpty()) &#123; MatrixLog.i(TAG, "default splash activity[%s]", activity); coldCost = firstScreenCost; &#125; else &#123; MatrixLog.w(TAG, "pass this activity[%s] at duration of start up! splashActivities=%s", activity, splashActivities); &#125; &#125; if (coldCost &gt; 0) &#123; // 分析 analyse(ActivityThreadHacker.getApplicationCost(), firstScreenCost, coldCost, false); &#125; &#125; // 温启动 else if (isWarmStartUp()) &#123; isWarmStartUp = false; // 计算的是第一个 activity 从启动到 onActivityFocused 的时间 // ActivityThreadHacker hook 了 H 的 LAUNCH_ACTIVITY // 温启动，application 还在 long warmCost = uptimeMillis() - ActivityThreadHacker.getLastLaunchActivityTime(); if (warmCost &gt; 0) &#123; analyse(ActivityThreadHacker.getApplicationCost(), firstScreenCost, warmCost, true); &#125; &#125;&#125; 无论是冷启动还是温启动，都需要分析这些数据，然后上报： 1234567891011121314151617181920private void analyse(long applicationCost, long firstScreenCost, long allCost, boolean isWarmStartUp) &#123; MatrixLog.i(TAG, "[report] applicationCost:%s firstScreenCost:%s allCost:%s isWarmStartUp:%s", applicationCost, firstScreenCost, allCost, isWarmStartUp); long[] data = new long[0]; // 冷启动不得超过 10s if (!isWarmStartUp &amp;&amp; allCost &gt;= coldStartupThresholdMs) &#123; // for cold startup // 分析 ApplicationCreateBeginMethodIndex 的方法栈 data = AppMethodBeat.getInstance().copyData(ActivityThreadHacker.sApplicationCreateBeginMethodIndex); ActivityThreadHacker.sApplicationCreateBeginMethodIndex.release(); &#125; // 温启动不得超过 4s else if (isWarmStartUp &amp;&amp; allCost &gt;= warmStartupThresholdMs) &#123; // 分析 LastLaunchActivityMethodIndex 的方法栈 data = AppMethodBeat.getInstance().copyData(ActivityThreadHacker.sLastLaunchActivityMethodIndex); ActivityThreadHacker.sLastLaunchActivityMethodIndex.release(); &#125; MatrixHandlerThread.getDefaultHandler().post(new AnalyseTask(data, applicationCost, firstScreenCost, allCost, isWarmStartUp, ActivityThreadHacker.sApplicationCreateScene));&#125; 这里就是从 sBuffer 里面截取对应的 index 段来分析里面涉及到的方法，对 sBuffer 这里就不分析了，跟前面是一样的，这里说一下几个变量的意义。 12345678910111213AnalyseTask(long[] data, long applicationCost, long firstScreenCost, long allCost, boolean isWarmStartUp, int scene) &#123; this.data = data; // 当前 activity this.scene = scene; // application 耗时 this.applicationCost = applicationCost; // 启动直到用户看到第一个 activity 耗时 this.firstScreenCost = firstScreenCost; // 冷启动/温启动耗时 this.allCost = allCost; // 是冷启动还是温启动 this.isWarmStartUp = isWarmStartUp;&#125; 传进来 data，是为了两件事： 修正启动时间，与 data 里面的方法耗时累积做比较 计算 data 的 key，方便聚合 那么，启动监测就分析完成了。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[006-Matrix源码分析：FrameTracer 监控帧率]]></title>
    <url>%2F2020%2F07%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F006-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AFrameTracer%20%E7%9B%91%E6%8E%A7%E5%B8%A7%E7%8E%87%2F</url>
    <content type="text"><![CDATA[FrameTracer 与前面的两个 tracer 一样，都是继承的 Tracer。所以分析的套路也是一样的简单。而且它没有覆盖 dispatchBegin 与 dispatchEnd 这两个方法。123456@Overridepublic void doFrame(String focusedActivityName, long start, long end, long frameCostMs, long inputCostNs, long animationCostNs, long traversalCostNs) &#123; if (isForeground()) &#123; notifyListener(focusedActivityName, end - start, frameCostMs, frameCostMs &gt;= 0); &#125;&#125; 在前台才会进行帧率分析。 notifyListener 是 FrameTracer 内部可以注册监听，然后这里会回调这些监听。我们看看监听会回调一些什么信息过去： 1234567891011121314151617181920212223242526272829303132333435363738private void notifyListener(final String visibleScene, final long taskCostMs, final long frameCostMs, final boolean isContainsFrame) &#123; long start = System.currentTimeMillis(); try &#123; synchronized (listeners) &#123; for (final IDoFrameListener listener : listeners) &#123; if (config.isDevEnv()) &#123; listener.time = SystemClock.uptimeMillis(); &#125; // 掉了几帧，这里是整除 final int dropFrame = (int) (taskCostMs / frameIntervalMs); // taskCostMs 与 frameCostMs 差不多，多执行几行代码的时间差别 // 不过 frameCostMs 有可能为 0，当处理的message 是普通消息，而不是 doFrame 消息的时候 // visibleScene 是当前 activity 的名字 // isContainsFrame 我没搞懂，这个不是肯定为 true 吗？ listener.doFrameSync(visibleScene, taskCostMs, frameCostMs, dropFrame, isContainsFrame); if (null != listener.getExecutor()) &#123; // 将回调转给 Executor 去执行 listener.getExecutor().execute(new Runnable() &#123; @Override public void run() &#123; listener.doFrameAsync(visibleScene, taskCostMs, frameCostMs, dropFrame, isContainsFrame); &#125; &#125;); &#125; if (config.isDevEnv()) &#123; listener.time = SystemClock.uptimeMillis() - listener.time; MatrixLog.d(TAG, "[notifyListener] cost:%sms listener:%s", listener.time, listener); &#125; &#125; &#125; &#125; finally &#123; long cost = System.currentTimeMillis() - start; if (config.isDebug() &amp;&amp; cost &gt; frameIntervalMs) &#123; MatrixLog.w(TAG, "[notifyListener] warm! maybe do heavy work in doFrameSync! size:%s cost:%sms", listeners.size(), cost); &#125; &#125;&#125; notifyListener 就是将该消息的耗时，丢了多少帧，当前 activity 的名字传递过去。而且会在 listener 的 Executor 里面执行。 我们看一个 listener 的实现类： com.tencent.matrix.trace.tracer.FrameTracer.FPSCollector 123456789101112131415161718192021222324252627282930313233343536373839404142434445private class FPSCollector extends IDoFrameListener &#123; // 也是放到了MatrixHandlerThread中去执行 private Handler frameHandler = new Handler(MatrixHandlerThread.getDefaultHandlerThread().getLooper()); // 转到 MatrixHandlerThread 里面去执行 Executor executor = new Executor() &#123; @Override public void execute(Runnable command) &#123; frameHandler.post(command); &#125; &#125;; private HashMap&lt;String, FrameCollectItem&gt; map = new HashMap&lt;&gt;(); @Override public Executor getExecutor() &#123; return executor; &#125; @Override public void doFrameAsync(String visibleScene, long taskCost, long frameCostMs, int droppedFrames, boolean isContainsFrame) &#123; super.doFrameAsync(visibleScene, taskCost, frameCostMs, droppedFrames, isContainsFrame); if (Utils.isEmpty(visibleScene)) &#123; return; &#125; // 存放到 map 集合里面，以activity为单位 FrameCollectItem item = map.get(visibleScene); if (null == item) &#123; item = new FrameCollectItem(visibleScene); map.put(visibleScene, item); &#125; // 进行数据收集 item.collect(droppedFrames, isContainsFrame); // 当统计时间超过 10000 ms 时进行上报 if (item.sumFrameCost &gt;= timeSliceMs) &#123; // report map.remove(visibleScene); item.report(); &#125; &#125;&#125; 我们看看它上报了什么东西： 12345678910111213141516171819202122232425262728293031void collect(int droppedFrames, boolean isContainsFrame) &#123; long frameIntervalCost = UIThreadMonitor.getMonitor().getFrameIntervalNanos(); // 总的帧数耗时 sumFrameCost += (droppedFrames + 1) * frameIntervalCost / Constants.TIME_MILLIS_TO_NANO; // 总的掉帧数 sumDroppedFrames += droppedFrames; // 总帧数 sumFrame++; if (!isContainsFrame) &#123; sumTaskFrame++; &#125; // 按本次掉帧数来判断警戒级别 // 在该页面，级别严重的越多，说明这个页面有问题，可以采取措施 if (droppedFrames &gt;= frozenThreshold) &#123; dropLevel[DropStatus.DROPPED_FROZEN.index]++; dropSum[DropStatus.DROPPED_FROZEN.index] += droppedFrames; &#125; else if (droppedFrames &gt;= highThreshold) &#123; dropLevel[DropStatus.DROPPED_HIGH.index]++; dropSum[DropStatus.DROPPED_HIGH.index] += droppedFrames; &#125; else if (droppedFrames &gt;= middleThreshold) &#123; dropLevel[DropStatus.DROPPED_MIDDLE.index]++; dropSum[DropStatus.DROPPED_MIDDLE.index] += droppedFrames; &#125; else if (droppedFrames &gt;= normalThreshold) &#123; dropLevel[DropStatus.DROPPED_NORMAL.index]++; dropSum[DropStatus.DROPPED_NORMAL.index] += droppedFrames; &#125; else &#123; dropLevel[DropStatus.DROPPED_BEST.index]++; dropSum[DropStatus.DROPPED_BEST.index] += (droppedFrames &lt; 0 ? 0 : droppedFrames); &#125;&#125; 然后，将这些数据上报，report方法只是拼接了一个 JSONObject，就不说了。 最后看下来，这个类就只是做了上报，没有输出日志。但是我在运行demo的时候，有个悬浮窗显示出来了，看看是在哪里做的。再次戳一下 IDoFrameListener 的实现类，看看有哪些，果然发现了一个 FrameDecorator。这个类实际上与性能优化没啥关系，它只是提供一个实时限制帧率信息的一个悬浮窗，这里我们只介绍它展示了哪些信心，不去探究如何实现一个悬浮穿，画实时的线条之类的。 我们直接看它的 doFrameAsync 方法： 123456789101112131415161718192021@Overridepublic void doFrameAsync(String visibleScene, long taskCost, long frameCostMs, int droppedFrames, boolean isContainsFrame) &#123; super.doFrameAsync(visibleScene, taskCost, frameCostMs, droppedFrames, isContainsFrame); sumFrameCost += (droppedFrames + 1) * UIThreadMonitor.getMonitor().getFrameIntervalNanos() / Constants.TIME_MILLIS_TO_NANO; sumFrames += 1; long duration = sumFrameCost - lastCost[0]; long collectFrame = sumFrames - lastFrames[0]; // 至少要累积到200ms才做一次更新 if (duration &gt;= 200) &#123; // 拿到帧率 final float fps = Math.min(60.f, 1000.f * collectFrame / duration); updateView(view.fpsView, fps); view.chartView.addFps((int) fps); lastCost[0] = sumFrameCost; lastFrames[0] = sumFrames; // 没有消息处理了，就显示 60FPS mainHandler.removeCallbacks(updateDefaultRunnable); mainHandler.postDelayed(updateDefaultRunnable, 130); &#125;&#125; FrameDecorator 其实就显示了一个帧率，只不过使用悬浮窗现实的。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[005-Matrix源码分析：EvilMethodTracer 监控慢方法]]></title>
    <url>%2F2020%2F07%2F05%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F005-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AEvilMethodTracer%20%E7%9B%91%E6%8E%A7%E6%85%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里我们来分析一下如何监测主线程里面的一些慢方法。我们先写一个例子，例子很简单，点击一个按钮，执行一个方法，这个方法里面又调用了许多别的方法：1234567891011121314151617181920212223242526272829303132333435363738Button test = findViewById(R.id.test);test.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; f(); &#125;&#125;);void f() &#123; A(); A(); A(); A(); B(); C(); D(); E();&#125;void A() &#123; SystemClock.sleep(100);&#125;void B () &#123; SystemClock.sleep(200);&#125;void C() &#123; SystemClock.sleep(300);&#125;private void D() &#123; SystemClock.sleep(1);&#125;private void E() &#123; SystemClock.sleep(5);&#125; 这里可以想一下，如果是你自己的话，你希望得出一个什么样的足够直观的监测结果呢？ 这里其实 A B C 三个方法都比较耗时，我们看看日志输出： 1234567891011121314151617181920212223242526&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; maybe happens Jankiness!(916ms) &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;|* scene: com.example.sample.MainActivity|* [ProcessStat]|* Priority: 10|* Nice: -10|* Foreground: true|* [CPU]|* usage: 0.33%|* [doFrame]|* inputCost: 120000|* animationCost: 418100|* traversalCost: 6311100|* [Trace]|* StackSize: 8|* StackKey: 2||* TraceStack:|* [id count cost]|* 1048574 1 916|* .1 1 913|* ..2 1 913|* ...3 4 403|* ...4 1 198|* ...5 1 300|* ...6 1 6|* ...7 1 6========================================================================= doFrame 项里面的参数都是 ns，所以他们都是正常范围的。 我们看 trace 项，发现有个方法耗时 913 毫秒，这个肯定就是不正常了。 看下 methodMapping： 123456781,4,com.example.sample.MainActivity onCreate (Landroid.os.Bundle;)V2,0,com.example.sample.MainActivity f ()V3,0,com.example.sample.MainActivity A ()V4,0,com.example.sample.MainActivity B ()V5,0,com.example.sample.MainActivity C ()V6,2,com.example.sample.MainActivity D ()V7,2,com.example.sample.MainActivity E ()V1048574,1,android.os.Handler dispatchMessage (Landroid.os.Message;)V 与堆栈一对应，发现就是我们例子的调用。 仔细想一下，这个的工作原理应该是与 AnrTracer 是一样的，都是以单个 message 为单位，分析所有调用的函数，然后生成堆栈信息。 我们看看源码： 12345@Overridepublic void dispatchBegin(long beginMs, long cpuBeginMs, long token) &#123; super.dispatchBegin(beginMs, cpuBeginMs, token); indexRecord = AppMethodBeat.getInstance().maskIndex("EvilMethodTracer#dispatchBegin");&#125; 创建一个 IndexRecord。 123456@Overridepublic void doFrame(String focusedActivityName, long start, long end, long frameCostMs, long inputCostNs, long animationCostNs, long traversalCostNs) &#123; queueTypeCosts[0] = inputCostNs; queueTypeCosts[1] = animationCostNs; queueTypeCosts[2] = traversalCostNs;&#125; 记录 doFrame 三个队列的耗时。 123456789101112131415161718192021222324@Overridepublic void dispatchEnd(long beginMs, long cpuBeginMs, long endMs, long cpuEndMs, long token, boolean isBelongFrame) &#123; super.dispatchEnd(beginMs, cpuBeginMs, endMs, cpuEndMs, token, isBelongFrame); long start = config.isDevEnv() ? System.currentTimeMillis() : 0; try &#123; long dispatchCost = endMs - beginMs; // 消息处理耗时超过 700ms if (dispatchCost &gt;= evilThresholdMs) &#123; long[] data = AppMethodBeat.getInstance().copyData(indexRecord); long[] queueCosts = new long[3]; System.arraycopy(queueTypeCosts, 0, queueCosts, 0, 3); String scene = AppMethodBeat.getVisibleScene(); // 发送到子线程去分析 MatrixHandlerThread.getDefaultHandler().post(new AnalyseTask(isForeground(), scene, data, queueCosts, cpuEndMs - cpuBeginMs, endMs - beginMs, endMs)); &#125; &#125; finally &#123; indexRecord.release(); if (config.isDevEnv()) &#123; String usage = Utils.calculateCpuUsage(cpuEndMs - cpuBeginMs, endMs - beginMs); MatrixLog.v(TAG, "[dispatchEnd] token:%s cost:%sms cpu:%sms usage:%s innerCost:%s", token, endMs - beginMs, cpuEndMs - cpuBeginMs, usage, System.currentTimeMillis() - start); &#125; &#125;&#125; 这个方法最重要，就是在每个 message 处理完成后，分析一下设计到的所有方法的执行时间。 我们看看 AnalyseTask 做了什么： 1234567891011121314151617181920212223242526272829303132333435363738394041 void analyse() &#123; // process int[] processStat = Utils.getProcessPriority(Process.myPid()); String usage = Utils.calculateCpuUsage(cpuCost, cost); LinkedList&lt;MethodItem&gt; stack = new LinkedList(); if (data.length &gt; 0) &#123; TraceDataUtils.structuredDataToStack(data, stack, true, endMs); TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, new TraceDataUtils.IStructuredDataFilter() &#123; @Override public boolean isFilter(long during, int filterCount) &#123; return during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS; &#125; @Override public int getFilterMaxCount() &#123; return Constants.FILTER_STACK_MAX_COUNT; &#125; @Override public void fallback(List&lt;MethodItem&gt; stack, int size) &#123; MatrixLog.w(TAG, "[fallback] size:%s targetSize:%s stack:%s", size, Constants.TARGET_EVIL_METHOD_STACK, stack); Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK)); while (iterator.hasNext()) &#123; iterator.next(); iterator.remove(); &#125; &#125; &#125;); &#125; StringBuilder reportBuilder = new StringBuilder(); StringBuilder logcatBuilder = new StringBuilder(); long stackCost = Math.max(cost, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder)); String stackKey = TraceDataUtils.getTreeKey(stack, stackCost); MatrixLog.w(TAG, "%s", printEvil(scene, processStat, isForeground, logcatBuilder, stack.size(), stackKey, usage, queueCost[0], queueCost[1], queueCost[2], cost)); // for logcat... &#125; 这里差不多与 AnrTracer 一样的流程，因该很好看懂，就不多说了。 其实只要理清核心之处就好了，AnrTracer 是延迟5s发送分析任务，EvilMethodTracer 是每个消息处理结束后分析，但是它设定了阈值。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[004-Matrix源码分析：AnrTracer 监控ANR]]></title>
    <url>%2F2020%2F07%2F02%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F004-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AAnrTracer%20%E7%9B%91%E6%8E%A7ANR%2F</url>
    <content type="text"><![CDATA[AnrTracer是用来监测ANR的，可以打印出ANR发生的具体位置。打印log如下：123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; maybe happens ANR(5001 ms)! &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;|* scene: com.example.sample.MainActivity|* [ProcessStat]|* Priority: 10|* Nice: -10|* Foreground: true|* [Memory]|* DalvikHeap: 2076kb // 占用的堆内存|* NativeHeap: 17137kb // 占用的本地内存，使用 Debug 得到|* VmSize: 5256708kb // 虚拟内存大小，从 proc/[pid]/stat 文件中取得|* [doFrame]|* inputCost: 0|* animationCost: 0|* traversalCost: 0|* [Thread]|* State: RUNNABLE|* Stack: |* at android.view.View:performClickInternal(6574)|* at android.view.View:access$3100(778)|* at android.view.View$PerformClick:run(25885)|* at android.os.Handler:handleCallback(873)|* at android.os.Handler:dispatchMessage(99)|* at android.os.Looper:loop(193)|* at android.app.ActivityThread:main(6669)|* [Trace]|* StackSize: 2|* StackKey: 1||* TraceStack:|* [id count cost]|* 1048574 1 5005|* .1 1 5004========================================================================= postTime:1734934 curTime:1739939 第一项是进程状态。 从 proc/[pid]/stat 文件中获取的，主要描述了进程的优先级与前后台状态。nice 值与 oom_adj 有关，越低越好。 进程前后台状态是根据 ActivityLifecycleCallbacks 来判断的，没啥稀奇的。有一个地方需要注意，它判断进入后台是使用的 com.tencent.matrix.AppActiveMatrixDelegate#getTopActivityName 这个方法，里面使用反射查找 ActivityThread 的 mActivities 集合中 activity 的状态。不清楚这样是否会更好一点。我们通常是直接在 onStop 里面直接做了处理，没有这么麻烦。 第二项是内存状态。 第三项是 doFrame 的状态，是看看 3 个队列分别耗时多少。由于我写了一个死循环，所以他们都是0。 第四项是线程状态与当前堆栈信息，可以看到堆栈信息只能在ANR的附近，并不能准确的指出ANR是哪个函数导致的。 第五项是 trace，就是被插桩的方法的调用链。 1234567|* [Trace]|* StackSize: 2|* StackKey: 1||* TraceStack:|* [id count cost]|* 1048574 1 5005|* .1 1 5004 这个堆栈的意义需要解释一下，我们先看demo中的methodMapping： 121,1,com.example.sample.MainActivity$2 onClick (Landroid.view.View;)V1048574,1,android.os.Handler dispatchMessage (Landroid.os.Message;)V 数据格式的意义为：methodId，方法的访问符，类， 函数。实现的函数为 com.tencent.matrix.trace.item.TraceMethod#toString。 所以上面的 traceStack 我们逆推一下，就是 Handler#dispatchMessage 调用了MainActivity$2#onClick，而 MainActivity$2#onClick 耗时 5004 毫秒，所以可以得出 MainActivity$2#onClick 这个方法里面有耗时操作。 实际上，我的demo里面确实是这样： 1234567891011test.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; final long s = System.currentTimeMillis(); while (true) &#123; if (System.currentTimeMillis() &gt; s + 6000) &#123; break; &#125; &#125; &#125;&#125;); 所以，这个 AnrTracer 还是挺准确的。 我们看看它的实现代码吧。 Tracer 类都是继承了 LooperObserver，我们从这个类的3个方法入手。 12345678public void dispatchBegin(long beginMs, long cpuBeginMs, long token) &#123; super.dispatchBegin(beginMs, cpuBeginMs, token); anrTask = new AnrHandleTask(AppMethodBeat.getInstance().maskIndex("AnrTracer#dispatchBegin"), token); if (traceConfig.isDevEnv()) &#123; MatrixLog.v(TAG, "* [dispatchBegin] token:%s index:%s", token, anrTask.beginRecord.index); &#125; anrHandler.postDelayed(anrTask, Constants.DEFAULT_ANR - (SystemClock.uptimeMillis() - token));&#125; anrHandler 会将消息 post 到一个子线程，所以该类对插桩方法堆栈的分析都是在子线程。注意这里延迟了大约 5s。 12345public void doFrame(String focusedActivityName, long start, long end, long frameCostMs, long inputCost, long animationCost, long traversalCost) &#123; if (traceConfig.isDevEnv()) &#123; MatrixLog.v(TAG, "--&gt; [doFrame] activityName:%s frameCost:%sms [%s:%s:%s]ns", focusedActivityName, frameCostMs, inputCost, animationCost, traversalCost); &#125;&#125; doFrame 可以忽略。 123456789101112@Overridepublic void dispatchEnd(long beginMs, long cpuBeginMs, long endMs, long cpuEndMs, long token, boolean isBelongFrame) &#123; super.dispatchEnd(beginMs, cpuBeginMs, endMs, cpuEndMs, token, isBelongFrame); if (traceConfig.isDevEnv()) &#123; MatrixLog.v(TAG, "[dispatchEnd] token:%s cost:%sms cpu:%sms usage:%s", token, endMs - beginMs, cpuEndMs - cpuBeginMs, Utils.calculateCpuUsage(cpuEndMs - cpuBeginMs, endMs - beginMs)); &#125; if (null != anrTask) &#123; anrTask.getBeginRecord().release(); anrHandler.removeCallbacks(anrTask); &#125;&#125; 这个与 dispatchBegin 对应，如果 dispatchEnd 在 5s 内执行完了，那么就不用处理 AnrHandleTask 了，如果在 5s 内该方法没有调用，就需要分析方法调用，看看是哪里出了问题。我们看看 AnrHandleTask 里面做了什么： com.tencent.matrix.trace.tracer.AnrTracer.AnrHandleTask#run 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public void run() &#123; long curTime = SystemClock.uptimeMillis(); boolean isForeground = isForeground(); // process int[] processStat = Utils.getProcessPriority(Process.myPid()); long[] data = AppMethodBeat.getInstance().copyData(beginRecord); beginRecord.release(); String scene = AppMethodBeat.getVisibleScene(); // memory long[] memoryInfo = dumpMemory(); // Thread state Thread.State status = Looper.getMainLooper().getThread().getState(); StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace(); String dumpStack = Utils.getStack(stackTrace, "|*\t\t", 12); // frame UIThreadMonitor monitor = UIThreadMonitor.getMonitor(); long inputCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_INPUT, token); long animationCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_ANIMATION, token); long traversalCost = monitor.getQueueCost(UIThreadMonitor.CALLBACK_TRAVERSAL, token); // trace LinkedList&lt;MethodItem&gt; stack = new LinkedList(); if (data.length &gt; 0) &#123; // 将 buffer 中的 long 转为 MethodItem TraceDataUtils.structuredDataToStack(data, stack, true, curTime); // TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, new TraceDataUtils.IStructuredDataFilter() &#123; @Override public boolean isFilter(long during, int filterCount) &#123; return during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS; &#125; @Override public int getFilterMaxCount() &#123; return Constants.FILTER_STACK_MAX_COUNT; &#125; @Override public void fallback(List&lt;MethodItem&gt; stack, int size) &#123; MatrixLog.w(TAG, "[fallback] size:%s targetSize:%s stack:%s", size, Constants.TARGET_EVIL_METHOD_STACK, stack); Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK)); while (iterator.hasNext()) &#123; iterator.next(); iterator.remove(); &#125; &#125; &#125;); &#125; StringBuilder reportBuilder = new StringBuilder(); StringBuilder logcatBuilder = new StringBuilder(); long stackCost = Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder)); // stackKey String stackKey = TraceDataUtils.getTreeKey(stack, stackCost); MatrixLog.w(TAG, "%s \npostTime:%s curTime:%s", printAnr(scene, processStat, memoryInfo, status, logcatBuilder, isForeground, stack.size(), stackKey, dumpStack, inputCost, animationCost, traversalCost, stackCost), token, curTime); // for logcat if (stackCost &gt;= Constants.DEFAULT_ANR_INVALID) &#123; MatrixLog.w(TAG, "The checked anr task was not executed on time. " + "The possible reason is that the current process has a low priority. just pass this report"); return; &#125; // report try &#123; TracePlugin plugin = Matrix.with().getPluginByClass(TracePlugin.class); if (null == plugin) &#123; return; &#125; JSONObject jsonObject = new JSONObject(); jsonObject = DeviceUtil.getDeviceInfo(jsonObject, Matrix.with().getApplication()); jsonObject.put(SharePluginInfo.ISSUE_STACK_TYPE, Constants.Type.ANR); jsonObject.put(SharePluginInfo.ISSUE_COST, stackCost); jsonObject.put(SharePluginInfo.ISSUE_STACK_KEY, stackKey); jsonObject.put(SharePluginInfo.ISSUE_SCENE, scene); jsonObject.put(SharePluginInfo.ISSUE_TRACE_STACK, reportBuilder.toString()); jsonObject.put(SharePluginInfo.ISSUE_THREAD_STACK, Utils.getStack(stackTrace)); jsonObject.put(SharePluginInfo.ISSUE_PROCESS_PRIORITY, processStat[0]); jsonObject.put(SharePluginInfo.ISSUE_PROCESS_NICE, processStat[1]); jsonObject.put(SharePluginInfo.ISSUE_PROCESS_FOREGROUND, isForeground); // memory info JSONObject memJsonObject = new JSONObject(); memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_DALVIK, memoryInfo[0]); memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_NATIVE, memoryInfo[1]); memJsonObject.put(SharePluginInfo.ISSUE_MEMORY_VM_SIZE, memoryInfo[2]); jsonObject.put(SharePluginInfo.ISSUE_MEMORY, memJsonObject); Issue issue = new Issue(); issue.setKey(token + ""); issue.setTag(SharePluginInfo.TAG_PLUGIN_EVIL_METHOD); issue.setContent(jsonObject); plugin.onDetectIssue(issue); &#125; catch (JSONException e) &#123; MatrixLog.e(TAG, "[JSONException error: %s", e); &#125;&#125; 可以看出里面就是输出上面我们看到的一些日志信息。 这里只详细说一下方法堆栈的处理： 1234567891011121314151617181920212223242526272829303132// traceLinkedList&lt;MethodItem&gt; stack = new LinkedList();if (data.length &gt; 0) &#123; // 将 buffer 中的 long 转为 MethodItem TraceDataUtils.structuredDataToStack(data, stack, true, curTime); // TraceDataUtils.trimStack(stack, Constants.TARGET_EVIL_METHOD_STACK, new TraceDataUtils.IStructuredDataFilter() &#123; @Override public boolean isFilter(long during, int filterCount) &#123; return during &lt; filterCount * Constants.TIME_UPDATE_CYCLE_MS; &#125; @Override public int getFilterMaxCount() &#123; return Constants.FILTER_STACK_MAX_COUNT; &#125; @Override public void fallback(List&lt;MethodItem&gt; stack, int size) &#123; MatrixLog.w(TAG, "[fallback] size:%s targetSize:%s stack:%s", size, Constants.TARGET_EVIL_METHOD_STACK, stack); Iterator iterator = stack.listIterator(Math.min(size, Constants.TARGET_EVIL_METHOD_STACK)); while (iterator.hasNext()) &#123; iterator.next(); iterator.remove(); &#125; &#125; &#125;);&#125;StringBuilder reportBuilder = new StringBuilder();StringBuilder logcatBuilder = new StringBuilder();long stackCost = Math.max(Constants.DEFAULT_ANR, TraceDataUtils.stackToString(stack, reportBuilder, logcatBuilder)); 第一个关键函数：com.tencent.matrix.trace.util.TraceDataUtils#structuredDataToStack 它就是将 sBuffer 转成一个 LinkedList。之前我们有一张图，这里再看一下： 还是只看上半部分，对于 4 5 6 7 这4个方法来说，经过转换后，就变为了 1List list = &#123;&#123;4， 0&#125;, &#123;5，1&#125;, &#123;6， 1&#125;, &#123;7， 1&#125;&#125; 。 这个列表里面是一个对象，我只写了 methodId 与 depth： 123456789101112public class MethodItem &#123; // 方法的id public int methodId; // 耗费的时间 public int durTime; // 调用的深度 public int depth; // 被调用的次数 public int count = 1;&#125; 拿到了所有的调用栈之后，有可能调用栈特别大，所以需要裁剪： TraceDataUtils.trimStack 。 这个方法就是用来过滤一些不耗时的函数，过滤类是IStructuredDataFilter： 1234567891011public interface IStructuredDataFilter &#123; // 将满足过滤条件的删掉 // filterCount 是当前的过滤次数，可以根据过滤次数来做动态的调整，更改过滤条件，使之更宽 boolean isFilter(long during, int filterCount); // 最大的过滤次数 int getFilterMaxCount(); // 如果达到最大过滤次数后，还是太多了，则在这个方法里面处理，一般就是直接丢弃掉多余的 void fallback(List&lt;MethodItem&gt; stack, int size);&#125; 将方法堆栈裁剪完之后，就可以打印输出了。这个类的核心就介绍完毕了。 哦，对了，还有一个较重要的函数：com.tencent.matrix.trace.util.TraceDataUtils#getTreeKey(java.util.List&lt;com.tencent.matrix.trace.items.MethodItem&gt;, long) 这个就是为堆栈生成一个 key，因为上报到后台，没有一个 key 的话很麻烦，而且将堆栈简化为key，可以更容易的做处理。具体就是：分析出主要耗时的那一级函数，作为代表卡顿堆栈的key。就是上图的下半部分。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[003-Matrix源码分析：方法监控]]></title>
    <url>%2F2020%2F07%2F01%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F003-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%96%B9%E6%B3%95%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[在上一节中，我们看到过 AppMethodBeat 这个类，但是却没有介绍它，是因为这个玩意特别的难搞，需要单独的起一篇。这个类其实是用来统计每个函数的耗时的，具体的可以看官方文档：https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary 知道了每个函数的耗时，就可以找出卡顿的原因。 下面我们来分析这个类。 com.tencent.matrix.trace.core.AppMethodBeat#status 1private static volatile int status = STATUS_DEFAULT; 这个字段还是挺重要的，它涉及到该类的状态的管理。 一开始是 STATUS_DEFAULT 状态 然后当我们调用了 i 方法之后，会变为 STATUS_READY 状态。 然后当我们调用了 onStart 方法之后，会变为 STATUS_STARTED 状态。 然后当我们调用了 onStop 方法之后，会变为 STATUS_STOPPED 状态。 需要注意一下调用的顺序，如果顺序不对，有些逻辑是不会走的。 由于，i 与 o 方法会插桩到我们的代码中，所以 i 肯定是会先于 onStart 方法执行，这个没有问题。 状态搞清楚了，我们看看 i 与 o 这两个方法。 com.tencent.matrix.trace.core.AppMethodBeat#i 123456789101112131415161718192021222324252627282930313233343536373839public static void i(int methodId) &#123; if (status &lt;= STATUS_STOPPED) &#123; return; &#125; if (methodId &gt;= METHOD_ID_MAX) &#123; return; &#125; if (status == STATUS_DEFAULT) &#123; synchronized (statusLock) &#123; if (status == STATUS_DEFAULT) &#123; // 逻辑只会执行一次 realExecute(); status = STATUS_READY; &#125; &#125; &#125; long threadId = Thread.currentThread().getId(); if (sMethodEnterListener != null) &#123; sMethodEnterListener.enter(methodId, threadId); &#125; if (threadId == sMainThreadId) &#123; if (assertIn) &#123; android.util.Log.e(TAG, "ERROR!!! AppMethodBeat.i Recursive calls!!!"); return; &#125; assertIn = true; if (sIndex &lt; Constants.BUFFER_SIZE) &#123; mergeData(methodId, sIndex, true); &#125; else &#123; sIndex = 0; mergeData(methodId, sIndex, true); &#125; ++sIndex; assertIn = false; &#125;&#125; 应用插件之后，在每个方法的前面都会加上这个 i 方法。该方法里面做了两件事： realExecute(); mergeData com.tencent.matrix.trace.core.AppMethodBeat#realExecute 1234567891011121314151617181920212223242526private static void realExecute() &#123; MatrixLog.i(TAG, "[realExecute] timestamp:%s", System.currentTimeMillis()); sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime; sHandler.removeCallbacksAndMessages(null); // 开线程更新时间 sHandler.postDelayed(sUpdateDiffTimeRunnable, Constants.TIME_UPDATE_CYCLE_MS); // 启动过期检查，可以忽略 sHandler.postDelayed(checkStartExpiredRunnable = new Runnable() &#123; @Override public void run() &#123; synchronized (statusLock) &#123; MatrixLog.i(TAG, "[startExpired] timestamp:%s status:%s", System.currentTimeMillis(), status); if (status == STATUS_DEFAULT || status == STATUS_READY) &#123; status = STATUS_EXPIRED_START; &#125; &#125; &#125; &#125;, Constants.DEFAULT_RELEASE_BUFFER_DELAY); // hack H ActivityThreadHacker.hackSysHandlerCallback(); // 注册回调 LooperMonitor.register(looperMonitorListener);&#125; realExecute 只会调用一次，里面启动了一个线程专门用来更新时间（隔5ms循环一次），原因是： 考虑到每个方法执行前后都获取系统时间（System.nanoTime）会对性能影响比较大， 而实际上，单个函数执行耗时小于 5ms 的情况，对卡顿来说不是主要原因，可以忽略不计， 如果是多次调用的情况，则在它的父级方法中可以反映出来，所以为了减少对性能的影响， 通过另一条更新时间的线程每 5ms 去更新一个时间变量，而每个方法执行前后只读取该变量来减少性能损耗。 还hack了 ActivityThread 的 H 的 callback，主要是用来拦截消息的处理，是一种很常用的 hook 方式，里面做了启动的耗时监测，暂时不深入，后面再说。 com.tencent.matrix.trace.core.AppMethodBeat#mergeData 1234567891011121314151617181920private static void mergeData(int methodId, int index, boolean isIn) &#123; // 看注释这里是修复了一个bug，anr时间计算有问题，没看懂 if (methodId == AppMethodBeat.METHOD_ID_DISPATCH) &#123; sCurrentDiffTime = SystemClock.uptimeMillis() - sDiffTime; &#125; long trueId = 0L; if (isIn) &#123; trueId |= 1L &lt;&lt; 63; &#125; trueId |= (long) methodId &lt;&lt; 43; trueId |= sCurrentDiffTime &amp; 0x7FFFFFFFFFFL; // sBuffer 是一个long数组，long的结构： // 第1位是 1或者0，1是函数入口，0是函数出口 // 2-21位是 methodId // 22-64位是 函数的执行前后距离 MethodBeat 模块初始化的时间，一个函数会有占两个问题，根据 methodId 就可以计算出函数耗时 sBuffer[index] = trueId; // 该方法用于处理循环问题，sBuffer满了，会重头开始覆盖旧数据，主要是更新 indexRecord 链表头位置 checkPileup(index); sLastIndex = index;&#125; 这个方法也不难，就是往 sBuffer 里面添加数据，数据的结构注释也解释的很清楚了。 最终sBuffer大致长这样： 我们再看看 o 方法： com.tencent.matrix.trace.core.AppMethodBeat#o 1234567891011121314151617public static void o(int methodId) &#123; if (status &lt;= STATUS_STOPPED) &#123; return; &#125; if (methodId &gt;= METHOD_ID_MAX) &#123; return; &#125; if (Thread.currentThread().getId() == sMainThreadId) &#123; if (sIndex &lt; Constants.BUFFER_SIZE) &#123; mergeData(methodId, sIndex, false); &#125; else &#123; sIndex = 0; mergeData(methodId, sIndex, false); &#125; ++sIndex; &#125;&#125; 就做了一件事就是 mergeData，这里就没啥好说的了。再看一下 sBuffer 的结构图，只看上半部分： 我们在 sBuffer 中找到 methodId 一致的，就可以拿到该函数的耗时。 一般情况下，我们需要获取的是 sBuffer 中的一段数据，比如执行 doFrame 消息的时候，我们想知道，它里面调用到了哪些函数，这个时候就需要记录一下 doFrame 前后的 sIndex，有一个内部类是专门做这个的： com.tencent.matrix.trace.core.AppMethodBeat.IndexRecord 12345678public static final class IndexRecord &#123; public int index; private IndexRecord next; public boolean isValid = true; public String source;&#125; index 字段是用来记录 sBuffer 中的位置的。next 说明它是一个链表。 用法如下： 比如我们在，分发消息之前，首先调用 com.tencent.matrix.trace.core.AppMethodBeat#maskIndex 方法，传递一个 source 作为参数，得到一个 IndexRecord 对象，然后在分发消息结束后，再获取拿到 sIndex 的值，这样就有了两个 sIndex。取出这个范围里面的数据就好了。 123AppMethodBeat.IndexRecord beginRecord = AppMethodBeat.getInstance().maskIndex("AnrTracer#dispatchBegin");long[] data = AppMethodBeat.getInstance().copyData(beginRecord);beginRecord.release(); AppMethodBeat 里面重要的方法就分析完了，我们看看上面忽略的 ActivityThreadHacker 这个类。这个类也很简单，主要就是 hook ActivityThread的内部类 H 这个类。 hook Hanlder 一般使用 callback 的方式，不清楚的可以看下消息分发优先级。 com.tencent.matrix.trace.hacker.ActivityThreadHacker#hackSysHandlerCallback 12345678910111213141516171819202122public static void hackSysHandlerCallback() &#123; try &#123; sApplicationCreateBeginTime = SystemClock.uptimeMillis(); sApplicationCreateBeginMethodIndex = AppMethodBeat.getInstance().maskIndex("ApplicationCreateBeginMethodIndex"); Class&lt;?&gt; forName = Class.forName("android.app.ActivityThread"); Field field = forName.getDeclaredField("sCurrentActivityThread"); field.setAccessible(true); Object activityThreadValue = field.get(forName); Field mH = forName.getDeclaredField("mH"); mH.setAccessible(true); Object handler = mH.get(activityThreadValue); Class&lt;?&gt; handlerClass = handler.getClass().getSuperclass(); Field callbackField = handlerClass.getDeclaredField("mCallback"); callbackField.setAccessible(true); Handler.Callback originalCallback = (Handler.Callback) callbackField.get(handler); HackCallback callback = new HackCallback(originalCallback); callbackField.set(handler, callback); MatrixLog.i(TAG, "hook system handler completed. start:%s SDK_INT:%s", sApplicationCreateBeginTime, Build.VERSION.SDK_INT); &#125; catch (Exception e) &#123; MatrixLog.e(TAG, "hook system handler err! %s", e.getCause().toString()); &#125;&#125; 那么，我们直接看 HackCallback 做了什么： com.tencent.matrix.trace.hacker.ActivityThreadHacker.HackCallback 1234567891011121314151617181920212223242526public boolean handleMessage(Message msg) &#123; if (!AppMethodBeat.isRealTrace()) &#123; return null != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg); &#125; boolean isLaunchActivity = isLaunchActivity(msg); if (hasPrint &gt; 0) &#123; MatrixLog.i(TAG, "[handleMessage] msg.what:%s begin:%s isLaunchActivity:%s", msg.what, SystemClock.uptimeMillis(), isLaunchActivity); hasPrint--; &#125; if (isLaunchActivity) &#123; ActivityThreadHacker.sLastLaunchActivityTime = SystemClock.uptimeMillis(); ActivityThreadHacker.sLastLaunchActivityMethodIndex = AppMethodBeat.getInstance().maskIndex("LastLaunchActivityMethodIndex"); &#125; if (!isCreated) &#123; if (isLaunchActivity || msg.what == CREATE_SERVICE || msg.what == RECEIVER) &#123; // todo for provider ActivityThreadHacker.sApplicationCreateEndTime = SystemClock.uptimeMillis(); ActivityThreadHacker.sApplicationCreateScene = msg.what; isCreated = true; &#125; &#125; return null != mOriginalCallback &amp;&amp; mOriginalCallback.handleMessage(msg);&#125; 是对 activity 的启动做了监控。记录了 activity 启动的时间，记录了对应的 sIndex，以便后面进行启动分析。 还记录了 application 的启动情况，原理是，如果是第一次启动一个 activity，那么记录当前时间，这个时间就当成 application 创建完成的时间，还记录了启动场景，因为启动APP的，可以有 Activity，Service，BroadcastReceiver 等。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HttpDnsLib分析]]></title>
    <url>%2F2020%2F06%2F30%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2FHttpDnsLib%2FHttpDnsLib%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[框架地址：https://github.com/CNSRE/HTTPDNSLib先从，框架的几个模块开始介绍。测速模块对于一个大型app来说，在全国会有多个服务器， 每个服务器的ip地址肯定也是不一致的，所以对于不同地区的用户，一般情况下与之最近的服务器肯定访问最快，测速模块就是找到访问最快的服务器。 测速有两种方法，第一种是使用 ping 命令，第二种是使用 socket。下面分别介绍： Ping1234567891011121314151617181920212223242526272829303132333435363738394041public static class Ping &#123; // ping -c1 -s1 -w1 www.baidu.com //-w 超时单位是s private static final String TAG_BYTES_FROM = "bytes from "; public static int runcmd(String cmd) throws Exception &#123; Runtime runtime = Runtime.getRuntime(); Process proc = null; final String command = cmd.trim(); // 这里计算的是命令跑完的时间，而不是ping输出的时间 long startTime = System.currentTimeMillis(); proc = runtime.exec(command); proc.waitFor(); long endTime = System.currentTimeMillis(); InputStream inputStream = proc.getInputStream(); String result = "unknown ip"; BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuilder resultBuilder = new StringBuilder(); String line = ""; while (null != (line = reader.readLine())) &#123; resultBuilder.append(line); &#125; reader.close(); String responseStr = resultBuilder.toString(); result = responseStr.toLowerCase().trim(); if (isValidResult(result)) &#123; return (int) (endTime - startTime); &#125; return SpeedtestManager.OCUR_ERROR; &#125; private static boolean isValidResult(String result) &#123; if (!TextUtils.isEmpty(result)) &#123; if (result.indexOf(TAG_BYTES_FROM) &gt; 0) &#123; return true; &#125; &#125; return false; &#125;&#125; 这段代码其实就是使用 Runtime 执行了一个 ping 命令，但是它测的时间是这个命令同步执行耗费的时间，而不是命令返回的结果里面的时间。 Socket1234567891011121314151617181920212223public int speedTest(String ip, String host) &#123; Socket socket = null; try &#123; // 计算的是 socket 的 connect 连接时间 long begin = System.currentTimeMillis(); Socket s1 = new Socket(); s1.connect(new InetSocketAddress(ip, 80), TIMEOUT); long end = System.currentTimeMillis(); int rtt = (int) (end - begin); return rtt; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != socket) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return SpeedtestManager.OCUR_ERROR;&#125; 使用的 Socket 的 connect 方法来测量访问速度。 在进行测速的时候，会优先使用 Socket 来测速，如果 Socket 测通了，那么就不会再使用 Ping 来测速了。 评分模块框架里面虽然缓存了各个域名的IP地址，但是有效期只有1分钟，所以开了一个任务来不断的更新过期的域名IP。 更新了IP之后，也会对新IP进行测速，在测速后会统计该IP测试通过– 成功的次数，失败的次数，最后成功的时间，以及RTT值，另外还有一个HttpDns服务器返回IP的时候会带一个优先级，这个也计入评分项。 RTT 的概念可以自己搜索一下。 成功的次数使用上面的测速模块对IP进行测速之后，我们记录一下测速状态： 12345678910111213for (IpModel ipModel : ipArray) &#123; int rtt = speedtestManager.speedTest(ipModel.ip, domainModel.domain); boolean succ = rtt &gt; SpeedtestManager.OCUR_ERROR; if (succ) &#123; ipModel.rtt = String.valueOf(rtt); ipModel.success_num = String.valueOf((Integer.parseInt(ipModel.success_num) + 1)); ipModel.finally_success_time = String.valueOf(System.currentTimeMillis()); &#125; else &#123; ipModel.rtt = String.valueOf(SpeedtestManager.MAX_OVERTIME_RTT); ipModel.err_num = String.valueOf((Integer.valueOf(ipModel.err_num) + 1)); ipModel.finally_fail_time = String.valueOf(System.currentTimeMillis()); &#125;&#125; 代码逻辑很简单： 如果成功了，记录RTT值，成功次数加一，记录成功时间。 如果失败了，RTT记为9999，失败次数加一，记录失败时间。 我们看一下成功次数这一项对评分的影响： 1234567891011121314151617181920212223242526272829public void run(ArrayList&lt;IpModel&gt; list) &#123; // 查找到最大历史成功次数 float MAX_SUCCESSNUM = 0; for (IpModel temp : list) &#123; if (temp.success_num == null || temp.success_num.equals("")) continue; float successNum = Float.parseFloat(temp.success_num); MAX_SUCCESSNUM = Math.max(MAX_SUCCESSNUM, successNum); &#125; // 计算比值 if (MAX_SUCCESSNUM == 0) &#123; return; &#125; float bi = getWeight() / MAX_SUCCESSNUM; // 计算得分 for (IpModel temp : list) &#123; if (temp.success_num == null || temp.success_num.equals(""))&#123; continue; &#125; float successNum = Float.parseFloat(temp.success_num); temp.grade += (successNum * bi); &#125;&#125;public float getWeight() &#123; return PlugInManager.SuccessNumPluginNum;&#125; 逻辑不负责，使用的是比较简单的评分算法，找到所有IP的最大成功次数，然后按照自己的成功次数计算出一个比例，在诚意一个固定的值。 这种算法最神奇的地方就是参数了，没人知道为什么是这个参数，但是它就是可以工作。所以调参是个技术活。 其他项的评分算法其实是一样的逻辑，就不过多的介绍了，再拿RTT举个例子吧。 RTT1234567891011121314151617181920212223242526272829@Overridepublic void run(ArrayList&lt;IpModel&gt; list) &#123; // 查找到最大速度 float MAX_SPEED = 0; for (IpModel temp : list) &#123; if (temp.rtt == null || temp.rtt.equals("")) continue; float finallySpeed = Float.parseFloat(temp.rtt); MAX_SPEED = Math.max(MAX_SPEED, finallySpeed); &#125; // 计算比值 if (MAX_SPEED == 0) &#123; return; &#125; float bi = getWeight() / MAX_SPEED; // 计算得分 for (IpModel temp : list) &#123; if (temp.rtt == null || temp.rtt.equals(""))&#123; continue; &#125; float finallySpeed = Float.parseFloat(temp.rtt); temp.grade += (getWeight() - (finallySpeed * bi)); &#125;&#125;@Overridepublic float getWeight() &#123; return PlugInManager.SpeedTestPluginNum;&#125; 唯一不同点就是，RTT越小，评分应该越高，所以采用的是减法。 DNS服务器模块我一直以为HttpDns服务器要一个就够用了，没想到真是开了眼界了。这个库里面有4个DNS服务器，其中有一个是本地服务器。 PodDns这个是一个免费的HttpDns。 12345678910111213141516171819202122232425262728293031323334public HttpDnsPack requestDns(String domain) &#123; // 如果新浪自家的服务器没有拿到数据，或者数据有问题，则使用 dnspod 提供的接口获取数据 String jsonDataStr = null; HttpDnsPack dnsPack = null; String dnspod_httpdns_api_url = DnsConfig.DNSPOD_SERVER_API + DNSPodCipher.Encryption(domain); jsonDataStr = netWork.requests(dnspod_httpdns_api_url); if (jsonDataStr == null || jsonDataStr.equals("")) return null; // 如果dnspod 也没提取到数据 则返回空 jsonDataStr = DNSPodCipher.Decryption(jsonDataStr); dnsPack = new HttpDnsPack(); try &#123; String IP_TTL[] = jsonDataStr.split(","); String IPArr[] = IP_TTL[0].split(";"); String TTL = IP_TTL[1]; dnsPack.rawResult = jsonDataStr; dnsPack.domain = domain; dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress(); dnsPack.device_sp = NetworkManager.getInstance().getSPID() ; dnsPack.dns = new HttpDnsPack.IP[IPArr.length]; for (int i = 0; i &lt; IPArr.length; i++) &#123; dnsPack.dns[i] = new HttpDnsPack.IP(); dnsPack.dns[i].ip = IPArr[i]; dnsPack.dns[i].ttl = TTL; dnsPack.dns[i].priority = "0"; &#125; &#125; catch (Exception e) &#123; dnsPack = null; &#125; return dnsPack;&#125; 这个就没啥好说的了，就是按照文档里面的来就好了。值得一提的是，因为这个免费的返回数据里面并没有提供Model里面的各个字段（比自身的HttpDns服务器返回的字段少了一些，所以有些字段需要自己拼一下）。 比如，设备的ip与运营商。关于运营商还有个小知识点需要说一下： 在客户端内如果是手机网络可以知道网络类型（2G、3G、4G）也可以知道当前SP（移动、联通、电信）. 如果是Wifi网络环境可以知道SSID，但是无法知道当前SP. LocalDns这个是本地的Dns，使用的是 InetAddress 来获取对应的域名 IP。 12345678910111213141516171819202122232425262728293031323334353637public HttpDnsPack requestDns(String domain) &#123; try &#123; InetAddress[] addresses = InetAddress.getAllByName(domain); String[] ipList = new String[addresses.length]; for (int i = 0; i &lt; addresses.length; i++) &#123; ipList[i] = addresses[i].getHostAddress(); &#125; if (null != ipList &amp;&amp; ipList.length &gt; 0) &#123; HttpDnsPack dnsPack = new HttpDnsPack(); String IPArr[] = ipList; String TTL = "60"; dnsPack.domain = domain; dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress(); dnsPack.device_sp = NetworkManager.getInstance().getSPID() ; dnsPack.rawResult = "domain:" + domain + ";\nipArray:"; dnsPack.dns = new HttpDnsPack.IP[IPArr.length]; for (int i = 0; i &lt; IPArr.length; i++) &#123; String ip = IPArr[i]; if (i == IPArr.length - 1) &#123; //去掉最后的逗号 dnsPack.rawResult += (ip); &#125; else &#123; dnsPack.rawResult += (ip + ","); &#125; dnsPack.dns[i] = new HttpDnsPack.IP(); dnsPack.dns[i].ip = ip; dnsPack.dns[i].ttl = TTL; dnsPack.dns[i].priority = "0"; &#125; return dnsPack; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 这个也很简单，就是利用一些信息，在本地自己拼出来一个HttpDnsPack对象。 SinaHttpDns12345678910111213141516171819202122232425public HttpDnsPack requestDns(String domain) &#123; String jsonDataStr = null; HttpDnsPack dnsPack = null; ArrayList&lt;String&gt; serverApis = new ArrayList&lt;String&gt;(); serverApis.addAll(DnsConfig.SINA_HTTPDNS_SERVER_API); while (null == dnsPack &amp;&amp; serverApis.size() &gt; 0) &#123; try &#123; String api = ""; int index = serverApis.indexOf(usingServerApi); if (index != -1) &#123; api = serverApis.remove(index); &#125; else &#123; api = serverApis.remove(0); &#125; String sina_httpdns_api_url = api + domain; jsonDataStr = netWork.requests(sina_httpdns_api_url); dnsPack = jsonObj.JsonStrToObj(jsonDataStr); usingServerApi = api; &#125; catch (Exception e) &#123; e.printStackTrace(); usingServerApi = ""; &#125; &#125; return dnsPack;&#125; 自身的服务器，返回的数据直接使用 Json 转对象了，没啥好说的。 里面的逻辑有做一个循环，是因为它的请求地址有多个，一个不行再试另外一个。 UdpDns这个应该是访问的公共的DNS服务器。 1234567891011121314151617181920212223242526public HttpDnsPack requestDns(String domain) &#123; try &#123; UdpDnsInfo info = UdnDnsClient.query(DnsConfig.UDPDNS_SERVER_API, domain); if (null != info &amp;&amp; info.ips.length &gt; 0) &#123; HttpDnsPack dnsPack = new HttpDnsPack(); String IPArr[] = info.ips; String TTL = String.valueOf(info.ttl); dnsPack.rawResult = "domain : " + domain + "\n" + info.toString(); dnsPack.domain = domain; dnsPack.device_ip = NetworkManager.Util.getLocalIpAddress(); dnsPack.device_sp = NetworkManager.getInstance().getSPID(); dnsPack.dns = new HttpDnsPack.IP[IPArr.length]; for (int i = 0; i &lt; IPArr.length; i++) &#123; dnsPack.dns[i] = new HttpDnsPack.IP(); dnsPack.dns[i].ip = IPArr[i]; dnsPack.dns[i].ttl = TTL; dnsPack.dns[i].priority = "0"; &#125; return dnsPack; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 一共有4个服务器，他们也是有优先级的，与测速一样，优先级高的跑通了，后面的就不再跑了。 我们总结一下上面的3个模块： DNS模块是获取域名对应的IP地址 测速模块是对IP地址进行测速 评分模块是对IP地址的访问状况做评分，选出最好的 基本上，经过这3个模块后，我们就可以拿到表现最好的IP地址了。但是这还不够，接下来还有几个模块需要介绍。 缓存模块我们从 HttpDns 服务器里面请求下来了那么多数据，而且我们还设置了IP的有效期为一分钟，会不断的更新这些数据，所以将这些数据进行缓存是非常有必要的。 缓存分为两部分，内存与数据库。 内存就比较简单，就是一个ConcurrentHashMap。 1234/** * 缓存链表，域名与 DomainModel 的键值对。 */private ConcurrentHashMap&lt;String, DomainModel&gt; data = new ConcurrentHashMap&lt;String, DomainModel&gt;(INIT_SIZE, MAX_CACHE_SIZE); 数据库是分为了三个表： 123db.execSQL(CREATE_DOMAIN_TABLE_SQL);db.execSQL(CREATE_IP_TEBLE_SQL);db.execSQL(CREATE_CONNECT_FAIL_TABLE_SQL); DOMAIN表 是域名。 IP表 是域名对应的IP集合。 DOMAIN 与 IP 是关联的。 CONNECT_FAIL表 是用于上报，这里不分析。 我们先来看一下数据模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public class DomainModel &#123; /** * 自增id &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_ID 字段 &lt;br&gt; */ public long id = -1 ; /** * 域名 &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_DOMAIN 字段 &lt;br&gt; */ public String domain = "" ; /** * 运营商 &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_SP 字段 &lt;br&gt; */ public String sp = "" ; /** * 域名过期时间 &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_TTL 字段 &lt;br&gt; */ public String ttl = "0" ; /** * 域名最后查询时间 &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants &#125; DOMAIN_COLUMN_TIME 字段 &lt;br&gt; */ public String time = "0" ; /** * 域名关联的ip数组 &lt;br&gt; */ public ArrayList&lt;IpModel&gt; ipModelArr = null ; &#125;public class IpModel &#123; /** * 自增id &lt;br&gt; * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_ID &#125;字段 &lt;br&gt; */ public long id = -1 ; /** * domain id 关联id * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_DOMAIN_ID &#125;字段 &lt;br&gt; */ public long d_id = -1 ; /** * 服务器ip地址 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PORT &#125;字段 &lt;br&gt; */ public String ip = "" ; /** * ip服务器对应的端口 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PORT &#125;字段 &lt;br&gt; */ public int port = -1 ; /** * ip服务器对应的sp运营商 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_SP &#125;字段 &lt;br&gt; */ public String sp = "" ; /** * ip过期时间 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_TTL &#125;字段 &lt;br&gt; */ public String ttl = "0" ; /** * ip服务器优先级-排序算法策略使用 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PRIORITY &#125;字段 &lt;br&gt; */ public String priority = "0" ; /** * 访问ip服务器的往返时延 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_PRIORITY &#125;&#125;字段 &lt;br&gt; */ public String rtt = "0" ; /** * ip服务器链接产生的成功数 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_SUCCESS_NUM &#125;字段 &lt;br&gt; */ public String success_num = "0" ; /** * ip服务器链接产生的错误数 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_ERR_NUM &#125;字段 &lt;br&gt; */ public String err_num = "0" ; /** * ip服务器最后成功链接时间 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_FINALLY_SUCCESS_TIME &#125;字段 &lt;br&gt; */ public String finally_success_time = "0" ; /** * ip服务器最后失败链接时间 * * 该字段映射类 &#123;@link com.sina.util.dnscache.cache.DBConstants#IP_COLUMN_FINALLY_FAIL_TIME &#125;字段 &lt;br&gt; */ public String finally_fail_time = "0" ; /** * 评估体系 评分分值 */ public float grade = 0 ; &#125; 可以看出。数据库就是储存了这些对象的信息。 我们看一下缓存对外暴露的接口： 123456789101112131415161718192021222324/** * 获取 domain 缓存 * * @param sp * @param domain * @return */public DomainModel getDnsCache(String sp, String domain);/** * 插入一条缓存记录 * * @param dnsPack * @return */public DomainModel insertDnsCache(HttpDnsPack dnsPack);/** * 获取缓存中全部的 DomainModel数据 * * @return */public ArrayList&lt;DomainModel&gt; getAllMemoryCache(); 这里我只列出了3个，还有很多，但是这3个可以说明缓存的大致作用，就是将服务器请求的数据缓存起来，然后用时可以查找取出。 定时器定时器是属于缓存模块的，但是我个人是觉得很重要的，因为只有开了定时器，才会不断的去 HttpDns 服务器中去同步IP地址。 12345678910111213141516171819202122232425262728293031323334private TimerTask task = new TimerTask() &#123; @Override public void run() &#123; timerTaskOldRunTime = System.currentTimeMillis(); //无网络情况下不执行任何后台任务操作 if (NetworkManager.Util.getNetworkType() == Constants.NETWORK_TYPE_UNCONNECTED || NetworkManager.Util.getNetworkType() == Constants.MOBILE_UNKNOWN) &#123; return; &#125; /************************* 更新过期数据 ********************************/ Thread.currentThread().setName("HTTP DNS TimerTask"); final ArrayList&lt;DomainModel&gt; list = dnsCacheManager.getExpireDnsCache(); for (DomainModel model : list) &#123; checkUpdates(model.domain, false); &#125; long now = System.currentTimeMillis(); /************************* 测速逻辑 ********************************/ if (now - lastSpeedTime &gt; SpeedtestManager.time_interval - 3) &#123; lastSpeedTime = now; RealTimeThreadPool.getInstance().execute(new SpeedTestTask()); &#125; /************************* 日志上报相关 ********************************/ now = System.currentTimeMillis(); if (HttpDnsLogManager.LOG_UPLOAD_SWITCH &amp;&amp; now - lastLogTime &gt; HttpDnsLogManager.time_interval) &#123; lastLogTime = now; // 判断当前是wifi网络才能上传 if (NetworkManager.Util.getNetworkType() == Constants.NETWORK_TYPE_WIFI) &#123; RealTimeThreadPool.getInstance().execute(new LogUpLoadTask()); &#125; &#125; &#125;&#125;; 这个任务逻辑很清晰： 先更新缓存中过期的数据，然后对缓存中所有的IP，重新进行测速。 这样，一个完整的库就差不多写好了。]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[002-Matrix源码分析：UIThreadMonitor监测主线程]]></title>
    <url>%2F2020%2F06%2F30%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F002-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AUIThreadMonitor%E7%9B%91%E6%B5%8B%E4%B8%BB%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[常说的一个问题：为啥Looper有个死循环却不会阻塞主线程？？？这是因为我们所谓的主线程就是这个死循环。我们的每一帧都是封装成了消息然后被分发，在主线程处理，主线程是不断的在处理这些消息，如果什么时候有个特别耗时的消息来了，那么主线程就会卡死。上面说了一个题外话，我们现在来看看如何监测主线程。了解这个类还需要一点预备知识： FrameDisplayEventReceiver 在收到 VSYNC 信号之后，会调用 doFrame 方法，而 doFrame 方法就会处理 Choreographer.CALLBACK_INPUT，Choreographer.CALLBACK_ANIMATION，Choreographer.CALLBACK_TRAVERSAL这些东西。 他们分别是 事件处理，动画，界面绘制相关的东西。比如对于属性动画，它注册了帧回调，会将相关代码添加到 Choreographer 的动画队列里面，然后下一帧就会被执行，动画也就得到了处理。 doFrame方法本身也是一个 message： 1Message msg = mHandler.obtainMessage(MSG_DO_FRAME); 这里发送了一个消息，然后接受者会处理消息，处理这个消息的时候会调用 doFrame 方法，可以认为这个 doFrame 方法是在Looper的Printer的两个打印代码之间执行的。 所以相当于这个类将消息的处理过程更加细化了，我们看看代码： com.tencent.matrix.trace.core.UIThreadMonitor#init 12345678choreographer = Choreographer.getInstance();callbackQueueLock = reflectObject(choreographer, "mLock");callbackQueues = reflectObject(choreographer, "mCallbackQueues");addInputQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_INPUT], ADD_CALLBACK, long.class, Object.class, Object.class);addAnimationQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_ANIMATION], ADD_CALLBACK, long.class, Object.class, Object.class);addTraversalQueue = reflectChoreographerMethod(callbackQueues[CALLBACK_TRAVERSAL], ADD_CALLBACK, long.class, Object.class, Object.class);frameIntervalNanos = reflectObject(choreographer, "mFrameIntervalNanos"); 这里是使用反射获取了 Choreographer 类的一些字段与方法，后面会用于向队列里面添加回调。 com.tencent.matrix.trace.core.UIThreadMonitor#init 12345678910111213141516171819LooperMonitor.register(new LooperMonitor.LooperDispatchListener() &#123; @Override public boolean isValid() &#123; return isAlive; &#125; @Override public void dispatchStart() &#123; super.dispatchStart(); UIThreadMonitor.this.dispatchBegin(); &#125; @Override public void dispatchEnd() &#123; super.dispatchEnd(); UIThreadMonitor.this.dispatchEnd(); &#125;&#125;); 接下来就是注册了监听，这个监听的触发时机上一节我们分析过，分发消息的时候会成对的回调。我们继续看 dispatchBegin 与 dispatchEnd： com.tencent.matrix.trace.core.UIThreadMonitor#dispatchBegin 12345678910111213private void dispatchBegin() &#123; token = dispatchTimeMs[0] = SystemClock.uptimeMillis(); dispatchTimeMs[2] = SystemClock.currentThreadTimeMillis(); AppMethodBeat.i(AppMethodBeat.METHOD_ID_DISPATCH); synchronized (observers) &#123; for (LooperObserver observer : observers) &#123; if (!observer.isDispatchBegin()) &#123; observer.dispatchBegin(dispatchTimeMs[0], dispatchTimeMs[2], token); &#125; &#125; &#125;&#125; 记录了一些时间： dispatchTimeMs[0] 是手机从启动到现在的时间。 dispatchTimeMs[2] 是线程运行的时间。 然后是通知自己的 observers，相当于又转了一下，利用 LooperDispatchListener 来通知自己的 LooperObserver。 com.tencent.matrix.trace.core.UIThreadMonitor#dispatchEnd 12345678910111213141516171819202122232425262728293031private void dispatchEnd() &#123; if (isBelongFrame) &#123; doFrameEnd(token); &#125; long start = token; long end = SystemClock.uptimeMillis(); synchronized (observers) &#123; for (LooperObserver observer : observers) &#123; if (observer.isDispatchBegin()) &#123; observer.doFrame(AppMethodBeat.getVisibleScene(), token, SystemClock.uptimeMillis(), isBelongFrame ? end - start : 0, queueCost[CALLBACK_INPUT], queueCost[CALLBACK_ANIMATION], queueCost[CALLBACK_TRAVERSAL]); &#125; &#125; &#125; dispatchTimeMs[3] = SystemClock.currentThreadTimeMillis(); dispatchTimeMs[1] = SystemClock.uptimeMillis(); AppMethodBeat.o(AppMethodBeat.METHOD_ID_DISPATCH); synchronized (observers) &#123; for (LooperObserver observer : observers) &#123; if (observer.isDispatchBegin()) &#123; observer.dispatchEnd(dispatchTimeMs[0], dispatchTimeMs[2], dispatchTimeMs[1], dispatchTimeMs[3], token, isBelongFrame); &#125; &#125; &#125;&#125; dispatchEnd 方法要稍微复杂一点，但是还是一样的，它也是记录了一些时间： dispatchTimeMs[3] 是线程运行时间，与 dispatchTimeMs[2] 对应起来看就可以知道线程执行这个消息的耗时。 dispatchTimeMs[1] 是手机从启动到现在的时间，dispatchTimeMs[0] 对应就可以知道该方法现实时间的耗时。注意两个耗时的区别，现实耗时是大于线程耗时的，因为线程会切片运行。 这个方法，也主要是回调了 observer.doFrame 和 observer.dispatchEnd 两个方法。 这里有个地方有点疑问：按照 LooperObserver 的3个方法来看，显然是要监测 doFrame 的运行情况，而 doFrame 只是一个特定的消息才会回调，假如我随便发送了一个普通的消息，也会触发这3个回调，那不是有问题吗？ 我调试了一下这个回调，发现如下日志： 123activityName[com.example.sample.MainActivity] frame cost:0ms [104300|2480|218640]ns000000000activityName[com.example.sample.MainActivity] frame cost:0ms [104300|2480|218640]ns 我使用hander发送了一个message，打印出来的日志是这样的，就是说如果不是执行的 doFrame 的消息，frameCostMs 是 0，其余的是上一帧的值。 我们注意一下就行了，上面的函数中，开头就有一个 if 判断，这个很重要，里面涉及到我们上面所说的3个队列。 让我们从头道来： 首先，外部会调用该类的 onStart 方法： com.tencent.matrix.trace.core.UIThreadMonitor#onStart 1234567891011121314151617public synchronized void onStart() &#123; if (!isInit) &#123; throw new RuntimeException("never init!"); &#125; if (!isAlive) &#123; this.isAlive = true; synchronized (this) &#123; MatrixLog.i(TAG, "[onStart] callbackExist:%s %s", Arrays.toString(callbackExist), Utils.getStack()); callbackExist = new boolean[CALLBACK_LAST + 1]; &#125; // queueStatus 存放状态，队列开始执行时，置为 DO_QUEUE_BEGIN，队列执行完毕时，置为 DO_QUEUE_END。 queueStatus = new int[CALLBACK_LAST + 1]; // queueCost 存放队列执行完毕的时间。 queueCost = new long[CALLBACK_LAST + 1]; addFrameCallback(CALLBACK_INPUT, this, true); &#125;&#125; 这里做了些初始化的判断，以及创建了一些数组，这个数组就是用来存放那3个队列的相关信息的。 最后一行代码，往 input 队列里面添加了一个 runnable，这个 runnable 就是自己，所以当input队列执行的时候会运行该类的 run 方法。 com.tencent.matrix.trace.core.UIThreadMonitor#run 1234567891011121314151617181920212223242526272829303132333435363738public void run() &#123; final long start = System.nanoTime(); try &#123; // 这个方法里面就做了一件事，就是将 isBelongFrame 置为 true doFrameBegin(token); // 开始执行 input 队列 doQueueBegin(CALLBACK_INPUT); // 向 animation 队列添加一个 runnable addFrameCallback(CALLBACK_ANIMATION, new Runnable() &#123; @Override public void run() &#123; // input队列执行结束 doQueueEnd(CALLBACK_INPUT); // 开始执行 animation 队列 doQueueBegin(CALLBACK_ANIMATION); &#125; &#125;, true); // 向 traversal 队列添加一个 runnable addFrameCallback(CALLBACK_TRAVERSAL, new Runnable() &#123; @Override public void run() &#123; // animation 队列执行结束 doQueueEnd(CALLBACK_ANIMATION); // 开始执行 traversal 队列 doQueueBegin(CALLBACK_TRAVERSAL); &#125; &#125;, true); &#125; finally &#123; if (config.isDevEnv()) &#123; MatrixLog.d(TAG, "[UIThreadMonitor#run] inner cost:%sns", System.nanoTime() - start); &#125; &#125;&#125; 这里其实就是向3个队列的头部插入 runnable，然后执行runnable的时候，调用对应的 begin与end方法。 com.tencent.matrix.trace.core.UIThreadMonitor#doQueueBegin com.tencent.matrix.trace.core.UIThreadMonitor#doQueueEnd 123456789101112private void doQueueBegin(int type) &#123; queueStatus[type] = DO_QUEUE_BEGIN; queueCost[type] = System.nanoTime();&#125;private void doQueueEnd(int type) &#123; queueStatus[type] = DO_QUEUE_END; queueCost[type] = System.nanoTime() - queueCost[type]; synchronized (this) &#123; callbackExist[type] = false; &#125;&#125; 这两方法啊就是设置队列的运行状态，计算队列的执行耗时。 最后总结，这个类做了两件事： 记录了3个队列的耗时 提供了 LooperObserver 回调，doFrame回调可以获取到 doFrame（Choreographer）的耗时，也可以知道每个消息处理的耗时（dispatchEnd）。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程007：QUIC协议]]></title>
    <url>%2F2020%2F06%2F22%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B007%EF%BC%9AQUIC%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP协议在创建连接之前需要进行三次握手：如果是传输加密数据的话，还需要建立 TLS 连接，握手次数更多：前面我们说过，TCP在网络稳定的情况下性能会比较好，但是在弱网情况下就会暴露出许多问题。QUIC协议登场QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。 UDP 协议是无连接协议。它无需在传输层对数据包进行确认，为了确保数据传输的可靠性，应用层协议需要自己完成包传输情况的确认。 这其实是一种很常见的优化思路：由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。所以采用UDP，然后将TCP的一些特性自己接管过来实现，这样就可以自由选择，甚至根据应用场景自由调整优化。 QUIC 核心特性建立连接需要的 RTT 少 RTT(Round-Trip Time)：往返时延。 是客户端发送数据，到收到回应的时间。 TCP协议的RTT主要是多在 TCP的三次握手上。TLS1.3的握手只需要一个 RTT。所以QUIC的握手应该是和1.3差不多的，或者它会直接使用TLS1.3，囧，我也没去细看这些。 改进的拥塞控制从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点。 单调递增的 Packet NumberTCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。 但是这样会导致一个问题： 如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断！！！ RTT 采样的结果会影响RTO，而 RTO 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。 如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。 没有队头阻塞的多路复用 HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。 不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞。 Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。 当 Record 大小超过了 MTU 的时候，就会分多个数据包发送。 那 QUIC 多路复用为什么能避免上述问题呢？ QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞； Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。 连接迁移一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。 什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。 比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。 那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。 由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。 还有其他的新特性，暂时就不介绍了。 最新的HTTP3也是基于QUIC的，所以，是一种趋势。 参考文档http://www.52im.net/thread-1309-1-1.html http://www.52im.net/thread-2816-1-1.html https://liudanking.com/network/tls1-3-quic-%E6%98%AF%E6%80%8E%E6%A0%B7%E5%81%9A%E5%88%B0-0-rtt-%E7%9A%84/ http://www.52im.net/thread-515-1-1.html]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程007：IP地址与MAC地址]]></title>
    <url>%2F2020%2F06%2F18%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B006%EF%BC%9AIP%E5%9C%B0%E5%9D%80%E4%B8%8EMAC%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[经过前面几篇文章的洗礼，你应该知道IP地址与MAC地址各自的作用。我自己的理解就是：IP地址是用来连接子网的，MAC地址是用来处理子网内部的。但是这只是比较粗浅的理解，如果有人问到：12有了IP地址，为何还要用MAC地址？或者，有了MAC地址，为何还要IP地址？对于这些问题，你该如何给他解释清楚呢？我们先来探讨一下，没有IP地址的情况： 一开始时，网络中的机器并不多。大家都连到同一个集线器就可以了，就可以实现互通。这时，机器 A 发消息到机器 B ，消息头里附上机器 B 的MAC，集线器收到消息后就广播给所有连到集线器的机器。 机器 C 收到消息，发现消息里的 MAC 地址和自己的不一样，就丢弃。机器B发现消息里的 MAC 地址和自己一样，就收到下并解析。 这样机制带来问题很明显：首先每次广播，给所在网络带来不必要的浪费。所以，就出现了交换机。它能识别消息里的目标 MAC 地址后，直接就消息丢到机器 B 所连接的端口中。另一个角度，交换机必须记住所有的 MAC 地址和端口之间的关系。 这样的机制在网络规规模小的时候是高效的。但是当网络规模扩大到全球的时候，不可能让一台交换机记录下全球这么多的网络设备，也不可能让全球的机器连接到一台交换机上。 一个交换机无法解决，那么多个交换机可以解决吗？可以解决部分问题，如下图： 但是随着网络越来越大，交换机越来越多，那么交换机之间还是只能采用广播的方式来通信，显然是不可取的。 也就是说，当两个网络互接时，MAC 地址 + 交换机还能解决问题广播问题，但是两个以上的网络互连时，MAC 地址 + 交换机就没有办法解决广播问题了。 我们再来探讨一下，没有MAC地址的情况：我们知道OSI 7层模型，IP、TCP分别对应第三层和四层，因特网协议族并没有覆盖完整的7层 。 因特网并不存粹，还包括以太网。因为因特网是第三层协议，是没有根基的“空中楼阁”，需要以太网这样的2层网具体落地实施，而MAC地址又是2层概念，所以MAC地址就这样进入了因特网的体系结构。 当然了，如果因特网从开始制定之初，就定义了从物理层到传输层的协议，那么因特网就不再依赖于其它任何的网络，这个纯粹的因特网就只需要纯粹的IP地址，网线所插上的也不再是以太网卡，而是“因特网卡”，既然没有了以太网，也就不用什么MAC地址了。 说了历史原因，我们再说一个现实的问题： 因为 IP 地址是要设备上线以后，才能根据他进入了哪个子网来分配的，在设备还没有 IP 地址的时候（或者分配 IP 地址的过程中），我们还需要用 MAC 地址来区分不同的设备。 所以说，在现在的这个模型体系下，MAC地址是不能被省去的。 ARP攻击ARP（Address Resolution Protocol），即地址解析协议，我们前面的文章说到过，是根据IP地址解析物理地址的一个TCP/IP协议。 我们通过图解的方式来深入了解ARP攻击是如何实现的。 在这个局域网里面，PC1、PC2、PC3三台主机共同连接到交换机SW1上面，对应3个接口port1/2/3。假设PC3这台主机安装了ARP攻击软件或遭受ARP病毒，成为这个网络的攻击者（hacker），接下来，PC3是如何攻击的？先不急，先来回顾下PC1和PC2是如何通信的。 我们来看看PC3（Hacker）是如何发起ARP攻击的=&gt; 正常情况下，若收到的ARP请求不是给自己的，则直接丢弃；而这里PC3（Hacker）在监听之后，发起了ARP回应包：我就是PC2（IP2-MAC3）。 从拓扑可以出现，PC3明明是IP3对应MAC3，很显然这就是一个ARP欺骗行为。于此同时，PC2正常的ARP回应包也交到了PC1手中，我们来看PC1接下来如何处理的： PC1收到两个ARP回应包，内容分别如下： ③我是PC2，我的IP地址是IP2，我的MAC地址是MAC2； ③我是PC2，我的IP地址是IP2，我的MAC地址是MAC3； PC1一脸懵：咋回事？还有这操作？不管了，我选最新的！（后到优先） 那么问题来了，上面两个ARP回应包到底哪个先到哪个后到呢？ 作为初学者，可能还在纠结前后这种naive的问题；而作为hacker，只要持续不停发出ARP欺骗包，就一定能够覆盖掉正常的ARP回应包。稳健的ARP嗅探/渗透工具，能在短时间内高并发做网络扫描（例如1秒钟成千上百的数据包），能够持续对外发送欺骗包。 无论如何，当PC1和PC2这种”小白”用户遇到PC3（hacker）时，最终的结果一定是这样的： 其实就是，不断和发送 ARP 回复包，包里面的是自己的 MAC 地址，这样，后续的通信内容就会发送到自己的PC上。 就是利用 IP -&gt; MAC 的漏洞。 这个漏洞被IPV6堵上了。 参考文档https://www.zhihu.com/question/21546408 http://www.52im.net/thread-2067-1-1.html https://zhuanlan.zhihu.com/p/28818627]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Window 与 View的动态更改思考]]></title>
    <url>%2F2020%2F06%2F17%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FWindow%20%E4%B8%8E%20View%E7%9A%84%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[我们创建一个悬浮窗的时候，需要使用 WindowManager 来创建。WindowManager 是一个接口，它继承至 ViewManager，主要有3个方法供我们使用：123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); 我们获取WindowManager： 1WindowManager windowManager = (WindowManager)context().getSystemService(Context.WINDOW_SERVICE); 一般通过这种方法调用的，最终都会触发一个 IPC 调用。 那么，这就引发了我的一个猜想：我们在 Activity 的布局里面，每次动态添加和删除 View 的时候，里面有没有触发 IPC 调用？？？ 我们拿 WindowManager的addView方法来分析一下，它的实现类是 android.view.WindowManagerGlobal。 android.view.WindowManagerGlobal#updateViewLayout 1root.setLayoutParams(wparams, false); 它调用了 ViewRootImpl 的 setLayoutParams 方法。 android.view.ViewRootImpl#setLayoutParams 1scheduleTraversals(); 这个方法内部又会调用 performTraversals方法，这个方法我们就很熟悉了，它就是 View 的绘制流程的入口。 android.view.ViewRootImpl#performTraversals 1relayoutWindow(...) 这个方法就会发起IPC调用来更新Window。 我们的普通的 ViewGroup 的addView等方法，会触发 requestLayout 方法，同样的会导致 scheduleTraversals 方法的调用，所以也会有 IPC 调用。 可以想象到，addView 是一个比较重量的操作。 update at 2020/4/20 今天看书又有新的理解。 先上一张图： 上图讲的是：我们使用 WindowManager 将一个 view add 到 window 所涉及到的关键类。 但是里面有一个叫做 IWindowSession 的东西，这个就是用来与 WMS 交互的类。刚开始我以为我们是直接与WMS进行交互的，没想到居然又转了一层。 关于 ViewRootImpl 与 WMS 的交互，并不是直接操作的，而是通过 Session 来进行的，看下面的这张图：]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解 RecyclerView 的缓存机制]]></title>
    <url>%2F2020%2F06%2F17%2Fblog_bak%2FBlog%2FAndroid-View%2FRecyclerView%20%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[以后会尽量写非源码的东西，因为过一段时间之后，发现自己看自己的文章都费劲，而且，源码大部分是在分析方法的调用链，意义不大，需要多写写自己的体悟才行。如果有时候必须要写，也要简化调用链的分析，提供类图，写重点和结论。 本文的思路与结论是基于参考文档的Anatomy of RecyclerView: a Search for a ViewHolder与 Anatomy of RecyclerView: a Search for a ViewHolder (continued) 这两篇文章而来。由于这两篇文章的某些观点与其他文章的的不一致，我经过自己的理解与推断调试后，是支持这两篇文章的观点的，所以当你阅读参考文档时，需要自己考量。 RecyclerView 的构成首先来从整体上来了解一下 RecyclerView RecyclerView 有五虎上将： 类名 作用 RecyclerView.LayoutManager 负责Item视图的布局的显示管理 RecyclerView.ItemDecoration 给每一项Item视图添加子View,例如可以进行画分隔线之类 RecyclerView.ItemAnimator 负责处理数据添加或者删除时候的动画效果 RecyclerView.Adapter 为每一项Item创建视图 RecyclerView.ViewHolder 承载Item视图的子布局 RecyclerView.Recycler 负责处理View的缓存 RecyclerView的职责就是将Datas中的数据以一定的规则展示在它的上面，但说破天RecyclerView只是一个ViewGroup，它只认识View，不清楚Data数据的具体结构，所以两个陌生人之间想构建通话，我们很容易想到适配器模式，因此，RecyclerView需要一个Adapter来与Datas进行交流： 如上如所示，RecyclerView表示只会和ViewHolder进行接触，而Adapter的工作就是将Data转换为RecyclerView认识的ViewHolder，因此RecyclerView就间接地认识了Datas。 事情虽然进展愉快，但RecyclerView是个很懒惰的人，尽管Adapter已经将Datas转换为RecyclerView所熟知的View，但RecyclerView并不想自己管理些子View，因此，它雇佣了一个叫做LayoutManager的大祭司来帮其完成布局，现在，图示变成下面这样： 如上图所示，LayoutManager协助RecyclerView来完成布局。但LayoutManager这个大祭司也有弱点，就是它只知道如何将一个一个的View布局在RecyclerView上，但它并不懂得如何管理这些View，如果大祭司肆无忌惮的玩弄View的话肯定会出事情，所以，必须有个管理View的护法，它就是Recycler，LayoutManager在需要View的时候回向护法进行索取，当LayoutManager不需要View(试图滑出)的时候，就直接将废弃的View丢给Recycler，图示如下： 到了这里，有负责翻译数据的Adapter，有负责布局的LayoutManager，有负责管理View的Recycler，一切都很完美，但RecyclerView乃何等神也，它下令说当子View变动的时候姿态要优雅(动画)，所以用雇佣了一个舞者ItemAnimator，因此，舞者也进入了这个图示: 如上，我们就是从宏观层面来对RecylerView有个大致的了解，可以看到，RecyclerView作为一个View，它只负责接受用户的各种讯息，然后将信息各司其职的分发出去。 还有最后一个 ，ItemDecoration 是为了显示每个 item 之间分隔样式的。它的本质实际上就是一个 Drawable。当 RecyclerView 执行到 onDraw() 方法的时候，就会调用到他的 onDraw()，这时，如果你重写了这个方法，就相当于是直接在 RecyclerView 上画了一个 Drawable 表现的东西。 而最后，在他的内部还有一个叫getItemOffsets()的方法，从字面就可以理解，他是用来偏移每个 item 视图的。当我们在每个 item 视图之间强行插入绘画了一段 Drawable，那么如果再照着原本的逻辑去绘 item 视图，就会覆盖掉 Decoration 了，所以需要getItemOffsets()这个方法，让每个 item 往后面偏移一点，不要覆盖到之前画上的分隔样式了。 PS: 其实 ItemDecoration 的宽高是计算在 itemview 中的，只不过 itemview 本身绘制区域没有那么大，留出来的地方正好的透明的，于是就透过 itemview 显示出了 ItemDecoration。那么就很有意思了，如果我故意在 ItemDecoration 的偏移量中写成0，那么 itemview 就会挡住 ItemDecoration，而在 itemview 的增加或删除的时候，会短暂的消失(透明)，这时候就又可以透过 itemview 看到 ItemDecoration 的样子。使用这种组合还可以做出意想不到的动画效果。 虽然，Google 尽力的解耦了，但是在源码中有的地方还是会有逻辑混杂在一起的地方，比如：动画的处理。 pre-layout 与 post-layout为了能够更好的理解下面的内容，这里先介绍一下 pre-layout 与 post-layout 是什么。 有这样的一个场景：我们有3个item【a, b, c】，其中a与b显示在屏幕上，当我们删除b的时候，c会显示出来。 我们希望看到的是 c 从底部顺利滑动到它的新位置。 但这是如何发生呢？ 我们知道新布局中 c 的最终位置，但我们如何知道它应该从何处开始滑动？ 谷歌的解决方案提供如下： 在adapter发生更改后，RecyclerView会从LayoutManager请求两个布局。 第一个 —— pre-layout，因为我们可以收到适配器的变化，所以这里我们可以做一些特殊的处理。在我们的例子中，因为我们现在知道b被删除了，所以我们会额外的显示出c，尽管它已经超出界限。 第二个 ——post-layout，一个正常的布局，对应于更改后的适配器状态。 现在，通过比较pre-layout和post-layout中c的位置，我们可以正确地为其设置动画。 仔细思考一下这个动画，This kind of animation — when the animated view is not present either in previous layout or in the new one — is called predictive animation。 再思考一个场景：如果b只是发生了变化，而不是被删除了，那么会怎么样呢？ ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_zzI5wYYr3KdkexZ4_ (1).png?raw=true) 答案是，仍然会在 pre-layout 阶段将 C 放置到后面！为什么呢？因为无法预测C的动画是什么动画，也许动画使b的高度变小了呢，那么c就需要显示出来，如果没有，那么 C 就会被放到缓存里去。 缓存介绍123456789101112131415161718public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2;&#125; scrapscrap 缓存是 recyclerView 最先搜索的缓存，网上有很多缓存调用图，第一个缓存调用就是 scrap。 scrap 仅仅在 layout 期间不为空。当 LayoutManager 开始 layout 的时候（pre-layout 或 post-layout），会将所有的 viewHolder 都放到 scrap 中。然后一个个在取回来，除非有些 view 发生了变化。 这里说一个题外话，就是有人可能会问，为啥要先放到 scrap 了之后，再取出来啊，这不是没事找事么？ 我的观点是：layout 的事归 LayoutManager 管，缓存的事归 Recycler 管。LayoutManager 不应该知到哪个 viewHolder 是否有效，这是一种职责分离设计。 scrap 分为两个集合：mAttachedScrap 和 mChangedScrap：这两个比较特殊，我跟踪了一下 mAttachScrap 添加的时机，在 LinearLayoutManager 的 onLayoutChildren 方法里面： 12345678public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; ... onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); // 这里调用了 mAttachedScrap.add(holder); // 这里也调用了 mChangedScrap.add(holder); detachAndScrapAttachedViews(recycler); ...&#125; 这里的调用时机很值得思考，它在布局的时候就放到缓存里面了，这里说明这个缓存针对的是屏幕上显示的View. 那么问题就来了，屏幕上显示的为什么要缓存起来呢？我的想法倾向于是减少 layout 方法调用带来的影响。 比如说，当我们调用 notifyItemRangeChanged 方法的时候，会触发 requestLayout 方法，就会重新布局，重新布局的话，就会先将 viewHolder 放到 scrap 中（屏幕上变化的放入mChangedScrap 中，其余的放入mAttachedScrap 中），然后 fill 布局的时候，再从 mAttachedScrap 里面取出来直接使用。mChangedScrap 中的 viewHolder 会被移动到 RecycledViewPool 中，所以 mChangedScrap 对应的 item 需要从 pool 中取对应的 viewHolder，然后重新绑定。 现在再来思考一下，为什么需要 mChangedScrap 与 mAttachedScrap 这两个缓存？ 因为 mChangedScrap 表示 item 变化了，有可能是数据变化，有可能是类型变化，所以它的 viewHolder 无法重用，只能去 RecycledViewPool 中重新取对应的，然后再重新绑定。 然后一点需要注意：mChangedScrap 只能在 pre-layout 中使用，mAttachedScrap 可以在 pre-layout 与 post-layout 中使用。 在继续讨论之前，需要先说明几个方法之间的区别： View中的detach和remove detach 在ViewGroup中的实现很简单，只是将当前View从ParentView的ChildView数组中移除，将当前View的mParent设置为null, 可以理解为轻量级的临时remove。 remove 代表真正的移除，不光从ChildView数组中移除，其他和View树各项联系也会被彻底斩断。 Recycled View中的Scrap View Scrap View指的是在RecyclerView中，经历了detach操作的缓存。RecyclerView源码中部分代码注释的detach其实指代的是remove，此类缓存是通过position匹配的，不需要重新bindView。 Recycled View指代的就是真正的移除操作remove后的缓存，取出时需重新bindView使用。 cache 与 poolcache 与 pool 中储存的均属于 Recycled View ，需要重新 add 到 列表中。 mCachedViews，这个比较简单。 它是一个 ArrayList 类型，不区分 viewHolder 的类型，大小限制为2，但是你可以使用 setItemViewCacheSize()这个方法调整它的大小。 由于它不区分 viewHolder 的类型，所以只能根据 position 来获取 viewHolder 。 RecycledViewPool，它储存了各个类型的 viewHolder 最大数量为5，可以通过 setMaxRecycledViews() 方法来设置每个类型储存的容量。 还有一个重要的点就是，可以多个列表公用一个 RecycledViewPool，使用 setRecycledViewPool() 方法。 这里顺便说一下，各个缓存的使用上的区别，也好对各个缓存池有一个大概的了解： 如果在所有缓存中都没有找到 viewHolder，那就会调用 create 和 bind 方法。 如果在 pool （RecycledViewPool ） 中找到了，那么会调用 bind 方法。 如果在 cache （mCachedViews）中找到了，啥都不用做，直接显示就好了。 所以，需要注意他们的区别，一个 viewHolder 进入到 cache 与进入到 pool 中是不一样的。 现在，我们来思考下一个问题：mCachedViews 的大小是有限制的，如果存不下了，怎么办？ 实际上，mCachedViews 虽然是一个 ArrayList ，但是它的工作方式却和链表有点类似。当 mCachedViews 满了之后，它会将最先存入的元素移除，放入到 pool 中，如下图： 当我们滑动列表的时候，一旦 item 超出了屏幕，那么就会被放入到 mCachedViews 中，如果满了，就会将“尾部”的元素移动到 pool 中，如果 pool 也满了，那么就会被丢弃，等待回收。 下面，用几个场景来巩固一下我们学到的知识： 场景一： 先看图的左边（此时假设 cache 与 pool 中没有东西），当向下滑动时，3 最先进入 mCachedViews，随后是 4 与 5，5 会将3挤出来，3就会跑到 pool 中去了。 再看图的右边，继续向下滑动时，4 被 6 挤出来，放到了 pool 中，同时，8需要显示，那么就会先从 pool 中取，发现正好有一个 3，那么就会取出来，将 3 重新显示到屏幕上。 场景二： 如果，向下滑倒7显示出来之后，不再继续向下，而是往上滑动，那么又会怎么样呢？ 看图的右边，很明显，5 从 cache 中被取出来直接复用，不用重新绑定，7 被放入了 cache 中。 思考一下，对于这种情况，我们应该如何加以利用呢？ 比如，我们有一个壁纸库的列表，用户经常会上下（左右）滑动，那么我们增加 cache 的容量，就会获得更好得性能。然而对于feed流之类得列表，用户很少返回，所以增加 cache 容量意义不大。 再深入一下，我们继续向上滑动，那么，6与 7 会放入到 cache 中，3 会从 pool 中取出来，但是，这里需要注意，因为 3 是从 pool 中取出来的，所以它需要重新绑定，但是从逻辑上来说，如果 3 位置的数据没有发生变化，它不需要重新绑定，也是有效的。所以，你也可以把这里当作一个优化点，在 onBindViewHolder() 方法中，检查一下。 再再深入一下，在我们滑动的过程中，一个类型的 viewHolder 在 pool 中应该一直只会存在一个（除非你使用了 GridLayoutManager），所以，如果你的 pool 中存在多个 viewHolder 的话，他们在滚动过程中基本上是无用的。 场景三： 当我们调用 notifyDataSetChanged() 或者 notifyItemRangeChanged(i, c) （c这个范围非常大的时候），那么很多 viewHolder 都会最终被放入到 pool 中，因为 pool 只能放置 5 个，那么多余的就会被丢弃，等待回收。最重要的是会重新 create 与 bind 对性能影响比较大。如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。 1recyclerView.getRecycledViewPool().setMaxRecycledViews(0, 20); ViewCacheExtension这个是需要自定义的，而且使用有很大的限制，所以不深入介绍了。 因为它需要你自己创建 viewHolder，并将它缓存起来，那么问题就来了。当我们删除或添加一个 item 的时候，AdapterHelper 回调 RecyclerView 通知它需要处理变化。 RecyclerView 会遍历当前显示的 viewHolder 然后移动它们的位置。但是这里有个bug，RecyclerView 根本不知道你创建的 viewHolder，所以它不会管你自己缓存的 viewHolder。 所以，如果你想使用的话，需要满足一些条件： 位置固定，比如，广告位。 不会改变 数量合理，保存在内存中没啥关系。 Stable Ids之前我们说过，当调用 notifyDataSetChanged 的时候，recyclerView 不知道到底发生了什么，所以它只能认为所有的东西都发生了变化，即，将所有的 viewHolder 都放入到 pool 中。 但是，如果我们设置了 stable ids，那么就会不一样了： viewHolder 被放入了 scrap 中，而不是 pool 中。注意，这里，它的性能提升了很多！ 不用重新绑定，重新创建新的 viewHolder，不用重新 addView。addView会导致重新测量… 原来我们需要调用 notifyItemMoved(4, 6)，但是现在直接调用 notifyDataSetChanged() 就好了. 这个方法应该在什么情况下使用呢？ 当你可以为每一个item设置一个唯一的id的时候，注意有些时候直接使用 position 会导致item错乱。因为 position 不会变，但是item是会变的。 setHasFixedSize()这个方法有很详细的注释： 1234&gt; RecyclerView can perform several optimizations if it can know in advance that RecyclerView&apos;s size is not affected by the adapter contents. RecyclerView can still change its size based on other factors (e.g. its parent&apos;s size) but this size calculation cannot depend on the size of its children or contents of its adapter (except the number of items in the adapter).&gt; &lt;p&gt;&gt; If your use of RecyclerView falls into this category, set this to &#123;@code true&#125;. It will allow RecyclerView to avoid invalidating the whole layout when its adapter contents change.&gt; 意思就是说，如果你的 RecyclerView 的尺寸是固定的，那么你应该使用这个方法，因为 RecyclerView 的内部做了优化，在添加与删除等操作的时候，会走自己内部的 layout 方法，而不会走 View 体系的 layout 方法，所以这样就提升了性能。 我们看看这个字段在代码里面做了什么： 1234void onItemsInsertedOrRemoved() &#123; if (hasFixedSize) layoutChildren(); else requestLayout();&#125; 但是需要注意的是，设置了这个方法之后，RecyclerView 的宽高就基本不会变化了（除非它的parent变化了），所以如果你在 XML 里面使用的 wrap_content 的话，不能使用这个方法，其他情况下基本适用，特别是添加与删除特别频繁的。 到了这里，你应该可以回答下面的问题了： notifyDataSetChanged 与 notifyItemRangeChanged 的区别？ RecyclerView 与 ListView 缓存的区别？这个问题，即使你不知道 ListView 的缓存机制，也应该能说些什么。 如何对一个列表进行性能优化？调用 notifyDataSetChanged 时闪烁的原因？ 参考文档https://www.kymjs.com/code/2016/07/10/01/ https://juejin.im/post/5b79a0b851882542b13d204b https://blog.saymagic.cn/2016/10/21/understand-recycler.html Anatomy of RecyclerView: a Search for a ViewHolder Anatomy of RecyclerView: a Search for a ViewHolder (continued) RecyclerView机制解析: ChildHelper]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程005：实现基于TCP的长连接]]></title>
    <url>%2F2020%2F06%2F17%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B005%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[Socket 的基本用法Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。先看服务端的使用：12345678910ServerSocket serverSocket = new ServerSocket(port);Socket client = serverSocket.accept();InputStream in = client.getInputStream();OutputStream out = client.getOutputStream();byte[] buffer = new byte[1024];int n;// 将客户端发送过来的数据原封不动的发送回去while ((n = in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, n);&#125; 再看客户端的使用： 12345678910111213141516171819202122232425Socket socket = new Socket(host, port);// 发送数据OutputStream out = socket.getOutputStream();byte[] buffer = new byte[1024];int n;while ((n = System.in.read(buffer)) &gt; 0) &#123; out.write(buffer, 0, n);&#125;// 读取响应Thread readerThread = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; InputStream in = socket.getInputStream(); byte[] buffer = new byte[1024]; int n; while ((n = in.read(buffer)) &gt; 0) &#123; System.out.write(buffer, 0, n); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);readerThread.start(); 这里客户端的既要发送数据，又要展示接收到的响应数据，所以开了一个线程来处理。 Socket 与 ServerSocket先说 ServerSocket，我们在 IDE 里面查看一下它的构造方法，发现： 12getImpl().bind(epoint.getAddress(), epoint.getPort());getImpl().listen(backlog); 它实际上是调用了 bind 与 listen 这两个方法。 而 getImpl 是返回的一个成员变量，你可以理解为它是将 SocketImpl 对象给包装了一下，提供给我们使用。 所以，一切最终走的是 SocketImpl 的方法。 同样的，Socket 也是包装的 SocketImpl 的一些方法，所以我们可以理解为 Socket 与 ServerSocket 都是一个包装类，简化了 SocketImpl 的使用。 还有一点需要注意： 1Socket client = serverSocket.accept(); 这行代码创建了一个新的 Socket。我们的 ServerSocket 包装的 Socket 是用来做监听的，它不处理别的事，所以每次有连接到来都会创建一个新的返回。 所以实际上，连接成功之后，会产生3个 Socket。 关于accept创建的这个 socket，还有一个很有意思的地方。它的端口号跟 ServerSocket 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。 Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 (source_ip, source_port, destination_ip, destination_port) 这个四元组： 1234567891. 服务器的IP2. 服务器的Port3. 客户端的IP4. 客户端的Port假设，我们的 ServerSocket 长这样：&lt;*:*, *:9877&gt;。accept 返回的 Socket 则是这样：&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;，xxxx 是客户端的端口号。如果是客户端要发起连接，这时候只有 &lt;*:*, *:9877&gt; 会匹配成功。如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。 实现长连接Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。 1socket.setKeepAlive(true); 我们要实现一个 socket 的长连接，只需要这一个调用即可。Socket 的这个 keep alive 选项如果打开并且两个小时内没有通信，那么底层会发一个心跳，看看对方是不是还活着。 注意：两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。 我们自己实现长连接，实际上就是隔一段时间发送一个数据包：就是不断地给对方写数据，然后读取对方的数据，也就是所谓的心跳。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。 这里有一个简单的例子：https://github.com/Jekton/Echo 我们来分析一下这个例子是如何做的： 首先，Socket 自带的方法肯定是无法满足我们的要求的，那么只能对 Socket 进行增强。 这里我们使用包装类来完成这个功能。 12345public final class KeepAliveSocket &#123; private Socket mSocket; &#125; 首先我们一样的建立连接： 123456789private void connect() &#123; Socket socket = new Socket(mHost, mPort); mSocket = socket; // 每次创建新的 socket，会开一个线程来读数据 Thread reader = new Thread(new ReaderTask(socket), "socket-reader"); reader.start(); // 发送心跳包 mWriterHandler.post(mHeartBeatTask);&#125; 连接建立起来之后，我们会开启一个线程去读取回应。 这里发送心跳包是通过 HandlerThread 来做的，所以也是运行在一个线程里面，所以需要考虑同步问题，为了理清逻辑，这里省去同步代码。 我们看看是如何发送心跳包的： 1234567891011121314151617181920212223242526272829private final Runnable mHeartBeatTask = new Runnable() &#123; private byte[] mHeartBeat = new byte[0]; @Override public void run() &#123; ++mSeqNumHeartBeatSent; // 我们使用长度为 0 的数据作为 heart beat write(mHeartBeat, new WritingCallback() &#123; @Override public void onSuccess() &#123; // 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次 mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS); // At this point, the heart-beat might be received and handled if (mSeqNumHeartBeatRecv &lt; mSeqNumHeartBeatSent) &#123; // 没收到服务端的回应，超时判断 mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS); // double check if (mSeqNumHeartBeatRecv == mSeqNumHeartBeatSent) &#123; mUIHandler.removeCallbacks(mHeartBeatTimeoutTask); &#125; &#125; &#125; @Override public void onFail(byte[] data, int offset, int len) &#123; &#125; &#125;); &#125;&#125;; 其实就是发送了一个空的数据过去，然后客户端还记录了心跳包的编号。 这里是一个常见的循环代码，就不多说了。里面处理了心跳包超时等情况。 我们再看看心跳包编号的相关代码，上面说到我们单独开了一个线程去读取响应： 12345678910111213141516171819202122232425262728private void readResponse() throws IOException &#123; // For simplicity, assume that a msg will not exceed 1024-byte byte[] buffer = new byte[1024]; InputStream inputStream = mSocket.getInputStream(); DataInputStream in = new DataInputStream(inputStream); while (true) &#123; int nbyte = in.readInt(); if (nbyte == 0) &#123; Log.i(TAG, "readResponse: heart beat received"); mUIHandler.removeCallbacks(mHeartBeatTimeoutTask); mSeqNumHeartBeatRecv = mSeqNumHeartBeatSent; continue; &#125; if (nbyte &gt; buffer.length) &#123; throw new IllegalStateException("Receive message with len " + nbyte + " which exceeds limit " + buffer.length); &#125; if (readn(in, buffer, nbyte) != 0) &#123; // Socket might be closed twice but it does no harm silentlyClose(mSocket); // Socket will be re-connected by writer-thread if you want break; &#125; mDataCallback.onData(buffer, 0, nbyte); &#125;&#125; 可以看到对心跳包和其他数据做了一定程度的区分，如果是心跳包，则更新收到的编号，如果是数据会触发回调。 对于心跳包的处理考虑这样的一种情况，假设服务端没有对心跳包做出回应，那么 mHeartBeatTask 就会进入心跳超时的逻辑代码中，如果在超时之前服务器回应了，那么当作啥都没有发生，如果在超时时间内没有回应，就会进入到 mHeartBeatTimeoutTask。 此时会关闭 Socket： 1234private final Runnable mHeartBeatTimeoutTask = () -&gt; &#123; Log.e(TAG, "mHeartBeatTimeoutTask#run: heart beat timeout"); closeSocket();&#125;; 当然这只是一个例子，所以就做了最直接的处理。实际上不会这么做的。 这个例子的主要内容就是这些了，有兴趣了下载下来自己运行一下看看。 参考文档http://www.52im.net/thread-1722-1-1.html]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程004：理解HTTP协议]]></title>
    <url>%2F2020%2F06%2F16%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B004%EF%BC%9A%E7%90%86%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP的工作过程HTTP请求响应模型：HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤： 建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80； 客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；例如：GET/sample/hello.jsp HTTP/1.1； 客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送； 服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；例如： HTTP/1.1 200 OK响应的第一部分是协议的版本号和响应状态码； 服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档； 服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据； 服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP协议基础HTTP协议是不保存状态的不保存状态为了更快地处理大量事务。 但是现在我们的很多业务都需要对通信状态进行保存。Cookie技术随之而来。 Cookie服务端发送一个 Set-Cookie 首部字段，客户端就会保存 Cookie。 客户端后续的请求会在请求报文中带上 Cookie 值。 服务端会处理该 Cookie，用于辨别客户端的身份，做处理。 持久链接与管线化 最开始的 HTTP 协议，每次请求都会创建一个新的 TCP 连接，请求完成之后会断开 TCP 连接。如果一个页面里面有很多图片，就会浪费资源。 持久连接就是只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。 管线化就是在持久连接的基础上进一步提升请求响应时间：之前的 HTTP 请求都是串行的，一个请求接着一个响应，使用管线化之后可以一次发送多个 HTTP 请求（可以理解为批量 HTTP 请求），这样就不用等前一个请求返回响应了下一个才能开始。 注意管线化的请求发送顺序与响应顺序是一致的，不会乱序，这样就会出现一些问题，嗯，了解一下就行了。 一些常见头部字段缓存相关 Last-Modified：资源的最后修改日期。 Last-Modified 是由服务器往客户端发送的 HTTP 头，另一个 If-Modified-Since是由客户端往服务器发送的头。 再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了。 ETag：资源的标识，可以当成id来理解。它的作用与 Last-Modified 一样，但是它可以解决 Last-Modified 无法解决的一些问题。 ETag 是由服务器往客户端发送的 HTTP 头，另一个 If-None-Match 是由客户端往服务器发送的头。 1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET; 2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒) 3、某些服务器不能精确的得到文件的最后修改时间； 范围请求1234GET /bigfile.html HTTP/1.1Host: [url=http://www.sample.com]www.sample.com[/url]Range: bytes=20224-··· 假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。 有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。 内容编码就是使用压缩技术对报文主体进行压缩，然后再进行传输。 压缩的是上图左边的主体部分。 传输编码-分块编码使用传输编码是为了改变报文中的数据在网络上传输的方式。 拿分块编码来举例： 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。 分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号。 网关 将 HTTP 流量转换成其他的协议。 隧道 HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。 上面这句话，我第一看到是一脸懵逼了，我查了一些资料，总算了解一点了。 我们先了解一下什么是 HTTP 代理服务器。 在一次请求中，客户端（浏览器）明文的请求代理服务器。代理服务器明文去请求远端服务器（网站），拿到返回结果，再将返回结果返回给客户端。代理服务器可以看到请求中的任何东西。 那么你可以想一下，如果是 HTTPS 请求会怎么样呢？ 如果我们想在复用现有的HTTP proxy的传输方式来代理HTTPS流量，那么就会变成浏览器和代理握手跑TLS，代理拿到明文的请求报文，代理和网站握手跑TLS。但是代理没有，也不可能有网站的私钥证书，所以这么做会导致浏览器和代理之间的TLS无法建立，证书校验根本通不过。HTTP tunnel解决了这个问题，代理服务器不再作为中间人，不再改写浏览器的请求，而是把浏览器和远端服务器之间通信的数据原样透传，这样浏览器就可以直接和远端服务器进行TLS握手并传输加密的数据。 参考文档http://www.52im.net/thread-1677-1-1.html https://www.cnblogs.com/flysnow-z/archive/2012/08/17/2644420.html https://www.zhihu.com/question/21955083]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程003：TCP与UDP]]></title>
    <url>%2F2020%2F06%2F16%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B003%EF%BC%9ATCP%E4%B8%8EUDP%2F</url>
    <content type="text"><![CDATA[建立链接的差异TCPTCP是面向链接的，也就是我们通常说的三次握手。这里有张图描述的有点蛋疼，大致看没问题，仔细看为题很多。我刚开始看到这张图的时候，对图里面的 ACK 值感到疑惑。因为我发现了有两个 ack，一个大写，一个小写，他们的意义是不同的：具体的解释可以看这里：https://blog.csdn.net/baiyan3212/article/details/81302448 上图中的 ACK 应该表示的是“确认编号”。 一个是确认值(Acknowledgement)，为1便是确认连接。另一个是确认编号(Acknowledgement Number)。 还有一个问题，有的发送过程只写了 ACK，没有写 seq，难道是侧重点不同？？？我哪里没get到吗？？？ 好的，我们仔细分析这个图，可以看出其实三次握手的主要目的是： 通知对方，自己发送包的初始编号。 所以三次握手的次序是这样子的： client端首先发送一个SYN包告诉Server端我的初始序列号是X； Server端收到SYN包后回复给client一个ACK确认包，告诉client说我收到了； 接着Server端也需要告诉client端自己的初始序列号，于是Server也发送一个SYN包告诉client我的初始序列号是Y； Client收到后，回复Server一个ACK确认包说我知道了。 其中的 2 、3 步骤可以简化为一步，也就是说将 ACK 确认包和 SYN 序列化包一同发送给 Client 端。 UDPUDP 压根不会建立什么连接。UDP 只需要知道对方的 ip 地址，将数据报一份一份的发送过去就可以了，其他的作为发送方，都不需要关心。 数据发送方式的差异差异主要体验在对数据包大小的限制上： TCP：由于 TCP 是建立在两端连接之上的协议，所以理论上发送的数据流不存在大小的限制。但是由于缓冲区有大小限制，所以你如果用 TCP 发送一段很大的数据，可能会截断成好几段，接收方依次的接收。 UDP：由于 UDP 本身发送的就是一份一份的数据报，所以自然而然的就有一个上限的大小。 我们知道，当一个数据包超过了以太网数据帧的大小时，IP层会将数据进行分片，这对于TCP来说，没什么问题，应为它有重传与确认机制。但是UDP没有这个机制，假设一个数据包分为了 10 片，那么就需要传输10次，而只要其中某一个片丢失了，那么UDP会弃掉整个数据包，影响范围就变大了。所以最好我们使用UDP的时候，一个数据包不要超过这里的限制。 有关UDP协议的最大包长限制，详见《UDP中一个包的大小最大能多大？》 有序性的差异TCP有序，UDP无序。 可靠性的差异TCP可靠，UDP不可靠。 研究下，什么情况会导致 UDP 丢包： 数据报分片重组丢失：在文章之前我们就说过，UDP 的每个数据报大小多少最合适，事实上 UDP 协议本身规定的大小是 64kb，但是在数据链路层有 MTU 的限制，大小大概在 5kb（这些数据dou），所以当你发送一个很大的 UDP 包的时候，这个包会在 IP 层进行分片，然后重组。这个过程就有可能导致分片的包丢失。UDP 本身有 CRC 检测机制，会抛弃掉丢失的 UDP 包； UDP 缓冲区填满：当 UDP 的缓冲区已经被填满的时候，接收方还没有处理这部分的 UDP 数据报，这个时候再过来的数据报就没有地方可以存了，自然就都被丢弃了。 使用场景先来说 UDP 的吧，有很多人都会觉得 UDP 与 TCP 相比，在性能速度上是占优势的。因为 UDP 并不用保持一个持续的连接，也不需要对收发包进行确认。但事实上经过这么多年的发展 TCP 已经拥有足够多的算法和优化，在网络状态不错的情况下，TCP 的整体性能是优于 UDP 的。 那在什么时候我们非用 UDP 不可呢？ 对实时性要求高：比如实时会议，实时视频这种情况下，如果使用 TCP，当网络不好发生重传时，画面肯定会有延时，甚至越堆越多。如果使用 UDP 的话，即使偶尔丢了几个包，但是也不会影响什么，这种情况下使用 UDP 比较好； 对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有 sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。 流媒体：采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。 多点通信：TCP 需要保持一个长连接，那么在涉及多点通讯的时候，肯定需要和多个通信节点建立其双向连接，然后有时在NAT环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，而 UDP 可以无需保持连接，直接发就可以了，所以成本会很低，而且穿透性好。这种情况下使用 UDP 也是没错的。 以上我们说了 UDP 的使用场景，在此之外的其他情况，使用 TCP 准没错。 毕竟有一句话嘛： when in doubt，use TCP。 参考文档http://www.52im.net/thread-29-1-1.html http://www.52im.net/thread-1160-1-1.html http://www.52im.net/thread-1277-1-1.html]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程002：快速理解TCP协议]]></title>
    <url>%2F2020%2F06%2F15%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B002%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。IP 协议实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。 TCP数据包的大小 以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。 这些字节里面包含了很多头，所以真正的数据大约为 1400 字节。所以我们的 HTTP 请求可能会分为多个数据包来发送。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。 TCP数据包的编号我们常听说TCP的三次握手，但是这三次握手是干嘛呢？ 我们发送一个1M的文件，必然要分成很多个数据包发送，其中如果有丢包，那么怎么知道是丢了哪个包呢？ 其实是在发送的时候，TCP 协议为每个包编号了。 第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。 而由于TCP是两端都可以发送数据的，所以三次握手的情况大致如下： 序号 方向 seq ack 1 A-&gt;B 10000（随机数） 0 2 B-&gt;A 20000（随机数） 10000+1=10001 3 A-&gt;B 10001 20000+1=20001 确认序号（ack）应当是上次已成功收到数据字节序号加1，它的作用是告知发送端的数据接受成功，期望下一个包的字节为此序号。 字节序号（seq）是上次已成功收到的确认序号，它的作用就是发送接收端期望的下一个包的数据。 在三次握手的过程中，ACK是直接加一了，但是在正式通信的时候，会不一样： 序号 方向 seq ack 数据长度 数据包长度 23 A-&gt;B 40000 70000 1460 1514 24 B-&gt;A 70000 40000+1514-54=41460 0 54 25 A-&gt;B 41460 70000+54-54=70000 1460 1514 26 B-&gt;A 70000 41460+1514-54=42920 0 54 可以看到这里的 ACK 是加上了数据包的数据的长度。你可以理解为，握手的时候只发送了一个字节的数据。 四次挥手的过程与握手类似，就不多说了。 另外提一下，在三次握手的过程中，还有一个叫做 SYN 的标识，它标识希望建立链接，所以只有开始两次会有这个标识。同样的在四次握手会有 FIN 标识，标识希望断开链接。 数据包的遗失处理每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。 如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。 参考文档http://www.52im.net/thread-1107-1-1.html https://blog.csdn.net/huaishu/article/details/93739446]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Protobuf 通信协议详解]]></title>
    <url>%2F2020%2F06%2F14%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2FProtobuf%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Protobuf 通信协议详解在移动互联网时代，手机流量、电量是最为有限的资源，而移动端的即时通讯应用无疑必须得直面这两点。解决流量过大的基本方法就是使用高度压缩的通信协议，而数据压缩后流量减小带来的自然结果也就是省电：因为大数据量的传输必然需要更久的网络操作、数据序列化及反序列化操作，这些都是电量消耗过快的根源。 当前即时通讯应用中最热门的通信协议无疑就是Google的Protobuf了。本文将详细介绍Protobuf的使用、原理等。 protobuf 简介github地址：https://github.com/protocolbuffers/protobuf Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。 看了这些介绍，可能你和我一样刚开始都是一脸懵逼，不过不要紧，我们写一个小例子来帮助我们理解。 一个简单的例子安装 Google Protocol Buffer首先，我们去Github地址，里面有 Protobuf 的源码，你可以 clone 下来自己编译。当然，Google 也提供已经编译好了的程序供我们直接使用。这里就不说如何自己编译了，有兴趣的搜索一下。我们直接去 release 页面，下载对应平台的编译器，我的是 windows 系统，所以我选择下载 protoc-3.12.3-win64.zip 文件。 下载完成之后，打开，里面有如下文件： 123-bin-include-readme.txt bin 里面就是存放的编译器了，专门编译 .proto 文件，类似于 javac。 include 里面是 Google 提供的一些标准 proto 文件，你可以把它当作 sample 看待。 这里，我们只需要使用 bin 里面的 protoc.exe 程序。你可以把它放到一个特定的目录，然后添加到 path，因为之后需要在 terminal 中使用，或者你直接拷贝到你的工程目录下。 关于例子的简单描述这里我是用 java 来写这个简单的程序，程序分为两部份，一个 Writer，一个 Reader。 Writer 负责将一些结构化的数据写入一个磁盘文件，Reader 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。 准备用于演示的结构化数据是 HelloWorld，它包含两个基本数据： ID，为一个整数类型的数据 Str，这是一个字符串 写 .proto 文件123456789101112131415syntax = &quot;proto3&quot;; //文件的第一行指定了你正在使用proto3语法：如果你没有指定这个，编译器会使用proto2。option java_package = &quot;com.aprz.proto&quot;; // 生成的类的包名option java_outer_classname = &quot;HelloWorldProto&quot;; // 生成的外部类的名字，该文件定义的消息体都是这个类的内部类// 如果我们使用 java，这个消息体的类名就是：com.aprz.proto.HelloWorldProto.HelloWordmessage HelloWorld &#123; int32 number = 1; // proto3 不用写 required 修饰符了 string text = 2;&#125;message HelloWorld2 &#123; float money = 1; string text = 2;&#125; 里面的 option 只针对 java 才生效。 在消息定义中，每个字段都有唯一的一个数字标识符。这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。注：[1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。 编译 .proto 文件这个就很简单了，会 javac 的肯定会这个。 假设您的 proto 文件存放在 $SRC_DIR 下面，您也想把生成的文件放在同一个目录下，则可以使用如下命令： 12345protoc -I=$SRC_DIR --java_out=$DST_DIR addressbook.proto-I 后面是 proto 文件所在目录--java_out 后面是生成的 java 文件存放的地址最后是 proto 文件名称 引入依赖执行编译命令之后，发现生成了 HelloWorldProto.java 文件，但是却有很多地方报错，这里因为该类里面引用到了很多 protobuf 库里面的类，所以我们需要在工程里面导入该依赖库。 这里，我导入的是 ： 1com.google.protobuf:protobuf-java:3.12.2 导入完成后，发现类中没有了错误。有兴趣的可以自己看一下生成的消息类，由于生成的消息类的代码太多（一个600多行），所以这里就不贴代码了。 编写 Writer 与 Reader在编写 Writer 与 Reader 之前，我们先看看如何使用生成的消息体。 1234HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder() .setNumber(10) .setText("123") .build(); 可以看到，protobuf 为我们定义的每一个消息体都生成了一个 builder 类，所以使用起来是很方便的。 编写 Writer： 12345678File dst = new File("protobuf-text");try &#123; BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst)); helloWorld.writeTo(bos); bos.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 生成的类提供了 writeTo 方法，可以直接写进输出流，当然你也可以自己做处理，里面有很多方法可以使用。 编写 Reader： 12345678File tar = new File("protobuf-text");try &#123; HelloWorldProto.HelloWorld helloWorld1 = HelloWorldProto.HelloWorld.parseFrom(new FileInputStream(tar)); System.out.println(helloWorld1.getNumber()); System.out.println(helloWorld1.getText());&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 直接从输入流中解析出 java 对象，也很方便。其实这就是一个反序列化的过程，将二进制流转成一个对象的字段。 123456789101112131415161718192021222324int tag = input.readTag();switch (tag) &#123; case 0: done = true; break; case 8: &#123; number_ = input.readInt32(); break; &#125; case 18: &#123; java.lang.String s = input.readStringRequireUtf8(); text_ = s; break; &#125; default: &#123; if (!parseUnknownField( input, unknownFields, extensionRegistry, tag)) &#123; done = true; &#125; break; &#125;&#125; 从这段代码应该可以看出一点东西，不过这里面涉及到 protobuf 序列化的规则，后面会介绍到。 这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 socket，那么就可以实现基于网络的数据交换任务。而存储和交换正是 Protobuf 最有效的应用领域。 Protobuf 的优点Protobuf 有如 XML，不过它更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。 它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。 Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。 使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。 Protobuf 的不足Protbuf 与 XML 相比也有不足之处。它功能简单，无法用来表示复杂的概念。 XML 已经成为多种行业标准的编写工具，Protobuf 只是 Google 公司内部使用的工具，在通用性上还差很多。 由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。 高级应用导入如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？你可以通过导入（import）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如： 1import &quot;myproject/other_protos.proto&quot;; 嵌套类型你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如： 123456789message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; // repeated 在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）,一般对应数组或者List repeated string snippets = 3; &#125; repeated Result results = 1;&#125; 细节问题同 XML 相比， Protobuf 的主要优点在于性能高。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。 对于这样的说法，严格的程序员需要一个解释。因此在本文的最后，让我们稍微深入 Protobuf 的内部实现吧。 有两项技术保证了采用 Protobuf 的程序能获得相对于 XML 极大的性能提高。 第一点，我们可以考察 Protobuf 序列化后的信息内容。您可以看到 Protocol Buffer 信息的表示非常紧凑，这意味着消息的体积减少，自然需要更少的资源。比如网络上传输的字节数更少，需要的 IO 更少等，从而提高性能。 第二点我们需要理解 Protobuf 封解包的大致过程，从而理解为什么会比 XML 快很多。 Google Protocol Buffer 的 EncodingProtobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。 考察消息结构之前，让我首先要介绍一个叫做 Varint 的术语。 Varint 说的通俗一点，就是“变长”。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。（那么问个问题，让你设计一个变长类型，你如何设计？？？） 比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。 变长类型还是挺常见的，比如描述 dex 的结构里面，就会有很多类型都是变长的，为了节省空间。 Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示： 1234561010 1100 0000 0010我们用计算器看一下 300 的二进制表示：‭0001 0010 1100‬ -&gt; 0000010 0101100 -&gt; 00000010 10101100 -&gt; 10101100 00000010 看这张图应该会比较好理解，它将300的二进制表示分成了两段（7 bit 为一段，不足的补0），由于Google Protocol Buffer 字节序采用 little-endian 的表示方式，所以需要将字节倒过来看。 消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 Key-Value 对。如下图所示： 采用这种 Key-Pair 结构无需使用分隔符来分割不同的 Field。对于可选的 Field，如果消息中不存在该 field，那么在最终的 Message Buffer 中就没有该 field，这些特性都有助于节约消息本身的大小。 假设我们的消息体中有两个字段： 1234message HelloWorld &#123; int32 number = 1; string text = 2;&#125; 那么 number 的 key 为： 1(field_number &lt;&lt; 3) | wire_type field_number 就是我们定义的数字标识符了，这里 number 的为 1。 那么 wire_type 是什么呢？wire_type 需要查表才能得到： Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimi string, bytes, embedded messages, packed repeated fields 3 Start group Groups (deprecated) 4 End group Groups (deprecated) 5 32-bit fixed32, sfixed32, float 可以看到 int32 的 wire_type 为 0 。 所以 number 的 key 为 (1 &lt;&lt; 3 | 0) = 8，text 的 key 为 （2 &lt;&lt; 3 | 2） = 18，这两个数是不是有点熟悉，是的！就是上面生成的代码里面，我们见过的。那部分代码其实就是反序列话，根据 key 读取 value，然后给创建的对象赋值。 看到这里，你是不是觉得变长类型就已经很吊了呢？那么我有一个问题，表示正数 1 可以只需要一个字节，那么表示负数 -1，需要几个字节呢？ 我们看一下 -1 的二进制代码： 1‭11111111 11111111 11111111 11111111 一共有32位，这显然没法用一个字节表示，需要 5 个字节，那怎么办呢？ 为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。 Zigzag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词的含义了。 使用 zigzag 编码，绝对值小的数字，无论正负都可以采用较少的 byte 来表示，充分利用了 Varint 这种技术。 我们运行程序来看一下是不是这样吧： 123456HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder() .setNumber(10) .setText("1123").build();for (byte b : helloWorld.toByteArray()) &#123; System.out.println(b + " = " + Integer.toBinaryString((b &amp; 0xFF) + 0x100).substring(1));&#125; 看一下输出的结果： 123456788 = 00001000 // number 的 key10 = 00001010 // number 的 value18 = 00010010 // text 的 key4 = 00000100 // text 的 value 的长度49 = 00110001 // 149 = 00110001 // 150 = 00110010 // 251 = 00110011 // 3 这里需要知道的一点是：字符串等则采用类似数据库中的 varchar 的表示方法，即用一个 varint 表示长度，然后将其余部分紧跟在这个长度部分之后即可。 text 的 value 是 4 个长度，每个字节可以查 ascii 码得到。这里的编码不太清楚，可能是 utf8。 我们设置一个负数来看看结果： 123456HelloWorldProto.HelloWorld helloWorld = HelloWorldProto.HelloWorld.newBuilder() .setNumber(-1) .setText("李").build();for (byte b : helloWorld.toByteArray()) &#123; System.out.println(b + " = " + Integer.toBinaryString((b &amp; 0xFF) + 0x100).substring(1));&#125; 输出结果： 123456789101112131415168 = 00001000-1 = 11111111-1 = 11111111-1 = 11111111-1 = 11111111-1 = 11111111-1 = 11111111-1 = 11111111-1 = 11111111-1 = 111111111 = 0000000118 = 000100103 = 00000011-26 = 11100110-99 = 10011101-114 = 10001110 可以看到，-1 的表示非常的长，用了 10 个字节。那么问题就来了，我们不是声明的 int32 吗，为啥实际上是 int64，还有王法吗，还有法律吗！！！ 我查了些资料： https://developers.google.com/protocol-buffers/docs/encoding If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long – it is, effectively, treated like a very large unsigned integer. 这个我是没想到为啥要这样搞！！！ 我们改一下 proto 中消息体的定义，使用 sint32 重新生成一下。 1234567===== Byte 开始 =====8 = 000010001 = 0000000118 = 000100101 = 0000000149 = 00110001===== Byte 结束 ===== 看到，生成的二进制是短了很多。 那么为啥这个就能生成的短些呢？难道 number 字段在源代码里面不是 int 吗？我们可以分析源码： 12345private int number_; // 是 int 类型没变// 但是它序列化与反序列化的时候使用的是不同的方法output.writeSInt32(1, number_);number_ = input.readSInt32(); 更细节的部分，可以自行查看。 封解包的速度首先我们来了解一下 XML 的封解包过程。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。 反观 Protobuf，它只需要简单地将一个二进制序列，按照指定的格式读取到 Java 对应的结构类型中就可以了。从上一节的描述可以看到消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。 述可以看到消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。 为了说明这并不是我拍脑袋随意想出来的说法，下面让我们简单分析一下 Protobuf 解包的代码流程吧。 以代码清单 3 中的 Reader 为例，该程序首先调用 msg1 的 ParseFromIstream 方法，这个方法解析从文件读入的二进制数据流，并将解析出来的数据赋予 helloworld 类的相应数据成员。 该过程可以用下图表示： 整个解析过程需要 Protobuf 本身的框架代码和由 Protobuf 编译器生成的代码共同完成。Protobuf 提供了基类 Message 以及 Message_lite 作为通用的 Framework，，CodedInputStream 类，WireFormatLite 类等提供了对二进制数据的 decode 功能，从 5.1 节的分析来看，Protobuf 的解码可以通过几个简单的数学运算完成，无需复杂的词法语法分析，因此 ReadTag() 等方法都非常快。 在这个调用路径上的其他类和方法都非常简单，感兴趣的读者可以自行阅读。 相对于 XML 的解析过程，以上的流程图实在是非常简单吧？这也就是 Protobuf 效率高的第二个原因了。 编解码性能测试建议看看这篇文章，有从各个方面对比。 得出的结论是，protobuf 在整形与浮点型 编解码方面具有很大的优势。但是在字符串与对象的编解码方面性能不如 DSL-JSON。 http://www.52im.net/thread-772-1-1.html 参考文档http://blog.csdn.net/u011518120/article/details/54604615 https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html https://developers.google.com/protocol-buffers/docs/overview https://www.jianshu.com/p/bb3ac7e5834e]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络编程001:快速理解网络通信协议]]></title>
    <url>%2F2020%2F06%2F14%2Fblog_bak%2FBlog%2F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B001%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[互联网的五层模型层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守的规则，就叫做”协议”（protocol）。链接层通过网线传输的数据都是 0 和 1，但是单纯的 0 与 1 并没有意义，没法被解读，传输再多又有个鬼用。“链接层”的功能：确定了0和1的分组方式。 以太网协议以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。 “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”标头”的长度，固定为18字节。 “数据”则是数据包的具体内容。”数据”的长度，最短为46字节，最长为1500字节。 MAC 地址以太网数据包的”标头”中的发送者和接受者需要使用 MAC 地址来标识。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 广播以太网使用“广播”的方式向本网络内的所有计算机发送数据包，让计算机自己判断是不是接收方！！！ 这里还有一个问题：通常我们发送只需要一个 ip 地址和端口就行了，那么我们是没法知道接受方的 MAC 地址的啊，那么帧数据该怎么构建呢？ 这里又可以分成两种情况： 1）第一种情况：如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理；所以对方的MAC地址这一栏，填的是网关的 MAC 地址（网关是在同一个子网，使用ARP得到MAC地址）。 2）第二种情况：如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 网络层使用广播传递数据包会有问题： 广播只能在子网生效，如果不这样设计，将会引发广播风暴！一台上海的电脑能与一台纽约的电脑在同一个子网吗，显然是不可能的！ 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。 IP协议IPv4这个版本规定，网络地址由32个二进制位组成： 地址分为两部分，前面一部分为网络，后面一部分为主机。但是我们没法知道前面几位是网络，有肯能是24位，有可能是28位。所以我们需要子网掩码来判断。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 最终，我们只需要将子网掩码与IP地址做位与运算，结果相等就是在子网内。 IP数据包IP数据包也分为”标头”和”数据”两个部分： “标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样： 传输层我们的电脑中有多个程序，那么传输过来的数据应该给哪个程序使用呢？需要端口来标识。 UDP协议UDP数据包，也是由”标头”和”数据”两部分组成： “标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分： TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。 应用层“应用层”的作用，就是规定应用程序的数据格式。 DHCP协议计算机开机后，会自动分配到一个IP地址。每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。 1）最前面的”以太网标头”：设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 2）后面的”IP标头”：设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。 3）最后的”UDP标头”：设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 参考文档http://www.52im.net/thread-1095-1-1.html http://www.52im.net/thread-1103-1-1.html]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本地广播]]></title>
    <url>%2F2020%2F04%2F20%2Fblog_bak%2FBlog%2FAndroid-%E7%9F%A5%E8%AF%86%E7%82%B9%2F%E6%9C%AC%E5%9C%B0%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[在没有看本地广播的源码之前，我一直以为本地广播是借用了Broadcast实现的，它也会走进程间通信。但是看完之后，我发现完全不是这样的，它其实就是一个简单的观察者模式而已。我们先来看本地广播的好处：121. 发送的广播只会在自己App内传播，不会泄露给其他App，确保隐私数据不会泄露2. 其他App也无法向你的App发送该广播，不用担心其他App会来搞破坏比系统全局广播更加高效 这肯定是必然的，因为它就是一个观察者模式，和我们自己写的是没有什么实质上的区别的，不能支持进程间通信，肯定别的APP收不到我们发的广播，我们也收不到别的APP的广播。 关于本地广播的这个名字，我其实很想吐槽，因为这个名字给人的感觉就是广播的阉割版，会误让人以为是系统做了什么处理，才会有上面的好处。 使用123456789101112LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this);// 订阅lbm.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Handle the received local broadcast &#125; &#125;, new IntentFilter(LOCAL_ACTION)); // 发布lbm.sendBroadcast(new Intent(LOCAL_ACTION)); 上面就是本地广播的使用了。接下来，我们正式进入源码环节。 源码分析12345678public static LocalBroadcastManager getInstance(Context context) &#123; synchronized (mLock) &#123; if (mInstance == null) &#123; mInstance = new LocalBroadcastManager(context.getApplicationContext()); &#125; return mInstance; &#125;&#125; 本地广播是一个单例模式。 1234567891011121314151617181920212223public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; ReceiverRecord entry = new ReceiverRecord(filter, receiver); //从映射表取得receiver对应的IntentFilter ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); //如果没有找到，就添加这个映射 if (filters == null) &#123; filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(filter); //遍历filter,保存action到mActions中 for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125;&#125; 我们分析一下订阅的逻辑。 首先将 receiver 与 filter 封装成为一个 ReceiverRecord。 我们知道一个 action 也能会对应多个广播接收者，所以 mReceivers 肯定是 HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; 这样的。 我们知道一个广播接收者也可能会对应多个 action，所以 mActions 肯定是 HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; 这样的。 所以，这个方法的作用，其实就是在建立 IntentFilter 与 BroadcastReceiver 的相互映射关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) &#123; if (debug) Log.v(TAG, "Action list: " + entries); ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); // 省略代码 int match = receiver.filter.match(action, type, scheme, data, categories, "LocalBroadcastManager"); if (match &gt;= 0) &#123; if (debug) Log.v(TAG, " Filter matched! match=0x" + Integer.toHexString(match)); if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; else &#123; //省略代码 &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; // 核心代码 mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false;&#125; 虽然，sendBroadcast 方法有点长，但是大致的逻辑就是根据 intent 找到所有需要接受的 receivers，然后将他们添加到 mPendingBroadcasts 中，最后发送一个消息，让 handler 去处理。 12345678910111213141516private LocalBroadcastManager(Context context) &#123; mAppContext = context; mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; 这里 handler 直接调用了 executePendingBroadcasts 方法。 1234567891011121314151617181920private void executePendingBroadcasts() &#123; while (true) &#123; BroadcastRecord[] brs = null; synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); if (N &lt;= 0) &#123; return; &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; for (int i=0; i&lt;brs.length; i++) &#123; BroadcastRecord br = brs[i]; for (int j=0; j&lt;br.receivers.size(); j++) &#123; br.receivers.get(j).receiver.onReceive(mAppContext, br.intent); &#125; &#125; &#125;&#125; 逻辑还是很简单的，直接调用了 onReceive 方法，这样订阅者就可以接收到了。 LocalBroadcastManager 的核心实现实际上还是Handler，只是利用到了IntentFilter的match功能，至于BroadcastReceiver换成其他接口也无所谓，顺便利用了现成的类和概念而已。 而且还需要注意，因为使用的是主线程的 Looper，所以不要在接收者里面搞事情。]]></content>
      <tags>
        <tag>Android-知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap与LruCache]]></title>
    <url>%2F2020%2F04%2F11%2Fblog_bak%2FBlog%2FJava%2FLinkedHashMap%E4%B8%8ELruCache%2F</url>
    <content type="text"><![CDATA[与HashMap的关系123public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; ...&#125;accessOrder 字段1234567/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */final boolean accessOrder; 当这个字段为true的时候，迭代器的顺序是按照访问的顺序来输出的，为false的时候，是按照插入的顺序来输出的。 看几个例子： 当使用默认的构造函数，accessOrder为false 12345678910111213public static void main(String[] args) &#123; LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; 10; i++) &#123;//按顺序放入0~9 map.put(i, i); &#125; System.out.println(&quot;原数据：&quot;+map.toString()); map.get(3); System.out.println(&quot;查询存在的某一个：&quot;+map.toString()); map.put(4, 4); System.out.println(&quot;插入已存在的某一个：&quot;+map.toString()); //直接调用已存在的toString方法，不然自己需要用迭代器实现 map.put(10, 10); System.out.println(&quot;插入一个原本没存在的：&quot;+map.toString()); &#125; 输出： 12345// 输出结果// 原数据：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;// 查询存在的某一个：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;// 插入已存在的某一个：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;// 插入一个原本没存在的：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9, 10=10&#125; 使用带参数的构造函数 12345678910111213public static void main(String[] args) &#123; LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;Integer, Integer&gt;(20, 0.75f, true); for (int i = 0; i &lt; 10; i++) &#123;//按顺序放入1~9 map.put(i, i); &#125; System.out.println("原数据："+map.toString()); map.get(3); System.out.println("查询存在的某一个："+map.toString()); map.put(4, 4); System.out.println("插入已存在的某一个："+map.toString()); //直接调用已存在的toString方法，不然自己需要用迭代器实现 map.put(10, 10); System.out.println("插入一个原本没存在的："+map.toString());&#125; **输出**： 12345// 输出结果// 原数据：&#123;0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9&#125;// 查询存在的某一个：&#123;0=0, 1=1, 2=2, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3&#125;，被访问（get）的3放到了最后面// 插入已存在的某一个：&#123;0=0, 1=1, 2=2, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3, 4=4&#125;，被访问（put）的4放到了最后面// 插入一个原本没存在的：&#123;0=0, 1=1, 2=2, 5=5, 6=6, 7=7, 8=8, 9=9, 3=3, 4=4, 10=10&#125;，新增一个放到最后面迭代顺序正如注释所说。那么为何会这样呢？让我们慢慢来揭开LinkedHashMap神秘的面纱。 头尾指针123456789/** * The head (eldest) of the doubly linked list. */transient LinkedHashMapEntry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMapEntry&lt;K,V&gt; tail; head是双链表的头节点，tail自然是双链表的尾节点。那么这两个变量有什么用呢？他们与accesOrder有啥关系？ 我们先来分析，上面例子的行为。在第二个例子中，设置了 accessOrder 为 true，当我们调用 get() 方法之后，发现被访问的那个元素移动到了最后面。顺着get()方法来分析，为何为出现这种情况。 12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; getNode 是父类的方法，没有什么可以说的，值得深入的地方是最后的那个判断语句 12if (accessOrder) afterNodeAccess(e); 只有 accessOrder 为 true 的时候，才会执行 afterNodeAccess 这个判断似乎比较符合上面的行为。看来一切玄机都在这个方法里面。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMapEntry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 方法名后面的注释解释了这个方法的作用：将参数节点移动到双向链表的最后面去，即让 tail 节点指向 e。下面用一幅图来解释这个方法运作的原理： 如此这般，就将访问的节点e，移动到了双链表的尾节点。 同样的，我们在看看put()方法，由于LinkedHashMap没有覆盖put()方法，我们就去HashMap的源码中找找源头： 1234567if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue;&#125; 这里有个陷阱，你突然猛地一看，感觉是那么回事，调用了 afterNodeAccess 方法，但是调用这个方法的前提条件是 e != null，用普通话说就是 如果key已经在map里面存在的时候，才会调用这个方法，那么当 e == null 的时候呢，源码里面调用了 newNode 方法： 12345678// tab[i] 为null的时候tab[i] = newNode(hash, key, value, null);// 红黑树上添加一个TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);// 链表上添加一个p.next = newNode(hash, key, value, null); 这里又有一个坑，当我天真的查看 newNode 与 newTreeNode 的时候，发现根本就只是调用了一个构造方法，突然就懵逼了，这根本说不通啊，按照之前的例子的行为，每次添加一个新的元素，也应该要放到双链表的最后才对。在我翻了几篇博客的时候突然想到，这两个方法会不会被LinkedHashMap重写了，查看源码，果然： 123456Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMapEntry&lt;K,V&gt; p = new LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; 12345TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next); linkNodeLast(p); return p;&#125; 这两个货都调用了 linkNodeLast 方法，这个方法看名字就知道是将节点放到最后面，虽然它没有调用 afterNodeAccess，但是他们的作用确是一样的。 1234567891011// link at the end of listprivate void linkNodeLast(LinkedHashMapEntry&lt;K,V&gt; p) &#123; LinkedHashMapEntry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; 这个很简单，就不多说了。稍微提一下，按照源码的逻辑，每次新增的元素都是放在迭代器最后的，无论有没有开启 accessOrder，因为这里没有判断 accessOrder 字段，可以写demo验证一下。 还有一个忽略的地方，就是 LinkedHashMapEntry 这个 Entry 里面有两个变量 before，after，他们是前后指针，有了他们才能形成双链表。 LinkedHashMap的结构上面也说到过，LinkedHashMap是继承HashMap的，所以底层的数据结构与HashMap一样，不过它有自己的成员变量：head与tail。也就是说它增强了HashMap，在HashMap的基础上又维护了一个双链表。上图便于理解： 红色的箭头就是LinkedHashMap自己维护的双链表，其他的还是HashMap自己的东西。 LruCache 原理LruCache 解释：LRU是Least Recently Used的缩写，即最近最少使用。 为什么会有这个算法？ LRU算法的提出，是基于这样一个事实：之前使用过的数据，很可能在后面会频繁的使用到。反过来说，已经很久没有使用的数据很可能在未来较长的一段时间内不会被用到。这个，就是著名的局部性原理。因此，我们只需要在每次缓存满了的时候，移除最长时间没有使用的元素就好了。 其实看了这段解释，你应该能够想到LinkedHashMap，因为这个货设置 accessOrder 为 true的时候，每次都会将访问的元素放在双链表的最后面，那么当存放的数据满了之后，我们只需要移除head指向的元素就好了，这样的行为非常符合Lru的原理。 先上类图，搞清楚关系： 根据类图可以看出一个大概，LruCache的核心还是利用LinkedHashMap来实现的。LruCache的代码并不多，而且不难，300行不到，我们一点一点来看。 LruCache 构造函数123456789101112/** * @param maxSize for caches that do not override &#123;@link #sizeOf&#125;, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; look，它将 accessOrder 字段设置为 true，负载因子使用推荐（默认）的0.75。 LruCache get 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Returns the value for &#123;@code key&#125; if it exists in the cache or can be * created by &#123;@code #create&#125;. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; // 统计 hitCount 与 missCount synchronized (this) &#123; mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ // 如果key值不存在与map中，那么调用 create 方法创建一个，注意这个方法没有同步 V createdValue = create(key); // create 方法默认返回 if (createdValue == null) &#123; return null; &#125; // synchronized (this) &#123; createCount++; // 将创建的值放入map中，如果map在前面的过程中有别的线程放入了这对key-value，那么会返回放入的value mapValue = map.put(key, createdValue); // 不为空，说明不需要我们所创建的值，所以又把返回的值放进去 // 将新创建的值丢弃 if (mapValue != null) &#123; // There was a conflict so undo that last put map.put(key, mapValue); &#125; else &#123; //为空，说明我们更新了这个key的值，需要重新计算大小 size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; // 通知创建的值需要被移除，已经有别的线程创建了对应的key-value entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; // 没有冲突时，因为放入了新创建的值，大小已经有变化，所以需要修整大小 trimToSize(maxSize); return createdValue; &#125;&#125; 本来是不想贴代码的，因为贴了之后自己记不住，别人也懒得看，但是这个类确实很简单，自己看看就明白了。不帖代码也不知道该怎么写。 LruCache put 方法123456789101112131415161718192021222324public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; // 计算该 value 占用的缓存大小 size += safeSizeOf(key, value); previous = map.put(key, value); // 如果 key 存在，总的大小需要减去key对应的旧value的大小 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; // 调用钩子函数 if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; // 查看是否需要释放缓存空间 trimToSize(maxSize); return previous;&#125; LruCache trimToSize 方法1234567891011121314151617181920212223242526272829303132333435363738private void trimToSize(int maxSize) &#123; while (true) &#123; K key; V value; synchronized (this) &#123; if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; if (size &lt;= maxSize) &#123; break; &#125; // BEGIN LAYOUTLIB CHANGE // get the last item in the linked list. // This is not efficient, the goal here is to minimize the changes // compared to the platform version. Map.Entry&lt;K, V&gt; toEvict = null; for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123; toEvict = entry; &#125; // END LAYOUTLIB CHANGE if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; 看起来很长，但是其实就是不断的删除Head节点，直到缓存大小小于我们设置的最大缓存大小。没啥说的。 LruCahe 使用例子12345678910111213141516171819202122232425262728293031 mMemoryCache = new LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) &#123; /** * Notify the removed entry that is no longer being cached */ @Override protected void entryRemoved(boolean evicted, String key, BitmapDrawable oldValue, BitmapDrawable newValue) &#123; if (RecyclingBitmapDrawable.class.isInstance(oldValue)) &#123; // The removed entry is a recycling drawable, so notify it // that it has been removed from the memory cache ((RecyclingBitmapDrawable) oldValue).setIsCached(false); &#125; else &#123; // The removed entry is a standard BitmapDrawable if (Utils.hasHoneycomb()) &#123; // We're running on Honeycomb or later, so add the bitmap // to a SoftReference set for possible use with inBitmap later mReusableBitmaps.add(new SoftReference&lt;Bitmap&gt;(oldValue.getBitmap())); &#125; &#125; &#125; /** * Measure item size in kilobytes rather than units which is more practical * for a bitmap cache */ @Override protected int sizeOf(String key, BitmapDrawable value) &#123; final int bitmapSize = getBitmapSize(value) / 1024; return bitmapSize == 0 ? 1 : bitmapSize; &#125; &#125;;&#125; 上面的代码是Google很老的例子，因为Lru使用很简单，所以仍然用这个说明一下。 构造函数传递一个值，是用来限制缓存的大小的，比如你存放 bitmap，那么就需要根据App的可用内存来动态计算这个缓存应该占据多少。 entryRemoved 就是当资源被回收是会自动回调的一个钩子函数，如果你的缓存里面存放的资源被回收时，你还需要做一些别的操作，那么你需要实现这个方法。举个不恰当的例子，你想缓存一些连接，那么当这个连接被移除的时候，你肯定需要关闭这个连接，这个时候，在 entryRemoved 里面关闭就很容易了。 sizeOf 就是用来计算每个元素占用空间的大小。比如，图片一般的计算方式是计算图片被读取到内存中的大小，但是有时候可能产品脑子被驴踢了（不恰当的例子），它就要缓存固定个数的图片，不论图片大小，这个时候，sizeOf 就需要返回 1，只有这样才能满足要求。 LruCache 工作流程图 参考 https://blog.csdn.net/maosidiaoxian/article/details/51393753]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的扩容原理(基于JDK1.8)]]></title>
    <url>%2F2020%2F04%2F11%2Fblog_bak%2FBlog%2FJava%2FHashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[寻找储存的位置将一个键值对放到HashMap里面的时候，需要计算这个键值对存放到哪个位置，该位置的计算方式如下： 计算 key 的 hashCode 1234567// 使用 key 的 hashCode 方法来计算static final int hash(Object key) &#123; int h; // 当key = null时，hash值 = 0，所以HashMap的key 可为null // 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 根据容量大小与key的hashCode来算出位置 12// 这里 i 就是计算出来的位置，hash 就是上面 hash() 函数返回的值。i = (n - 1) &amp; hash 代码解析：因为 n 始终是2的幂次方，所以结果就是 hash &amp; （二进制位数全部为1的数），效果就相当于截取hash的最后几位，如果n=32，那么就是截取最后5位。 唯一的疑问就是为什么要将 key 的 hashCode 异或自己的高16位？其实计算hashCode的那段代码叫“扰动函数”。那它有什么作用呢？ 假设我们没有这段代码，直接使用 key 的 hashCode 来计算 table 中的位置，由于 key 可以是任意对象，这里再次假设它是一个自定义的对象，并且它的 hashCode 方法实现的非常糟糕，如下： 123int hashCode() &#123; return i &lt;&lt; 4;&#125; 可以看出来，无论i的值是多少，计算出来的 hashCode 的值，它的低 4 位全是 0 。那么使用这个 hashCode 去计算 table 的位置会发生什么呢？我们先认为这个HashMap 的容量是默认的 16，那么使用上面的 hashCode 计算出来的结果就全部是 0，所有的数据都会放在同一个位置，那么散列表就变成了链表。 可以看到，无论 hashCode 的高位是多少，&amp; 计算出来的结果，全都是0，所以就会导致非常高的碰撞几率。 其实，这都由于只取了散列值的最后几位引起的，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。 那么为了减少这种情况，扰动函数的作用就出来了，就是让 hashCode 的每一位都参与的计算中去，使用异或的方式，让结果保留一点高位的影子，这样它的低位值就是随机的了，即使 key 的 hashCode 实现的很糟糕。 2次方与扩容 为什么HashMap的容量要设计成2的幂次方呢？ 默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么HashMap会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) 因为HashMap的底层结构是数组，要将key的hashCode映射到这个数组中，最方便的办法就是取余，用hashCode % 容量大小就ok了。将容量设计为2的幂次方时，计算位置时，(n-1)&amp;hash 相当于 hash%n，而计算机里面位运算是基本运算，位运算的效率是远远高于取余%运算的。这是第一个考虑，还有一个好处，后面再说。 容量初始化算法 1234567891011121314151617/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) &#123; int n = cap - 1; // 右移1位，第一个为1的位的后面的位也变成了1，就有了两个连续的1 n |= n &gt;&gt;&gt; 1; // 因为有两个为1的位，所以右移2位，将那两个连续的1扩展为4个连续的1 n |= n &gt;&gt;&gt; 2; // 扩展为 8 位 n |= n &gt;&gt;&gt; 4; // 扩展为 16 位 n |= n &gt;&gt;&gt; 8; // 扩展为 32 位，正所谓星星之火可以燎原。 n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这里其实是很简单的一个思想：对于一个数字的二进制，从第一个不为0的位开始，把后面的所有位都设置成1。比如说一个数为1000,0000,0000，它的变化过程如下： 123451000,0000,00001100,0000,00001111,0000,00001111,1111,00001111,1111,1111 扩容的小技巧 扩容每次都是在原来的基础上变为2倍，这个比较简单，需要注意的是一个叫做负载因子的东西。HashMap扩容时，并不是装满容量了之后才扩容，而是有一个阈值：容量的大小 * 负载因子。那么负载因子的取值会有什么影响呢？ 上面说了这么多，都不是我们的目标，我们这次的目的是探究一下，每一个entry里面的元素是扩容之后是如何分配的？这要从hash碰撞说起。 无论Hash函数设计的多么精妙，总免不了hash碰撞，所以HashMap的结构才是数组加上链表加上红黑树，我们现在探究的就是如果一个entry是链表的时候，这个entry里面的数据是如何分配到扩容之后的HashMap中的。 看看源码的算法： 12345678910111213141516171819202122232425262728293031323334353637383940final Node&lt;K,V&gt;[] resize() &#123; ... Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 注意：不是(e.hash &amp; (oldCap-1));而是(e.hash &amp; oldCap) // (e.hash &amp; oldCap) 得到的是元素的在数组中的位置是否需要移动 // 这里是一个非常巧妙的地方，计算位置用的是 e.hash &amp; oldCap -1 // oldCap -1 的二进制位全部位1，比如32：1,1111，有5位 // oldCap 的二进制位只有第一位为1，后面的全部为0，比如32：10,0000，有6位 // 所以利用高出来的一位来计算新数组中的位置（这样就可以认为是随机分散的） if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 高位为0，则位置不变 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 高位为1，则位置变化 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; ...&#125; 这是JDK1.8的算法，e就是entry的头节点。可以看出来，它将原来的一个链表分成了两个链表loHead与hiHead，分割的条件就是`(e.hash &amp; oldCap) == 0`，e的hash其实就是上面分析的hash函数的值。因为代码中给了详尽的注释，所以这里不在赘述这行代码的意思。 容量为2的幂次方的第二个好处在`newTab[j + oldCap] = hiHead;`这行代码里面体现了出来，计算新的位置时，只需要在原来的基础上加上oldCap就行了。由于新分配的空间是原来的2倍，所以有一般还没有利用起来，这个时候，随机的（因为不知道hash值的高位是0还是1，所以可以认为是随机的）将原来的entry分为2个，一个放在原位置，一个放在新分配的位置，就完美的分散了原来的数据，并且将新的空间利用了起来。 上图说话： ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/Java/hashmap/resize.png?raw=true)初始化时，强烈建议给定容量大小 这个容量如何确定呢？在《阿里巴巴Java开发手册》有以下建议：initialCapacity = (需要储存的元素个数 / 负载因子) + 1。负载因子默认是0.75，如果实在是无法确定大小，可以给出默认值16。 为何需要给定大小？是因为如果需要put的数据非常多，而默认值是16的话，就需要进行很多次扩容操作，而扩容操作需要先申请新的内存，将原数据copy过去，再分配，比较耗时。 参考文档 https://blog.csdn.net/carson_ho/article/details/79373134 https://www.zhihu.com/question/20733617 http://www.hollischuang.com/archives/2431 https://blog.csdn.net/u013494765/article/details/77837338 https://blog.csdn.net/witsmakemen/article/details/78820410]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多指触控]]></title>
    <url>%2F2020%2F04%2F08%2Fblog_bak%2FBlog%2FAndroid-View%2F%E5%A4%9A%E6%8C%87%E8%A7%A6%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[有的博文已经写的非常好了，而且我在项目中几乎没有使用过，所以就贴个链接吧。请先阅读下面的参考文档，然后能够回答下面的问题： 为什么要把mFirstTouchTarget设计成链表？ 记录目标的TouchTarget的pointerIdBits又起到什么作用？ 设ViewGroup中，有2个Button：A，B： 按下A，再按下A（多点触控），为什么释放后A的点击事件只会触发一次？ 按下A，按下 ViewGroup 的空白区域，为什么先释放A，却无法触发A的点击事件，继续释放VG，又会触发A的点击事件？ 按下 ViewGroup 的空白区域，为什么点击A，B无响应？ 参考文档安卓自定义View进阶-MotionEvent详解 安卓自定义View进阶-多点触控详解 官方文档]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2020%2F04%2F06%2Fblog_bak%2FBlog%2FJava%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[几个参数我们先来看一下创建线程池的几个参数：123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize：核心线程数量。如果运行的线程少于该值，则直接创建新线程来处理任务，即使线程池中的其他线程是空闲的。 maximumPoolSize：最大线程数量。当任务队列已经满了，才会创建新线程直到线程数量等于该值。 workQueue：等待队列。当线程数量已经达到设置的核心线程的数量，仍然有新任务进来时，会进入该队列等待执行。 handler：拒绝处理策略。当线程数量已经达到设置的最大线程的数量，且等待队列已满，仍然有新任务进来时，会将任务交给该 handler 处理。 线程池的工作原理大致如下： 这个过程是从分析源码得出来的逻辑，我们可以大致看一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * clt记录着runState和workerCount */ int c = ctl.get(); /* * workerCountOf方法取出低29位的值，表示当前活动的线程数； * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中； * 并把任务添加到该线程中。 */ if (workerCountOf(c) &lt; corePoolSize) &#123; /* * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断； * 如果为true，根据corePoolSize来判断； * 如果为false，则根据maximumPoolSize来判断 */ if (addWorker(command, true)) return; /* * 如果添加失败，则重新获取ctl值 */ c = ctl.get(); &#125; /* * 如果当前线程池是运行状态并且任务添加到队列成功 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 重新获取ctl值 int recheck = ctl.get(); // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了， // 这时需要移除该command // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); /* * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法 * 这里传入的参数表示： * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动； * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断； * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。 */ else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; /* * 如果执行到这里，有两种情况： * 1. 线程池已经不是RUNNING状态； * 2. 线程池是RUNNING状态，但workerCount &gt;= corePoolSize并且workQueue已满。 * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize； * 如果失败则拒绝该任务 */ else if (!addWorker(command, false)) reject(command);&#125; 可以看到逻辑还是很清晰的。 那么，为什么会这样设计呢？为什么要等待队列满了之后才会创建更多的线程，而不是直接创建更多的线程？ 我们先要理解线程池是做什么的？为什么要设计出这么一个东西？？？ 我们先来说一下什么是线程，线程是一种轻量级的进程，是由进程派生出来的子任务，它是程序执行的一个路径；每个线程都有自己的局部变量表、程序计数器（指向真正执行的指令指针）以及各自的生命周期。 了解了这个定义，我们想一下，当 JVM 创建一个线程的时候，它创建线程需要消耗资源吗？不仅需要，而且这个消耗是无法忽略的。 那么，我们假设有这样的一种场景：任务请求数量非常多，但每个任务执行的时间很短，没有线程池会怎么样？会不断的创建然后销毁线程，这样就很影响系统性能。那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？ 这就是线程池的目的了。知道了线程池的目的之后，我们应该就明白了为啥要等待队列满了之后才会创建更多的线程。其实，想一下我们的现实生活，比如银行排队，只有队列站的老长了，才会有可能新开窗口，新开窗口还不够，就直接不接待后面的人了。 几个问题当线程池没有任务的时候，里面的线程处于什么状态？处于阻塞状态。 这是因为如果线程是新创建的，那它肯定会直接去处理刚拿到的任务了。 12345if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get();&#125; 这个 command 就是 execute 传进来的，新创建的线程就会执行这个 runnable。 当线程执行完任务之后，它会做什么呢？我们发现，线程执行的其实是一个 while 循环，里面才执行了 runnable： 123while (task != null || (task = getTask()) != null) &#123; ...&#125; 这个 task 就是 execute 传进来的 runnable。当线程执行完，它会被置空，所以会走到 getTask 方法。而 getTask 实际上是从等待队列取任务： 12Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :workQueue.take(); 所以，线程池没有任务的时候，线程会阻塞在 workQueue.take() 方法上。 新创建了一个线程池，里面有线程吗？显然是没有的，只有执行了 execute 才会创建线程。不过有方法指定。 如何关闭线程池？如何彻底关闭？我们知道，想让线程池关闭，就需要关闭线程。想关闭线程只有一个方法，跟它商量，怎么商量呢？使用中断。 我们看一下 shutdown 方法的注释： shutdown 方法会将已经提交的任务执行完毕，但是不会接受新的任务，该方法不是阻塞的，所以不会等到任务全部结束才返回。 再看源码： 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; interruptIdleWorkers 这个方法是中断空闲线程，所以它不会中断正在执行的线程，已经提交的任务，依然可以正常执行。 我们再看另一个方法 shutdownNow。 123456789101112131415public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125; interruptWorkers() 这个方法会中断所有线程。另外它还将workQueue中的任务给移除，并将这些任务添加到列表中进行返回。 所以 shutdownNow 比 shutdown 更彻底！但是还有一个问题，shutdownNow 会中止正在执行的任务吗？比如我有个任务超级耗时，调用 shutdownNow 的时候，才执行了 10%，那么这个线程会中止吗？其实这里就是为啥线程的中止需要两方协商了。假设A想要中止线程，但是线程不响应这个中止状态（比如做死循环），A能咋办呢？没办法！所以这个还是要看任务的具体状态，如果你在每次循环时都检查一下中断状态，就可以主动中止。 参考文档https://juejin.im/entry/58fada5d570c350058d3aaad]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001-Matrix源码分析：LooperMonitor 监测基石]]></title>
    <url>%2F2020%2F04%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FMatrix%2F001-Matrix%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ALooperMonitor%20%E7%9B%91%E6%B5%8B%E5%9F%BA%E7%9F%B3%2F</url>
    <content type="text"><![CDATA[Matrix是一个APM库，它提供了许多功能供我们使用。我们从最简单的功能开始分析。 com.tencent.matrix.trace.tracer.FrameTracer 这个类是用来展示app的帧率的，我们知道收集一个帧率还是相当容易的，但是这个库里面有些小细节以及扩展我们可以学习以下。这里我们不从Matrix的入口函数开始分析，因为这样函数的调用栈会显得很长，不利于阅读，我们直接从最低层的类开始说起，慢慢往上走，就像搭建房子一样。 我们介绍的第一个类是 LooperMonitor，它的作用是监听主线程Looper的消息处理回调。 我们知道，Looper在分发消息的时候，会打印日志： android.os.Looper#loop 1234567891011 final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125;... if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; 我们可以利用这个机制来监控消息的分发。首先，我们设置一个 Printer 进去： com.tencent.matrix.trace.core.LooperMonitor#resetPrinter 1234567891011121314151617181920212223private synchronized void resetPrinter() &#123; Printer originPrinter = null; try &#123; if (!isReflectLoggingError) &#123; originPrinter = ReflectUtils.get(looper.getClass(), "mLogging", looper); if (originPrinter == printer &amp;&amp; null != printer) &#123; return; &#125; &#125; &#125; catch (Exception e) &#123; isReflectLoggingError = true; Log.e(TAG, "[resetPrinter] %s", e); &#125; if (null != printer) &#123; MatrixLog.w(TAG, "maybe thread:%s printer[%s] was replace other[%s]!", looper.getThread().getName(), printer, originPrinter); &#125; looper.setMessageLogging(printer = new LooperPrinter(originPrinter)); if (null != originPrinter) &#123; MatrixLog.i(TAG, "reset printer, originPrinter[%s] in %s", originPrinter, looper.getThread().getName()); &#125;&#125; 这一段逻辑不复杂，首先是使用反射来获取原来的 Printer，然后将它包装一下，在重新设置回去。 我们看一下这个 Printer 的包装类的实现： com.tencent.matrix.trace.core.LooperMonitor.LooperPrinter 1234567891011121314151617181920212223242526272829303132class LooperPrinter implements Printer &#123; public Printer origin; boolean isHasChecked = false; boolean isValid = false; LooperPrinter(Printer printer) &#123; this.origin = printer; &#125; @Override public void println(String x) &#123; if (null != origin) &#123; origin.println(x); if (origin == this) &#123; throw new RuntimeException(TAG + " origin == this"); &#125; &#125; if (!isHasChecked) &#123; isValid = x.charAt(0) == '&gt;' || x.charAt(0) == '&lt;'; isHasChecked = true; if (!isValid) &#123; MatrixLog.e(TAG, "[println] Printer is inValid! x:%s", x); &#125; &#125; if (isValid) &#123; dispatch(x.charAt(0) == '&gt;', x); &#125; &#125;&#125; 对 println 方法进行了增强，也没做啥，就是先调用了原来的 println 方法，然后做了一下校验，校验是否有输出 ‘&lt;’ 和 ‘&gt;’ 这两个特殊字符。 如果校验通过，则会进行分发处理。注意这里的校验只会进行一次。 com.tencent.matrix.trace.core.LooperMonitor#dispatch 12345678910111213141516171819private void dispatch(boolean isBegin, String log) &#123; for (LooperDispatchListener listener : listeners) &#123; if (listener.isValid()) &#123; if (isBegin) &#123; if (!listener.isHasDispatchStart) &#123; listener.onDispatchStart(log); &#125; &#125; else &#123; if (listener.isHasDispatchStart) &#123; listener.onDispatchEnd(log); &#125; &#125; &#125; else if (!isBegin &amp;&amp; listener.isHasDispatchStart) &#123; listener.dispatchEnd(); &#125; &#125;&#125; 分发方法就是触发了 listener 的一些回调方法，里面的逻辑用了许多字段来判断，一下子不太好懂，有些逻辑理论上会重复，但是没错，建议多看几遍。 粗浅的理解就是遇到 ‘&gt;’ 字符，回调 onDispatchStart 方法，遇到 ‘&lt;’ 字符回调 onDispatchEnd 方法。 我们看看 LooperDispatchListener 的代码： com.tencent.matrix.trace.core.LooperMonitor.LooperDispatchListener 1234567891011121314151617181920212223242526272829public abstract static class LooperDispatchListener &#123; boolean isHasDispatchStart = false; public boolean isValid() &#123; return false; &#125; public void dispatchStart() &#123; &#125; @CallSuper public void onDispatchStart(String x) &#123; this.isHasDispatchStart = true; dispatchStart(); &#125; @CallSuper public void onDispatchEnd(String x) &#123; this.isHasDispatchStart = false; dispatchEnd(); &#125; public void dispatchEnd() &#123; &#125;&#125; 也没做什么，就是自身使用一个变量来控制了回调必须成对。然后将回调又封装了一层，子类只需要处理无参的方法就好了。 LooperMonitor类我们就分析完了，主要是提供了一个监听，我们注册这个监听就可以知道消息分发的开始与结束。]]></content>
      <categories>
        <category>Matrix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[屏幕适配]]></title>
    <url>%2F2020%2F04%2F05%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[我们先来理解一下屏幕适配这个概念。什么叫屏幕适配？屏幕适配是为了做什么？是为了让一个 10x10 的图标在所有屏幕上表现出一样的大小吗？不是的！那是为了什么？是为了让这个图标在所有手机屏幕上占的比例是一样的。比如，一个 320x480 的手机，10x10 的图标占手机宽度（讨论高度意义不大）的 1/32。而在一个 1080x1920 的手机上只占手机宽度的 1/108，这样就显得很奇怪。同样都是手机，你凭在我的手机上显示这么小，眼睛都看瞎了。 那么有没有什么办法能够解决这个问题呢？有的，Google提出了一个 dp 的概念。它能做什么呢？它可以让图标在所有屏幕上显示的是差不多一样大！！！但是这个解决了屏幕适配的问题吗？没有。 我们先看一下Google是如何借助于 dp 让图标在所有屏幕上显示的是差不多一样大的。 12345678910111213141516171819public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; 上面的代码就是Android的源代码，是用于单位转换的，我们看 COMPLEX_UNIT_DIP 这个 case。 它里面用到了一个叫做 density 的东西，那么什么是 density 呢？ 手机在出厂的时候，厂商就给手机设置了一个 dpi 值。按照规范来说，对于一个 320x480 的手机，它的 dpi 是 160。对于 1080 * 1920 的手机来说，它的 dpi 是 480。 density 就是 dpi/160 我们来计算一下，当我们在 xml 指定一个图标的宽度为 10dp： 在 320x480 的手机上，它占了 10 * （160/160）个像素，也就是10px。 在 1080 * 1920 的手机上，它占了 10 * （480/160）个像素，也就是30px。 所以，我们在 xml 指定单位为 dp 的时候，在不同的手机上会占据不同的 px 像素，这就是为什么它可以让图标在所有屏幕上显示的是差不多一样大。 但是我们之前说过了，仅仅是这样还是不够的，我们需要的是让图标占据屏幕宽度的比例一样大。上面的例子中，图标占据屏幕宽度的比例一样大吗？不一样！ 一个是 10/320，一个是 30/1080。 那么，有没有办法可以让他们的比例变得一样大呢？有，改变 density 的值。 density 适配假如，我们以 320x480 为基准，那么想让 1080x1920 的比例也是 1/32，就应该修改 density 的值为 (1 * density) / 1080 = 1 / 320。density = 1080 / 320 。 得出了这个公式，我们再来反推一下，1080 / 320 是什么意思，就是 屏幕的宽/设计图的宽，就是将屏幕分成了320份，由于源码里面最后乘上density，所以我们只需要按照设计图来写就ok了。 所以，只要UI出了设计图，我们就可以取设计图的宽为基准，然后为每个手机计算出 density，这样就完成了屏幕适配。 这个方法不适用于老项目，以及依赖的三方库有图标等资源的项目。 sw限定符适配smallestWidth适配，或者叫sw限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。 举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。 smallestWidth限定符适配和宽高限定符适配最大的区别在于，前者有很好的容错机制，如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件。这个特性就完美的解决了上文提到的宽高限定符的容错问题。 参考文章https://juejin.im/post/5b7a29736fb9a019d53e7ee2]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0053-面试中的算法]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[面试中的算法当时间复杂度为 O(1) 时，则无法再优化，需要从空间方面想办法。同样的，当空间复杂度为 O(1)时，只能从算法时间方面想办法（需出奇兵）。如何判断链表中是否有环？最容易想到的就是将每个节点记录下来，然后判断判断是否出现过即可。这样的话空间复杂度为0(n)，如果想要空间复杂度为 O(1)，该如何做呢？ 可以将链表想象成一条路，链表有环，即路也有环。想象一下操场。 操场的圆圈即链表的环。 判断一个链表有没有环，可以这样来。 我们小时候不是会进程做这样的题目么： 两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过 。这是因为跑的快的已经比跑的慢的多跑了一圈了，所以，我们可以利用这个现象来解决这个问题。 这个解决办法叫做快慢指针法。具体过程如下： 首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。 好的，解决方法理解了，那么下面出一些扩展内容： 如何求出环的长度？如果你能想出快慢指针法，那么这个问题也不难。如果你真的理解了快慢指针法，这个问题也不难。 就是让指针继续跑，再次相遇时，快指针就比慢指针多跑了一圈了，这个长度就是环的长度。我们只需要记下循环次数就好了。 如何找到入环点？这个问题就有点难度了，涉及到数学知识。看下面的图：]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Final 关键字]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FJava%2FJava%20Final%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final 关键字一般会多用于这样的几个地方： 变量当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。 防止被重写比如：java.lang.String 类 内部类访问外部局部变量这个我们经常使用，而且IDE也会提示你。但是你有没有想过Java为什么要设计成这样，这其中的秘密何在？ 比如，我们有这样的代码： 12345678910// 这个方法没有意义 public void fun() &#123; final int i = 10; new Thread(new Runnable() &#123; @Override public void run() &#123; int c = i + 10; &#125; &#125;).start(); &#125; 如果，我们没有给 i 声明 final 修饰符，IDE就会报一个错误（need to be final）。需要声明为 final 是因为，编译器编译的时候其实悄悄对函数做了手脚，偷偷把外部环境方法的局部变量 i，拷贝了一份到匿名内部类里。其实我们的代码经过编译之后变成了这样： 123456789101112public void fun() &#123; final int i = 10; new Thread(new Runnable() &#123; // copy 了一份 int copyI = i; @Override public void run() &#123; int c = i+10; &#125; &#125;).start();&#125; 所以，这样就知道为啥需要声明为 final 了，因为内部拷贝了一份，而内部使用到了这个变量的值，如果在运行时外部的值改变了，那么内部的值却没有更新，就会出现各种问题，所以就干脆不让它改变。 以前在面试的时候，总是有很多面试官喜欢问：final、finally的区别！这特么就很蛋疼，这两货除了长的像，有啥是一样的。其实他们应该问 final 与 volatile 有啥区别？这个问题就比较阴险了，如果你不往并发上想的话，就会觉得这特么是什么脑残问题！！ 说到这里，我们还是应该从 Java 的内存模型说起。 计算机内存模型大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度，因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的，下面以多核CPU为例）。 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK#锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 说完了内存模型，我们还要了解并发中的3个名词。 3个名词 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：即程序执行的顺序按照代码的先后顺序执行。 这3个名词就不细说了，有兴趣的可以自己查查资料。 最后，我们来说，Java 的内存模型。 Java内存模型在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 Volatile了解了这些，我们再来看看 volatile 的作用。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 那么这两句话是什么意思呢？可见性比较好理解，就是一个线程更改了值，另外一个线程需要重新读取这个值。这里又有一个很有趣的问题，看下面的代码： 12345public volatile int inc = 0;public void increase() &#123; inc++;&#125; 当这个方法在多线程中运行的时候，会出现问题。我们来细细说到一下： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 这里可能就有人想不通了，线程 1 从阻塞变为运行状态后，应该还需要再次读取 inc 的值才对啊，为啥它没有读取呢？其实还是那个原因，我们写的是Java代码，而程序运行的是指令，我们将 inc++ 这行代码转成指令看看： 1230: iconst_11: istore_12: iinc 1, 1 那么，这3个指令是啥意思呢？我们再将这3个指令转为 Java 代码看看： 12345public void increase()&#123; int tmp = inc; // 0 tmp = tmp + 1; // 1 inc = tmp; // 2&#125; 嗯，现在明白了吧。再 inc++ 这个过程中，由于对 inc 的读取在阻塞前已经完成了，所以后面就不用再次读取了。 再说一个有趣的例子，我们有这样的代码： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？ 答案是不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 也许你会很奇怪，就算是多线程，这段代码也不会出现问题啊，怎么可能会出现死循环，简直是无稽之谈！ 实际上，从代码上来看，只要线程2后执行，那么就一定会终止线程。但是，我们需要知道我们写出来的代码不一定就是运行的代码（编译器还会做一些手脚的）。在某些情况下，编译器会直接将上面的代码优化成下面这样： 123456789//线程1boolean stop = false;// 这里编译器做了优化while(true)&#123; doSomething();&#125; //线程2stop = true; 可以看到，由于没有 volatile 关键字，编译器不知道它是多线程程序，所以就直接优化成了死循环。 下面，来到了我们想要说的重点，重排序。啥是重排序呢？一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 一般情况下，这个优化没啥问题，它不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 如果，我们给 inited 添加 volatile 关键字，那么就不会发生指令重排序，程序也就不会出错。 说完了 volatile 对重排序的影响，下面我们说说 final，它对重排序也有一点的影响。 对于 final 域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个 final 域的写，与随后把这个构造对象的引用赋值给一个变量，这两个操作之间不能重排序 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序 举个例子（摘自《Java并发编程实践》）： 12345678public class Holder &#123; private int n; public Holder(int n) &#123; this.n = n; &#125; public void assertSanity() &#123; if (n != n) throw new AssertionError("error"); &#125;&#125; 假设这里有一个线程A执行了下面一段代码： 1Holder holder = new Holder(10); 同时有另一个线程B也在执行下面这段代码： 1if (holder != null) holder.assertSanity(); 那么在某些情况下就会抛出上面的异常，原因就是：Holder holder = new Holder(10);其实是由三步组成的 给holder分配内存 调用构造函数 将holder指向刚分配的内存 理想中是这个执行顺序，然而事实上这三步并不一定按照这个顺序执行，是为了优化效率而存在的指令重排在作怪，假如一个执行顺序为1 3 2，那么在刚执行完1和3的时候线程切换到B，这时候holder由于指向了内存所以不为空并调用assertSanity函数，该函数中的if语句并不是一步完成： 取左表达式n的值 取右表达式n的值 进行！=表达式运算 那么假设刚执行完第一步的时候B线程挂起并重新回到A线程，A线程继续执行构造函数并将n赋值为10，然后再次跳回B线程，这时候执行第2步，那么就会造成前后取到的n不一样，从而抛出异常。 那么加了final修饰之后会如何呢，JVM做了如下保证：一旦对象引用对其他线程可见，则其final成员也必须正确的赋值了。就是说一旦你得到了引用，final域的值(即n)都是完成了初始化的，因此不会再抛出上面的异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android V1 V2 签名机制]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FAndroid%20V1%20V2%20%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[很早之前就想写这个，直到现在才有时间。理解了这个发现对 HTTPS 也有了进一步的理解。 为什么需要签名 ？了解 HTTPS 通信的同学应该知道，在消息通信时，必须至少解决两个问题： 一是确保消息来源的真实性 二是确保消息不会被第三方篡改 我们先来看 HTTPS 签名以及校验的过程：这里只是简单的理了一下核心思路，有不懂的还是应该查看相关文献。 在安装 APK 时，同样需要确保 APK 来源的真实性，以及 APK 没有被第三方篡改。如何解决这两个问题呢？方法就是开发者对 APK 进行签名：在 APK 中写入一个“指纹”。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。 V1 签名过程首先我们任意选取一个签名后的 APK（Sample-release.APK）解压： 在 META-INF 文件夹下有三个文件：MANIFEST.MF、CERT.SF、CERT.RSA。它们就是签名过程中生成的文件，它们就是签名三贱客。 MANIFEST.MF该文件中保存的内容其实就是逐一遍历 APK 中的所有条目，如果是目录就跳过，如果是一个文件，就用 SHA1（或者 SHA256）消息摘要算法提取出该文件的摘要然后进行 BASE64 编码后，作为“SHA1-Digest”属性的值写入到 MANIFEST.MF 文件中的一个块中。该块有一个“Name”属性， 其值就是该文件在 APK 包中的路径。 在这个文件里面，我们也可以搜索到我们的dex文件的摘要，资源的摘要，有兴趣的可以自己动手试试，将apk拖到AS里面就搞定了。需要注意的是，这个文件中存放了未压缩之前的所有文件的摘要。 CERT.SF 发现这里里面的内容与 MANIFEST.MF 的文件差不多。MANIFEST.MF是对APK中的每个文件进行摘要，那么这个文件里面的条目是什么东西的摘要呢？ SHA1-Digest-Manifest：对整个 MANIFEST.MF 文件做 SHA1（或者 SHA256）后再用 Base64 编码 SHA1-Digest：对 MANIFEST.MF 的各个条目做 SHA1（或者 SHA256）后再用 Base64 编码 所以，CERT.SF 做了这些东西： 计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下 逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest CERT.RSA这里会把之前生成的 CERT.SF 文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。这里要注意的是，Android APK 中的 CERT.RSA 证书是自签名的，并不需要这个证书是第三方权威机构发布或者认证的，用户可以在本地机器自行生成这个自签名证书。Android 目前不对应用证书进行 CA 认证。 我们在 gradle 文件中配置的签名文件： 12345678signingConfigs &#123; release &#123; storeFile file('..\\release.jks') storePassword 'release' keyAlias = 'key0' keyPassword 'release' &#125;&#125; .jks 文件里面就包含了这些东西（通过 keytool 命令可以查看，但是看不到私钥）： 私钥 证书 这里会把之前生成的 CERT.SF文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。 需要理解的是：MANIFEST.MF 文件 与 CERT.SF 文件都是在计算 apk 文件的摘要。 签名校验签名验证是发生在APK的安装过程中，一共分为三步： 检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致。 使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过。 使用签名文件（SF 文件）检验 MF 文件没有被修改过。 由于使用了自签名证书，没有CA的参与，所以公钥有被替换的可能，但是由于是第三方重新签名，所以无法覆盖已安装的应用。 基于V1的多渠道打包方案最早的多渠道打包方案是这样的，由于以前都是使用的友盟统计，按照友盟官方文档说明，渠道信息通常需要在AndroidManifest.xml中配置如下值： 1&lt;meta-data android:value="Channel ID" android:name="UMENG_CHANNEL"/&gt; 然后，在build.gradle设置productFlavors： 12345678910111213141516171819android &#123; productFlavors &#123; kuan &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "kuan"] &#125; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"] &#125; qh360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "qh360"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "baidu"] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"] &#125; &#125; &#125; 这样打包虽然可以工作，但是只是为了替换一个 AndroidManifest.xml 里面的 meta-data 就需要将所有的 apk 文件重新打进一个新包里面，非常的浪费时间。 那么，有没有快速打包方法呢？显然是有的，下面介绍一下美团的打包方案。 美团V1签名打包方案我们上面分析过APK签名的校验，但是仔细想想，它有个漏洞，它校验了所有的 APK 里面的文件，以及签名3剑客，但是却没有对 MATE-INF 这个文件夹做校验。那么我们就可以这样做： 在 META-INF 目录下添加空文件，用空文件的名称来作为渠道的唯一标识。 这样我们的渠道信息就写入apk中的，而且不会影响签名。然后在app运行的时候，从 apk 文件里面读取出来就好了。 具体过程如下： 123456789# 创建渠道名的空文件f_empty_channel = open(channel_name, 'w')f_empty_channel.close() # 往渠道apk中添加空的渠道文件dest_channel_path = "./META-INF/" + channel_namef = zipfile.ZipFile(dest_apk, 'a')f.write(channel_name, dest_channel_path)f.close() 这样就搞定了，是不是很简单呢？这种方式的特点是：生成一个渠道包，需要经过解压缩、创建空文件、压缩这些步骤。 一种更快速的打包继美团多渠道打包方案之后，万能的网友又想出了一种更快速的打包方式。 由于apk文件实质上就是个zip包，因此可以利用zip包的文件结构，将渠道信息带进去即可。这种方式的特点：没有解压缩、压缩、重签名等步骤，比美团的打包效率还要高。 有兴趣的可以找找代码看看。 V2签名过程APK 签名方案 v2 是一种全文件签名方案，该方案能够发现对 APK 的受保护部分进行的所有更改，从而有助于加快验证速度并增强完整性保证。 从 Android 7.0 开始，Android 支持了一套全新的 V2 签名机制，为什么要推出新的签名机制呢？通过前面的分析，可以发现 v1 签名有两个地方可以改进： 签名校验速度慢校验过程中需要对apk中所有文件进行摘要计算，在 APK 资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢。 完整性保障不够META-INF 目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。 为了解决这两个问题，在 Android 7.0 Nougat 中引入了全新的 APK Signature Scheme v2。 V2 带来的影响由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。 v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。 V2签名过程v2 签名模式在原先 APK 块中增加了一个新的块（签名块），新的块存储了签名，摘要，签名算法，证书链，额外属性等信息，这个块有特定的格式，具体格式分析见后文，先看下现在 APK 成什么样子了。 为了保护 APK 内容，整个 APK（ZIP文件格式）被分为以下 4 个区块： ZIP 条目的内容（从偏移量 0 处开始一直到“APK 签名分块”的起始位置） APK 签名分块 ZIP 中央目录 ZIP 中央目录结尾 其中，应用签名方案的签名信息会被保存在 区块 2（APK Signing Block）中，而区块 1（Contents of ZIP entries）、区块 3（ZIP Central Directory）、区块 4（ZIP End of Central Directory）是受保护的，在签名后任何对区块 1、3、4 的修改都逃不过新的应用签名方案的检查。 ZIP 文件结构需要了解一下，不然不明白 ZIP 中央目录子类的东西。 zip文件分为3部分： 数据区 此区块包含了zip中所有文件的记录，是一个列表，每条记录包含：文件名、压缩前后size、压缩后的数据等； 中央目录 存放目录信息，也是一个列表，每条记录包含：文件名、压缩前后size、本地文件头的起始偏移量等。通过本地文件头的起始偏移量即可找到压缩后的数据； 对于待压缩的目录而言，每一个子目录对应一个中央目录数据项，记录该目录的描述信息。 中央目录结尾记录 标识中央目录结尾，包含：中央目录条目数、size、起始偏移量、zip文件注释内容等。 继续回到正题。 V2 签名摘要计算 说一下摘要计算规则： 将每个部分拆分成多个大小为 1 MB大小的chunk，最后一个chunk可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度； 计算chunk摘要：字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算； 计算整体摘要：字节 0x5a + chunk数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。 最后，将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。 V2 签名多渠道打包方案这里就不细说 APK Signing Block 区块里面的结构了，有兴趣的可以查查资料。 V2 签名这种方案，只保证了第1、3、4部分和第 2 部分（APK签名分块）包含的APK 签名方案 v2分块中的 signed data 分块的完整性。 APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。 所以，我们可以定义一个新的ID-VALUE，将渠道信息写入APK签名分块中。 V2 V1 签名校验2 签名机制是在 Android 7.0 以及以上版本才支持。因此对于 Android 7.0 以及以上版本，在安装过程中，如果发现有 v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制。 v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 .SF 文件属性当中有一个 X-Android-APK-Signed 属性： 1X-Android-APK-Signed: 2 因此如果想绕过 v2 走 v1 校验是不行的。 下一篇讲 V2 机制下的多渠道打包。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0015-线性表的链式储存结构]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0015-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[之前，我们说过，用顺序储存在插入与删除的情况下是效率比较低的。我们分析一下原因：每个元素是相邻的，当需要插入的时候，就必须要移动一些元素。想要提高插入与删除的效率，那么就不能让元素相邻。所以另外一种储存方案就被设计出来了——链式储存。所谓链式储存，就是不仅储存数据，还需要储存下一个元素储存的位置，就像一条链子一样，我们叫这种数据结构为单链表。如图： 要注意的是：链表中的第一个节点的储存位置叫头指针。 有两个概念比较容易混淆：头节点与头指针。 头指针是指向第一个节点的指针，如果链表有头节点，则头指针指向头节点，如果链表没有头节点，则头指针指向第一个元素的节点。 头节点是为了操作统一而创建的，一般只会储存第一个元素节点的位置信息。 看下面两个图： 没有头节点 有头节点 现在，我们来定义一下链表储存结构的节点的数据类型。 首先，它要储存下一个元素的位置 然后，它还有能储存数据 那么类就应该是这样的： 123456public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next; &#125; 链表就可以这样写： 12345678910public class MyList&lt;T&gt; &#123; private Node&lt;T&gt; head; public MyList() &#123; this.head = new Node&lt;&gt;(); &#125; &#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-逻辑结构与物理结构]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0002-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构就是说，一堆数据放在一起，它们之间会有某种关系在里面。下面，我们就来聊聊储存这些关系的结构，按照角度的不同，我们分为两大类：逻辑结构、物理结构。逻辑结构是描述数据之间的关系的，是我们今后要关注的，这是从我们的理解角度出发的。物理结构是数据之间的关系在计算机中的储存形式，是从计算机的角度出发的。 逻辑结构分为四种： 集合结构：可以理解为数学中的集合概念，就是一堆同性质（一般是）的数据放在一起，没啥别的要求。 线性结构：数据项之间是一对一的关系。比如，幼儿园放学的时候，小孩儿都拍成一排。 树形结构：数据项之间是一对多的关系。比如：公司上下级的关系。 图形结构：数据项之间是多对多的关系。比如：一个班级中的同学之间的朋友关系。 物理结构分为两种虽然计算机有多种储存介质，但是对于数据结构来说，都是针对内存说的。我们可以将内存理解为一个一个的格子。 顺序储存关系 顺序就是强迫症一样的摆东西，一个格子挨着一个格子，整整齐齐的。 链式储存关系 链式储存就是瞎几把乱放，有空位置就塞一个，但是需要额外的信息来储存下一个储存位置在哪，不然就找不到了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002_Dagger2使用及原理（1）]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F002_Dagger2%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们将上篇文章的例子用 dagger2 实现一下。dagger2 的引入就不说了，github文档很详细了。首先我们实现 Dragons 类：12345class Dragons &#123; fun callForWar() &#123; Log.e("EX01", "Dragons callForWar...") &#125;&#125; 再看 Targaryens 类： 12345678910111213141516class Targaryens constructor(dragons: Dragons) &#123; // 因为 dragons 是私有的，所以只能修饰 set 方法 var dragons = dragons @Inject set init &#123; DaggerEx01Component.create().inject(this) &#125; fun war() &#123; Log.e("EX01", "Targaryens call war...") dragons.callForWar() &#125;&#125; 我们使用 @Inject 注解修饰了 dragons 变量的 set 方法，在Java里面是修饰的字段，kotlin的写法有点不一样。 @Inject 注解是用来标记依赖的。它可以修饰字段与方法。这里表示这个字段需要注入，有点像butterknife。但是 @Inject 在不同的地方会有不同的意义，我们后面再说。 init 方法里的代码我们后面会说到。 现在，我们有了接收依赖（需要注入）的地方，那么哪里是生产依赖的地方呢？答案就是 @Module 注解了。 1234567891011121314@Moduleclass Ex01Module &#123; @Provides fun provideDragons(): Dragons &#123; return Dragons() &#125; @Provides fun provideTargaryens(dragons: Dragons): Targaryens &#123; return Targaryens(dragons) &#125;&#125; 首先，我们使用 @Module 修饰了这个类。类中有方法，使用 @Provides 修饰。 我们先说这个 provideDragons 方法的作用，显然就是提供一个 Dragons 的实例。看到这里，我们就立刻明白这里是生产依赖的地方。 provideTargaryens 提供一个 Targaryens 实例，这个方法很重要。因为上一篇文章，我们说过，如果每次创建一个 Targaryens 实例的时候，还要自己去创建一个 Dragons 实例，那写起代码来就很痛苦了。那么怎么办呢？办法就是把这种麻烦事交给 Dagger2 。 这里我们提供一个创建 Targaryens 实例的方法，这个方法需要一个 Dragons 作为参数，神奇的是，Dagger2 会自动使用 provideDragons 创建 Dragons 实例。所以这个 provideTargaryens 方法不是给我们使用的，而是给 Dagger2 用的。那么我们怎么从 Dagger2 获取 Targaryens 实例呢？后面再说。 可以想象一下，一个接收，一个生产，这两处地方，需要有一根线将它们连接起来，才能正常工作。 那么，怎么牵这根线呢？？？答案是使用 @Component 注解。 12345678@Component(modules = [Ex01Module::class])interface Ex01Component &#123; fun inject(targaryens: Targaryens) fun newTargaryens(): Targaryens&#125; 需要注意的是，Ex01Component 是一个接口，不是一个类！！！ @Component 注解可以设置参数值，是一个数组，里面是 class 值。我们传递了 Ex01Module 的 class 进去，这样就将 Module 连起来了。 接口里面有一个方法，这个方法相当于一个定义，因为我们要给 Targaryens 类的字段赋值，所以必须要声明一个方法。实际上，写完这个接口之后，对应的生成类就会生成了： com.aprz.daggerexamples.ex01.DaggerEx01Component 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class DaggerEx01Component implements Ex01Component &#123; private final Ex01Module ex01Module; private DaggerEx01Component(Ex01Module ex01ModuleParam) &#123; this.ex01Module = ex01ModuleParam; &#125; public static Builder builder() &#123; return new Builder(); &#125; public static Ex01Component create() &#123; return new Builder().build(); &#125; @Override public void inject(Targaryens targaryens) &#123; injectTargaryens(targaryens);&#125; @Override public Targaryens newTargaryens() &#123; return Ex01Module_ProvideTargaryensFactory.provideTargaryens(ex01Module, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));&#125; private Targaryens injectTargaryens(Targaryens instance) &#123; Targaryens_MembersInjector.injectSetDragons(instance, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module)); return instance; &#125; public static final class Builder &#123; private Ex01Module ex01Module; private Builder() &#123; &#125; public Builder ex01Module(Ex01Module ex01Module) &#123; this.ex01Module = Preconditions.checkNotNull(ex01Module); return this; &#125; public Ex01Component build() &#123; if (ex01Module == null) &#123; this.ex01Module = new Ex01Module(); &#125; return new DaggerEx01Component(ex01Module); &#125; &#125;&#125; 这个类很简单，里面有一个 Builder 类。但是一般我们不需要使用，因为这个类又提供了一个 create 方法，将Builder 又简化了。我们可以直接使用这个方法。 DaggerEx01Component类实现了 Ex01Component，我们看它的 inject 方法是做了什么。 com.aprz.daggerexamples.ex01.DaggerEx01Component#inject 12345678@Overridepublic void inject(Targaryens targaryens) &#123; injectTargaryens(targaryens);&#125;private Targaryens injectTargaryens(Targaryens instance) &#123; Targaryens_MembersInjector.injectSetDragons(instance, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module)); return instance;&#125; 这两个方法都很短，一看就明白，这里调用了 MembersInjector 类，一看就是给字段注入值。 com.aprz.daggerexamples.ex01.Targaryens_MembersInjector#injectSetDragons 123public static void injectSetDragons(Targaryens instance, Dragons p0) &#123; instance.setDragons(p0);&#125; 方法很简单，就是直接调用 set 方法就好了。 这里我没有看 Java 生成类是不是一样的，因为 Java 要求待注入的字段不能是私有的，所以是通过在同包下直接调用类的字段赋值，和 butterKnife 一样。 还有一个方法 : com.aprz.daggerexamples.ex01.DaggerEx01Component#newTargaryens 123@Overridepublic Targaryens newTargaryens() &#123; return Ex01Module_ProvideTargaryensFactory.provideTargaryens(ex01Module, Ex01Module_ProvideDragonsFactory.provideDragons(ex01Module));&#125; 这个就更简单了，其实就是调用了 Module 的 provide 方法创建了 Targaryens。可以看到，Dragons 也是由 Module 创建的。 到这里，基本就分析完了 dagger 最简单的运作原理。还是还有两个个地方。 第一个地方就是 com.aprz.daggerexamples.ex01.DaggerEx01Component#inject 这个方法应该在哪里调用呢？因为只有调用了这个方法，才算真正的赋值了。 因为 inject 方法需要一个 Targaryens 类的实例，所以，你可以在访问到该实例的任何地方调用。但是我们最好写在类里面，这样就不用没有实例都调用一遍，具体看上面的 Targaryens 类的 init 方法里面。 第二个地方是，如何获取 Targaryens 对象呢？显然是需要从 Component 里面获取。 12val targaryens = DaggerEx01Component.create().newTargaryens()targaryens.war() Dagger2 其实还有另外一种使用方式，不使用 Module 的方式。 com.aprz.daggerexamples.ex02.Dragons2 12345class Dragons2 @Inject constructor() &#123; fun callForWar() &#123; Log.e("EX02", "Dragons callForWar...") &#125;&#125; 注意这里与上面的不同之处，我们使用 @Inject 修饰了它的构造函数。 com.aprz.daggerexamples.ex02.Ex02Component 123456@Component(modules = [])interface Ex02Component &#123; fun inject(targaryens2: Targaryens2)&#125; 这里，我们没有使用Module，所以不用传值， com.aprz.daggerexamples.ex02.Targaryens2 12345678910111213141516class Targaryens2 &#123; // 直接标注属性@Inject lateinit var car: Car，编译时会报错 lateinit var dragons: Dragons2 @Inject set init &#123; DaggerEx02Component.create().inject(this) &#125; fun war() &#123; Log.e("EX02","Targaryens call war...") dragons.callForWar() &#125;&#125; 这里与之前代码一样。 可以看到，实际上，我们使用 @Inject 修饰构造函数的方法，代替了 @Module，少写了不少东西。 我们再看看生成的类，其中的不同之处在于： com.aprz.daggerexamples.ex02.DaggerEx02Component#injectTargaryens2 1234private Targaryens2 injectTargaryens2(Targaryens2 instance) &#123; Targaryens2_MembersInjector.injectSetDragons(instance, new Dragons2()); return instance;&#125; 这里是直接调用了 Dragons2 的构造函数，而 Module 写法是调用了 Module 类的 provide 方法。 所以有两种写法，这两种写法是可以配合使用的，看需要选择使用。 说明一下，这里如果我们使用的是 @Inject 修饰构造函数的方式，那么我们想 mock Dragons2 对象还是比较蛋疼的。但是我们可以取巧，我们直接 new 一个 Targaryens2 对象，mock 一个 Dragons2 对象出来，然后调用set方法设置进去就行了，但是这也只能对 kotlin 起作用，因为 java 不会自动生成 set 方法。所以最好还是使用 Module。 最后再总结一下各个注解的作用： @Inject 是用来标记依赖的（修饰字段是表示该字段要被注入依赖实例，修饰构造函数是）。 @Module 是用来给 Dagger2 自己使用的，创建依赖图的。 @Component 是用来给开发者使用的，它的生成类实现了我们定义的接口，用于我们的开发。]]></content>
      <tags>
        <tag>Android-单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001-做单元测试为何要使用Dagger2？]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F001-%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%BA%E4%BD%95%E8%A6%81%E4%BD%BF%E7%94%A8Dagger2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[首先，我们说一下依赖注入（Dependency Injection，以下简称DI）。为了解释以下概念，我将使用“权力的游戏”作为类比。如果你没有听说过，可以将（Targaryens和Dragons）替换为A和B。举个例子，我们有一个叫做Targaryens的类。这个类里面用到了另一个叫做 Dragons 的类。我们称 Targaryens 依赖 Dragons 。当我们要想使用 Targaryens 类，就必须也要一个 Dragons 类，Targaryens 不能单独存在。看下面的代码： 123456789class Targaryens &#123; public Targaryens() &#123; //Each time we use Targaryens, we need to create Dragons instance Dragons dragons = new Dragons(); dragons.callForWar(); &#125; &#125; 这样写有什么不好的地方呢？其实会有很多问题，比如，可重用行，可维护性，但是这些问题都很模糊，没有刻骨经历过的人都是体会不到的。看了也会转头忘掉。 由于我是基于学习单元测试的原因学习的dagger，所以我就只说一点原因–可测试性。 继续上面的例子，我们想测试一下 Targaryens 的构造函数中，callForWar 方法是否被调用了一次 ： 那么我们就需要 mock 出一个 Dragons 对象来测试（这里不明白的需要先去补补 mock 相关的东西再往下看）。现在问题就来了，就算我们 mock 出了一个 Dragons 对象出来后，怎么才能让这个 mock 对象替换构造函数里面的那个对象呢？？？这里是没法替换的！！！ 由此可见，这里这样写代码的话，我们的测试很难进行下去。 那么应该如果做呢？我们可以使用构造函数注入。看如下代码： 12345678910class Targaryens &#123; Dragons dragons; public Targaryens(Dragons dragons) &#123; this.dragons = dragons; dragons.callForWar(); &#125; &#125; 这样改写之后，我们 mock 出来的对象就可以传递到 Targaryens 中，接着就可以测试 callForWar 方法是否被正确的调用了，而且可以查看调用次数。 假如你的代码里面，一个类用到了另外一个类，那么前者叫Client，后者叫Dependency。结合上面的例子，Targaryens用到了Dragons，那么Targaryens叫Client，Dragons叫Dependency。 当然，这是个相对的概念，一个类可以是某个类的Dependency，却是另外一个类的Client。 DI的基本思想就是，对于Dependency的创建过程，并不在Client里面进行，而是由外部创建好，然后通过某种方式set到Client里面。这种模式，就叫做依赖注入。 是的，依赖注入就是这么简单的一个概念，这边需要澄清的一点是，这个概念本身跟dagger2啊，RoboGuice这些框架并没有什么关系。现在很多介绍DI的文章往往跟dagger2是在一起的，因为dagger2的使用相对来说不是很直观，所以导致很多人认为DI是多么复杂的东西，甚至认为只能用dagger等框架来实现依赖注入，其实不是这样的。实现依赖注入很简单，dagger这些框架只是让这种实现变得更加简单，简洁，优雅而已。 好了，了解了依赖注入之后，下面我们接着说，为何要使用 dagger 2！ 依赖注入可以让我们更轻松的写单元测试（当然还有其它好处），那么有的人就会说，这很简单的，我只要遵循这个规则，永远把依赖在外部实例化，不就好了吗？为啥我要用 dagger2 呢？？ 请看下面的一个例子： 假设有一个登录界面，LoginActivity，他有一个LoginPresenter，LoginPresenter用到了UserManager和PasswordValidator，为了让问题变得更明显一点，我们假设UserManager用到SharedPreference（用来存储一些用户的基本设置等）和UserApiService，而UserApiService又需要由Retrofit创建，而Retrofit又用到OkHttpClient（比如说你要自己控制timeout、cache等东西）。应用DI模式，UserManager的设计如下： 1234567891011public class UserManager &#123; private final SharedPreferences mPref; private final UserApiService mRestAdapter; public UserManager(SharedPreferences preferences, UserApiService userApiService) &#123; this.mPref = preferences; this.mRestAdapter = userApiService; &#125; /**Other code*/&#125; LoginPresenter的设计如下： 1234567891011public class LoginPresenter &#123; private final UserManager mUserManager; private final PasswordValidator mPasswordValidator; public LoginPresenter(UserManager userManager, PasswordValidator passwordValidator) &#123; this.mUserManager = userManager; this.mPasswordValidator = passwordValidator; &#125; /**Other code*/&#125; 在这种情况下，最终的client LoginActivity里面要new一个presenter，需要做的事情如下： 1234567891011121314151617181920212223public class LoginActivity extends AppCompatActivity &#123; private LoginPresenter mLoginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); OkHttpClient okhttpClient = new OkHttpClient.Builder() .connectTimeout(30, TimeUnit.SECONDS) .build(); Retrofit retrofit = new Retrofit.Builder() .client(okhttpClient) .baseUrl("https://api.github.com") .build(); UserApiService userApiService = retrofit.create(UserApiService.class); SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this); UserManager userManager = new UserManager(preferences, userApiService); PasswordValidator passwordValidator = new PasswordValidator(); mLoginPresenter = new LoginPresenter(userManager, passwordValidator); &#125;&#125; 可以看到。我们想使用一个简单的 LoginPresenter ，却要实例化一大堆我们根本不关心的东西。我们遵循了依赖注入的规则，却陷入了另一个漩涡。 dagger2 就是帮助我们逃离这个漩涡的工具。大致过程是：我们提供依赖的实例化方法，dagger2会管理这些方法，当某个对象需要一个依赖时，对应的实例化方法就会被调用。这样我们就不用手动的去实例化一大堆的对象了。]]></content>
      <tags>
        <tag>Android-单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[000_Android单元测试系列文章介绍]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F000-Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[最近主要在看关于代码风格与设计方面的书，它们都提到了TDD，然而从业这么多年，我却没有用到过。不得不说有点沮丧，所谓知耻而后勇，所以我准备看一下单元测试的系列教程，然后在以后的工作中慢慢实现TDD。下面的这个系列是最符合我口味的文章，所以我决定将链接搬过来。以下这个片段是最能触动我学习TDD的，先贴在这里，如果你也觉得说的不错，不妨再深入看看。 我为什么写单元测试首先，是因为我不够自信我相信大家都有接手，或者说参与到一个新项目的经历，也许是因为换了工作，也许是因为职位调动，或其他原因。当我拿到一个新项目的时候，会有一种诚惶诚恐的感觉，因为一时间比较难理清楚整个app的结构是怎么划分的，各部分各模块之间又是什么样的关系。我怕我改了某一个地方，结果其他一个莫名其妙的地方的受到了影响，然后导致了一个bug。这对于用户群大的app，尤其严重。所以，那种时候就会希望，如果我改了某个地方，能有个东西告诉我，这个改动影响到哪些地方，这样改是不是有问题的，会不会导致bug。虽然我可以把app启动起来，看看是不是能正常工作，然而一种case能工作，并不代表所有影响到的case都能工作。尤其是在不知道有哪些地方用到了的情况下，我更加难以去遍历所有用到的地方，一个一个去验证这个改动有没有问题。哪怕我知道所有的case，这也是一个很痛苦很费时间的过程，而且很多的外部条件也很难满足，比如说需要什么样的网络条件，需要用户是会员等等。在这种情况下，单元测试是才是最好的工具。首先，单元测试只是针对一个代码单元写的测试，保证一个代码单元的正确性总比保证整个app的正确性容易吧？遍历一个方法的所有参数和输出情况总比遍历一个app的所有用户场景容易吧？跑一次单元测试总比运行一次app快吧？因此，在改现有的代码之前，我会先对要改的代码单元做好隔离，写好测试，再去改，改好以后跑一边单元测试，验证他们依然是通过的，这时候我才有信心，将代码合并进去。同样的情况会发生在重构的时候，我是一个对烂代码不大有忍受能力的人，看到不好的代码，我会忍不住想要去重构，不然的话，没有办法写新的代码。而重构就会有风险。因为我不够自信，重构的时候，也会有一种诚惶诚恐的感觉。这时候如果有完备的单元测试的话，我就能知道我的这次重构到底破坏了哪些地方，是不是对的，这样相对来说，就会放心的多了。因此，想用单元测试来保证代码的正确性，这个是我喜欢写单元测试的重要原因之一。 再次，是因为我没有耐心对于有一定经验，有一定代码思想的人来说，当他拿到一个新的需求，他会先想想代码的结构，应该有那些类，那些组件，什么责任应该划分到哪里去，然后才开始动手写代码，这个是很自然的一个思维过程。然而在不写单元测试的情况下，我们可能要把整个feature都做完整，从model到controller(或Presenter、ViewModel）到view到util等等，一整套流程做下来，到最后才可能运行起来看看是不是对的，有的时候哪怕所有代码都写完了，也不一定能验证是不是对的，比如说后台还没有ready等等。总之，在没有单元测试的情况下，我们需要等到最后一刻才能手动验证代码是不是对的，然后发现原来这里错了一点，那里少了一点，然后一遍一遍的把app运行起来，改一点运行一遍。。。当我开始写单元测试之后，我发现这个过程实在是太漫长了，我喜欢写完一部分功能独立的代码，就能立刻看到他们是不是正确的。如果不是的话，我可以立刻就改正，而不用等到所有代码都写完整。要达到这点，那就只有写单元测试了。当然，哪怕有单元测试，最后还是要做一遍手动测试工作，然而因为前面我已经保证每一个单元都是对的，最后只不过是验证每一部分都是正确的串联起来了而已，这点相对来说，是很容易的。所以最后所需要的手动测试，可以少很多，顺利很多，也简单得多。 最后，是因为我懒如前所述，如果没有单元测试的话，那就只有手工测试，把app运行起来，如果有错的话，改一点东西，再运行起来。。。这个过程太漫长太痛苦，对于一个很懒的人来说，如果能写代码来代替手工测试，每次写完代码只需要按一次快捷键，就可以直接在IDE里面看到结果，那是多爽的一件事！所以冲着这点，我也不想回头。我记得上一次使用“把app运行起来”这种开发方式，还是因为调试一个动画效果。因为动画效果是很难单元测试的，那就只有改一点代码，跑一边app，觉得不对，再改一点，跑一边，这样来来回回反反复复，那感觉真是。。。 单元测试给我带来了什么更好的设计当你为自己的代码写单元测试的时候，尤其是采用TDD的方式，你会很自觉地把每个类写的比较小，功能单一，这是软件设计里面很重要的SRP原则。此外，你能把每个功能职责分配的很清楚，而不是把一堆代码都塞到一个类里面（比如Activity）。你会不自觉的更偏向于采用组合，而不是继承的方式去写代码。这些都是很好的一些代码实践。至于为什么TDD能够改善代码的设计，网上有很多的文章去分析和论证这个结论。我看到比较印象深刻的一句话是（具体在哪看的搜不出来了）：当你TDD的时候，你是从一开始，就从一个代码的使用者，或者说维护者的角度，去写你的代码。这样写出来的代码，自然会有更好的设计。 其实仅凭这一点，我就有足够的理由去学习TDD，在我优化自己的代码的过程中，无论如何处理，都会感觉自己处于一个瓶颈状态。而TDD刚好可以让我从使用者的角度来看待自己的代码，这是一个非常好的优化角度。 Android单元测试（一）：首先，从是什么开始 Android单元测试（二）：再来谈谈为什么 Android单元测试（三）：JUnit单元测试框架的使用 Android单元测试在蘑菇街支付金融部门的实践 再往后面学习，可能需要Dragger2、Robolectric、Mockito相关的知识，后面的文章也会讲到，不用太过担心，但是还是建议系列学习一下。 Mockito 的 kotlin 版本，MockK 系列文章： MockK：一款強大的 Kotlin Mocking Library (Part 1 / 4) MockK：一款強大的 Kotlin Mocking Library (Part 2 / 4) MockK：一款強大的 Kotlin Mocking Library (Part 3 / 4) MockK：一款強大的 Kotlin Mocking Library (Part 4 / 4) 学完这个系列，对 Mock 应该就有自己的理解了。继续单元测试系列。 Android单元测试（四）：Mock以及Mockito的使用 Android单元测试（五）：依赖注入，将mock方便的用起来 Android单元测试（六）：使用dagger2来做依赖注入，以及在单元测试中的应用 Android单元测试（七）：Robolectric，在JVM上调用安卓的类 看完了上面7篇文章，就可以写一些基本的测试了。但是还有一些高级用法可能不知道，下面开始介绍。 Android单元测试（八）：Junit Rule的使用 Android单元测试（九）：使用Mockito Annotation快速创建Mock]]></content>
      <tags>
        <tag>Android-单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003_单元测试中如何使用Android相关的类?]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F003_%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Android%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[习惯写单元测试的人都会这样说：android unit testing不好做！！！我们知道安卓的app需要运行在delvik上面，我们开发Android app是在JVM上面，在开发之前我们需要下载各个API-level的SDK的，下载的每个SDK都有一个android.jar的包，这些可以在你的android_sdk_home/platforms/下面看到。 当我们开发一个项目的时候，我们需要指定一个API-level，其实就是将对应的android.jar 加到这个项目的build path里面去。这样我们的项目就可以编译打包了。然而现在的问题是，我们的代码必须运行在emulator或者是device上面，说白了，就是我们的IDE和SDK只提供了开发和编译一个项目的环境，并没有提供运行这个项目的环境，原因是因为android.jar里面的class实现是不完整的，它们只是一些stub，如果你打开android.jar下面的代码去看看，你会发现所有的方法都只有一行实现：throw RuntimeException(&quot;stub!!&quot;); 而运行unit test，说白了还是个运行的过程，所以如果你的unit test代码里面有android相关的代码的话，那运行的时候将会抛出RuntimeException(“stub!!”)。 为了解决这个问题，现在业界提出了很多不同的程序架构，比如MVP、MVVM等等，这些架构的优势之一，就是将其中一层抽出来，变成pure Java实现，这样做unit testing就不会遇到上面这个问题了，因为其中没有android相关的代码。 但是 MVP、MVVM这些架构模式虽然解决了部分问题，可以测试项目中不含android相关的类的代码，然而一个项目中还是有很大部分是android相关的代码的，所以上面那种解决方案，其实是放弃了其中一大块代码的unit test。 当然，话说回来，android还是提供了他自己的testing framework，叫instrumentation，但是这套框架还是绕不开刚刚提到的问题，他们必须跑在emulator或者是device上面。这是个很慢的过程，因为要打包、dexing、上传到机器、运行起来界面。。。这个相信大家都有体会，尤其是项目大了以后，运行一次甚至需要一两分钟，项目小的话至少也要十几秒或几十秒。 那么怎么样即可以给android相关的代码做测试，又可以很快的运行这些测试呢？ Robolectric 来也解决的办法就是使用一个开源的framework，叫robolectric，他们的做法是通过实现一套JVM能运行的Android代码。 这样的话，调用 android 类就和调用普通类是一样的了。 看一个例子 com.aprz.daggerexamples.ex03.TipsHelper 123456789class TipsHelper constructor(private val status: Int) &#123; fun buildTips(context: Context): String &#123; return doSomething() + LicenseStatusResouceResolver.getString(context, status) &#125; private fun doSomething(): String = "doSomething"&#125; com.aprz.daggerexamples.ex03.LicenseStatusResourceResolver 1234567891011121314151617181920212223242526class LicenseStatusResourceResolver &#123; companion object &#123; fun getString(context: Context, @LicenseStatus licenseStatus: Int): String &#123; when (licenseStatus) &#123; WILL_EXPIRE -&gt; &#123; return context.getString(R.string.license_will_expire) &#125; EXPIRED -&gt; &#123; return context.getString(R.string.license_expired) &#125; &#125; return context.getString(R.string.unknown_error) &#125; &#125;&#125;const val WILL_EXPIRE = 1const val EXPIRED = 2@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)@Retention(AnnotationRetention.SOURCE)@IntDef(WILL_EXPIRE, EXPIRED)annotation class LicenseStatus 假如，让你测试一下com.aprz.daggerexamples.ex03.TipsHelper#buildTips 这个方法是否正常，你准备如何写做呢？ 如果我们按照单元测试的写法，做测试的话，会发现一个问题，就是我们无法获取一个 Context 对象。就算我们强行创建一个对象的话，传递进去，也会报出各种错误。 但是使用了Robolectric，就可以很容易的获取 Context，甚至 Activity，还可以控制 Activity 的生命周期。 看具体代码： 12345678910111213141516171819202122232425@RunWith(RobolectricTestRunner::class)@Config(sdk = [28])class TipsHelperTest &#123; private lateinit var context: Context @Before fun setupContext() &#123; val activity = Robolectric.buildActivity(MainActivity::class.java) context = activity.get() &#125; @Test fun testBuildTips() &#123; val willExpireTips = TipsHelper(WILL_EXPIRE) assertEquals("doSomething您的证件即将过期！！！", willExpireTips.buildTips(context)) val expiredTips = TipsHelper(EXPIRED) assertEquals("doSomething您的证件已过期！！！", expiredTips.buildTips(context)) val unknownTips = TipsHelper(-1) assertEquals("doSomething未知错误！！！", unknownTips.buildTips(context)) &#125;&#125; 可以看到，我们在类上加了些注解。 @RunWith 表示该测试是运行在 Robolectric 的 testRunner 上的，写过 androidTest 的都知道@RunWith(AndroidJUnit4::class)，表示运行在 AndroidJUnit4 上。 @Config 是对 RobolectricTestRunner 的运行环境的一些配置，可以配置 sdk 等等，具体可以戳类里面进去看看。 想要获取一个 Context，有几种方法： 1val activity = Robolectric.buildActivity(MainActivity::class.java) 这可以创建出一个 MainActivity 的对象，而且它是有生命周期的。比如，我们可以调用 activity.pause() 方法让 activity 进入暂停状态。 当然，不要忘记Gradle配置： 1234567891011android &#123; testOptions &#123; unitTests &#123; includeAndroidResources = true &#125; &#125;&#125;dependencies &#123; testImplementation 'org.robolectric:robolectric:4.3.1'&#125; 想了解 Robolectric 更多的API信息，只能去官网了。就先简单的介绍到这。 最后说一下，Robolectric 到底是个啥？ Robolectric就是一个能够让我们在JVM上跑测试时够调用安卓的类的框架。 在没有Robolectric的pure JUnit世界，我们是很难对一整个流程进行测试的，因为上层的界面是安卓的类，底层的数据库和SharedPreference等等是安卓的类。 然而有了robolectric以后，我们就可以这么做了：启动activity，向网络或数据库请求数据，更新界面。。。基本上覆盖的所有的逻辑。 我更倾向于使用 robolectric 做单元测试。]]></content>
      <tags>
        <tag>Android-单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004_如何测试一个没有返回值的函数？]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F004_%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[看下面的一个例子：12345678910111213141516171819202122232425262728293031class LoginViewModel constructor( val loginRepository: LoginRepository, val loginChecker: LoginChecker) &#123; fun login(username: String, password: String) &#123; // .... 其他代码 if (loginChecker.check(username, password)) &#123; loginRepository.login(password, username) &#125; &#125;&#125;class LoginRepository &#123; fun login(username: String, password: String) &#123;&#125;&#125;class LoginChecker &#123; fun check(username: String, password: String): Boolean &#123; return checkUsername(username) &amp;&amp; checkPassword(password) &#125; private fun checkUsername(username: String): Boolean &#123; return true &#125; private fun checkPassword(password: String): Boolean &#123; return true &#125;&#125; 这是一个很简单例子！ 现在，我们想测试： 当 LoginViewModel 的 login 方法被调用的时候，loginChekc.check 是否执行了，且参数是否正确？ 当 loginChekc.check 返回 true 的时候，loginRepository.login 是否执行了，且参数是否正确？ 让你写测试代码，你该如何做呢？ 可以看到，login 方法没有返回值，我们没法使用 assert 等语句。 那，啥玩意可以知道方法被调用了几次，还能检查参数呢？？？ Mockito我们先看看代码： 12345678910111213141516@Testfun testViewModelLogin() &#123; val loginRepository = mock(LoginRepository::class.java) val loginChecker = mock(LoginChecker::class.java) val loginViewModel = LoginViewModel(loginRepository, loginChecker) // 让 loginChecker#check 返回 true `when`(loginChecker.check("aprz512", "niubi")).thenReturn(true) loginViewModel.login("aprz512", "niubi") // 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致 verify(loginChecker).check("aprz512", "niubi") // 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致 verify(loginRepository).login("aprz512", "niubi")&#125; 我们首先使用 mock 方法创建了一个 mock 对象，注意这个参数接收的是一个 class！这个mock对象里面的方法都是空实现，返回值都是默认值。 其他的API可以去查一下文档，还是蛮简单的，这里就不说了，我要说的是其他东西。 当你运行这个单元测试的时候，会发现，报错了！！！ 原因是 kotlin 的类默认是 final 的，而 Mockito 是无法 mock final 类的。 当我们给类加上 open 修饰符时，发现又出了另外一个错误，原因是 kotlin 类里面的方法也是 final 的，也没法mock，我们还要给方法加上 open 才能正常进行测试，那这样的话，我们用 Kotlin 写的代码基本就没法使用 Mockito 测试了，该怎么办呢？ ###PowerMockito powerMockito 是一个对 Mockito 增强的库，可以测试私有方法，final类等等，可以 配合Mockito 使用。 1234567@RunWith(PowerMockRunner::class)@PowerMockRunnerDelegate(RobolectricTestRunner::class)@Config(sdk = [28])@PowerMockIgnore("org.mockito.*", "org.robolectric.*", "android.*")@PrepareForTest(Server::class)class ServerTest &#123;&#125; powerMockito 的使用需要写多一点配置，具体可看官方文档。 @PowerMockIgnore 是用来忽略哪些类是不用处理的，因为 PowerMockito 使用了自己的类加载来加载所有类，而某些包里面的类也使用了别的类加载器，如果不忽略的话，就会出现 ClassCastException。 但是，使用 PowerMockito 还有一个更蛋疼的问题，当我们的代码中有 Android 代码的时候，就需要向上面的代码一样配置 PowerMockRunnerDelegate，但是我配置了之后，还是有问题（照着官方文档配置的，也不知道哪里出了问题），所以我就暂时放弃研究 PowerMockito 了。 MOCKK这个是我在搜索 kotlin 应该如何使用 Mockito 时发现的一个库，看起来比上面两个都好用，所以就研究记录一下。 我们仍然是测试LoginViewModel，看看应该如何做。 123456789101112131415161718192021222324@Testfun testViewModelLogin() &#123; val loginRepository = mockk&lt;LoginRepository&gt;() val loginChecker = mockk&lt;LoginChecker&gt;() val loginViewModel = LoginViewModel(loginRepository, loginChecker) // 无论参数是啥，让 loginChecker#check 返回 true every &#123; loginChecker.check(any(), any()) &#125;.returns(true) // 因為在 MockK 裡面，預設情況下 Mock 這個動作是很嚴謹的，你必須要指定所有的行為操作才行 // 因为 com.aprz.daggerexamples.ex04.LoginViewModel.login 这个操作调用到了 loginRepository 的方法 // 所以，我们必须指定该方法在什么情况下返回什么，不然会出现如下错误 ： // io.mockk.MockKException: no answer found for: LoginRepository(#1).login(aprz512, niubi) every &#123; loginRepository.login("aprz512", "niubi") &#125; just Runs loginViewModel.login("aprz512", "niubi") // 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致 verify &#123; loginChecker.check("aprz512", "niubi") &#125; // 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致 verify &#123; loginRepository.login("aprz512", "niubi") &#125;&#125; 可以看到，基本的使用还是差不多，就是语法变化了，更加 kotlin。 运行没有出现任何问题，也不用将 class 与 方法 特地改为 open 的，但是唯一的缺点就是，我们需要手动的指定每个方法应该返回什么值。 假設今天 Class 的方法有 100 個，那豈不是要指定到天荒地老了嗎？有沒有辦法跟 Mockito 一樣不用指定行為也能做後續的 verify ？ 只要在 Mock 時，後面加上 relaxed = true 即可： 1val mother = mockk&lt;LoginChecker&gt;(relaxed = true) 也可以使用注解的方式： 12@RelaxedMockKlateinit var loginChecker: LoginChecker 与 RelaxedMockK 对应的有 MockK，显然 MockK 注解不具有 （relaxed = true） 的功能。 还有一种更细粒度的指定：对于没有返回值的函数无需显示指定，对于有返回值的函数需要手动指定。 单个指定 12@MockK(relaxUnitFun = true)lateinit var loginChecker: LoginChecker 全局指定 1234567@MockKlateinit var loginChecker: LoginChecker@Beforefun setUp() &#123; MockKAnnotations.init(this, relaxUnitFun = true)&#125; 那，我们使用 relaxed = true 来试一下： 123456789101112131415161718@Testfun testViewModelLogin() &#123; val loginRepository = mockk&lt;LoginRepository&gt;(relaxed = true) val loginChecker = mockk&lt;LoginChecker&gt;(relaxed = true) val loginViewModel = LoginViewModel(loginRepository, loginChecker) // 无论参数是啥，让 loginChecker#check 返回 true every &#123; loginChecker.check(any(), any()) &#125;.returns(true) loginViewModel.login("aprz512", "niubi") // 校验 loginChecker 的 check 方法是否执行了，且参数是否与之前的一致 verify &#123; loginChecker.check("aprz512", "niubi") &#125; // 校验 loginRepository 的 login 方法是否执行了，且参数是否与之前的一致 verify &#123; loginRepository.login("aprz512", "niubi") &#125;&#125; 运行代码，通过了测试！！！ verify如果，我们想验证某个方法执行了多少次，可以这样： 12verify(exactly = 0) &#123; xxx &#125;verify(exactly = 10) &#123; xxx &#125; exactly = 0 代表這段方法不會被调用，exactly = 10 代表會被调用 10 次，其他以此類推⋯⋯ verify 代码块里面也可以放入多个语句，表示它们分别执行了 exactly 次。 还可以验证方法被调用的顺序： 12345678verifySequence &#123; fun1() fun2()&#125;verifyOrder &#123; fun1() fun2()&#125; verifySequence 表示，fun2() 一定是接着 fun1()的。 verifyOrder 比较宽松，只要 fun2() 在 fun1() 后面调用就行。 Capture可以捕获方法的参数值。 12345678910111213141516171819class Kid(private val mother: Mother) &#123; var money = 0 private set fun wantMoney() &#123; mother.inform(money) money += mother.giveMoney() &#125;&#125;class Mother &#123; fun inform(money: Int) &#123; println("媽媽我現在有 $money 元，我要跟你拿錢！") &#125; fun giveMoney(): Int &#123; return 100 &#125;&#125; 测试代码： 123456789101112131415161718192021222324class MotherTest &#123; @RelaxedMockK lateinit var mother: Mother lateinit var kid: Kid @Before fun setUp() &#123; MockKAnnotations.init(this) kid = Kid(mother) &#125; @Test fun testMother() &#123; // Given val slot = slot&lt;Int&gt;() every &#123; mother.inform(capture(slot)) &#125; just Runs // When kid.wantMoney() // Then assertEquals(0, slot.captured) &#125;&#125; 可以看到，我们在 mother.inform(capture(slot)) 里面捕获了调用该方法的参数值，想要使用的时候，直接取就好了。 还有其他的用法，这里就不说了，请移步官网。 我们再测试，MockK配合Robolectric的使用情况。 12345678910class Kid(private val mother: Mother) &#123; var money = 0 private set fun wantMoney() &#123; mother.inform(money) money += mother.giveMoney() Log.e("Kid", "------") &#125;&#125; 添加一个 Android 特有的 Log.e 方法，再运行发现保住了，因为 Log 没有 mock。 我们在测试类上添加代码： 12@RunWith(RobolectricTestRunner::class)@Config(sdk = [28]) 再次运行，会发现测试通过了！！！所以 MockK 与 Robolectric 配合是没有问题的。]]></content>
      <tags>
        <tag>Android-单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Activity 的 onDestroy 方法里面调用 finish 会发生什么]]></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-Bugs%2F%E5%9C%A8%20Activity%20%E7%9A%84%20onDestroy%20%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%20finish%20%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[发现这个奇怪问题的起因在于同事看了MVVM的相关文章，里面提到屏幕旋转时，Activity 销毁重建不会导致 ViewModel随着销毁而重建。于是，就在项目中写了测试代码来验证。然后就发现了一个诡异的问题，打开的界面旋转后自动关闭了！！后来断点调试发现是因为 onDestroy 走了两次，分析逻辑之后，还原了执行流程，如下代码所示： Demo123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 由于历史原因，我们的项目里面出现了这样的代码（经过简化逻辑之后）。 finish();&#125; 那么问题就来了，Activity 在重建时，是创建了新的对象，为何旧的对象调用 finish 方法会将新创建的 Activity 对象给销毁？ 查看 finish 的源码： Activity android.app.Activity#finish(int) 12345678910111213141516171819202122private void finish(int finishTask) &#123; // mParent 为空，走里面的逻辑 if (mParent == null) &#123; ... try &#123; ... // 这里是最可疑的地方，AMS 是根据 mToken 的值去判断该 finish 哪个 Activity if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) &#123; mFinished = true; &#125; &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.finishFromChild(this); &#125; ...&#125; 那么，打印 mToken 的值看一下： Demo1234567891011121314151617181920@Override protected void onDestroy() &#123; super.onDestroy(); Class aClass = this.getClass(); while (aClass != Activity.class) &#123; aClass = aClass.getSuperclass(); &#125; try &#123; Field mToken = aClass.getDeclaredField("mToken"); mToken.setAccessible(true); Object o = mToken.get(this); Log.e("mToken", o.toString()); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; finish(); &#125; 输出 log 如下： 12E/mToken: android.os.BinderProxy@57d9656E/mToken: android.os.BinderProxy@57d9656 不出所料，那么现在就来看看源码，看 AMS 是如何根据 mToken 来管理 Activity 的。 Android 是如何根据手机方向来旋转屏幕的，这个我没法探究，但是 Activity 有一个方法，也可以设置屏幕方向，想来分析这个方法也是可行的。 Activity android.app.Activity#setRequestedOrientation 1234567891011121314public void setRequestedOrientation(@ActivityInfo.ScreenOrientation int requestedOrientation) &#123; // mParent 为null if (mParent == null) &#123; try &#123; // 走这里 ActivityManagerNative.getDefault().setRequestedOrientation( mToken, requestedOrientation); &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.setRequestedOrientation(requestedOrientation); &#125;&#125; 根据 Binder 机制，ActivityManagerNative.getDefault() 会返回 ActivityManagerProxy 对象，然后会调用到 ActivityManagerService 的 setRequestedOrientation 方法。 ActivityManagerService com.android.server.am.ActivityManagerService#setRequestedOrientation 1234567891011121314@Overridepublic void setRequestedOrientation(IBinder token, int requestedOrientation) &#123; synchronized (this) &#123; ... if (config != null) &#123; r.frozenBeforeDestroy = true; // 这里处理了方向的改变，里面还涉及到对 activity 方向改变的回调 if (!updateConfigurationLocked(config, r, false)) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; 后面的代码还是比较深的，这里就不贴出来了，跟踪到后面，会发现它调用了这样的一个方法。 com.android.server.am.ActivityStack#ensureActivityConfigurationLocked 123456 boolean ensureActivityConfigurationLocked( ActivityRecord r, int globalChanges, boolean preserveWindow) &#123; ...relaunchActivityLocked(r, r.configChangeFlags, true, preserveWindow); ... &#125; 这里它重新启动了这个 Activity（demo里面没有对方向变化做任何处理）。 我们知道，AMS 处理 Activity 的方法，都会通知到到应用进程，由应用进程自己处理。 ActivityThread android.app.ActivityThread#handleRelaunchActivity 1234567891011121314151617private void handleRelaunchActivity(ActivityClientRecord tmp) &#123; ... // tmp 是从需要重启的集合中找出来的 // 这里再次找一下，按照正常逻辑这里找出来的，应该还是同一个对象 ActivityClientRecord r = mActivities.get(tmp.token); ... // r.token 传递进去 handleDestroyActivity(r.token, false, configChanges, true); ... // r 传递进去 handleLaunchActivity(r, currentIntent, "handleRelaunchActivity"); ...&#125; ActivityClientRecord 是属于应用进程的，它里面存有 Activity 的信息。一个 ActivityClientRecord 对应一个 Activity。 这里可以看出，Activity销毁重建的时候，都使用的是同一个 ActivityClientRecord，mToken 没有变化。 当我们在 onDestroy 里面，调用 finish 的时候，传递的 mToken 值与重新创建的 Activity 的 mToken 值是一样的，所以会销毁掉刚刚启动的 Activity。 参考文章https://juejin.im/post/5c88fac76fb9a049c16013c6 https://blog.csdn.net/guoqifa29/article/details/46819377 https://www.jianshu.com/p/94816e52cd77]]></content>
      <tags>
        <tag>Android-Bugs</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F04%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FFragment%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[在做一个图片尺寸检查框架的时候，需要研究Activity与Fragment相关的源码，之前每次都分析过，但是却没有一个总体的影响，每次想要找一个什么东西的时候，都不得不从头找起，很蛋疼。这篇文章的作用就是整理出一个Fragment的轮廓，Fragment大概会涉及一些什么东西。首先，我们使用Fragment的方式如下： 1234getSupportFragmentManager() .beginTransaction() .add(R.id.container, new MyFragment()) .commit(); 上面的代码中，getSupportFragmentManager 其实是调用的 FragmentController 类的方法。 FragmentController这里就出现了第一个需要了解的类：FragmentController. 了解一个类最好的方法就是看它的结构： 我们顺便点个方法进去看： android.app.FragmentController#onCreateView 123public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; return mHost.mFragmentManager.onCreateView(parent, name, context, attrs);&#125; android.app.FragmentController#dispatchCreate 123public void dispatchCreate() &#123; mHost.mFragmentManager.dispatchCreate();&#125; 可以看到，这些方法都是转发给了 mFragmentManager。mFragmentManager 是一个 FragmentManagerImpl 对象。 除了这个 FragmentManagerImpl ，还有一个需要注意的地方，就是那个 mHost 变量。mFragmentManager 也是通过它调用的。 我们看一下构造函数： android.app.FragmentController#FragmentController 1234567private FragmentController(FragmentHostCallback&lt;?&gt; callbacks) &#123; mHost = callbacks;&#125;public static final FragmentController createController(FragmentHostCallback&lt;?&gt; callbacks) &#123; return new FragmentController(callbacks);&#125; mHost 是传递进来的。搜索一下调用的地方，发现只有Activity调用。Activity 有个成员变量： android.app.Activity#mFragments 1final FragmentController mFragments = FragmentController.createController(new HostCallbacks()); 所以，FragmentController 的 mHost 变量就是这里创建并传递进去的 HostCallbacks 了。 HostCallbacksHostCallbacks 是 Activity 的内部类，它的作用就和名字一样，是宿主的回调接口。 对于 Fragment 来说，Activity 就是宿主，这个类的作用，就是 Fragment 回调 Activity 方法的一个类。比如这个方法： android.app.Activity.HostCallbacks#onStartActivityFromFragment 1234@Overridepublic void onStartActivityFromFragment(Fragment fragment, Intent intent, int requestCode, Bundle options) &#123; Activity.this.startActivityFromFragment(fragment, intent, requestCode, options);&#125; 可以看到，就是调用了 activity 的方法。 Activity，FragmentController，HostCallbacks 3个类的关系如下： FragmentManager我们平常操作 fragment 所调用的 getSupportFragmentManager() 返回的就是 FragmentManager对象。FragmentManagerImpl 是 FragmentManager 的一个实现类。 FragmentManager是 fragment 的管理者，负责添加、删除、替换 fragment 等一些操作。 FragmentManager 做的一些操作，都是模仿数据库的，它会开启一个事务。实现这个事务的类叫做BackStackRecord。这个类不难，其实里面就是一个 ArrayList，然后将各种操作封装为 Op。事务就是将各种操作集合起来，然后一起执行。所以这个类的作用，就是将各种Op放到ArrayList里面，然后循环取出来执行。 最后，commit的时候，会调用到下面的这个方法： androidx.fragment.app.BackStackRecord#executeOps 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Executes the operations contained within this transaction. The Fragment states will only * be modified if optimizations are not allowed. */void executeOps() &#123; final int numOps = mOps.size(); for (int opNum = 0; opNum &lt; numOps; opNum++) &#123; final Op op = mOps.get(opNum); final Fragment f = op.fragment; if (f != null) &#123; f.setNextTransition(mTransition, mTransitionStyle); &#125; switch (op.cmd) &#123; case OP_ADD: f.setNextAnim(op.enterAnim); mManager.addFragment(f, false); break; case OP_REMOVE: f.setNextAnim(op.exitAnim); mManager.removeFragment(f); break; case OP_HIDE: f.setNextAnim(op.exitAnim); mManager.hideFragment(f); break; case OP_SHOW: f.setNextAnim(op.enterAnim); mManager.showFragment(f); break; case OP_DETACH: f.setNextAnim(op.exitAnim); mManager.detachFragment(f); break; case OP_ATTACH: f.setNextAnim(op.enterAnim); mManager.attachFragment(f); break; case OP_SET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(f); break; case OP_UNSET_PRIMARY_NAV: mManager.setPrimaryNavigationFragment(null); break; default: throw new IllegalArgumentException("Unknown cmd: " + op.cmd); &#125; if (!mReorderingAllowed &amp;&amp; op.cmd != OP_ADD &amp;&amp; f != null) &#123; mManager.moveFragmentToExpectedState(f); &#125; &#125; if (!mReorderingAllowed) &#123; // Added fragments are added at the end to comply with prior behavior. mManager.moveToState(mManager.mCurState, true); &#125;&#125; 这个方法里面就可以看到操纵 Fragment 的一些方法。然后这个方法里面又调用了另外一个很重要的方法： androidx.fragment.app.FragmentManagerImpl#moveToState(androidx.fragment.app.Fragment, int, int, int, boolean) 在这个方法里面，就有涉及到触发 fragment 生命周期的方法。比如说： 123456789case Fragment.CREATED:if (newState &gt; Fragment.CREATED) &#123; if (DEBUG) Log.v(TAG, "moveto ACTIVITY_CREATED: " + f); if (!f.mFromLayout) &#123; ViewGroup container = null; ... f.mContainer = container; f.performCreateView(f.performGetLayoutInflater( f.mSavedFragmentState), container, f.mSavedFragmentState); 这里就是调用 Fragment 的 onCreateView 方法的地方了，还有就是可以看到 inflater 的由来。 整体类图关系图如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[动态代理与InvocationHandler]]></title>
    <url>%2F2020%2F04%2F03%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EInvocationHandler%2F</url>
    <content type="text"><![CDATA[在说动态代理之前，我们先看一下静态代理。说起静态代理，很多人都会会心一样，因为它太简单了。静态代理看下面的一个例子：12345678910111213141516171819202122232425262728293031323334353637383940public interface Movie &#123; void play();&#125;public class RealMovie implements Movie &#123; @Override public void play() &#123; // TODO Auto-generated method stub System.out.println("您正在观看电影 《肖申克的救赎》"); &#125;&#125;public class Cinema implements Movie &#123; RealMovie movie; public Cinema(RealMovie movie) &#123; this.movie = movie; &#125; @Override public void play() &#123; guanggao(true); movie.play(); guanggao(false); &#125; public void guanggao(boolean isStart)&#123; if (isStart) &#123; System.out.println("电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！"); &#125; else &#123; System.out.println("电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！"); &#125; &#125;&#125; 上面的代码里面，Cinema就是一个代理类，它代理了 RealMovie 对象。一般来说，代理类与被代理类都会实现同一个接口，这样使用者就不用管它到底是不是代理类。使用者只需要知道它可以实现想要的功能就行了。 甚至有时候，我为了偷懒都不想去写接口，只是写一个包装类做些处理，然后将请求转发给被代理类。 所以，静态代理就是这样的一个东西，代理类可以预先处理一些东西，而被代理类是实现真正的功能。 动态代理我们再来看看动态代理。Java 里面使用动态代理很简答，我们看代码： 1Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), DInvocationHandler()); Proxy.newProxyInstance 就是为了生成一个代理类，上面说静态代理的时候已经说了啥是代理类。这里我们不去追踪源码研究这个类是怎么生成的，我们直接看看它生成的类是个什么样子！！！ 这是一个接口： 12345public interface ICook &#123; void dealWithFood(); void cook();&#125; 这里是生成的代理类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public final class $Proxy0 extends Proxy implements ICook &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m4; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void cook() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void dealWithFoot() throws &#123; try &#123; super.h.invoke(this, m4, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[]&#123;Class.forName("java.lang.Object")&#125;); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m3 = Class.forName("com.company.ICook").getMethod("cook", new Class[0]); m4 = Class.forName("com.company.ICook").getMethod("dealWithFoot", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 是不是没什么惊喜！它和静态代理的代理类是一样的功能，将请求转发给被代理类。 只不过这里它多了一个东西，那就是 InvocationHandler。那么为什么要多一个 InvocationHandler 呢？ 显然是因为这个类是动态生成的，我们无法修改它，那么我们想在代理类里面搞事的想法不就无法实现了吗！但是这难不倒Java设计人员，它搞了一个接口 InvocationHandler ，将每个请求的转发转给 InvocationHandler，然后由实现者自己再去将请求转发给代理类。 所以，动态代理的本质与静态代理是一样的，它只不过是将请求先转发到 InvocationHandler，然后由开发者自己再去将请求转发给被代理类。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画原理]]></title>
    <url>%2F2020%2F04%2F02%2Fblog_bak%2FBlog%2FAndroid-View%2F%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android 的动画分为两种：一种是补间动画，一种是属性动画。补间动画补间动画，很简答，就是我们使用的各种 Animation。这段代码就可以执行一个缩放动画，那么你知道补间动画到底是怎么运行的吗？我们先来看一张图：这是 View 的绘制流程，它与动画有什么关系呢？我们看一下 draw 方法的源码： android.view.View#draw(android.graphics.Canvas, android.view.ViewGroup, long) 1boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123;...&#125; 大致过一下里面的代码，很长，与动画相关的代码在很前面，很容易找到： 1more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); 这里其实是计算动画对脏区的影响。与动画是如何实现的并没有关系！！！ android.view.View#applyLegacyAnimation 12345678910111213141516171819202122232425262728293031private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) &#123; ... // 这里主要是获取 invalidationTransform final Transformation t = parent.getChildTransformation(); boolean more = a.getTransformation(drawingTime, t, 1f); if (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != 1f) &#123; if (parent.mInvalidationTransformation == null) &#123; parent.mInvalidationTransformation = new Transformation(); &#125; invalidationTransform = parent.mInvalidationTransformation; a.getTransformation(drawingTime, invalidationTransform, 1f); &#125; else &#123; invalidationTransform = t; &#125; if (more) &#123; if (!a.willChangeBounds()) &#123; ... &#125; else &#123; ... // 获取到 invalidationTransform，使用它去计算脏区 a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region, invalidationTransform); ... &#125; &#125; return more;&#125; 我们继续往下搜索动画相关的代码： android.view.View#draw(android.graphics.Canvas, android.view.ViewGroup, long) 123456more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);concatMatrix = a.willChangeTransformationMatrix();if (concatMatrix) &#123; mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;&#125;transformToApply = parent.getChildTransformation(); 这个 transformToApply 很像我们要找的东西，因为如果让你做动画，你怎么做呢？我们该如何将一个View平移？？有几种方案，一种是直接改变View的位置，一种是改变 child 画布的位置。而 Transformation 里面有一个 matrix 是可以进行变化画布的。 我们最终这个 transformToApply，会发现如下代码： 12345// Undo the scroll translation, apply the transformation matrix,// then redo the scroll translate to get the correct result.canvas.translate(-transX, -transY);canvas.concat(transformToApply.getMatrix());canvas.translate(transX, transY); 这里证实了我们的猜想。在重绘的过程中，将动画某一时机的改变记录成 Matrix，然后应用到画布里面。这样动画就实现了。 那么，问个问题：当调用了 View.startAnimation() 之后，动画是马上就执行了么？ 属性动画属性动画的原理其实也不难。 相较于补间动画，属性动画的优势在于，它不用在动画执行的时候不断的调用 View 的 draw 方法了，只是简单的更新了脏区，而且如果 View 支持硬件加速，只需要更新 DisplayList 即可。 我们知道，屏幕的显示都是由一帧一帧的画面组成的，属性动画其实就是利用了这一点。 动画向 Choreographer 注册一个 callback，注册了监听之后，每次屏幕刷新的时候，它都会回调这个 callback，然后我们就可以在这里面处理动画逻辑了。 记录动画的起始时间，这个时间是用来计算动画的百分比。里面会用到插值器与估值器，不明白这两个概念的需要去补一下。 这里简单介绍。 我们将时间进行归一化，将动画时间范围归化到 [0, 1] 这个区间，下面我们称这个为时间进度。 插值器：根据时间进度计算出动画进度。什么意识呢？当你的动画不是匀速的时候，动画进度与时间进度不是一样的。比如加速动画，可能时间到了 50%，动画才到 25%，后面才越来越快。 估值器：当我们指定一个值从 20 变化到 100，那么估值器的作用就是根据动画进度（插值器计算出来的新的进度）计算出当前时刻的动画值。 其实有了上面两个步骤，我们自己应该也能写出一个动画效果。但是Android源码不满足于此，它还有更多东西：关键帧。关键帧可以看作是对动画某一重要时刻的数据的封装。 关键帧的数量是由 ValueAnimator.ofInt(0, 1, 2, 3) 参数的数量来决定的，比如这个就有四个关键帧，第一帧和最后一帧是必须的，所以最少会有两个关键帧，如果参数只有一个，那么第一帧默认为 0，最后一帧就是参数的值。当调用了这个 ofInt() 方法时，关键帧组也就被创建了。 当只有两个关键帧时，映射的规则是，如果没有设置估值器，那么就等比例映射，比如动画进度为 0.5，需要的值变化区间是 0-100，那么等比例映射后的值就是 50，那么我们在 onAnimationUpdate 的回调中通过 animation.getAnimatedValue() 获取到的值 50 就是这么来的。 插值器，关键帧，估值器配合，就可计算出当前时间的动画值，然后拿到这个动画值，去更新 View。如何更新呢？使用反射： android.animation.PropertyValuesHolder#setAnimatedValue 123456789101112131415void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; try &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125; catch (InvocationTargetException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e("PropertyValuesHolder", e.toString()); &#125; &#125;&#125; 这里面的 mSetter 其实是对 View 反射方法的一个封装，它是调用了如 android.view.View#setTranslationX 之类的方法。 android.view.View#setTranslationX 12345678910public void setTranslationX(float translationX) &#123; if (translationX != getTranslationX()) &#123; invalidateViewProperty(true, false); mRenderNode.setTranslationX(translationX); invalidateViewProperty(false, true); invalidateParentIfNeededAndWasQuickRejected(); notifySubtreeAccessibilityStateChangedIfNeeded(); &#125;&#125; 这样，View 的属性动画就完成了。]]></content>
      <tags>
        <tag>Android-动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件加速了解一下]]></title>
    <url>%2F2020%2F04%2F02%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[由于几年前在XXX面试时，有一个 Canvas.saveLayer 的问题没有答好，导致没有拿到期望的薪资，所以拒绝了，心有怨念，所以做了一些笔记。今天突然发现这些知识点完全想不起来了，多以再次复习一下。应该还是有相当一部分开发者不知道硬件加速到底是个什么东西。这个名词跟硬件相关，可能是一个很高级的东西，潜意思里都不想去接触。但是实际上，以我们的能力理解起来是没有问题的。听我慢慢道来。 系统变化在Android平台的演变过程中，针对图形渲染方面的改进： Android 3.0 Honeycomd 中，引入了硬件加速。 Android 4.0 Ice Cream Sandwich 中，默认开启硬件加速。 随着平台带来的这个变化，视图以及所有的Canvas对象的绘制操作，原本由CPU来完成，现在都交由GPU来完成。 硬件加速的主要原理通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，转由GPU完成。 可以看到，硬件加速的底层确实是与硬件相关，但是这个不是我们的主要了解对象。我们需要了解的是它对我们开发者有什么影响。 从例子开始我们开一个新项目： 自定义两个View： 12345678910111213141516171819202122232425262728293031323334class HardwareLinearLayout @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr) &#123; init &#123; setWillNotDraw(false) &#125; override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) Log.e("HardwareLinearLayout", "onDraw") &#125;&#125;class HardwareTextView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : TextView(context, attrs, defStyleAttr) &#123; companion object &#123; @JvmStatic val TAG = "HardwareTextView" &#125; override fun onDraw(canvas: Canvas?) &#123; super.onDraw(canvas) Log.e(TAG, "onDraw") &#125;&#125; 给这两个控件都设置上背景颜色，如果没有给HardwareLinearLayout设置背景色，需要调用 setWillNotDraw(false)，在界面上的布局如下： 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.example.hardware.HardwareLinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/colorAccent" android:gravity="center" android:id="@+id/linear" android:orientation="horizontal" tools:context=".MainActivity"&gt; &lt;com.example.hardware.HardwareTextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@color/colorPrimary" android:text="Hello World!" /&gt;&lt;/com.example.hardware.HardwareLinearLayout&gt; 界面非常的简单，一个 LinearLayout 包含了一个 TextView。 然后给添加点击事件，事件也很简单，重绘自己而已。 1234567override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) text.setOnClickListener &#123; text.invalidate() &#125; linear.setOnClickListener &#123; linear.invalidate() &#125;&#125; 那么，有趣的问题来了！！！ 测试会出现以下几种情况： 给Application设置 android:hardwareAccelerated=”false” ，当我们点击这个TextView的时候： 12E/HardwareLinearLayout: onDrawE/HardwareTextView: onDraw 给Application设置 android:hardwareAccelerated=”true”，当我们点击这个TextView的时候： 1E/HardwareTextView: onDraw 给Application设置 android:hardwareAccelerated=”false” ，当我们点击这个LinearLayout的时候： 12E/HardwareLinearLayout: onDrawE/HardwareTextView: onDraw 下面我们来说说为什么会这样。我们首先介绍一下两个绘制模型。 基于软件的绘制模型也就是没有硬件加速之前的模型。 基于软件的绘制模型主要由以下两步构成： Invalidation: 当视图层级需要更新，或者只是 View 的一个属性发生变化，View.invalidata() 方法就会被调用，该方法会传播到整个视图层级，使得整个视图层级被重绘。 Redrawing: 每个 View 在重绘时，都会消耗大量的CPU性能。 基于软件的绘制模型缺点分析： 首先，这个模型需要在每个绘图过程中执行大量代码。 例如，如果您的应用程序界面中有一个按钮，并且该按钮位于另一个视图的顶部。 调用按钮的invalidate()方法，则Android系统会重新绘制整个视图（包括按钮下面的另一个视图），即使它没有更改。 第二个问题是绘图模型可以隐藏应用程序中的错误。 由于Android系统在与脏区域相交时重绘视图，因此即使invalidate()方法没有在脏区域上调用，也可能会重绘它。 发生这种情况时，我们是依赖于另一个视图触发了invalidate()方法以获得正确的行为。 因此，每当修改影响视图绘图代码的数据或状态时，应始终在自定义视图上调用invalidate()。 基于软件绘制模型中调用 invalidate() 所发生的事情: 默认情况下，View的clipChildren属性为true，即每个View绘制区域不能超出其父View的范围。如果设置一个页面根布局的clipChildren属性为false，则子View可以超出父View的绘制区域。 当一个View触发invalidate，且没有播放动画、没有触发layout的情况下： clipChildren为true时，脏区会被转换成ViewRoot中的Rect，刷新时层层向下判断，当View与脏区有重叠则重绘。如果一个View超出父View范围且与脏区重叠，但其父View不与脏区重叠，这个子View不会重绘。 clipChildren为false时，ViewGroup.invalidateChildInParent()中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。 简而言之，就是基于软件绘制的模型不仅仅会重绘自己，还会影响到与自己相交的控件。 基于硬件加速绘制模型基于硬件加速绘制模型主要由以下三步构成：随着全新硬件加速绘制模型的引入，重绘并不会立即执行，因为View被存储起来了。所以步骤变成这样： Invalidate: 与软件绘制模型一样。 Storing： 在这种情况下，只有需要被更新的视图才进行重绘，并且在重绘之后被存储起来，以便重用，从而减少运行时的计算量。 Redrawing: 每个View利用之前存储下来的绘图进行更新，也就是说，那些不需要被更新的View，可以通过上次被储存下来的绘图进行更新（注：绘图这个词可能描述的并不准确，希望自行体会）。 优点很明显了，完全弥补了软件绘制模型的缺点，做到了按需更新，缓存更新操作。 两个模型的View绘制流程图对比通过上面的介绍，开发者应该能有一个大致的了解，现在截取美团基于Android 6.0的绘制流程分析来具体的讲解硬件加速做了什么。 下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。 从ViewRootImpl.performTraversals到PhoneWindow.DecroView.drawChild是每次遍历View树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行Canvas的创建等操作开始绘制。 如果硬件加速不支持或者被关闭，则使用软件绘制，生成的Canvas即Canvas.class的对象； 如果支持硬件加速，则生成的是DisplayListCanvas.class的对象； 两者的isHardwareAccelerated()方法返回的值分别为false、true，View根据这个值判断是否使用硬件加速。 View中的draw(canvas,parent,drawingTime) - draw(canvas) - onDraw - dispachDraw - drawChild这条递归路径（下文简称Draw路径），调用了Canvas.drawXxx()方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建DisplayList。 View中的updateDisplayListIfDirty - dispatchGetDisplayList - recreateChildDisplayList这条递归路径（下文简称DisplayList路径），仅在硬件加速时会经过，用于在遍历View树绘制的过程中更新DisplayList属性，并快速跳过不需要重建DisplayList的View。 Android 6.0中，和DisplayList相关的API目前仍被标记为“@hide”不可访问，表示还不成熟，后续版本可能开放。 硬件加速情况下，draw流程执行结束后DisplayList构建完成，然后通过ThreadedRenderer.nSyncAndDrawFrame()利用GPU绘制DisplayList到屏幕上。 从图中可以看出，只有父布局的 DisplayList 构建完成之后，才会去建构 child 的 DisplayList。 总结： CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。 页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。 硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。 硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。 实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。 当然这篇文章只是让你知道硬件加速做了什么，如果你想了解的更深入，应该去看看上面流程图的源码了。 补充知识点离屏缓冲每个View都能被渲染并保存为一个离屏位图，以供未来使用。首先通过调用Canvas.saveLayer()方法，渲染并保存位图，接着通过Canvas.restore()方法将所保存的位图绘制回画布。这些操作需要谨慎自行，因为绘制一个不需要的离屏位图同样需要消耗计算量。 上面我们说了硬件加速，但是不是所有的操作都支持硬件加速，如果你的绘制操作不支持硬件加速，你需要手动关闭硬件加速来绘制界面，关闭的方式是通过这行代码： 1view.setLayerType(LAYER_TYPE_SOFTWARE, null); 下面再截取Hencoder关于离屏缓冲的讲解： 有不少人都有过疑问：什么是 layer type？如果这个方法是硬件加速的开关，那么它的参数为什么不是一个 LAYER_TYPE_SOFTWARE 来关闭硬件加速以及一个 LAYER_TYPE_HARDWARE 来打开硬件加速这么两个参数，而是三个参数，在 SOFTWARE 和 HARDWARE 之外还有一个 LAYER_TYPE_NONE？难道还能既不用软件绘制，也不用硬件绘制吗？ 事实上，这个方法的本来作用并不是用来开关硬件加速的，只是当它的参数为 LAYER_TYPE_SOFTWARE 的时候，可以「顺便」把硬件加速关掉而已；并且除了这个方法之外，Android 并没有提供专门的 View 级别的硬件加速开关，所以它就「顺便」成了一个开关硬件加速的方法。 setLayerType() 这个方法，它的作用其实就是名字里的意思：设置 View Layer 的类型。所谓 View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU。这块「地方」可能是一块单独的 Bitmap，也可能是一块 OpenGL 的纹理（texture，OpenGL 的纹理可以简单理解为图像的意思），具体取决于硬件加速是否开启。采用什么来绘制 View 不是关键，关键在于当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果，而不是像硬件加速那样只是把 GPU 的操作保存下来再交给 GPU 去计算。通过这样更进一步的缓存方式，View 的重绘效率进一步提高了：只要绘制的内容没有变，那么不论是 CPU 绘制还是 GPU 绘制，它们都不用重新计算，而只要只用之前缓存的绘制结果就可以了。 基于这样的原理，在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View。所以在这种动画的过程中开启 Hardware Layer，可以让本来就依靠硬件加速而变流畅了的动画变得更加流畅。实现方式大概是这样： 1234567891011view.setLayerType(LAYER_TYPE_HARDWARE, null); ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;rotationY&quot;, 180);animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; view.setLayerType(LAYER_TYPE_NONE, null); &#125;&#125;);animator.start(); 或者如果是使用 ViewPropertyAnimator，那么更简单： 1234// withLayer() 可以自动完成上面这段代码的复杂操作view.animate() .rotationY(90) .withLayer(); 不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用 invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生改变时，缓存未更新所带来的时间的节省。所以简单地说——这种方式不适用于基于自定义属性绘制的动画，一定记得这句话。 由于设置了 View Layer 后，View 在初次绘制时以及每次 invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。 每当你要让View执行一个Alpha动画，或者仅仅只是对其设置一个不同的Alpha值时，都可以考虑使用View.LAYER_TYPE_HARDWARE。这点非常重要，以至于Google改写了View.setAlpha()方法，从Android 6.0 开始，自动应用硬件层。所以，如果你的应用程序目标SDK大于等于23的话，就没有必要这样做了。 最后，希望开发者能理解，硬件加速与离屏缓冲他们不是同一个东西，但是在API上又有一定的联系。两者都能加快渲染速度，一个缓存的是绘制操作，减少计算量，一个缓存的是绘制结果，只用绘制一次。同时开始硬件加速与硬件离屏缓存就能达到最好的效果，当然要注意View的内容不能改变。 参考文档： https://www.mtyun.com/library/hardware-accelerate https://hencoder.com/ui-1-8/ https://juejin.im/post/5a1f7b3e6fb9a0451b0451bb https://developer.android.com/guide/topics/graphics/hardware-accel]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2的doOnSubscribe引发的一个问题]]></title>
    <url>%2F2020%2F04%2F01%2Fblog_bak%2FBlog%2FAndroid-Bugs%2FRxJava2%E7%9A%84doOnSubscribe%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[接到一个需求，需要对一个旧功能做改动，由于网络部分的逻辑都很模板化（想念retrofit），所以我直接从别的地方copy了一份，在这里改吧改吧就运行了。但是运行时报错，报了在子线程访问UI的异常。这个异常很常见，也很好理解。我们的代码逻辑大致如下：12345Http.request(xxxx) // 这里面弹出一个加载框 .doOnSubscribe(xxx) .subscribeOn(io()) .observerOn(main()); 对RxJava2比较熟悉的同学，立马就能知道问题出在了哪里！因该把 doOnSubscribe 放在 subscribeOn 后面才对。 这里贴一张图，便于理解RxJava2。 但是这里又有另外一个问题！！！这段代码是我从别的地方copy过来的，我copy的地方为什么没有问题？？？ 我特意的断点查看，发现copy代码的地方，确实是在子线程执行的，那么它为什么没有报错呢？ 经过一番排查，发现我copy地方弹出的加载框是使用的 DialogFragment，而老的代码加载框使用的是 ProgressDialog。 查看源码发现，DialogFragment 的 show 方法，实际上是显示了一个 Fragment。 我们知道，对 Fragment 的操作，都只是一个很简单的 addOp 操作，然后在 commit 的时候，会将这些操作一起执行，而 commit 操作的内部逻辑都是通过 handler.post 执行的。所以在子线程操作没有问题！！！ 另外，有一个控件可以在子线程更新：ProgressBar。如果你去查看源码，会发现里面有不少同步代码！！！ 再说一句，不让UI在子线程更新，是为了避免同步问题，如果可以在子线程更新UI，那UI框架非常容易导致死锁。输入事件处理与任何GUI组件背后的对象模型之间存在偶发的交互。用户发起的动作总会冒泡似的从操作系统传递给应用程序—先是由os检测到一次鼠标点击，然后工具集把它转化为“鼠标点击”事件，最终它会作为一个高层事件（比如“buttonpressed”事件）转发给应用程序的监听器。另一方面，应用程序发起的动作又会以冒泡的形式传回操作系统—应用程序发起一个动作要改变某个组件的背景颜色，这会被转发给一个特定的组件类，最终转发给os进行渲染。两种动作以完全相反的顺序访问相同的GUI对象，需要保证让每一个对象都是线程安全的，这会导致一系列的锁顺序的不一致，这会直接引发死锁。]]></content>
      <tags>
        <tag>Android-Bugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter的BLOC模式]]></title>
    <url>%2F2019%2F12%2F02%2Fblog_bak%2FBlog%2Fflutter%2Fflutter%E7%9A%84BLOC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学习 Flutter 已经差不多两周，使用 BLOC 模式写了一个简单的 App，回想起来，居然与 Android 开发还挺相似的。可能是因为我们的应用本来就是使用 Google 推荐的框架，所以发现 BLOC 模式与我们应用的模式居然是一模一样，这可真的没有夸张，就是将 ViewModel 的名字改成了 BLOC 而已。 下面，从几个方面来说说自己对 Flutter 的感觉吧。 Dart语言现在的语言越来越多了，但是真正学起来会发现，其实上手都很简单，觉得语言由百花齐放慢慢的趋向于大一统。 不是说语言会变得单一，而是说它们的用法开始越来越像了。像我在大学接触 C++ 的时候，简直痛苦的不行。花了2个月，看了半本 C++ Primer，书上的习题都自己敲过，然后过了半年，全忘光了，一点没剩下。 我自己觉得，如果你对 Java 比较精通，不用看 dart 的语法，强行阅读，也是可以读的通的。你再有点 kotlin 的知识，简直如虎添翼。其他的细微末节，平时多看看项目，查查资料就好了。 但是，如果想深入了解，我似乎还没有找到什么好的资料。比如，Dart 的类加载机制，它的全局变量是如何工作的，是与 kotlin 一样吗？ 界面编写Flutter 编写界面，是真的难受。尤其是从 Android 开发转过来的，界面写起来的感觉与用 Java 代码写 Android 的界面一样。不过使用 Dart 写起来，还是方便不少的，而且 Flutter 对 Widget 封装的比较好，所以基本只需要填填属性值就好了，与 XML 一样。 因为是使用的 Dart 来编写界面，也没有提供界面预览的方式，所以如果你想要改一个界面，还得先运行起来看一下它长什么样。然后再慢慢的看代码，慢慢改。 里面的一些控件的用法与 CSS 很像，熟悉 html 开发的，应该会比较有亲切感。 在 Flutter 中，刚开始接触很容易产生万物皆为 Widget 的感觉，在编写界面的时候，也是一个 Widget “嵌套” 一个 Widget，会导致代码层次嵌套的特别深，所以需要把握控件的粒度。 界面绘制flutter 有自己的绘制引擎。我们将开发者模式打开，想查看过度绘制与布局边界，都是看不了的，因为它走的不是 Android 的绘制逻辑。 Flutter 与 Android 还有一个更大的不同之处在于，Flutter 中的 widget 可以理解为是不可变的。举个例子： 在 Android 中，我们想要显示一个文字，使用 TextView 控件就好了，当我们想要将文字改变的时候，自需要调用这个控件的 setText 方法即可。 但是，在 Flutter 中，我们想要显示一串文字，可以使用 Text 控件，但是当我们想要改变显示的文字的时候，只能重新创建一个新的 Text 控件，替换原来的 Text 控件。 虽然感觉不可思议，但是实际上却非常简单，Flutter 里面会自动重新走一遍创建 Text 的逻辑，所以会自动生成新的对象。 所以，我们在 build 方法中写的东西，相当于是一个蓝图，而 flutter 会依照这个蓝图创建出多个对象出来。同时需要好好思考，如何传递数据，以便创建出来的对象都不相同。就拿 Text 来说，每次 build 会创建不同的 Text 出来，但是如果你的 Text 的属性都是固定的，虽然每次都会创建出不同的 Text 对象，但是它们显示的却是同样的文字，所以需要将显示的文字传递进来。 当然，还有更多可以探索的东西，就不细说了，给两个链接： https://www.youtube.com/watch?v=wE7khGHVkYY&amp;feature=youtu.be https://www.youtube.com/watch?v=AqCMFXEmf3w 这两个视频都讲的非常的不错，看懂了之后，至少一般的界面逻辑，你都看得懂，知道为什么。 BLOC 模式界面的东西了解了之后，其他的就是如何搭建一个结构清晰的应用框架了。 其实，像我们做一些简单的 App，似乎很难涉及到复杂的逻辑。一般都是请求后台，然后展示数据，很少会遇到比较复杂的功能。更加高级一点的，再写一个自定义控件，这也不过是对于绘制api的使用。 说了这许多，还是回到 BLOC。这个模式与 MVVM 等都没有啥重大的区别，只要掌握了思想就好了。写出来的东西都是一样的。由于我们一般都是做的“简单App”，所以掌握了这个模式之后，写起来很是非常顺畅的，接手别人的代码也会变得很容易。 我们先来看一张图： 看过 Google jetpack 教程的，应该就很熟悉这张图了。 界面相关的东西，我们就放到 ui 层，逻辑相关的放在 bloc 层，数据相关的放在 repository 层。 由于我们的应用一般都是从网络请求数据，所以我将 Repository 与 Network Provider 合并层了一层。如果有用到缓存的话，还是不要合并，然后再实现 一个 Cache Provider 即可。 应用结构目录如下： 每个模块下，都有这样的一个结构，这样看起来就会比较清晰。 下面再说说每个目录里面应该放什么。 bloc 目录对应于 android 的 viewModel 目录： 123456789101112131415class MoviesBloc &#123; final _repository = MovieRepository(); final _moviesFetcher = PublishSubject&lt;ItemModel&gt;(); Observable&lt;ItemModel&gt; get allMovies =&gt; _moviesFetcher.stream; fetchAllMovies() async &#123; ItemModel itemModel = await _repository.fetchMovieList(); _moviesFetcher.sink.add(itemModel); &#125; dispose() &#123; _moviesFetcher.close(); &#125;&#125; 可以看的到，与 viewModel 的写法是一样的。只不过在 Android 中，我们现在使用了 LiveData 替换掉了 Rx，但是用法是一样的。 Bloc 需要数据会从 Repository 里面取，取到之后放入到 stream 中，然后我们只需要监听 stream 返回的数据就可以更新界面了。 repository目录我这里是将 repository 与 data provider 合并了。 1234567891011121314class MovieRepository &#123; Future&lt;ItemModel&gt; fetchMovieList() async &#123; final response = await client.get("$_baseUrl/popular?api_key=$_apiKey"); if (response.statusCode == 200) &#123; // If the call to the server was successful, parse the JSON return ItemModel.fromJson(json.decode(response.body)); &#125; else &#123; // If that call was not successful, throw an error. throw Exception('Failed to load post'); &#125; &#125;&#125; client 是网络请求对象。 这里才是真正发送请求的地方，只需要写请求逻辑即可。 models目录这个不用多说，就是存放 json 对应的对象的。有一个蛋疼的地方，dart 似乎没有类似 Gson 的库，因为它不让使用反射，所以只能自己手动解析 Json。不过还好有人写了对应的Json解析插件，自动生成代码。 ui目录这里就是存放app的页面的地方，对应的 android 的 activity/fragment 目录。 bloc 模式差不多就是这些东西了，从 Jetpack 转过来还是非常容易入手的，都是 Google 的一套东西，用起来也很舒服。 我的进度似乎就到这里了，其余的就是慢慢熟悉里面的 api，熟悉各种控件的特殊用法了。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0031-串]]></title>
    <url>%2F2019%2F10%2F12%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0031-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[想不到，一个国庆能让我断更20天，除了国庆9天左右的假期之外，还有11天居然什么都没做。其实也不算什么都没做，之不过是看 KMP 算法的时候卡住了，花了 4、5 天左右才真正的理解，当然还有 6、7 天我也不知道我为啥没有继续写笔记这里仅为反思一下，不期望起任何作用，但作为一个开头，还是挺不错的，因为串本身没啥可以讲的。 在 Java 语言中，串就是 String 类型的变量，如下： 12String hello1 = "Hello";String hello2 = "你好"; String 与基本类型一样，都是 Java 内置的类型，足以说明它有多么重要。 储存方式串一般都采用顺序储存，虽然有着空间限制，但是可以接受。如果采用链式储存的话，空间利用率太低了，因为一个界面除了储存了串的一个字符，还要储存一个指针，而且表示节点的这个对象，也要额外占用空间，再加上补齐之类的消耗，空间利用率实在是低得很。 搜索匹配情景通常我们再看一个文档、网页之类的东西的时候，都希望它有一个检索的功能。比如我常常在 github 上的源码网页上搜索一些方法。 这个情景简化一下，其实就是在一个大的字符串（将源码当作一个大的有很多换行与空格的字符串）里面找一个特定的小字符串（我们要搜索的字符串）。 遇到这种字符串匹配的功能，应该如何做呢？ 最简单的就是暴力匹配，从头开始一个一个的匹配，String 类自带的 indexOf 方法就是这样实现的。写两个循环就搞定了。 但是这个算法显然是不太高效的，那么有没有更好的算法呢？显然是有的，就是 KMP 算法了，下节介绍。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0032-KMP算法]]></title>
    <url>%2F2019%2F10%2F12%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0032-KMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP 算法并不是从一个全新的角度来思考字符串如何匹配会更快，它仍然是一个一个的比较两个字符串是否相等，但是它去除了暴力比较过程中一些无用的比较过程。那我们自己举例，假设让你取寻找一个大的字符串中，是否有某一个特定的字串，我们也是从头开始寻找，这符合人的认知，算法也是人写出来的，所以这个思路是不会变的。 KMP 算法之所以高效，是因为它做了很多改进。我们一点一点来说明。 下面的内容 主串代表前面例子中的源码 子串代表我们需要搜索的字符串 忽略主串与字串之间的空格，这个是为了更好看 假设，我有这样的一个主串[aaa aaa aaa b]，和子串[aaa aaa aab]，它们看起来极为相似。如果让我们来判断是否有匹配的，我们应该一眼就能看出来，确实是有匹配的，主串截取[1, n]，就是与子串匹配的。 注意上面，我的说话，是一眼就看出来的，虽然我们大脑运作的很快，但是在你思考事情的时候，你应该知道你想了哪些步骤，与 O(n) 的考量一样，我们不关心你思考的速度，只关心你思考了几个步骤。 我想你一定没有傻乎乎的去一个一个去匹配，这需要归功于这个子串很简单，简单到我们能记住，所以我们才不会去一个一个的对着子串去和主串匹配。 那么这个时候，我们的大脑究竟做了什么呢？你可以先自己仔细想一想！ 下面，我们再举一个例子： 假设，我有这样的一个主串[ababbababa]，和子串[ababa]。 我们先不考虑算法，而是用我们的脑子来找出主串里面是否包含子串。当我们匹配到第5个字符的时候，发现不一样了，这个时候我们该怎么做呢？？？ 一般人的做法是，回到主串的第二个字符，再次比较字串。这种做法是什么？暴力匹配。是效率很低的！！！那么应该怎么做呢？ 我们观察一下我们已经匹配过的串[abab]，发现什么没有，这个串是对称的（这里的对称是 ab ab 这样的对称，不是镜像对称）。那么对称能怎么样呢？ 上面的图中说的很清楚了，有了对称性，我们可以省不少事，至少不用回溯。我们可以从主串的第5个字符开始，直接与字串的第3个字符比较。 我们总结一下经验，发现只要我们匹配过的串是对阵的，我们就可以不用主串，那么发现匹配过的不对称，该怎么办呢？ 这里就需要另外一个技巧了，这个技巧需要极强的记忆力。我们将主串的每一处的对称性都记录下来。当发现不对称了，我们就递归的回溯，直到找到对称的： 其实，最终就是找到 j 应该指向i的位置。 上面所说的就是 KMP 的主要思想了。了解了这个思想，我们再来看看算法的实现。 我们先看这一段： 1234567891011121314151617void getNext(char * p, int * next)&#123; next[0] = -1; int i = 0, j = -1; while (i &lt; strlen(p)) &#123; if (j == -1 || p[i] == p[j]) &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; &#125;&#125; 你能看出这个函数做了什么吗？这个函数其实就是使用 next 数组记录了主串从[0, i]的每个位置有多长是对称的。 当 p[i] == p[j] 说明[0, i]这个串两端有字符相等的，又因为 p[i] != p[j] 的时候，j 被重置过了，所以可以保证此时[0, i] 的两头是对称的。 那么，我们之后，就可以直接使用这个数组来进行判断了。 12345678910111213141516171819public static int KMP(String main,String model,int[] next)&#123; int i = 0; int j = 0; while (i&lt;main.length()&amp;&amp;j&lt;model.length())&#123; if(-1==j||main.charAt(i) == model.charAt(j))&#123; i++; j++; &#125;else &#123; //不相等,滑动 j = next[j]; &#125; &#125; if(j==model.length())&#123; //如果最后j到达模式串的尾部,则说明匹配上了 return i - j; &#125;else &#123; return -1; &#125;&#125; 这样就搞定了，是不是很简单呢！ 上面的算法是我copy的，不保证能正确运行，只是我看了没发现什么问题就直接用了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation Processor 的应用]]></title>
    <url>%2F2019%2F09%2F29%2Fblog_bak%2FBlog%2FJava%2FAnnotation-Processor-%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[作为一个程序员，每天的生活都是平淡而且枯燥。先开需求会，再来画界面。画着画着，突然感觉有点不对劲，以前画个界面不应该这么麻烦的，不知道是不是错觉，感觉使用了 ConstraintLayout 之后，画个界面越来越慢了。说到这里不得不吐槽一下，ConstraintLayout 虽然减少 了层级，但是阅读单独上升了不少，特比是对于刚接触的人来说，一个那么复杂的布局，就一层，里面十几个控件，位置乱放，毫无顺序，你要是不点一下右边的预览视图来看看它们之间的关系，根本看不懂。真希望谷歌出一个容器，将子控件可以包一下，但是却不参加编译。 画完了界面，就要开始写逻辑，有网络请求的页面，比如详情页面，应该还是要保存一下请求详情接口的 id 才行。 DetailActivity于是就有了下面的代码： 12345678910111213141516 // handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。@Override protected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); if (savedInstanceState != null) &#123; mId = savedInstanceState.getLong(KEY_ID); &#125; else if (intent != null) &#123; mId = intent.getLongExtra(KEY_ID, -1L); &#125; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putLong(KEY_ID, mId); &#125; 这都不知道是我多少次写这样的代码了，写完之后，终于受不了了，先将需求（不多）抛在一遍，想办法将这些重复的东西搞一搞。 BaseActivity首先，将 if - else if 封装一下再说，于是 Base 里面就多了一些下面的方法： 123456789101112protected int getSavedInt(Intent intent, Bundle savedInstanceState, String key) &#123; return getSavedInt(intent, savedInstanceState, key, 0);&#125;protected int getSavedInt(Intent intent, Bundle savedInstanceState, String key, int defaultValue) &#123; if (savedInstanceState != null) &#123; return savedInstanceState.getInt(key, defaultValue); &#125; else if (intent != null) &#123; return intent.getIntExtra(key, defaultValue); &#125; return defaultValue;&#125; 这里只列出了针对 int 的，当然还有其他类型的，按需添加。 SavedFieldHandler但是再一想，这个玩意虽然只在 Activity 里面用到，但是抽成一个工具类会不会更好一点，于是就有了一个工具类： SavedFieldHandler 将 Base 里面添加的方法，改为 public static 的，放入工具类： 123456789101112public static int getSavedInt(Intent intent, Bundle savedInstanceState, String key) &#123; return getSavedInt(intent, savedInstanceState, key, 0);&#125;public static int getSavedInt(Intent intent, Bundle savedInstanceState, String key, int defaultValue) &#123; if (savedInstanceState != null) &#123; return savedInstanceState.getInt(key, defaultValue); &#125; else if (intent != null) &#123; return intent.getIntExtra(key, defaultValue); &#125; return defaultValue;&#125; DetailActivity于是，我们的 Activity 里面的代码，就变成了这样： 123456789101112 // handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。@Override protected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); SavedFieldHandler.getSavedLong(intent, savedInstanceState, KEY_ID, 0L); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putLong(KEY_ID, mId); &#125; 看起来舒服了一点，但是每次复写这两个方法也很烦。再仔细观察一下这两个方法，其实就是 key 不一样，然后由于储存的类型不一样，所以调用的 get put 方法名也不一样。 那么，如果将这两个方法往上浮到 BaseActivity 里面，需要做一些什么呢？ 我们需要知道 字段的值，与字段对应的 KEY。那么怎么才能获取这两个东西呢？想一下，似乎直接获取有点难度，那么加点辅助信息呢，比如说注解，我们定义一个这样的注解： SaveField 12345public @interface SaveField &#123; String key() default ""; String defaultValue() default "";&#125; key() 方法表示 字段对应的 KEY。defaultValue() 方法表示 字段的值。然后我们使用反射可以获取被该注解修饰的字段的值，嗯，完美。 当我准备开始写代码的时候，突然感觉哪里不对劲，值有问题，如果我是一个 long 型的变量的话，那岂不是还需要调用 Long.parseLong 方法转一下，而且，我们写 long 型值的时候，都习惯添加一个 L 在后面的，比如：long x = 3L; ，为了兼容这样的情况，我特么不是要做的判断更多了。 想到长痛不如短痛，多做几个判断就多做几个吧。我灵光一现，既然一个注解搞不定，那多搞几个注解不就好了，于是下面的注解就出现了： FloatSavedField 1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface FloatSavedField &#123; String key() default ""; float defaultValue() default 0f;&#125; Retention 一定要是 RetentionPolicy.RUNTIME，因为要在反射的时候获取。 类似的还有 IntSavedField 等等，都是一样的代码，就不说了。 定义好了注解之后，我们就可以开始写 BaseActivity 的逻辑了。 BaseActivity BaseActivity 123456789101112@Overrideprotected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); // 收集注解标识的字段 Field[] declaredFields = this.getClass().getDeclaredFields(); for (Field declaredField : declaredFields) &#123; declaredField.setAccessible(true); Annotation[] annotations = declaredField.getAnnotations(); injectField(annotations, declaredField, intent, savedInstanceState); &#125;&#125; 这里就是遍历所有的字段。 12345678910111213141516171819private void injectField(Annotation[] annotations, Field field, Intent intent, Bundle savedInstanceState) &#123; try &#123; for (Annotation annotation : annotations) &#123; Class&lt;?&gt; type = field.getType(); if (annotation instanceof IntSavedField) &#123; if (type != int.class &amp;&amp; type != Integer.class) &#123; throw new IllegalArgumentException("字段类型与注解类型不匹配"); &#125; IntSavedField savedField = (IntSavedField) annotation; int defaultValue = savedField.defaultValue(); String key = savedField.key(); field.set(this, SavedFieldHandler.getSavedInt(intent, savedInstanceState, key, defaultValue)); mSavedFieldMap.put(field, savedField); &#125; else if (...) &#123;...&#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 看看字段上是否有我们定义的注解，如果有的话，将注解里面定义的 KEY 取出来，然后使用 SavedFieldHandler 去获取传递过来的值，最后设置到该字段里面。 mSavedFieldMap 是将有指定注解修饰的字段保存一下，以免在 onSaveInstanceState 又要重新遍历一下所有字段。 在 onSaveInstanceState 里面： 12345678910111213141516@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); try &#123; Set&lt;Map.Entry&lt;Field, Annotation&gt;&gt; entrySet = mSavedFieldMap.entrySet(); for (Map.Entry&lt;Field, Annotation&gt; entry : entrySet) &#123; Field key = entry.getKey(); Annotation value = entry.getValue(); if (value instanceof IntSavedField) &#123; outState.putInt(((IntSavedField) value).key(), (Integer) key.get(this)); &#125; else if(...) &#123;...&#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 这里的逻辑，也很简单，从字段里面取出值，然后储存到 outState 里面就好了。 运行一下demo，可以正常运行。但是这个 BaseActivity 里面的代码就不太好看了，是因为这两个方法里面有太长的 if - else if 了，那怎么解决呢？回想一下《重构》这本书，抽一个接口就好了： SavedFieldHandler 1234567public interface SavedFieldHandler&lt;T extends Annotation&gt; &#123; void injectField(T annotation, Object target, Field field, Intent intent, Bundle savedInstanceState); void saveField(Bundle outState, Object target, Field key, T annotation);&#125; 然后分别为各种类型写一个实现： DoubleHandler 123456789101112131415161718192021public class DoubleHandler implements SavedFieldHandler&lt;DoubleSavedField&gt; &#123; @Override public void injectField(DoubleSavedField annotation, Object target, Field field, Intent intent, Bundle savedInstanceState) &#123; double defaultValue = annotation.defaultValue(); String key = annotation.key(); try &#123; field.set(target, SavedFieldHandler.getSavedDouble(intent, savedInstanceState, key, defaultValue)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void saveField(Bundle outState, Object target, Field key, DoubleSavedField annotation) &#123; try &#123; outState.putDouble(annotation.key(), (Double) key.get(target)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再次重构 BaseActivity 的代码： 123456789101112131415161718192021222324252627282930313233private fun handleIntent(intent: Intent, savedInstanceState: Bundle?) &#123; val s = System.nanoTime() val declaredFields = this.javaClass.declaredFields for (declaredField in declaredFields) &#123; declaredField.isAccessible = true val annotations = declaredField.annotations for (annotation in annotations) &#123; val handler = HandlerFactory.get(annotation) if (handler != null) &#123; handler.injectField(annotation, this, declaredField, intent, savedInstanceState) mSavedFieldMap[declaredField] = annotation &#125; &#125; &#125; Log.e(TAG, "获取耗时" + ((System.nanoTime() - s) / 1000000.0).toString() + "毫秒")&#125;override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) val s = System.nanoTime() val entrySet = mSavedFieldMap.entries for (entry in entrySet) &#123; val key = entry.key val value = entry.value HandlerFactory.get(value)?.saveField(outState, this, key, value) &#125; Log.e(TAG, "保存耗时" + ((System.nanoTime() - s) / 1000000.0).toString() + "毫秒")&#125; 嗯，这次看起来就舒服多了。运行一下，看看耗时情况，结果如下： 12获取耗时第一次为 2-3 毫秒，再次运行在 0.5 毫秒左右保存耗时 为 0.2 ~ 0.3 毫秒左右 结果还是可以接收的。 在写完之后，又想了想，如果我不使用反射，那么耗时情况是怎么样的呢？既然不能使用反射，那么还要能给变量赋值与获取值，这咋办呢？给变量赋值…，ButterKnife 不就是给变量赋值，ButterKnife 的工作原理这里还是简单描述一下哈： 12345678我们有一个目标类：SbActivity，它在 com.sb 包下。我们使用注解处理器生成一个类 SbActivity_ViewBinding，也让它生成到 com.sb 包下面给 SbActivity_ViewBinding 类搞一个构造函数，构造函数有两个参数：第一个参数是 SbActivity，第二个参数是 SbActivity 的根 view这样，我们可以在 SbActivity_ViewBinding类中拿到 SbActivity 的所有非私有变量，就可以给这个变量设置值，获取它的值 了解了它的工作原理，这完全和我们的需求一摸一样啊，所以，我们直接按照 ButterKnife 来设计我们的结构。 SaveHelper首先，我们需要一个工具类，它的作用与 ButterKnife 类一样，提供一个 bind 方法，返回一个 UnBinder 对象，这里我们另起一个方法名： SaveHelper 1234@UiThreadfun get(target: Activity, intent: Intent?, savedInstanceState: Bundle?): SaveUnbinder &#123; return createBinding(target, intent, savedInstanceState)&#125; 这个方法的逻辑，都不用我们自己想，直接从 ButterKnife 里面 copy 出来用就好了。 123456789101112131415161718192021222324fun createBinding(target: Activity, intent: Intent?, savedInstanceState: Bundle?): SaveUnbinder &#123; val targetClass = target.javaClass Log.d(TAG, "Looking up binding for " + targetClass.name) val constructor = findBindingConstructorForClass(targetClass) ?: return EMPTY_UNBINDER //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. try &#123; return constructor.newInstance(target, intent, savedInstanceState) &#125; catch (e: IllegalAccessException) &#123; throw RuntimeException("Unable to invoke $constructor", e) &#125; catch (e: InstantiationException) &#123; throw RuntimeException("Unable to invoke $constructor", e) &#125; catch (e: InvocationTargetException) &#123; val cause = e.cause if (cause is RuntimeException) &#123; throw cause &#125; if (cause is Error) &#123; throw cause &#125; throw RuntimeException("Unable to create binding instance.", cause) &#125;&#125; 这个方法，就是根据我们的 Activity，创建 Activity_ViewBinding 的一个对象，因为我们使用注解处理器创建的类的构造函数是有两个参数的，这里使用反射创建 Activity_ViewBinding 类的实例。 1234567891011121314151617181920212223242526272829303132333435363738394041@Nullable@CheckResult@UiThreadfun findBindingConstructorForClass(cls: Class&lt;*&gt;): Constructor&lt;out SaveUnbinder&gt;? &#123; var bindingCtor: Constructor&lt;out SaveUnbinder&gt;? = BINDINGS[cls] if (bindingCtor != null) &#123; Log.d(TAG, "HIT: Cached in binding map.") return bindingCtor &#125; val clsName = cls.name if (clsName.startsWith("android.") || clsName.startsWith("java.")) &#123; Log.d(TAG, "MISS: Reached framework class. Abandoning search.") return null &#125; try &#123; val bindingClass = cls.classLoader?.loadClass(clsName + "_FieldSaving") bindingCtor = bindingClass?.getConstructor( cls, Intent::class.java, Bundle::class.java ) as Constructor&lt;out SaveUnbinder&gt; Log.d(TAG, "HIT: Loaded binding class and constructor.") &#125; catch (e: ClassNotFoundException) &#123; Log.d(TAG, "Not found. Trying superclass " + cls.superclass?.name) cls.superclass?.apply &#123; bindingCtor = findBindingConstructorForClass(this) &#125; &#125; catch (e: NoSuchMethodException) &#123; throw RuntimeException("Unable to find binding constructor for $clsName", e) &#125; bindingCtor?.apply &#123; BINDINGS[cls] = this &#125; return bindingCtor&#125; 这里是寻找 Activity_ViewBinding 这个类，然后加载这个类，获取它的 Constructor 并返回。 bindingCtor 缓存了对应的 Constructor 。 这里为了加以区分，我们注解处理器生成的类，后缀叫 _FieldSaving。 SaveUnbinderSaveUnbinder 对象的生成解决了，那么这个接口应该有哪些方法呢？ 123456789interface SaveUnbinder &#123; @UiThread fun save(outState: Bundle) @UiThread fun unbind()&#125; 这个接口的定义还是很简单的。 BaseActivity那么我们的 BaseActivity 就可以这样写了： 1234567891011121314151617181920212223242526272829abstract class BaseActivity2 : AppCompatActivity() &#123; companion object &#123; const val TAG = "BaseActivity2" &#125; private lateinit var saveUnbinder: SaveUnbinder override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val s = System.nanoTime() saveUnbinder = get(this, intent, savedInstanceState) Log.e(TAG, "获取花费了 $&#123;(System.nanoTime() - s) / 1000000.0&#125; 毫秒") &#125; override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) val s = System.nanoTime() saveUnbinder.save(outState) Log.e(TAG, "保存花费了 $&#123;(System.nanoTime() - s) / 1000000.0&#125; 毫秒") &#125; override fun onDestroy() &#123; super.onDestroy() saveUnbinder.unbind() &#125;&#125; 这个看起来就更舒服了。 接下来，就只需要搞定注解生成对应的类就好了，注解处理器，另外一篇有讲到，就不说了，主要是 JavaPoet 的使用。 可以将 JavaPoet 理解为一个盒子，它可以帮助我们生成一个 Java 文件。我们写 Java 文件都是用 IDE 手写，但是使用 JavaPoet，我们可以使用 Java 语言来生成一个 Java 文件。 直接使用 IO 流来创建文件，然后添加各种字符不一样，JavaPoet 有自己的用法，它可以很简单的让你处理Java 类的导入，编写方法的结构体等等。唯一复杂的就是，需要我们掌握这些 API 的用法。用法其实很简单的，也无需记住，需要的时候再去查文档就好了，因为对我们理解别的东西没啥帮助，除非你想看一下它的设计实现与思想。 它生成的类应该如下： 1234567891011121314151617181920212223242526public final class MainActivity_FieldSaving implements SaveUnbinder &#123; MainActivity target; public MainActivity_FieldSaving(MainActivity activity, Intent intent, Bundle bundle) &#123; this.target = activity; this.target.testL = IntentHandlerKt.getSavedLong(intent, bundle, "testL", 71L); this.target.testS = IntentHandlerKt.getSavedString(intent, bundle, "testS", "74"); this.target.testD = IntentHandlerKt.getSavedDouble(intent, bundle, "testD", 7.3D); this.target.testI = IntentHandlerKt.getSavedInt(intent, bundle, "testI", 70); this.target.testF = IntentHandlerKt.getSavedFloat(intent, bundle, "testF", 7.2F); &#125; @Override public void save(Bundle outState) &#123; outState.putLong("testL", this.target.testL); outState.putString("testS", this.target.testS); outState.putDouble("testD", this.target.testD); outState.putInt("testI", this.target.testI); outState.putFloat("testF", this.target.testF); &#125; @Override public void unbind() &#123; this.target = null; &#125;&#125; 嗯，这样就搞定了。 最后将这些类分开，我们新建 3 个不同作用的 Module： 123save-api 用于存放给外部使用的类save-annotation 用于存放需要处理的注解save-processor 用于处理注解 运行 demo，却报了一个错，报的是字段不能是私有的，这个是我在注解处理器里面输出的错误，可是这就奇怪了啊，我的字段不是私有的啊，经旁边同事的提醒，查看一下它的 byteCode，果然是私有的，原来是 Kotlin 搞的鬼，它为字段生成了公有的 get set 方法，所以变量是私有的了。那这可咋办呢？我去翻了一下 ButterKnife 的注解处理器，它也没有处理这种情况。看来 Java 的注解处理器来兼容 Kotlin，是用前朝的剑来斩本朝的官啊。不过听说又有一个 KotlinPoet，但是还是得分开处理，很麻烦。 本来想着，参考一下 Gson 的代码，看它是怎么处理有 get set 方法的。但是想了想还是算了，感觉这样兼容很脆弱，而且我对 Kotlin 还不太熟，不知道它没有什么注解处理器来兼容 Java。 最后，使用 Java 来写 Activity，测试性能结果： 12获取耗时第一次为 1.7-2.3 毫秒，再次运行在 0.2 毫秒左右保存耗时 为 0.06 毫秒左右 最后额外说一下，由于使用了注解处理器，注解的 Retention 可以改为了 SOURCE。 一个比较令人满意的依赖库就做好了。 项目代码并没有经过严格测试，只是写的有意思，所以分享一下，项目源代码地址如下： https://github.com/aprz512/SaveHelper]]></content>
      <categories>
        <category>AnnotationProcessor</category>
      </categories>
      <tags>
        <tag>Java-AnnotationProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-监控页面的销毁]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FLeakCanary%2F0002-%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%94%80%E6%AF%81%2F</url>
    <content type="text"><![CDATA[使用首先，还是要说一下使用，非常的简单：1234debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'// Optional, if you use support library fragments:debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3' 我这里依赖的版本是 1.6.3，所以源码分析也是基于这个版本的。最新的 2.0 版变化也是很大的，但是核心原理差不多，分析原理还是老一点的版本比较好，思路更清晰，逻辑分支更少。 releaseImplementation 表示打 release 版本的时候会依赖这个包。leakcanary-android-no-op 这个依赖包的名字意思也很明显，这个依赖包里面只有两个类，而且类的方法都是空方法，里面啥都不做，因为如果在 release 版也依赖 LeakCanary 的话，用户就会很奇怪了，而且会影响性能。当然你也可以选择在打 release 包的时候将依赖包与相关代码移除，这样就是比较麻烦。 leakcanary-support-fragment 这个依赖包是表示如果你的 Fragment 使用了 support 包里面的 Fragment，那么就应该使用这个依赖包，具体为啥，源码里面分析，这个依赖包里面也就一个类。 监控页面的方法我们想要监控页面（Activity 与 Fragment），需要做如下配置： 12// this 是 Application 对象LeakCanary.install(this); 因为，LeakCanary 会单独开一个进程用来做 .hprof 文件分析，所以需要排除分析进程。 1234567protected void initCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); BlockCanary.install(this, new AppBlockCanaryHelper()).start();&#125; 里面判断进程的逻辑可以自行去了解一下。 想要监控其他对象，需要做如下配置： 123456789public abstract class BaseService extends Service &#123; @Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = MyApp.getRefWatcher(); // 可以传入任何对象 refWatcher.watch(this); &#125;&#125; 这里使用了 RefWatcher 来监控 Service。同样的，你也可以监控其他对象，比如 Bitmap，数组 等。 如何做到对页面的监控的监控 Activity 比较简单，我们都能想的到，使用 ActivityLifecycleCallbacks 即可。源码里面也是这样实现的。但是 Fragment 是如何监控的呢？？？ 下面，我们开始分析源码。 com.squareup.leakcanary.LeakCanary#install 12345public static @NonNull RefWatcher install(@NonNull Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125; 一个链式调用。 refWatcher 是创建一个 Builder 对象。 listenerServiceClass 是起一个 Service，当然这里还没有真正的启动，只是做了准备工作，因为是 builder 模式，所以至少需要调用 build 后才会启动。 excludedRefs 是排除一些引用，这是啥意思呢，是因为 Android SDK 本身也会导致一些内存泄露问题，所以需要将这些问题排除，显然，这个类会一直更新，我们也可以贡献一下，比如我们会在华为的手机上遇到“键盘导致的泄露的问题”，但是实际上是没有泄露的，别的手机都没有出现过这个问题，而且代码最终到了 SDK 里面。有兴趣的可以去看看这个类 com.squareup.leakcanary.AndroidExcludedRefs。 buildAndInstall 才是核心代码，我们往下看。 com.squareup.leakcanary.AndroidRefWatcherBuilder#buildAndInstall 12345678910111213141516171819public @NonNull RefWatcher buildAndInstall() &#123; if (LeakCanaryInternals.installedRefWatcher != null) &#123; throw new UnsupportedOperationException("buildAndInstall() should only be called once."); &#125; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; if (enableDisplayLeakActivity) &#123; LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); &#125; if (watchActivities) &#123; ActivityRefWatcher.install(context, refWatcher); &#125; if (watchFragments) &#123; FragmentRefWatcher.Helper.install(context, refWatcher); &#125; &#125; LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher;&#125; buildAndInstall 这个方法只让调用一次。下面的 3 个if 才是核心。 com.squareup.leakcanary.internal.LeakCanaryInternals#setEnabledAsync先看第一个： 1LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); 这行代码的作用与桌面启动图标有关系。我们先看依赖库的 AndroidManifest.xml 文件： 1234567891011121314&lt;activity android:name="com.squareup.leakcanary.internal.DisplayLeakActivity" android:enabled="false" android:icon="@mipmap/leak_canary_icon" android:label="@string/leak_canary_display_activity_label" android:process=":leakcanary" android:taskAffinity="com.squareup.leakcanary.$&#123;applicationId&#125;" android:theme="@style/leak_canary_LeakCanary.Base" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 可以看到，这个依赖库里面也设置了一个 LAUNCHER 页，加上我们的 App 也有一个，那么就有两个了启动页了。但是注意这里 activity 的 enable 属性配置的是 false，所以这个启动页图标一开始不会显示，只有调用了 install 方法，执行了 setEnabledAsync 方法才会显示。里面的逻辑较简单就部分析了，注意一下这个方法是异步的，开了一个线程。 com.squareup.leakcanary.ActivityRefWatcher#install第二个 if，这里就是使用 ActivityLifecycleCallbacks。 com.squareup.leakcanary.ActivityRefWatcher#install 123456public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);&#125; 其实就是调用了 Application 的 registerActivityLifecycleCallbacks 方法。核心内容在 ActivityRefWatcher 这个类中。 com.squareup.leakcanary.ActivityRefWatcher 123456private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123; @Override public void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; &#125;; 它有一个成员变量，叫 lifecycleCallbacks，也是上一个方法用到的。ActivityLifecycleCallbacksAdapter 是 ActivityLifecycleCallbacks 的一个空实现，里面啥都没做，只是为了减少无关方法的复写。 所以 ActivityRefWatcher 的作用就是：创建了一个 ActivityLifecycleCallbacks 监听，在 onActivityDestroyed 回调里面，调用了 refWatcher.watch(activity); 这行代码。 最终，还是到了 com.squareup.leakcanary.RefWatcher#watch(java.lang.Object) 这个方法，如果你对前面的代码还有影响，可以发现，我们监控 Service 等对象，也是调用的这个方法。 所以，看了这么多，本质上还是调用了 com.squareup.leakcanary.RefWatcher#watch(java.lang.Object)。只不过一个是在统一的地方调用，一个是手动的一处一处的调用。 com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install这个方法就是实现了 Fragment 的监控。看看它是如何实现的。 com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install 1234567891011121314151617181920212223242526public static void install(Context context, RefWatcher refWatcher) &#123; List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;(); if (SDK_INT &gt;= O) &#123; fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher)); &#125; try &#123; Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME); Constructor&lt;?&gt; constructor = fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class); FragmentRefWatcher supportFragmentRefWatcher = (FragmentRefWatcher) constructor.newInstance(refWatcher); fragmentRefWatchers.add(supportFragmentRefWatcher); &#125; catch (Exception ignored) &#123; &#125; if (fragmentRefWatchers.size() == 0) &#123; return; &#125; Helper helper = new Helper(fragmentRefWatchers); Application application = (Application) context.getApplicationContext(); application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);&#125; 这个方法里面先是创建了两个 FragmentRefWatcher 对象，一个是 AndroidOFragmentRefWatcher，一个是 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME。 最后，又注册了一个 ActivityLifecycleCallbacks，注意这里的 ActivityLifecycleCallbacks 是 Helper 自己的，看看它做了什么： com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#activityLifecycleCallbacks 12345678private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; for (FragmentRefWatcher watcher : fragmentRefWatchers) &#123; watcher.watchFragments(activity); &#125; &#125; &#125;; 其实就是在 Activity 创建完成之后，调用了 FragmentRefWatcher 的方法。上面我们分析过，FragmentRefWatcher 有两个实例对象。 AndroidOFragmentRefWatcher我们先分析 AndroidOFragmentRefWatcher 做了什么。 com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#watchFragments 1234@Override public void watchFragments(Activity activity) &#123; FragmentManager fragmentManager = activity.getFragmentManager(); fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);&#125; 这里出现了一个我没见过的方法，没想到 Fragment 也能像 Activity 一样注册监听，学到了。同理，我们应该也能猜到，这个监听里面做了什么。 com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#fragmentLifecycleCallbacks 123456789101112131415private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks = new FragmentManager.FragmentLifecycleCallbacks() &#123; @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) &#123; View view = fragment.getView(); if (view != null) &#123; refWatcher.watch(view); &#125; &#125; @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) &#123; refWatcher.watch(fragment); &#125; &#125;; 这里监控了两个对象，一个是 Fragment 本身，一个是 Fragment 的 rootView。 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME还有一个 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME。 上面的逻辑分析中，如果你看的仔细的话，会发现我们获取 FragmentManager 实例的时候，使用的是 getFragmentManager 方法，而不是 getSupportFragmentManager 方法。就是说，AndroidOFragmentRefWatcher 是针对原生的 Fragment 的，而 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 就应该是针对 support 包里面的 Fragment 的。 还有一个要理解的地方就是，在创建 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 实例的时候，使用了反射，这是因为这个 Fragment 需要添加额外的依赖leakcanary-support-fragment，所以才使用的反射。 我们还是看看代码吧： com.squareup.leakcanary.internal.SupportFragmentRefWatcher 123456789101112131415161718192021222324252627282930class SupportFragmentRefWatcher implements FragmentRefWatcher &#123; private final RefWatcher refWatcher; SupportFragmentRefWatcher(RefWatcher refWatcher) &#123; this.refWatcher = refWatcher; &#125; private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks = new FragmentManager.FragmentLifecycleCallbacks() &#123; @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) &#123; View view = fragment.getView(); if (view != null) &#123; refWatcher.watch(view); &#125; &#125; @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) &#123; refWatcher.watch(fragment); &#125; &#125;; @Override public void watchFragments(Activity activity) &#123; if (activity instanceof FragmentActivity) &#123; FragmentManager supportFragmentManager = ((FragmentActivity) activity).getSupportFragmentManager(); supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true); &#125; &#125;&#125; 与 AndroidOFragmentRefWatcher 的代码几乎是一样的。]]></content>
      <categories>
        <category>LeakCanary</category>
      </categories>
      <tags>
        <tag>Android源码解析-LeakCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E7%9F%A5%E8%AF%86%E7%82%B9%2FHandler%2F</url>
    <content type="text"><![CDATA[ThreadLocal 的工作原理文字版理解 每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性。 ThreadLocalMap 类相当于一个Map，key 是 ThreadLocal 本身，value 就是我们的值。 当我们通过 threadLocal.set(new Integer(123)); ，我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 是 这个 threadlocal 自己，value 就是 new Integer(123)。 当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值。 源码分析这个类比较简单，我们直接从 java.lang.ThreadLocal#set 这个方法看起： java.lang.ThreadLocal#set 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 在 set 方法的第二行，由一个 getMap 方法获取了 ThreadLocalMap 的一个实例。 java.lang.ThreadLocal#getMap 12345678910/** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 看到了没，这里直接使用的是 Thread 类的变量。 java.lang.Thread 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 所以，我们储存的数据实际上时放入到了 Thread 类的成员变量中。继续深入 ThreadLocalMap 这个类，上面的 set 方法调用它的 set 方法，所以我们直接看它的 set 方法。 java.lang.ThreadLocal.ThreadLocalMap 1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 看这个代码，思路还是满清晰的。要说一些这个 Entry 类，它是继承了 WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，注意这里是一个弱引用。有一个比较有趣的问题就是：网上有讨论说 ThreadLocal 有可能出现内存泄漏问题，就与它有关系。我们来看一下引用链： ThreadLocal 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; WeakReference -&gt; ThreadLocal value 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value 可以看到，value 是被强引用的，所以如果没有其他对象引用 ThreadLocal 对象的话，ThreadLocal 可能会被回收，但是 value 不会被回收。而且这个时候，我们也没法访问到 value 了。这样就造成了内存泄露。一般的使用方式都是使用 static 的或者手动调用 set null。看看官方的使用方式： android.os.Looper 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 回到正题，分析 set 方法的流程：首先，利用 key 的 hashCode 获取索引值，然后查看索引值执行的位置有没有数据，没有数据就创建一个新的放进去，有的话，就比较 key ，key一样就直接替换 value 的值，key不一样就看下一个位置的值，再比较。 set 方法说完了，我们在看看 get 方法。 java.lang.ThreadLocal#get 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 了解了 set 方法，get 方法其实就是反过来的，与 set 的思路一样，由于 key 始终是自己（ThreadLocal&lt;?&gt;），所以总能取到正确的值。这里还有一个 setInitialValue 方法，它默认返回null，就是没有设置初始值的时候，就会触发这个方法，我们可以复写这个方法，返回一个默认值。 ThreadLocal 的大致原理就说完了，再说一下它的一般用法：第一个比较普通，就是通过它来储存线程中的数据，只有当前线程可以获取到，其他线程获取的是另一份自己的数据。第二个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实这个时候就可以采用 ThreadLocal，让监听器作为线程内的全局对象，在线程内部只要通过get方法就可以获取到监听器。如果不采用这种方式，那么一般会使用参数的传递或者使用静态变量。使用参数传递的话，如果方法调用栈不深还可以接收，如果调用栈很深，代码看起来就很糟糕了。使用静态变量的话，多个线程就难以维护了。 消息队列这里不会走源码了，最多给个图。我只是梳理一下以前没有注意到的东西。 在讨论这个主题之前，我们先来认识一下GUI的单线程模型，嗯，想来了解一下问什么。现代的 GUI 框架使用的模型：创建一个专门的线程，事件派发线程（event dispatch thread，RDT）来处理 GUI 事件。 有很多人都试图写出多线程的GUI框架，最终都由于竞争条件和死锁导致的稳定性问题，又回到了单线程化的事件队列模型的老路上来。多线程的GUI框架会尤其易受死锁的影响，部分原因在于： 用户发起的动作总会冒泡似的从操作系统传递给应用程序。先是由os检测到一次鼠标点击，然后工具集把它转化为“鼠标点击”事件，最终它会作为一个高层事件（比如“buttonpressed”事件）转发给应用程序的监听器。 另一方面，应用程序发起的动作又会以冒泡的形式传回操作系统。应用程序发起一个动作要改变某个组件的背景颜色，这会被转发给一个特定的组件类，最终转发给os进行渲染。两种动作以完全相反的顺序访问相同的GUI对象，需要保证让每一个对象都是线程安全的，这会导致一系列的锁顺序的不一致，这会直接引发死锁。 虽然，单线程模式比较简单，但是单线程消息队列机制存在一个问题： 消息响应函数中不能有耗时长的、计算密集型的操作，因为主线程在努力地处理这样的操作的时候就无法去处理其它的积压在消息队列中的绘制消息、事件消息了（一个消息处理完了主线程才会去队列中取下一个消息），这时候就会出现按键无响应、点击无反应的情况。 但这个问题有完美的解决方案，我们可以在消息响应函数中启动另一个工作线程（Worker Thread）来执行耗时操作，这样在线程启动起来后这个消息就算处理完了，主线程可以取下一个消息了，这时候主线程和还未执行完计算任务的工作线程就在操作系统的调度下并驾齐驱地狂奔了（调度算法会保证两个线程并发或并行地执行，不会专宠某个线程）。 Android 中也是采用的单线程消息队列，它是使用 Hanlder 来处理线程之间的消息传递的。一般我们在耗时任务执行完后还要更新界面展示计算的结果，正确的处理办法是将耗时任务改为异步通知机制，即工作线程向消息队列中添加消息以通知主线程耗时任务完成了，这样主线程在启动工作线程后就不需要主动地去调查任务的进展了。 了解了为什么，现在我们从几个问题来入手消息队列的运作过程。 消息是如何延迟发送的？不同的延时长度的消息是如何排序的？ 没有消息时，MessageQueue 在干什么，Looper在做什么？从没有消息到有消息，MessageQueue 是如何被唤醒的？ Message 分发的3种渠道？ Looper是死循环，为什么 UI 线程不会ANR? IdleHandler 是什么? 异步消息与同步屏障了解不？ 延时消息放入Message时会根据msg.when这个时间戳进行顺序的排序,如果非延迟消息则msg.when为系统当前时间，延迟消息则为系统当前时间+延迟时间(如延迟发送3秒则为：SystemClock.uptimeMillis() + 3000)。 Message放入MessageQueue时会以msg.when对msg进行排序确认当前msg处于单链表中的位置,分为几种情况: 头结点为null(代表MessageQueue没有消息),Message直接放入头结点。 头结点不为null时开启死循环遍历所有节点 遍历出的节点的when大于放入message的when(说明当前message是一个比放入message延迟更久的消息，将放入的Message放入当前遍历的Message节点之前)。 遍历出的节点的next节点为null(说明当前链表已经遍历到了末尾，将放入的Message放入next节点)。 android.os.MessageQueue#enqueueMessage 12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; // 退出循环 if (mQuitting) &#123; ... msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 没有其他消息，把它作为头结点 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; // 根据时间来寻找节点的位置 if (p == null || when &lt; p.when) &#123; break; &#125; // 异步消息与屏障的处理，后面会说到 if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; ... &#125; return true;&#125; 消息队列的阻塞与唤醒对于消息队列而言，从里面取出消息需要考虑多个方面： 如果队列为空了，或者队列里面的消息没有可以取出的消息（时间都没到），那么应该阻塞消息队列。阻塞肯定不能用一般的方式，如果像流一样，直接阻塞了线程，浪费CPU，导致 ANR，那肯定是不行的，所以应该怎么办呢？ 阻塞需要阻塞多长时间呢？怎么保存这个时间？ 这个比较简单，message 有个 when 字段保存了时间，由于 message 是排序了的，所以只需要去头部的 message 的 when 用来计算就好了。 阻塞后如何唤醒？ 我们根据代码来分析： android.os.MessageQueue#next 123...nativePollOnce(ptr, nextPollTimeoutMillis);... nativePollOnce 这个方法是一个 native 方法，它就是用来阻塞消息队列的，nextPollTimeoutMillis 就是阻塞的时间。在说明这个方法做了什么之前，我们需要先了解一下 epoll 是什么！ 为什么Android的Handler采用管道？我们先来看一张图，图里展示的是Android整个Hander的设计。 红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了Java如何调用C++代码，C++代码又是如何调用Java代码。 蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。 我们可以看出，Handler的设计不仅仅只是Java层，还有对应的C++层。这是因为Handler不仅仅要处理同一进程中别的线程发过来的消息，还要处理系统底层发过来的消息。在整个消息机制中，MessageQueue是连接Java层和Native层的纽带，换言之，Java层可以向MessageQueue消息队列中添加消息，Native层也可以向MessageQueue消息队列中添加消息。 如果只是Java层的话，使用 wait 与 notify 也可以做到唤醒。 分发优先级当遍历出Message后Message会获取其中的Handler并调用Handler的dispatchMessage进行分发,这时也会有三个优先级。 android.os.Handler#dispatchMessage 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Message的回调方法：message.callback.run()，优先级最高； 对应handler.post(new Runnable)的方式发送消息。 Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于上面； 对应新建Handler时传进CallBack接口 1Handler handler=new Handler(new Handler.Callback()); 通常我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息，场景如：Hook ActivityThread.mH，在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。 Handler的默认方法：Handler.handleMessage(msg)，优先级最低。对应新建Handler并复写handleMessage方法。 Looper 的死循环我们知道Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper的控制之下，如果它停止了，应用也就停止了。 真正的阻塞是因为轮询出message后在处理message消息的时候由于执行了耗时操作导致了ANR，而不是死循环导致的阻塞，没有消息处理的时候消息队列是阻塞在nativePollOnce方法中的，这个方法使用的是epoll管道机制，Linux底层执行后会释放CPU避免不断死循环造成的CPU浪费。 IdleHandler 是什么简而言之，IdleHandler 是一个接口，就是在looper里面的message暂时处理完了，这个时候会回调这个接口，返回false，那么就会移除它，返回true就会在下次message处理完了的时候继续回调。 IdleHandler 可以用来提升提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（譬如UI线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。 当从消息链中取消息的时候，如果取到的消息还未到执行的时间或者没有取到消息，那么就会触发 IdleHandler （当然前提是你设置了），需要注意的是，这个回调只会执行一次，嗯，意思是如果在 5s 内，都没有消息需要处理，在这 5s 内，只会调用一次，而不会不断的调用。 android.os.MessageQueue#next 12// Reset the idle handler count to 0 so we do not run them again.pendingIdleHandlerCount = 0; 可以看到，调用一次之后，就将 count 设置为 0，下次就不会调用了，直到再次触发 next 方法。 可以看一下这篇文章的使用。 同步分割栏所谓“同步分割栏”，可以被理解为一个特殊Message，它的target域为null。它不能通过sendMessageAtTime()等函数打入到消息队列里，而只能通过调用Looper的postSyncBarrier()来打入。 “同步分割栏”是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中摘取消息并进行处理时，一旦遇到这种“同步分割栏”，那么即使在分割栏之后还有若干已经到时的普通Message，也不会摘取这些消息了。请注意，此时只是不会摘取“普通Message”了，如果队列中还设置有“异步Message”，那么还是会摘取已到时的“异步Message”的。 在Android的消息机制里，“普通Message”和“异步Message”也就是这点儿区别啦，也就是说，如果消息列表中根本没有设置“同步分割栏”的话，那么“普通Message”和“异步Message”的处理就没什么大的不同了。 将普通消息变成异步消息，只需要调用一个方法就可以啦： android.os.Message#setAsynchronous 1234567public void setAsynchronous(boolean async) &#123; if (async) &#123; flags |= FLAG_ASYNCHRONOUS; &#125; else &#123; flags &amp;= ~FLAG_ASYNCHRONOUS; &#125;&#125; 参考文档带你真正攻克Handler 聊一聊Android的消息机制 我读过的最好的epoll讲解–转自”知乎“]]></content>
      <tags>
        <tag>Android-知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FLeakCanary%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[所有的三方框架里面，LeakCanary 简直是最老的伙伴了，经历的开发项目都用过这个，像网络图片的等加载框架每个项目的选择可能不一样， LeakCanary 一直都在。 可惜的是一直没有去看里面的源码，只是大致的了解了一下，现在想了起来，于是就开了这个系列。 不看不知道，看了是真的舒服。之前一段时间受过 Tangram 代码的摧残，现在看 LeakCanary 的代码就是一种享受。]]></content>
      <categories>
        <category>LeakCanary</category>
      </categories>
      <tags>
        <tag>Android源码解析-LeakCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0049-平衡二叉树]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0049-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树平衡二叉树也是一种二叉排序树，只不过它比较平衡。什么叫平衡呢？平衡就是指这个树的左右两个子树的高度差的绝对值不超过1。而且，它的左右子树也是平衡二叉树。（禁止套娃）在我们构造一个平衡二叉树的时候，肯定不会像构造排序二叉树那么简单，我们需要动态的调整这棵树的平衡性，每当插入一个节点时，导致了树不平衡了，就立刻调整这棵树。 我们会遇到四种需要调整的情况： LL型调整 比如，我们按照 4，2，1 的顺序构造一个平衡二叉树，就会出现上图的情况。 这个LL型调整，也有人称为“右旋”，下面给个图来形象的解释一下啥叫“右旋”。 算法实现123456789Node llRotate(Node root) &#123; Node newRoot = root.left; // 开始碰撞 root.left = newRoot.right; // 碰撞完成 newRoot.right = root; return newRoot;&#125; RR型调整 这个与LL刚好是相反的，理解了LL，这个也就理解了。只需要将 A 节点降下来就好了。 算法实现：12345678Node rrRotate(Node root)&#123; Node newRoot = root.right; root.right = newRoot.left; newRoot.left = root; return x;&#125; LR型调整 这个调整就比较难理解了。其实这里有一个技巧：我们会发现上图中节点A 与节点B 的平衡因子的符号不一样。 节点 A 的平衡因子为 2，节点 B 的平衡因子为 -1。这种情况下，我们不能直接旋转树，就算你旋转了也没啥屌用，还是不平衡的，那么应该怎么做呢？ 我们先将节点 A 的左子树左旋，会得到如下图： 然后，我们再右旋以A为根的树，就可以得到上面图中右边的树了。 算法实现 123456Node lrRotate(Node root) &#123; // 先旋转A的左子树，旋转完之后，让它接回来 root.left = rrRotate(root.left); // 再旋转A llRotate(root);&#125; RL型调整 这个与LR就是相反的，也就好理解了。 算法实现1234Node rlRotate(Node root) &#123; root.right = llRotate(root.right); rrRotate(root);&#125; 完整算法实现插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384Node insert(Node root, int key) &#123; // 空树 if (root == null) &#123; Node node = new Node(); node.key = key; // 节点的高度 node.height = 1; return node; &#125; // 递归的寻找节点 if (key &lt; node.key) &#123; node.left = insert(node.left, key); &#125; else if(key &gt; node.key) &#123; node.right = insert(node.right, key); &#125; else &#123; return node; &#125; node.height = 1 + max(height(node.left), height(node.right)); int balance = getBalance(node); // 在A的左孩子(L)的左子树(L)上插入新结点 if (balance &gt; 1 &amp;&amp; key &lt; node.left.key) &#123; return llRotate(node); &#125; // 在A的右孩子(R)的右子树(R)上插入新结点 if (balance &lt; -1 &amp;&amp; key &gt; node.right.key) &#123; return rrRotate(node); &#125; // 在A的左孩子(L)的右子树(R)上插入新结点 if (balance &gt; 1 &amp;&amp; key &gt; node.left.key) &#123; node.left = rrRotate(node.left); return llRotate(node); &#125; // 在A的右孩子(R)的左子树(L)上插入新结点 if (balence &lt; -1 &amp;&amp; key &lt; node.right.key) &#123; node.right = llRotate(node.right); return rrRotate(node); &#125; return node;&#125;Node llRotate(Node node) &#123; Node newRoot = node.left; node.left = newRoot.right; newRoot.right = node; node.height = max(height(node.left), height(node.right)) + 1; newRoot.height = max(height(newRoot.left), height(newRoot.right)) + 1; return newRoot;&#125;Node rrRotate(Node node) &#123; Node newRoot = node.right; node.right = newRoot.left; newRoot.left = node; node.height = max(height(node.left), height(node.right)) + 1; newRoot.height = max(height(newRoot.left), height(newRoot.right)) + 1; return newRoot;&#125;int height(Node node)&#123; if (node == null) return 0; return node.height;&#125;int getBalance(Node node)&#123; if (node == null) return 0; return height(node.left) - height(node.right);&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0048-二叉树的删除]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0048-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[二叉树的删除二叉树的删除是一个相对复杂一点的操作，因为它需要分情况考虑。情况一：如果待删除的节点是叶子节点，这个自然好说，直接删除就好了。情况二：如果待删除的节点只有左子树或者只有右子树，这个也简单，让它的左子树或者右子树的根节点来顶自己的位置就好了。情况三：如果待删除的节点既有左子树，又有右子树，该怎么办呢？我们举个例子，如果要删除的是根节点，该让谁来顶根节点的位置？？？ 按照二叉树的尿性，根节点一般是偏居中的一个值。所以有两种顶位的方案：让左子树最大的来顶或者让右子树最小的来顶。 我们仔细想一下这两种方案，会发现一件有趣的事情。 如果我们让左子树的最大值来顶，那么我们分3步： 将最大值复制一份 替换根的值 删除最大值节点 前两步简单，第三步看上去又回到了删除节点问题上，但是稍微思考一下就会发现因为它已经是最大值了，所以它没有右子树，即这个删除情况与第二种情况一样。 所以，最终我们是将情况三转换成了情况二，同样的，删除右子树的最小是也是同样的道理。 算法实现1234567891011121314// deleteBST 主要是找到要删除的节点boolean deleteBST(Node root, int key) &#123; if (root == null) &#123; return false; &#125; else &#123; if (key == root.data) &#123; return delete(root); &#125; else if (key &lt; root.data) &#123; return deleteBST(root.left, key); &#125; else &#123; return deleteBST(root.right, key); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829void delete(Node p) &#123; Node q,s; if (p.left == null) &#123; // 左子树为空 p = p.right; &#125; else if (p.right == null) &#123; // 右子树为空 p = p.left; &#125; else &#123; // 左右子树都不为空 q = p; s = p.left; // 找左子树的最大值 while (s.right != null) &#123; q = s; s = s.right; &#125; // while 之后，s 指向最大值，q是s的父节点 // 交换值 p.data = s.data; // 这里其实也可以直接递归调用 delete(s) if(q != p) &#123; q.right = s.left; &#125; else &#123; q.left = s.left; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0047-二叉树的插入]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0047-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%2F</url>
    <content type="text"><![CDATA[二叉树的插入二叉树的插入需要借助二叉树的查找。思考这样的一个问题，当我们在二叉树中寻找一个节点时，如果这个节点不存在，最后遍历的那个节点与要寻找的节点有什么关系？？？在脑子里过一下查找的过程，发现，没找到的情况下，肯定是在树中找到了与目标节点最接近的那个节点。知道了这个条件，我们就可以很容易的插入了。 我们将最后遍历的那个节点叫做 L，目标节点叫做 T。 如果 L.data &gt; T.data 则，T 可以做为 L 的右节点。反之作为左节点。 还有一个需要注意的地方，要特殊处理。如果树是空树，则 T 需要作为根。 1234567891011if(!find(key)) &#123; Node temp = new Node(); temp.data = key; if (isEmptyTree()) &#123; doSomeThing(); &#125; else if(last.data &gt; temp.data) &#123; last.left = temp; &#125; else &#123; last.right = temp; &#125;&#125; 有了二叉树的插入，构建一个二叉树就非常的简单了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0046-二叉树的查找]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0046-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二叉树的查找二叉树的查找与二分查找很像。12345678910111213public static boolean serachBinaryTree(BinaryTree bt, int key, BinaryTree parent) &#123; if (bt == null || bt.data == 0) &#123; // 树节点不存在，返回 parentNode = parent; return false; &#125; else if (key == bt.data) &#123; // 查找成功 parentNode = bt; return true; &#125; else if (key &lt; bt.data) &#123; // 关键字小于根节点查找左子树 return serachBinaryTree(bt.lchild, key, bt); &#125; else &#123; // 关键字大于根节点查找右子树 return serachBinaryTree(bt.rchild, key, parent); &#125;&#125; 我们看一下二分查找法： 123456789101112131415// 递归实现二分查找private static boolean binarySearch(int data, int[] arr, int minIndex, int maxIndex) &#123; int midIndex = (minIndex &amp; maxIndex) + ((minIndex ^ maxIndex) &gt;&gt; 1); if (data &lt; arr[minIndex] || data &gt; arr[maxIndex] || minIndex &gt; maxIndex) &#123; return false; &#125; if (data &gt; arr[midIndex]) &#123; return binarySearch(data, arr, midIndex + 1, maxIndex); &#125; else if (data &lt; arr[midIndex]) &#123; return binarySearch(data, arr, minIndex, midIndex - 1); &#125; else &#123; return true; &#125;&#125; 上面的都是递归的写法，理解起来应该也很简单。 当然也有循环的写法，就不介绍了。 递归转循环，无非就是在循环里面改变需要改变的值罢了。 上面的二分查找，每次递归，都是改变了 minIndex maxIndex 的值，其他的没有改变，那么我们将更改这两个值的代码，放到循环中就好了： 12345678910while (minIndex &lt;= maxIndex) &#123; midIndex = (minIndex &amp; maxIndex) + ((minIndex ^ maxIndex) &gt;&gt; 1); if (data &gt; arr[midIndex]) &#123; minIndex = midIndex + 1; &#125; else if (data &lt; arr[midIndex]) &#123; maxIndex = midIndex - 1; &#125; else &#123; return true; &#125;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0045-关键路径]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0045-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[关键路径关键路径是拓扑排序的一种进阶使用。当我们将一个工程的各个流程转换为一张有向图时，我们可以使用拓扑排序来判断工程是否能够顺利完成（有没有环）。但是如果我们想知道这个工程能够顺利完成，那么就需要知道这个有向图的关键路径了。什么是关键路径呢？就是在一个有向图中，从起点到终点，肯定会有不止一条路，关键路径就是最长的那条路。 如何计算关键路径我们先来看一个非常简单的图： 显然，图中的关键路径是 A -&gt; B -&gt; D。 这个对人类的大脑来说，非常简单就能计算出来，但是如果图变得复杂，我们就无法一眼看出来了。 这个关键路径有3个点，我们将这个图压扁，如下： 我们假设图上边的权重，代表的是时间（单位为小时）。 对于 A -&gt; C -&gt; D 这条不关键的路径，它由两条边构成： 12A -&gt; CC -&gt; D 如果我们一开始就进行 A -&gt; C 的工作，花 5 个小时完成。 然后继续进行 C -&gt; D 的工作，花 9 个小时完成。 这个时候，工程仍然处于未完成状态，因为 B -&gt; D 这条线还处于进行状态。 所以，我们也可以这样，我们一开始不做 A -&gt; C 的工作，我们等 （3 + 27 - 9 - 5） 个小时，在开始 A -&gt; C 的工作。 你就会发现，不关键的路径的执行时间是可以浮动的。 对于上面的例子，A -&gt; C 的浮动范围为 (0, 16)， C -&gt; D 的浮动范围为 (5, 21)。 就不要太在意边界条件了 算法思想先来四个定义： 前两个针对顶点，后两个针对边 事件最早开始时间：顶点Vi最早发生的时间。 事件最晚开始时间：顶点Vi最晚发生的时间，超出则会延误整个工期。 活动的最早开始时间：边Eg最早发生时间。 活动的最晚开始时间：边Eg最晚发生时间。不推迟工期的最晚开工时间。 我们很难直接计算出边的最早最晚开始时间，但是对于每个顶点来说，可以比较简单的计算出。 有了每个顶点的最早最晚发生时间，我们就可以计算出边的最早最晚发生时间，从而得出关键路径。 算法实现首先，我们仍然使用 拓扑排序 计算出一个顶点序列，不过，我们在做拓扑排序的时候，还可以顺便做一件事情，就是计算出每个定点的最早发生时间。 计算公式如下： etv[k] = max{etv[i] + len(vi, vk)} 这个公式的意思： 顶点 k 的最早发生时间 = 顶点 i 的最早发生时间 + i -&gt; k 这条边的值。 i 为与 k 相连的所有顶点。 顶点 i 为弧头，k 是弧尾。 我们得到了 拓扑序列 与 所有顶点的最早发生时间，然后就可以获取所有顶点的最晚发生时间了。 我们将拓扑序列倒序遍历，做如下计算： ltv[k] = min{ltv[j] - len(vk, vj)} 这个表达式，与上面的差不多，意思也差不多，不过这里是做减法。 还有一个需要注意的地方，就是 顶点 k 是弧头，顶点 j 是弧尾，与上面是相反的。 这样，我们就求的了各个顶点的最晚发生时间。 知道了最早最晚发生时间，就可以求边的最早最晚发生时间，从而得到关键路径。 1234567891011121314151617181920for (i=0;i&lt;g.numVextexs;i++)&#123; if (g.adjList[i].fitstedge) &#123; e = g.adjList[i].fitstedge; while(e) &#123; int eIdx = e-&gt;idx; //活动（i-&gt;eIdx）最早开始时间：事件（顶点） i最早开始时间 ete = g_etv[i]; //活动（i-&gt;eIdx）最迟开始时间：事件（顶点） eIdx 最迟开始时间 减去 活动持续时间 lte = g_ltv[eIdx] - e-&gt;weigh; if (ete == lte) &#123; printf("(%c - %c)-&gt;",g_init_vexs[i],g_init_vexs[eIdx]); &#125; e= e-&gt;next; &#125; &#125;&#125; 这个的循环，就是遍历每个顶点的邻接边，求各个边的最早最晚发生时间。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0044-拓扑排序]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0044-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[拓扑排序拓扑排序是对一个有向无环图进行排序。这么说可能很多人都不太理解，如果你常玩游戏，那我可以举一个例子。看上面图中的技能树，假设每个技能树点亮都需要花费一个技能点，我们有足够的技能点。那么，你告诉我，将技能树全部点亮，有多少种方式？？？肯定会不止一种，因为每次点亮都有多个选择。但是你也不能一开始就直接点亮最后面的技能。 当然这个问题，比较蛋疼，我们其实一般不关心有多少种，只需要一种方式就够了。这每一种方式都是一个拓扑排序。 好了，理解了拓扑排序，接下来，我们说一下该如何实现这个算法。 以技能树的方式来看，或许你会感觉这个算法应该很简单，确实如此，但是一个好的算法，还需要一个好的数据结构来辅助。 比如，我们如何知道，某个技能点亮了，某个技能可以被点亮，某个技能无法被点亮。 在我们前面学习的图的几种储存结构中，只有邻接表是最合适的，因为用链表储存了与他相邻的所有点。我们只需要加一个 “入度” 字段即可，如下： 123456789101112class EdgeNode &#123; int vex; int weight; EdgeNode next;&#125;class VexNode &#123; // 入度 int in; T data; EdgeNode edge;&#125; 我们首先，遍历所有顶点，总有几个顶点是没有顶点指向它的（对应技能树的最初几个技能），不然的话，就有环了。 我们使用一个栈（队列也可以）来储存所有 入度 为 0 的所有顶点。 12stack = new Stack();stack.push(node); 然后将弹出其中一个元素，遍历这个元素的 next 链表。 12345678910111213141516171819VexNode vexNode;EdgeNode edgeNode = vexNode.edge;while(edgeNode != null) &#123; // 获取这个边的另一边的顶点 int k = edgeNode.vex; // 拿到这个顶点 VexNode tempNode = getVexNodeWith(k); // 比如，顶点 1 与顶点 2 相邻 // 这里就是将 1-2 这条边删除了 tempNode.in--; if (tempNode.in == 0) &#123; // 如果将边删除之后，发现，这个顶点也成了没有顶点指向的顶点，则将它加入栈中 stack.push(tempNode); &#125; // 继续循环 node = node.next;&#125; 这样循环，直到栈为空。 这个算法不难，理解起来也简单。与广度优先遍历有相同的地方。 好奇，拓扑排序的作用，可以看下这个： https://www.zhihu.com/question/39748146 它也可以用来判断一个有向图是否有环，因为如果存在环，环上的顶点的入度不可能为 0。遍历完之后，会发现有几个顶点没有遍历到。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0043-最短路径之Floya算法]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0043-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BFloyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Flyod算法Flyod是个非常牛逼的人，拥有一个开挂的人生。人物简介在此：罗伯特·弗洛伊德 。算法介绍Flyod算法是一个非常优美的算法，因为它就只有几行，如下：1234for(k=0;k&lt;n;k++) for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) A[i][j]=min(A[i][j],A[i][k]+A[k][j]); 关于这个算法，它还有一个笑话： 为什么 Dijkstra 不能提出 floyd 算法？因为他的名字是 ijk 而不是 kij。 要理解这个笑话，你需要认真读一下这个算法，在这个算法的3层循环中，三个变量是有一定顺序的：k 必须要在 i 与 j 的外面，i 与 j 没有顺序。 动态规划我们下面来说一下这个算法的由来。Floyd 算法是基于动态规划而来的，不了解动态规划的可以先去补一下相关知识。 我们假设，为 i, j之间的最短路，它使用 作为中间节点，那么根据动态规划方程，可以知道: 。 本来，是有四种情况的，如下： 但是只有第一种形式是正确的，其余3中都是错误的，为啥呢？因为 k 不可能是或者的中间节点。我们拿 举例，如果 k 是 的中间节点。那就说明从 i 到 k 的最短路径包含了 k，那岂不是 k 经过了两次，说明形成了环，而环是不可能作为最短路径的。 自己的理解好，动态规划的公式，我们写出来了，接下来，我们再来理解一下这个公式的真正意义。 由公式可知，我们可以根据 K-1 的关系式得出 K 得关系式。这就意味着，只要我们慢慢的加入顶点，就可以得出最小路径。 这句话的意思是这样的： 想象一下，我们已经有了一个已求得各点最短路径的图。这个时候，我们往图里面添加一个顶点 X，我们就只需要求出各点经过 X 的路径，然后与原来的路径做比较即可。 那么，现在，应该就能理解 k 为什么在最外层了！ 如果 k 在最里层，那么在遍历 k 之前，没有保证各个点之间已经是最小路径，自然，经过 k 点时，也不是最短路径。 这个算法，最神奇的地方在于：先求出各个点经过 V0 点的最短路径之后，再求出各个点经过 V1 点的最短路径时，这个最小距离已经包含了经过 V0 的最小距离。 所以，外层循环每遍历一次，都相当于更新了一次各个点之间的最短路径。也许，本来最短路径只经过 V0 点，现在变成了 V1 点，或者 V0 + V1 点。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0052-几种排序算法]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序假设我们不是对序列进行排序，而是对角斗士进行武力排名，那么该怎么设立一个规则呢？我们给角斗士每人分配一个令牌，令牌的编号对应着排名，从 1 到 n，刚开始肯定是随机分配一个令牌。然后角斗士可以发起挑战，但是只能挑战排名比自己高1位的对手，比如编号为 14的，只能挑战编号为13的对手，如果挑战成功之后，互换令牌。 这样，经过一段时间之后，角斗士手里的令牌不再变化了，那么手里令牌为1的，就是武力最高的了。 这就是一个冒泡排序了，能力更出众的，总是会往上冒。 选择排序选择排序虽然也可以用角斗士的例子，但是这样不免重复，会导致记忆混乱。 选择排序着重于选择，每一次的选择结果都会导致序列变化。 假设你是一个农村里的孩子，一天你砍了很多竹子用来喂竹鼠，但是在喂之前你突然想给竹子按长度排一个序，然后再砍了喂竹鼠。那么该怎么排呢？ 可以这样，先扫一眼所有的竹子，找到最长的，放到第一位，这样最长的就找到了，将这个最长的拿到一边。 重复上面的步骤，就排好序了。 所谓选择，就是每次都选择一个自己需要的。 选择排序比起冒泡排序少了很多交换动作，所以要稍微快点。 插入排序 插入排序有一个最形象的例子了，每个人都玩过，就是扑克牌。 回想一下，你斗地主的时候，一张一张的起牌的时候，是不是每次都是插入一张牌到手里的牌里面。 比如，你的手里有一张 3，一张 5，这个时候来了一张 4，你肯定是将 4 插入到 3 与 5 中间。 因为你手里的牌本来就是有序的，所以插入也非常快。 插入排序不稳定，如果本来是有序的，最快可以为 o(n)，最慢为 o(n*n)。 希尔排序 前面说过，插入排序在序列有序的情况下，速度非常快，那么可不可以先让序列变为基本有序，然后再排序呢？ 说明一下，啥叫基本有序，基本有序就是小的基本在前面，大的基本在后面，不大不小的基本在中间。 比如一个序列，{9， 1， 5， 8， 3， 7， 4， 6 ，2}，它是一个无序序列。 想一下，怎么将它变成一个基本有序序列？ 我们将这个序列，按照镂空的方式分为3段，如下： 第一段：{o，x，x，o，x，x，o，x ，x}，得到 {9，8，4} 第二段：{x，o，x，x，o，x， x，o ，x}，得到 {1，3，6} 第三段：{x，x，o， x，x，o，x， x ，o}，得到 {5，7，2} 为啥要这样分呢？因为这样分了之后，每一段都保留了整个序列的部分特征，对这些子序列进行排序之后，整个序列就会基本有序。 比如，我们使用插入排序，将上面的3个子序列排序后： {4，8，9} {1，3，6} {2，5，7} 合并之后，就会得到{4，1，2，8，3，5，9，6，7}，虽然还不是有序的，但是比起原来的序列，已经算得上的基本有序的，然后我们重复上面的步骤，再次将整个序列分解，但是间隔要慢慢变小，直到为0。 为 0 时，就是最后一次比较，就是对整个序列进行一次插入排序，比较完之后，序列就是有序的了。 希尔排序的时间复杂度在 ${o(n^{\frac{3}2})}$，虽然它的代码里面有3个循环。 堆排序 堆是一个完全二叉树。 在排序算法中，我们使用数组来表示这个完全二叉树，如下： 上图是一个大顶堆，大顶堆就是最大的在根上。对应的还有小顶堆。 看图中每个节点的索引关系： 一个节点的索引为 i，其左孩子节点的索引为 2i + 1，右孩子节点的索引为 2\ i + 2. 当然这个关系不是固定的，如果不在0位置储存元素，那么关系就不一样了。 对于一个无序序列，刚开始的堆肯定是不满足条件的，需要调整这个堆，如何调整呢？很简单，只需要对非叶子节点，做如下处理就好了： 比较它的左右孩子，找到更大的孩子，然后与自己比较，如果孩子大，则交换。 注意，要对每个非叶子节点处理，遍历的时候，要从索引值由大到小开始，不然的话，小的（就是最上面的）先换了也没用。好的，我们使用内在化来强化记忆一下这个过程： 这里有一个动图，只看它的前半部分。 我们将每个节点当作一个角斗士，对于最下面一层的角斗士，他们下面已经没有人了，所以没必要决斗。对于其他角斗士，则需要从3个角斗士中选一个，让最厉害的角斗士站在顶端。如下： 对每个非最底层的角斗士（从下往上）都这样来一遍，这样处于最顶端的就是最厉害的角斗士了。这个和我们常见的两两对战不一样，而是三三对战。 如此，我们的大顶堆就构建好了。构建好了然后呢，这个玩意怎么帮助我们排序呢？ 假设，国王让你选出10个最厉害的角斗士，你按照上面的三三对战方式选出了最厉害的一个，然后该怎么办？将最厉害的择出来，然后按照同样的方式再一次选一个吗？这样也可以，但是就浪费了第一次比较的结果（时间复杂度为o(n*n)的都是这样，没有好好利用前一次比较的结果）。 那么应该如何利用前一次的比较结果呢？只需要找到完全二叉树里面，叶子节点最右边的一个（索引值最大的一个），将它与根节点交换，然后让根节点不断的下沉就好了。 所以，我们让序号最大的角斗士与序号最小的角斗士交换位置，再将最后一个位置去掉（它已经是最厉害的了）。 交换之后，让序号最小的角斗士与他下面的两人比较，谁最厉害就与谁交换位置。这里假设交换的左边的孩子位置，那么它应该下沉到左边孩子位置。 下沉之后，再让他与两个孩子比较，不断的重复这个过程，直到位置不再改变，这样，根上的就是第二厉害的角斗士了，而且依然是一个大顶堆。 堆排序的时间复杂度为 O(n*logn)，因为二叉树的高度为 logn，空间复杂度 o(1)，只需要一个用来储存临时数据的交换单元，还是非常不错的。 堆排序是一个不稳定的算法，因为交换不是相邻交换，而是跳跃式交换。 归并排序 归并排序使用了分治的思想。 假如你是皇帝，你要选出全国最美的十个少女，那么应该怎么做呢？ 你需要将命令传递到丞相，丞相将命令下发到各个州，各个州再传递到各个郡，各个郡再传递到各个县。 然后由县令统计出当地的少女并排好名次，再交给所属的太守，太守负责汇总所管辖的各个县，然后排出所有名次，再上传给刺史。然后刺史汇总所有管辖的郡，排好名次，上传给丞相，丞相汇总各个州的名词，在交给皇帝，就搞定了。 先看看归并排序的动图吧： 这个很容易理解： 就是将一个 n 长的序列，分解为n个1长度序列，然后两两比较，合成 n/2 个 2 长度的序列，再两两合并，直到序列只有一个。 归并排序是相邻的比较，所以是稳定的排序。它的时间复杂度为 O(n*logn)，但是空间负责度为 O(n)。将两个数组合并成一个数组的时候需要额外的储存空间。 快速排序 比如，你在逛一个超市，买了各种零食与家用品，全部放在了堆在了背包里面。 回家后，你想按照价值给它们排个序，你准备如何做呢？ 可以这样做，随便从包里选一个出来作为参照物，然后将比这个参照物价值小的放到左边，将比这个参照物价值大的放到右边。这样，参照物的位置就固定了，然后再堆左右两边做同样的操作，直到左右两边不可分隔。这样就排好序了。 这个就是快速排序。 看个图加深一下印象： 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 参考文档JS-Sorting-Algorithm 十大经典排序算法动画与解析，看我就够了！（配代码完全版）]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0041-最小生成树之Kruskal算法]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0041-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BKruskal%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Kruskal 算法前面的 Prim 算法是以顶点为主要思考方向，使用的是邻接矩阵。而 Kruskal 算法是以边为主要思考方向，它使用的是边集数组。Kruskal 算法，比较好描述： 将边按权值升序排序； 选出权值最小的边，记录下这条边的两个顶点，如果这两个顶点与集合中已有的顶点没有构成闭合回路，则将则两个顶点添加到集合中，否则排除这条边； 重复步骤2，直到所有顶点都加入最小生成树中； 用小人走迷宫举例就是： 让小人将迷宫所有的路都跑一遍，按每条路的长度排个序。 首先选取最短的路，将这条路画到小本本上。 然后再选取第二短的路，判断这条路是否与小本本上的路产生了闭合回路，如果没有，则画到小本本上，如果有，则排除这条路，这样不断地循环所有的路。 将图的边按权值排序，每个顶点放在单独的集合里： 选出权值最小的边（0，2）加入到最小生成树中，顶点0和2不在同一集合，没产生回路。合并顶点0和2所在的集合。 选出权值最小的边（3，5）加入到最小生成树中，顶点3和5不在同一集合，没产生回路。合并顶点3和5所在的集合。 选出权值最小的边（1，4）加入到最小生成树中，顶点1和4不在同一集合，没产生回路。合并顶点1和4所在的集合。 选出权值最小的边（2，5）加入到最小生成树中，顶点2和5不在同一集合，没产生回路。合并顶点2和5所在的集合。 选出权值最小的边（0，3）加入到最小生成树中，顶点0和3在同一集合中，产生回路，故放弃这条边。再选出权值最小的边（1，2）加入到最小生成树中，顶点1和2不在同一集合，没产生回路。合并顶点1和2所在的集合。 至此所有顶点都在同一个集合中，一颗最小生成树就构造完成。 算法中的难点，就是如何判断顶点，是否产生了回路！！！ 可以这样做： 我们定义一个数组 parent[]，x = parent[y]，我们记作 x -&gt; y。 当有一条边 [i - j] 到来时，我们让 i = parent[j]。 当下一条边 [i - n] 到来时，我们让 i = parent[n]。 我们就有了这样的关系图：n -&gt; i &lt;- j。 n 与 j 的 parent 都是 i。这样如果以后有一条边包含了 n 与 j，我们就知道，这条边肯定形成闭合回路了。 说了这么多，其实就是给这些边都加一个方向，从边两个顶点出发，都走到了同一个终点，那么就是形成回路了。 从某个顶点出发，走到最终点的代码逻辑如下： 123456int find(int[] parent, int f) &#123; while (parent[f] &gt;0) &#123; f = parent[f]; &#125; return f;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0042-最短路径之Dijkstra算法]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0042-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BDijkstra%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最短路径之Dijkstra算法看一个动图：算法原理：1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Dijkstra最短路径。 * 即，统计图中"顶点vs"到其它各个顶点的最短路径。 * * 参数说明： * vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。 */void MatrixUDG::dijkstra(int vs, int prev[], int dist[])&#123; int i,j,k; int min; int tmp; int flag[MAX]; // 初始化 for (i = 0; i &lt; mVexNum; i++) &#123; flag[i] = 0; prev[i] = 0; dist[i] = mMatrix[vs][i]; &#125; // vs 是起点 flag[vs] = 1; dist[vs] = 0; for (i = 1; i &lt; mVexNum; i++) &#123; // dist[] 储存的是各个顶点距离起点的距离 // 寻找里面的最小值 min = INF; for (j = 0; j &lt; mVexNum; j++) &#123; if (flag[j]==0 &amp;&amp; dist[j]&lt;min) &#123; min = dist[j]; k = j; &#125; &#125; // 认为 k 是离起点最近的，那么 k 之后就不再参与遍历 flag[k] = 1; // 利用 k 作为中转点，更新其他点到起点的距离 for (j = 0; j &lt; mVexNum; j++) &#123; tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j])); if (flag[j] == 0 &amp;&amp; (tmp &lt; dist[j]) ) &#123; // 发现j点经过k点到起点更短 // 将新的最短路径更新到 dist 中 dist[j] = tmp; // prev 是记录的最短路径 prev[j] = k; &#125; &#125; &#125; // 打印dijkstra最短路径的结果 cout &lt;&lt; "dijkstra(" &lt;&lt; mVexs[vs] &lt;&lt; "): " &lt;&lt; endl; for (i = 0; i &lt; mVexNum; i++) cout &lt;&lt; " shortest(" &lt;&lt; mVexs[vs] &lt;&lt; ", " &lt;&lt; mVexs[i] &lt;&lt; ")=" &lt;&lt; dist[i] &lt;&lt; endl;&#125; dist[i] 储存的是 i 到起点的最短路径值，没有记录详细的路径节点，前驱节点在 prev[i] 中储存着。 dist 会不断借助中转点进行更新。 不看算法，只看算法思想，需要用到邻接矩阵，所以复杂度为 O(n * n)； 参考文档https://www.cnblogs.com/msymm/p/9769915.html]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0039-图的遍历]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0039-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[可以想象一个走迷宫的过程，入口是其中一个顶点，沿着边前进，递归则意味着朝着深处前进，循环则意味着对于某个分叉点，把每条路都走一遍。深度优先遍历对于邻接矩阵的深度优先遍历：只需要针对某一行（列）进行遍历即可，这样只是遍历了某一个顶点的各个边，就不是深度优先了。所以在遍历的时候，如果值为 1，假设是在矩阵的 （x, y）位置，则应该递归的去遍历第 y 行。 想象不出来的，找个矩阵，自己连连线就明白了。 还有一个需要注意的就是，因为图可能是闭合的，所以，需要额外的空间来标记这个边是否走过了。 时间复杂度为 o(n*n)。 对于邻接表来说，其实是一样的，只需要遍历到另外的顶点的时候，递归这个顶点就好了。这就是深度优先的套路。时间复杂度为 o(n+e)。 广度优先遍历广度优先就是一个人走迷宫，遇到一个分叉点的时候，不是直接往深处行进，而是先将分叉的路全部都走一遍，做上记号，最后在选第一条，深入。 比如，对于 A 点来说，有两条道路，一条到 B，一条到 C，那么我先把 AB，AC 这两条路走了，顺便将 B，C 做个记号，再选 AB 这条路，到 B 点，继续深入，重复这个过程。 在代码中，做记号这个过程，就是用队列实现的，因为它是先进先出。也需要额外的空间来标记这个边是否走过了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0038-图的储存结构]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0038-%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[图的表示法有点不同于其他。用顺序储存是无法做的到，用链表可以做到，但是会有许多不便。所以这里介绍一些常见的储存图的方式。邻接矩阵邻接矩阵的思想，就是将顶点与边分开储存。顶点用一个一维的数组即可表示，边因为涉及到两个顶点，所以用二维数组表示。顶点的一维数组没啥说的，看看边的邻接矩阵。想要知道 X 与 Y 是否相连，看 X 与 Y 形成的十字交集是否为 1 即可。另外这个矩阵是一个对称矩阵，当然只有无向图的邻接矩阵才是对称的，有向图不一定。 邻接表如果顶点多，边数少，那么邻接矩阵就会浪费很多空间。此时，就不能使用二维数组来实现。 这种表示方法是不是很眼熟，与树的孩子表示法是差不多的。 123456789101112131415// 边表节点，上图中灰色竖线右边的节点class EdgeNode &#123; // 该顶点对应的下标 int adjvex; // 边的权值 int weight; // 下一个边 EdgeNode next;&#125;// 顶点节点，上图中灰色竖线左边的class VertexNode &#123; int adjvex; EdgeNode next;&#125; 十字链表对于有向图来说，邻接表可以很好的描述出某个顶点“指向了”哪些顶点。如果反过来，我想知道哪些顶点都指向了某个顶点，该怎么做呢？除非遍历整个邻接表，或者使用逆邻接表。但是使用逆邻接表又无法了解“出度”问题。两难啊！那么有没有一种办法将邻接表与逆邻接表结合起来呢？那就是十字链表了。 这里的数据结构需要注意一下： 对于顶点结构： 12345class VertexNode &#123; int adjvex; EdgeNode in; EdgeNode out;&#125; 对于边表结构： 123456class EdgeNode &#123; int tailVex; int headVex; EdgeNode head; // 逆邻接表的边 EdgeNode tail; // 邻接表的边&#125; 十字链表，就是同时画了邻接表与逆邻接表。 邻接多重表邻接多重表(Adjacency Multilist)主要用于存储无向图。 当我们这样的需求时：对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个结点。使用邻接表就会很复杂。 因此，在进行这一类操作的无向图的问题中采用邻接多重表作存储结构更为适宜。 其实，结构与邻接表差不多，但是，我们需要储存更多的信息。 123456class EdgeNode &#123; int ivex; // 这条边的其中一个顶点 int jvex; // 这条边的另一个顶点 EdgeNode iLink; EdgeNode jLink;&#125; 这里 iLink 与 jLink 的构造过程是这样的： 123456789101112131415161718192021222324void CreatGraph(Graph *G) &#123; int i, j, k, l; char s[MAX_INFO]; VertexType va, vb; EBox *p; cin &gt;&gt; G.vexnum &gt;&gt; G.edgenum; for(i =0; i &lt; G.vexnum; i ++) &#123; cin &gt;&gt; G.vertices[i].data; G.vertices[i].firstedge = NULL; &#125; for(k =0; k &lt; G.edgenum; k ++)&#123; cin &gt;&gt; va &gt;&gt; vb; i = Locate(va, G); j = Locate(vb, G); p = new EBox; p -&gt; ivex = i; p -&gt; jvex = j; p -&gt; info = NULL; p -&gt; ifirstedge = G.vertices[i].firstedge; G.vertices[i].firstedge = p; p -&gt; jfirstedge = G.vertices[j].firstedge; G.vertices[j].firstedge = p; &#125;&#125; 可以看出，每当输入一条边时，找到这条边对应的两个顶点（i，j）。 然后对顶点 i，将这条边使用头插法插入到顶点 i 的边链表（iLink）中，对于 j 做同样的操作，话不好理解，如下图：]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0037-线索二叉树]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0037-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[当我们决定使用链表结构来储存二叉树时，会出现比较多的空指针域。通过考察各种二叉链表，不管二叉树的形态如何，空链域的个数总是多过非空链域的个数。准确的说，n个结点的二叉链表共有2n个链域，非空链域为n-1个，但其中的空链域却有n+1个。那么，有人提出了一种方法，利用原来的空链域存放指针，指向树中其他结点。这种指针称为线索。 假设 Node 是二叉链表中的一个结点，以下是建立线索的规则： （1）如果 Node.lchild 为空，则存放指向中序遍历序列中该结点的前驱结点，这个结点称为ptr的中序前驱； （2）如果 Node.rchild 为空，则存放指向中序遍历序列中该结点的后继结点，这个结点称为ptr的中序后继； 那么，这里就会出现一个问题，如何才能知道，这个 lchild 到底是指向的左孩子，还是中序前驱结点呢？ 所以为了区别，还需要额外加两个字段： 1234567class Node &#123; T data; Node lchild; Node rchild; boolean isLeftChild; // 为 true，表示 lchild 指向左孩子，否则指向中序前驱节点。 boolean isRightChild;&#125; 下面，我们来看一下，如何将一个二叉树变成线索二叉树： 12345678910111213141516171819202122232425262728293031Node pre;void inTreading(Node n) &#123; if(n == null) &#123; return; &#125; inTreading(n.lchild); processNode(n); inTreading(n.rchild);&#125;void processNode(Node n) &#123; // pre 是刚访问过的前驱节点 // 将 pre 复制给 lchild if(n.lchild == null) &#123; n.isLeftChild = false; n.lchild = pre; &#125; // 这里对于后继的判断比较特殊，因为无法知道 n 的后继，所以改变思路 // 我们对 pre 做判断是一样的效果 if(pre.rchild == null) &#123; pre.isRightChild = false; pre.rchild = n; &#125; pre = n;&#125; 我们再来深入思考一下，这个线索二叉树，左边指向的是左孩子或者前驱，右边指向的是右孩子或者后继，就像一个双向链表一样。 但是我们在遍历这个链表的时候，还是要注意，因为有的节点指向的是孩子节点，而不是前驱节点，所以需要特殊处理。 下面，我们看看应该如何遍历这个链表： 加上线索的二叉树结构是一个双向链表结构，为了便于遍历线索二叉树，我们为其添加一个头结点，头结点左孩子指向原二叉树的根结点，右孩子指针指向中序遍历的最后一个结点。同时，将第一个结点左孩子指针指向头结点，最后一个结点的右孩子指针指向头结点。 12345678910111213141516171819202122232425262728//T指向头结点，头结点的lchild链域指针指向二叉树的根结点 //中序遍历打印二叉线索树T（非递归算法） void inOrderTraversePrint(Node n)&#123; //r指向根结点 Node r = n.lchild; //空树或遍历结束时 while(r != n)&#123; //让 r 指向中序遍历序列的第一个结点（最左下的结点） while(!r.isLeftChild)&#123; r = r.lchild; &#125; println(r.data); // 当 r 的右孩子是线索时 while(r.isRightChild &amp;&amp; r.rchild != n)&#123; r = r.rchild; println(r.data); &#125; //当p所指结点的rchild指向的是孩子结点而不是线索时， //p的后继应该是其右子树的最左下的结点，即遍历其右子树时访问的第一个节点 //更新节点，继续循环 r = r.rchild; &#125; println("\n"); &#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0036-二叉树的遍历]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0036-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的遍历分为4种。二叉树的遍历都很简单，使用递归写的，所以就不演示代码了。前序遍历先访问根节点，再对左子树使用前序遍历，再对右子树使用前序遍历。图中，前序遍历的结果是：1 2 4 5 3 6中序遍历先中序遍历根节点的左子树，再访问根节点，再中序遍历根节点的右子树。图中，中序遍历的结果是：4 2 5 1 6 3 后序遍历先后序遍历根节点的左子树，再后序遍历根节点的右子树，再访问根节点。 图中，后序遍历的结果是：4 5 2 6 3 1 层序遍历就是按照层次遍历。 图中，层序遍历的结果是： 1 2 3 4 5 6 推导遍历结果已知二叉树的前序遍历为 ABCDEF，中序遍历为 CBAEDF，请问这个二叉树的后序遍历结果？ 推导过程： 由前序遍历可知，A 为根节点。 由中序遍历可知，左子树为 CB，右子树为 EDF。 先看左子树 CB。在前序遍历中，B在前，说明 B 连着 A。而在中序遍历中， C 在 B 之前，说明 C 是 B 的左孩子。 再看 右子树 EDF ，在前序遍历中，D 在前，说明 D 连着 A，在中序遍历中，E 在 D 前，F 在 D 后，说明 E 是 D 的左孩子，F 是D 的右孩子。 所以，后序遍历为：C B E F D A.]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0035-二叉树的介绍]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0035-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[二叉树的特点 每个节点最多只能有两个孩子节点。 二叉树是有顺序的。 需要区分左子树还是右子树。 特殊的二叉树斜树所有的节点都只有左子树——左斜树。所有的节点都只有右子树——右斜树。满二叉树满二叉树可以理解为完美的二叉树，除了叶子节点外，所有的节点都有两个子树。完全二叉树完全二叉树有些不好理解，可以想象一下，满二叉树是一颗果树，每个节点是果实，你要从这个树上摘水果来吃，但是有两个条件，一是只能从叶子节点摘起，而是只能从右往左开始摘。 经过一段时间之后，树上剩下的果实就组成了一个完全二叉树。 我觉得这个“完全”两个字起的不好，但是别的词语也不太好描述，毕竟这树只是叶子节点的右边缺了一块。 二叉树的性质 在二叉树的第 i 层上，最多有 $2^{i-1}$ 个节点。 这个好理解，无非是一个指数计算而已。 深度为 K 的二叉树至多有 $2^k - 1$ 个节点。 这个利用第一个性质，就可以证明出来，等比数列相加可得。 对任何一颗二叉树 T，如果其终端节点数为 $n_0$，度为 2 的节点数为 $n_2$ ，则，$n_0 = n_2 + 1$ . 这个可以使用公式推导出来，但是不容易记住。可以另辟蹊径来思考： 对于一个只有一个节点的树来说，n0 = 1， n2 = 0。 我们给这个节点增加两个叶子节点，n0 = 2， n2 = 1。可以看到这种情况下，n0 与 n2 的关系并没有变化，都增加了 1。 我们再给其中一个叶子节点增加一个叶子节点，可以发现，n0 = 2， n2 = 1，这种情况下其实本质上只是替换了一个叶子节点而已。 所以，无论树长多大，n0 = n2 + 1。 具有 n 个节点的完全二叉树的深度为 $log_2n + 1$ 。 这个把性质2反过来想就好了。 如果对一颗有 n 个节点的完全二叉树的节点按层序编号，对任一节点 i （1 &lt;= i &lt;= n）有： 如果 i = 1，则节点是根。 如果 i &gt; 1，则其父节点是 i / 2. 如果 2i &gt; n，则 i 没有左孩子，否则，其左孩子为 2i。 如果 2i+1 &gt; n，则 i 没有右孩子，否则，其右孩子为 2i + 1. 这个性质，画个图就了解了。 二叉树的储存 顺序储存 这种方式是将二叉树储存到数组中。如下图： 可以看到这里利用了性质5（性质5是从 1 开始，不过这里是从 0 开始）. 链式储存 1234class BiTreeNode&#123; T data; BiTreeNode left, right;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0034-树的储存结构]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0034-%E6%A0%91%E7%9A%84%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[我们想要在程序中使用树，就先得将它用数据结构表示出来。下面说几种常见的表示方法。双亲表示法这个表示法很容易理解，每个节点只可能有一个父节点。所以我们可以定义出下面的结构：1234class Node&#123; T data; Node parent;&#125;这个类用来表示一个节点的信息。整个树就可以用一个 Node[] 来表示。 这个数据结构很简单，但是限制也很多，比如，我想知道某个节点有哪些孩子节点，那么就不得不遍历整个数组。当然你也可以给Node节点加入更多的信息，从而避免遍历数组。 无论我们如何修改、增强这个Node类，最终都是为了解决我们的需求问题，如果这个Node刚好满足我们的需求，那么这个数据结构就是最好的。 孩子表示法既然有双亲表示法，那么有孩子表示法也是可以理解的，😁。 孩子表示法，就是说某一个节点它有哪些孩子。如下： 1234class Node&#123; T data; Node[] children;&#125; 这种表示方式像一种树形链表。 孩子表示法除了这种树状外，还有另外一种写法。这种写法类似与 HashMap 的数据结构，可以先想象一下。 我们先将所有节点都放入数组中。对于有孩子的节点，那么用一个链表来储存它所有的孩子，对于没有孩子的节点，用空链表表示。 12345678class Node &#123; T data; Node childList;&#125;class Tree &#123; Node[] nodes;&#125; 兄弟表示法有父母，有孩子，有兄弟，全家齐活。 这种表示法有点奇特，它最大的特点就是将一个树转化成了二叉树。 对于任意一个节点来说，它的左孩子是唯一的，它的右兄弟也是唯一的。我们可以利用这个特性，来定义数据结构： 12345class Node &#123; T data; Node leftChild; Node rightSib;&#125; 对于下图的树： 使用兄弟表示法：]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0033-树的一些术语]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0033-%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[树的一些定义在学习树的过程中会不断地出现一些术语，所以，这里先列出一些常见的。度节点拥有的子树数量为度。度为0的节点成为叶子节点。树的度，是各个节点的度的最大值。节点关系节点 B 与 C 是 A 的孩子节点。B 与 C 是兄弟。A 是 B 与 C 的双亲节点。有点像族谱。其他概念树的深度（高度），就是计算这个树有多少层（这个家族有传承了多少代）。 树还分有序树（子节点有顺序）与无序树。 森林是多个树（不想交）的集合。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0051-B+树]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0051-B%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一个m阶的B树具有如下几个特征：1.根结点至少有两个子女。2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m4.所有的叶子结点都位于同一层。5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 一个m阶的B+树具有如下几个特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 B-树中的卫星数据（Satellite Information）： B+树中的卫星数据（Satellite Information）： 需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 第一次磁盘IO： 第二次磁盘IO： 第三次磁盘IO： B-树的范围查找过程 自顶向下，查找到范围的下限（3）： 中序遍历到元素6： 中序遍历到元素8： 中序遍历到元素9： 中序遍历到元素11，遍历结束： B+树的范围查找过程 自顶向下，查找到范围的下限（3）： 通过链表指针，遍历到元素6, 8： 通过链表指针，遍历到元素9, 11，遍历结束： 简要地介绍B+树：​ B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。 B+树的特征：1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。（链表） 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 B+树的优势：1.单一节点存储更多的元素（因为不需要储存卫星数据，所以可以存放更多的关键字），使得查询的IO次数更少。 2.所有查询都要查找到叶子节点，查询性能稳定。 3.所有叶子节点形成有序链表，便于范围查询。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2FTCP%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[滑动窗口是用于控制网络传输的流量的，说白了就是TCP在进行数据传输的时候，会有两个端，一个发送端，一个接收端。但是发送端与接收端它们是处于不同环境（应用、系统、硬件）的，所以它们的发送能力与接受能力肯定是不一样的，那么就很可能出现这样的问题：如果发送的速度过快，而接收端处理的较慢，就会出现接收端数据溢出的问题！！！ 那么滑动窗口就是处理这些问题的，上面只是举了一个例子，实际上会有更多的问题，这里就不细说了，直接看看滑动窗口是如何工作的吧。 过程分析 首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。 接收端没有收到A，所以不回复ACK包。发送端重传A,B,C,D四个包，这次全都到达了。 接收端先获得A，发ACK包A，但是中途丢失；根据累计确认的原则，发D的ACK包，然后窗口滑动。 这里解释一下，什么是累计确认！！！ 累计确认可以理解为发送端与接收端做的一个特殊约定。当接收端成功收到了 A-D的所有包后，那么可以直接发一个D的确认包就OK了，然后发送端收到了D的确认包之后，就明白A-D已经全被接受了。 根据上面的解释，我们可以推断出这样的一种情景： 发送端发送了 A-D 包，但是 D 先到达了，那么接收端是不能发送 D 的确认包的！！！接收端只能按照顺序来发送确认包。 发送端收到D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。 接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是发F的ACK包；收到H，还是发F的ACK包。不幸的是，三个ACK包全都丢失。 发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失。 接收端获得I，因为没有G，只好回复F的ACK包。之后又相继收到G,H包。 接收端根据累计确认，发I包，其中H对应的丢失。窗口向右滑动。 后面的就不详细说了，原来的动画在 这个地址， 下载一个 adobe player 就可以自己设置参数运行了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[0030-队列的链式储存结构以及实现]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0030-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[上一篇说了循环队列，但是由于是基于数组的，所以它还是会有溢出问题，为了改善这个问题，所以了解一下它的链式储存还是有必要的。虽然我们常用的 ArrayList 一看就知道是使用的数组，但是它实现了扩容，所以解决了溢出问题。而且我们一般只使用 add 方法，很少使用 remove 方法，所以元素的移动也很少。 看一下链式储存的结构图： 链式结构前面已经说了很多了，这里就直接给出插入与删除的算法吧，其实也很简单。 插入队列为空时，front 肯定与 rear 是相等的，刚开始他们都指向头节点。 队列插入比单链表的插入还要简单，因为是在队列尾部插入。 12345678910public void enqueue(T e) &#123; if (full()) &#123; return; &#125; Node n = new Node(); n.value = e; n.next = null; rear.next = n; rear = n;&#125; 删除删除元素是从队列（链表）头部移除一个元素，这里要注意，因为使用了头节点，所以移除元素需要注意。 当队列只有一个元素的时候，还需要更新 rear 的值。 1234567891011121314public T dequeue() &#123; if (empty()) &#123; return; &#125; Node t = front.next; front.next = t.next; if (rear == t) &#123; rear = front; &#125; return t.value;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0050-B树]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0050-B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树B树一般写作“B树”或者“B-树”。“B-树”就是“B树”，中间的横线并不是减号。B树用于大数据的储存，为什么呢？二叉树难道不行吗？其实，从算法逻辑上来讲，二叉查找树的查找速度和比较次数都是最小的。但是有一个现实的问题拦在了我们前面，磁盘IO问题。对于大数据的储存，必定要放入磁盘中，所以处理数据必定会涉及到磁盘IO。 看下面一个例子： 这里我们让树的节点对应磁盘页。 二叉查找树的结构： 第1次磁盘IO： 第2次磁盘IO： 第3次磁盘IO： 第4次磁盘IO： IO是非常耗时的，所以为了减少IO次数，我们就将树变矮变胖，就是B树了。 下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 &lt;= k &lt;= m 3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 上面的概念看着很蛋疼，还是来看一个例子吧： 第1次磁盘IO： 在内存中定位（和9比较）： 第2次磁盘IO： 在内存中定位（和2，6比较）： 第3次磁盘IO： 在内存中定位（和3，5比较）： 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。 节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 自顶向下查找元素11的节点位置。 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋） 在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。我们对B树进行调整，使B树的阶数与硬盘储存的页面大小相匹配。比如说一棵B树的阶为1000，高度为3，它可以储存超过10亿（1000x1000x1000）个关键字。 我们只需要让根节点持久地保留在内存中，那么在这棵树上，寻找某一个关键字，至多需要两次硬盘的读取。 参考文档https://juejin.im/post/5c31f64c6fb9a049ac794ffc]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0040-最小生成树之Prim算法]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0040-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B9%8BPrim%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[普里姆算法算法思想：新建一个空的集合V，新建一个空的集合E。在无向图中随便取一个顶点作为起点，加入V，然后遍历包含这个顶点的所有边，找到最短的边，加入E，将这条边的另一个顶点也加入V，这样我们就有了两个顶点。再对V中的每一个元素，重复做上面的操作，这个集合就会不断的增长，直到包含所有顶点为止。这样 E 的集合就是最小生成树。 下面对算法的图例描述： 图例 说明 不可选 可选 已选（Vnew） 此为原始的加权连通图。每条边一侧的数字代表其权值。 - - - 顶点D被任意选为起始点。顶点A、B、E和F通过单条边与D相连。A是距离D最近的顶点，因此将A及对应边AD以高亮表示。 C, G A, B, E, F D 下一个顶点为距离D或A最近的顶点。B距D为9，距A为7，E为15，F为6。因此，F距D或A最近，因此将顶点F与相应边DF以高亮表示。 C, G B, E, F A, D 算法继续重复上面的步骤。距离A为7的顶点B被高亮表示。 C B, E, G A, D, F 在当前情况下，可以在C、E与G间进行选择。C距B为8，E距B为7，G距F为11。E最近，因此将顶点E与相应边BE高亮表示。 无 C, E, G A, D, F, B 这里，可供选择的顶点只有C和G。C距E为5，G距E为9，故选取C，并与边EC一同高亮表示。 无 C, G A, D, F, B, E 顶点G是唯一剩下的顶点，它距F为11，距E为9，E最近，故高亮表示G及相应边EG。 无 G A, D, F, B, E, C 现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为39。 无 无 A, D, F, B, E, C, G 我们举一个走迷宫的例子，来比喻一下这个过程： 首先，有一个小人进入迷宫起点。 假设这个点有x个岔路，那么我们让这个小人将每条岔路都走一遍，用一个小本本将每条路的长短记录下来。 选取最短的路（将这条路圈起来），沿着这条路走到终点。 在假设这个点有y个岔路，那么我们让这个小人将每条岔路都走一遍，但是这次，我们只记录最短的一条到小本本上，然后选取小本本中记录的最短的（除去圈起来的），沿着这条路走到终点。 就这样不断的重复，直到所有点都走完。 要实现这个算法，我们需要一个邻接矩阵。 算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//Prim算法生成最小生成树void MiniSpanTree_prim(MGraph G)&#123; int min, i, j, k; int adjvex[MAXVEX]; int lowcost[MAXVEX]; lowcost[0] = 0; adjvex[0] = 0; // 我们先让lowcost[i]表示各个顶点i与第0个顶点之间的权值 // 邻接矩阵中，没有相连的两个点，我们记为最大值 for (i = 1; i &lt; G.numVertexes;i++) &#123; lowcost[i] = G.arc[0][i]; adjvex[i] = 0; &#125; for (i = 1; i &lt; G.numVertexes;i++) &#123; min = INFINITY; j = 1; k = 0; // 找到 lowcost 中的最小值，即为与已有集合中的某个点相距最近的点 // 我们以第一次循环举例，那么，这个就寻找的是距离顶点 0 最近的顶点 k while (j&lt;G.numVertexes) &#123; if (lowcost[j]!=0&amp;&amp;lowcost[j]&lt;min) &#123; min = lowcost[j]; // 将这个点记录下来 k = j; &#125; j++; &#125; // adjvex[k] 的意义，下面有讲解 printf("(%d,%d)", adjvex[k], k); lowcost[k] = 0; // 寻找距离顶点k最近的点 for (j = 1; j &lt; G.numVertexes;j++) &#123; if (lowcost[j] != 0 &amp;&amp; G.arc[k][j]&lt;lowcost[j]) &#123; // 找到之后，更新 lowcost[j] // 这样 lowcost 就包含了距离集合V中所有顶点最近的顶点 lowcost[j] = G.arc[k][j]; // 更新 adjvex[j] ，adjvex[j] 表示距离j最近的是顶点k adjvex[j] = k; &#125; &#125; &#125;&#125; 显然，该算法的时间复杂度为 O(n*n)。 参考文档： https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0029-循环队列]]></title>
    <url>%2F2019%2F09%2F20%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0029-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序结构的储存方式的最大不足就是：对头的元素移除的时候，需要将队列中的每一个元素向前移动一格。为了避免每次移动，所以想出了循环队列的结构。我们按照下面的方式来定义循环队列：上面的这个图表示空的循环队列，front 指向队头，rear指向队尾。front 与 rear 相等表示队列为空。那么我们需要思考一个问题。当队列满了的时候，front 与 rear 的关系是什么样的？看下面的这个图： 可以看到在这种情况下，a1 与 a3 被从队头移除，又添加了 a6 与 a7，front 与 rear 也是相等的，那么就分不清了队列到底是满还是空的了。我们可以额外加一个辅助条件来帮助我们判断队列是满还是空，但是这里我们介绍另外一种方式：我们最多只存放 SIZE-1 个元素，如下图： front 与 rear 之间始终隔了一个，这样我们认为队列满了，虽然这样浪费了一个格子，但是使用起来却非常的方便，因为 front 与 rear 始终满足这样的一个关系： 1(rear + 1) % SIZE = front 下面，我们来使用代码来实现它。 队列大小123public int size() &#123; return (rear - front + SIZE) % SIZE;&#125; 因为 rear 可能比 front 小，所以需要先加上 SIZE，然后再取余。 因为空了一个格子，所以 size 的计算很简单。 插入元素插入只需要在 rear 指向的位置放入一个元素就好了，rear 往后移动一格。 1234567public void inQueue(T e) &#123; if(isFull()) &#123; return; &#125; table[rear] = e; rear = (rear + 1) % SIZE&#125; 删除元素删除元素只需要将 front 指针往后移动一格就好了。 12345678public T deQueue() &#123; if(!inRange(i)) &#123; return; &#125; T result = table[front]; front = (front + 1) % SIZE; return result;&#125; 删除与插入都很简单，因为是数组所以需要考虑的东西不多。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0028-队列]]></title>
    <url>%2F2019%2F09%2F19%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0028-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列在生活中很常见了，几乎做什么都要排列，食堂打饭，取票厅取票，地铁进站等等。想象一下我们排队的时候是如何行动的，在队伍的尾部开始排队，然后慢慢向前移动，最后到了队伍的头部，搞完事情之后就可以走了。每次排特别长的队伍总是很烦躁的，因为很浪费时间，而且限制了自由，这相当于是一种顺序储存方式。那么既然有顺序储存方式也就有链式储存，再想一下，当我们在银行或者医院排队的时候，是不是需要先取号，然后就不用排队了，只需要找个位置坐下来，然后等着叫号就行了，这其实就是一种链式储存方式，每个排队的人可以随意的坐在任何位置，当队伍最前面的事情被处理完之后，排队的人也不需要移动。 下面，我们分别来说明顺序储存与链式储存，由于顺序储存与链表的顺序储存基本是一样的，所以这里就不再介绍了。我们说一个比较特殊的队列——循环队列。下篇见。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-View的层次]]></title>
    <url>%2F2019%2F09%2F18%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0003-View%E7%9A%84%E5%B1%82%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[前面我们说到，RecyclerView 的 view 不是在一个层次的。比如 FixView 就显示在最顶层。需要理解的是，这里的 layer 与 canvas 的 layer 比较类似，虽然分了层次，但是实际上是一个先绘制一个后绘制导致的，后绘制的 view 会盖在先绘制的 view 的上面。比如，我们写一个 FrameLayout，它又两个 child： 1234567891011121314151617181920212223242526&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/border_bg"&gt; &lt;TextView android:id="@+id/title" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/item_background" android:gravity="center" android:textColor="#999999" android:textSize="22sp" android:textStyle="bold"/&gt; &lt;TextView android:id="@+id/title2" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/item_background" android:gravity="center" android:textColor="#999999" android:textSize="22sp" android:textStyle="bold"/&gt;&lt;/FrameLayout&gt; 在显示这个布局的时候，显然下面的 TextView 会覆盖在上面的 TextView 上，这个是因为 ViewGroup 使用数组保存了所有的 child。 android.view.ViewGroup 12// Child views of this ViewGroupprivate View[] mChildren; 在绘制 child 的时候，是遍历的各个 child： android.view.ViewGroup#dispatchDraw 123for (int i = 0; i &lt; childrenCount; i++) &#123; drawChild(canvas, child, drawingTime);&#125; 由于都是在同一个画布上作画，先绘制的自然看起来是在下面，所以就有了一个层次效果。 同时，有一个需要特别注意的地方，就是要想 child 在最上面，显然在 addView 的时候，需要传递 index 为 -1，这样就会添加到最后面（当然不传递也是默认为 -1）。 好的，了解了这个我们再来看 com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView 这个方法做了什么： com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView 123456@Overridepublic void addFixedView(View view) &#123; showView(view); addView(view, -1); hideView(view);&#125; 上面的不是原来的代码，但是与原来的代码是等价的，看起来会更容易理解一点。 showView 方法，我们已经说过了，是使用 ChildHelper 设置了一个标识。 addView 方法，这里可以理解为向 RecyclerView 中添加了一个 view。 hideView 方法，使用 ChildHelper 设置了一个标识，标识这个 view 无法被找到。 hideView 这个方法的作用并不是说对我们隐藏了这个 view，而是对 LayoutManager 来说，隐藏了这个 view。这是什么意思呢？具体可以看这两篇文章（是一个在 Android Framework 组工作的大佬写的）： http://www.birbit.com/recyclerview-animations-part-1-how-animations-work http://www.birbit.com/recyclerview-animations-part-2-behind-the-scenes 我说一下我自己的理解，可能理解的不准确。 我们的列表上有 A B D E 四个元素，这个时候在 B D 之间准备添加一个 C，当我们添加了数据，调用 notifyxxx 之后，Adapter 中的数据就立刻是最新的了，但是这个时候 LayoutManager 中的数据仍然是没有发生变化的，为什么呢？这个是因为 RecyclerView 的动画导致的。因为 RecyclerView 要显示一个添加动画，而这个动画需要两个布局才能完成，一个添加之前的布局（pre-layout），一个添加之后的布局(post-layout)，将这个两个布局进行对比，才有可能执行正确的动画。 当 pre-layout 完成之后，Adapter 中数据的变化才会反应到 LayoutManager 中，然后 post-layout，接着再执行动画。 实际上，LayoutManager 工作的方式是这样的： LayoutManger 保存了可见与不可见的 child，可以认为它与 Adatper 的变化是同步的。 但是它有两套 API，一套用于获取可见的 view，一套用于获取所有的 view。即 pre-layout 获取的是所有的view，post-layout 获取的是可见的 view。 这里所说的可见与不可见都是针对 LayoutManager 的，showView 与 hideView 也是。 如果我们将 hideView 注释掉，就会发现当我们滚动的时候，所有的 child 都会显示出来，界面会变得很卡，这是因为 LayoutManager 知晓了所有的 child，并且每次滚动都会触发 addFixView 方法，所以 LayoutManager 管理的 child 越来越多（都是重复的），自然就会很卡。 如果我们将 showView 注释掉，当我们滚动的时候，会发现 FixView 跑到背景后面去了（VLayoutActivity），至于为什么下面说。 最后再说，addView，这个方法并没有重复添加 view，看下面的逻辑： android.support.v7.widget.RecyclerView.LayoutManager#addViewInt 12345678910111213// ensure in correct positionint currentIndex = mChildHelper.indexOfChild(child);if (index == -1) &#123; index = mChildHelper.getChildCount();&#125;if (currentIndex == -1) &#123; throw new IllegalStateException("Added View has RecyclerView as parent but" + " view is not a real child. Unfiltered index:" + mRecyclerView.indexOfChild(child));&#125;if (currentIndex != index) &#123; mRecyclerView.mLayout.moveView(currentIndex, index);&#125; 可以看到其实只是将 view 重新移动了最后的位置。但是如果我们没有调用 showView 的话，LayoutManager 是不知道有这个 view 的，会导致 currentIndex 为 -1，则抛出异常，从而导致 view 的位置没有移动，则被后面添加的 view 给覆盖了。 啊，终于比较能够说服自己了，解决了心头之恨，当初看了一天，看的几乎快要怀疑自己了。 嗯，再额外说一个东西，就是它的每个 Card 的背景是如何实现的。 先看如何设置背景： 12LinearLayoutHelper layoutHelper1 = new LinearLayoutHelper();layoutHelper1.setBgColor(Color.YELLOW); 这样设置之后，LinearLayoutHelper 对应的 Adapter 管理的所有 View 就都会在同一个背景上，如下图： 这个背景其实是一个 View 实现的，具体看代码吧。 com.alibaba.android.vlayout.layout.BaseLayoutHelper#requireLayoutView 1234@Overridepublic boolean requireLayoutView() &#123; return mBgColor != 0 || mLayoutViewBindListener != null;&#125; 像追踪这样的效果的源码，最好的方法就是直接看哪里用到了相关的变量，这里我们从 bgColor 入手。 com.alibaba.android.vlayout.layout.BaseLayoutHelper#afterLayout 1234if (mLayoutView == null) &#123; mLayoutView = helper.generateLayoutView(); helper.addOffFlowView(mLayoutView, true);&#125; 在 afterLayout 中，这里创建了一个 LayoutView，然后将这个 view 添加到最前头（head 的值为 true）。 这样 LayoutView 就是一个背景了。需要注意的是 LayoutView 的 LayoutParams 必须是对应 LayoutMangager 的 LayoutParams，否则会被替换掉。 com.alibaba.android.vlayout.VirtualLayoutManager#generateLayoutView 1234567891011@Overridepublic final View generateLayoutView() &#123; if (mRecyclerView == null) return null; View layoutView = mLayoutViewFatory.generateLayoutView(mRecyclerView.getContext()); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); attachViewHolder(params, new LayoutViewHolder(layoutView)); layoutView.setLayoutParams(params); return layoutView;&#125; 这里设置的 LayoutParams 是 VirtualLayoutManager.LayoutParams，然后还将 layoutParams 的 mViewHolder 变量赋值了，这个也很重要，否则会报空指针异常，因为这个 view 也添加到了 RecyclerView 中，由 LayoutManager 来管理，需要满足一定的条件。 这里需要理解的是，这个 view 是我们自行添加的，而不是通过 adapter 的流程添加的。 我们再看，如果不使用这个 LayoutParams 会怎样： android.support.v7.widget.RecyclerView.Recycler#bindViewToPosition 1234567891011final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();final LayoutParams rvLayoutParams;if (lp == null) &#123; rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams);&#125; else if (!checkLayoutParams(lp)) &#123; rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams);&#125; else &#123; rvLayoutParams = (LayoutParams) lp;&#125; 可以看到，它会检测 LayoutParams 是否会满足要求，不满足就自己生成了一个，而生成的 LayoutParams 的 mViewHolder 是 null，所以会报空指针异常。 这个问题，我在研究 view 的 generateLayoutParams 的时候就遇到过，知识点串联起来的感觉还是挺爽的。 我自己的测试代码，我想在 FixView 上额外添加一个 Button，见如下代码： 12345678910111213141516171819202122@Overridepublic void addFixedView(View view) &#123; //removeChildView(view); //mFixedContainer.addView(view); addOffFlowView(view, false); if (!t.contains(view)) &#123; Button button = new Button(view.getContext()); VirtualLayoutManager.LayoutParams layoutParams = new VirtualLayoutManager.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); attachViewHolder(layoutParams, new LayoutViewHolder(button)); button.setLayoutParams(layoutParams); button.measure(View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY)); button.layout(view.getLeft(), view.getTop(), view.getLeft() + 100, view.getTop() + 100); button.setText("Test"); showView(button); addView(button, -1); hideView(button); t.add(view); &#125;&#125; 这样一个 button 就显示出来了。 刚开始，我使用了 RecyclerView.LayoutParams，报了空指针异常，提示 mViewHolder 为null，立刻就想到是 LayoutParams 被替换了，然后改了一下就好了。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-自定义LayoutHelper]]></title>
    <url>%2F2019%2F09%2F17%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0002-%E8%87%AA%E5%AE%9A%E4%B9%89LayoutHelper%2F</url>
    <content type="text"><![CDATA[在实现自己的 LayoutHelper 之前，我们先看看官方是如何实现的。如果你之前了解过自定义 LayoutManager，那么这个就是小意思了。我们先来看一个比较简单的 com.alibaba.android.vlayout.layout.FixLayoutHelper。 com.alibaba.android.vlayout.layout.FixLayoutHelper 12345678@Overridepublic void setItemCount(int itemCount) &#123; if (itemCount &gt; 0) &#123; super.setItemCount(1); &#125; else &#123; super.setItemCount(0); &#125;&#125; 可以看到，固定的 item 只管理单个 view，就算我们设置了多个，也只取第一个。比如： 123456789101112131415FixLayoutHelper layoutHelper = new FixLayoutHelper(10, 10);// itemCount 设置为 0，不显示，LayoutHelper 认为没有 view 需要排列adapters.add(new SubAdapter(this, layoutHelper, 0));layoutHelper = new FixLayoutHelper(FixLayoutHelper.TOP_RIGHT, 20, 20);// 这里即使将 itemCount 设置为 10，效果也是一样的adapters.add(new SubAdapter(this, layoutHelper, 1) &#123; @Override public void onBindViewHolder(MainViewHolder holder, int position) &#123; super.onBindViewHolder(holder, position); LayoutParams layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 200); holder.itemView.setLayoutParams(layoutParams); &#125;&#125;); 看看别的方法，有三个比较重要，我们先看第一个： com.alibaba.android.vlayout.layout.FixLayoutHelper#layoutViews 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic void layoutViews(RecyclerView.Recycler recycler, RecyclerView.State state, VirtualLayoutManager.LayoutStateWrapper layoutState, LayoutChunkResult result, final LayoutManagerHelper helper) &#123; // reach the end of this layout if (isOutOfRange(layoutState.getCurrentPosition())) &#123; return; &#125; if (!mShouldDrawn) &#123; layoutState.skipCurrentPosition(); return; &#125; // find view in currentPosition View view = mFixView; if (view == null) &#123; view = layoutState.next(recycler); &#125; else &#123; layoutState.skipCurrentPosition(); &#125; if (view == null) &#123; result.mFinished = true; return; &#125; mDoNormalHandle = state.isPreLayout(); if (mDoNormalHandle) &#123; // in PreLayout do normal layout helper.addChildView(layoutState, view); &#125; mFixView = view; doMeasureAndLayout(view, helper); result.mConsumed = 0; result.mIgnoreConsumed = true; handleStateOnResult(result, view);&#125; 我们看第 16-21 行的代码，这是很重要的一个部分，这里就是获取是否有可以复用的 view。往下看，到 37 行，这里就是处理了 view 的测量与布局。里面的逻辑还是很简单的，这里截取两段看一看： 12345final int widthSpec = helper.getChildMeasureSpec(xxx);heightSpec = helper.getChildMeasureSpec(xxx);// do measurementhelper.measureChildWithMargins(view, widthSpec, heightSpec); 测量都是一样的，先创建 MeasureSpec，然后调用 measureChildWithMargins 方法，view 的大小就测量好了。 1234top = helper.getPaddingTop() + mY + mAdjuster.top;right = helper.getContentWidth() - helper.getPaddingRight() - mX - mAdjuster.right;left = right - params.leftMargin - params.rightMargin - view.getMeasuredWidth();bottom = top + params.topMargin + params.bottomMargin + view.getMeasuredHeight(); 布局就更简单了，因为是固定位置，所以只需要算一下绝对位置就好了，没啥好说的。 我们再看另外两个方法： com.alibaba.android.vlayout.layout.FixLayoutHelper#beforeLayout 123456789101112131415@Overridepublic void beforeLayout(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutManagerHelper helper) &#123; super.beforeLayout(recycler, state, helper); if (mFixView != null &amp;&amp; helper.isViewHolderUpdated(mFixView)) &#123; // recycle view for later usage helper.removeChildView(mFixView); recycler.recycleView(mFixView); mFixView = null; isAddFixViewImmediately = true; &#125; mDoNormalHandle = false;&#125; 这个方法的作用，是在 layout 之前做一些事情，这里做的事情是如果检测到 viewHolder 变化了，就将 view 放入复用池中，便于接下来layout时复用。 com.alibaba.android.vlayout.layout.FixLayoutHelper#afterLayout 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic void afterLayout(final RecyclerView.Recycler recycler, RecyclerView.State state, int startPosition, int endPosition, int scrolled, final LayoutManagerHelper helper) &#123; super.afterLayout(recycler, state, startPosition, endPosition, scrolled, helper); // disabled if mPos is negative number if (mPos &lt; 0) &#123; return; &#125; if (mDoNormalHandle &amp;&amp; state.isPreLayout()) &#123; if (mFixView != null) &#123; // Log.d(TAG, "after layout doNormal removeView"); helper.removeChildView(mFixView); recycler.recycleView(mFixView); isAddFixViewImmediately = false; &#125; mFixView = null; return; &#125; // Not in normal flow if (shouldBeDraw(helper, startPosition, endPosition, scrolled)) &#123; mShouldDrawn = true; if (mFixView != null) &#123; // already capture in layoutViews phase // if it's not shown on screen if (mFixView.getParent() == null) &#123; addFixViewWithAnimator(helper, mFixView); &#125; else &#123; // helper.removeChildView(mFixView); helper.addFixedView(mFixView); isRemoveFixViewImmediately = false; &#125; &#125; else &#123; Runnable action = new Runnable() &#123; @Override public void run() &#123; mFixView = recycler.getViewForPosition(mPos); doMeasureAndLayout(mFixView, helper); if (isAddFixViewImmediately) &#123; helper.addFixedView(mFixView); isRemoveFixViewImmediately = false; &#125; else &#123; addFixViewWithAnimator(helper, mFixView); &#125; &#125; &#125;; if (mFixViewDisappearAnimatorListener.isAnimating()) &#123; mFixViewDisappearAnimatorListener.withEndAction(action); &#125; else &#123; action.run(); &#125; &#125; &#125; else &#123; mShouldDrawn = false; if (mFixView != null) &#123; removeFixViewWithAnimator(recycler, helper, mFixView); mFixView = null; &#125; &#125;&#125; 这个方法的作用，是在 layout 之后做一些事情。不知道你看到这里时有没有产生疑问：我们 RecyclerView 时从上往下，或者从下往上布局的，那么如果我们的屏幕上只能显示 10 个 item，而在第 100 个位置有一个 FixView，那么问题就来了，为什么我们一打开这个界面 FixView 就能立即显示出来，而不是滑动到了第 100 个位置才显示出来？ 我们先看该方法时在什么时候被调用的？ com.alibaba.android.vlayout.VirtualLayoutManager#runPostLayout 12345678910111213141516171819202122232425private void runPostLayout(RecyclerView.Recycler recycler, RecyclerView.State state, int scrolled) &#123; mNested--; if (mNested &lt;= 0) &#123; mNested = 0; final int startPosition = findFirstVisibleItemPosition(); final int endPosition = findLastVisibleItemPosition(); List&lt;LayoutHelper&gt; layoutHelpers = mHelperFinder.getLayoutHelpers(); Iterator&lt;LayoutHelper&gt; iterator = layoutHelpers.iterator(); LayoutHelper layoutHelper = null; while (iterator.hasNext()) &#123; layoutHelper = iterator.next(); try &#123; layoutHelper.afterLayout(recycler, state, startPosition, endPosition, scrolled, this); &#125; catch (Exception e) &#123; if (VirtualLayoutManager.sDebuggable) &#123; throw e; &#125; &#125; &#125; if (null != mViewLifeCycleHelper) &#123; mViewLifeCycleHelper.checkViewStatusInScreen(); &#125; &#125;&#125; 这个方法在 com.alibaba.android.vlayout.VirtualLayoutManager#onLayoutChildren 里面被调用，而 onLayoutChildren 几乎是不断的在被调用，RecyclerView 刚显示时，滚动时都需要调用该方法，所以 runPostLayout 也是不断的会被调用。 看 runPostLayout 的内部逻辑，可以发现它调用了所有的 LayoutHelper 的 afterLayout 方法。即，与 layoutViews 不一样，layoutViews 只会在滚动到相应位置才会调用，afterLayout 与 beforeLayout 都会不断的被调用。 所以，FixView 一开始就可以显示，显然是在 afterLayout 中做了什么。 说实话，这段逻辑我没看懂，写这个代码的人太喜欢用bool变量来控制逻辑了，所以只好使出断点调试大法。界面（VLayoutActivity）刚展示的时候，只会走 afterLayout 与 beforeLayout，beforeLayout 没什么影响，afterLayout 走到了第 47 行： com.alibaba.android.vlayout.layout.FixLayoutHelper#addFixViewWithAnimator 1234567891011121314151617private void addFixViewWithAnimator(LayoutManagerHelper layoutManagerHelper, View fixView) &#123; if (mFixViewAnimatorHelper != null) &#123; ViewPropertyAnimator animator = mFixViewAnimatorHelper .onGetFixViewAppearAnimator(fixView); if (animator != null) &#123; fixView.setVisibility(View.INVISIBLE); layoutManagerHelper.addFixedView(fixView); mFixViewAppearAnimatorListener.bindAction(layoutManagerHelper, fixView); animator.setListener(mFixViewAppearAnimatorListener).start(); &#125; else &#123; layoutManagerHelper.addFixedView(fixView); &#125; &#125; else &#123; layoutManagerHelper.addFixedView(fixView); &#125; isRemoveFixViewImmediately = false;&#125; 然后调用了第 14 行，所以，是 addFixedView 方法起了作用。该方法是将 FixView add 到了 LayoutManager 里面。这里需要 add 是因为本来 fixView 不应该在 LayoutManager 管理的集合里面，但是它又需要显示出来，所以需要 add。 addFixedView 这个方法里面的逻辑也很简单： 12345678910111213141516@Overridepublic void addFixedView(View view) &#123; addOffFlowView(view, false);&#125;@Overridepublic void addOffFlowView(View view, boolean head) &#123; showView(view); addHiddenView(view, head);&#125;protected void addHiddenView(View view, boolean head) &#123; int index = head ? 0 : -1; addView(view, index); mChildHelperWrapper.hide(view);&#125; showView 是调用了 mChildHelperWrapper 的 show 方法，最终会调用到 android.support.v7.widget.ChildHelper.Bucket#clear 里面。这个类具体可以看看这篇文章：https://blog.csdn.net/fyfcauc/article/details/54175072 ，它的内部逻辑就是将该 view 标记为可见。 我刚开始以为这个 showView 方法没啥作用，因为后面不是又重新隐藏了么，直到我将这行代码注掉之后，发现刚开始是正常的吗，但是上下滑动之后， FixView 的层次变化了，但是没找到原因。 查看 LayoutManagerHelper 的注释与 layer 有点关系，下篇再讲。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-设计思想]]></title>
    <url>%2F2019%2F09%2F16%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0001-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一般的情况下，我们使用 RecyclerView 都是用来实现同一种类型的列表。实现多种类型的列表的话，也有解决方案，就是通过 android.support.v7.widget.RecyclerView.Adapter#getItemViewType 来区分不同的 item 类型，来加载不同的布局。但是这种解决方法有局限性，想要做出一个类似淘宝首页的界面，基本上是不可能的。 我们先来看一下淘宝的首页长什么样，然后再思考该如何去做。 这是一个比较复杂的界面，对于一个复杂的问题，我们需要将问题简化，或者将这个问题分解为多个相对简单的小问题，所以我们将这个界面分隔为多个部分： 我们将首页分为了几个部分，每个部分的结构都比较简单，那么这个时候就遇到了第一个需要解决的问题： 我们知道 RecyclerView 之所以能够流畅滑动，是因为它的复用机制，那么我们将首页分为了好几个部分之后，它的复用粒度应该是什么样的呢？是每个黑框框起来的作为一个复用粒度，还是说将黑框里面的每一个布局作为一个复用粒度呢？显然复用粒度越小滑动起来就越流畅，但是我们需要实现如何才能复用更小的粒度。 我们知道，RecyclerView 的五虎上将中，LayoutManager 是用来排列item的布局的，我们现有的 LayoutManager 都无法满足要求，那么应该怎么办呢？只能自定义 LayoutManager 了。通过自定义 LayoutManager 我们可以解决 item 的排列问题，但是这里我们又遇到了第二个问题： 首页的 item 排列并不是固定的，就算我们实现了一个 LayoutManager 将 item 排列成图上的模样，但是如果 UI 改了 item 的位置，那岂不是又要重新写一个 LayoutManager？这也太惨了。这个问题要怎么解决呢？这个就不是纯技术的问题了。如果 UI 随心所欲的改 item 样式，如果我们怎么写都是徒劳的，这个时候就需要与 UI 达成一致，给 UI 一定的创作空间，但是需要在某个范围内。这个创作空间就在 com.alibaba.android.vlayout.layout 下，什么意思呢？这个包下面的各种 Helper 其实本质上都是一个 LayoutManager。当然如果你实在杠不过UI，你也可以自定义 LayoutHelper 来实现特殊效果。 就算我们定义了各种 LayoutManager，那又能怎么样呢？ 我们回想一下 RecyclerView 的工作原理，首先，RecyclerView 从 Adapter 获取 View，然后 LayoutManager 将 View 按实现排列，这样我们的列表就出来了。 上面，我们将首页分为了多段，那么我们可不可以使用多个 Aadapter 与 LayoutManager 呢？每一段分别对应不同的 Adapter 与 LayoutManager，如下图： 那么，对于屏幕上的每一个位置，我们可以这样做： 当然，我们需要先将 LayoutHelper 给设置进去，也就是说，我们需要先知道每个位置的 item 是什么类型的（或者知道每个类型有多少个 item）。LayoutHelper 搞定了，同理，Adapter 也是一样的，具体的实现在 com.alibaba.android.vlayout.DelegateAdapter 里面。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-梳理（一）]]></title>
    <url>%2F2019%2F09%2F12%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0011-%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[再回顾一下，Tangram 是如何将一个 Json 文件变成一个个的 View，显示到页面上的？首先，我们发起网络请求，从服务器请求下来 json 数据，使用解析器将 json 数据解析成 Card 对象，这一步是由 com.tmall.wireless.tangram.dataparser.concrete.PojoDataParser 类完成的。 获取到了 Card 之后，Card 里面还有 Cell 数据需要解析，这一步是由 com.tmall.wireless.tangram.dataparser.concrete.Card 类完成的。 这样我们就将 Json 数据转成了 Tangram 可以理解的东西。 然后，我们需要对 RecyclerView 与 Adapter 有比较深入的了解。 我们一般是这样写 Adapter 的： 12345678910111213141516171819202122232425262728293031323334class StackAdapter(private var count: Int) : RecyclerView.Adapter&lt;StackViewHolder&gt;() &#123; fun addItem() &#123; notifyItemInserted(++count) &#125; override fun getItemCount() = count override fun onBindViewHolder(holder: StackViewHolder, position: Int) &#123; Log.e("tetg", "onBindViewHolder + $position") holder.bind(position) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123; Log.e("tetg", "onCreateViewHolder") val root = LayoutInflater.from(parent.context) .inflate(R.layout.item_stack, parent, false) return StackViewHolder(root) &#125;&#125;class StackViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; private val text: TextView = itemView.findViewById(R.id.text) private val root: View = itemView.findViewById(R.id.root) fun bind(position: Int) &#123; text.text = "$position" val rnd = Random() val color = Color.argb(255, rnd.nextInt(256), rnd.nextInt(256), rnd.nextInt(256)) root.setBackgroundColor(color) &#125;&#125; 我们仔细看一下，想要做出不同样式的item，主要将 onBindViewHolder 与 onCreateViewHolder 的逻辑分别封装到 Cell 里面，这样就简单很多。如下： 1234public class MyCell &#123; fun onBindViewHolder(holder: StackViewHolder, position: Int) &#123;&#125; fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123;&#125;&#125; 然后，我们在将 Adapter 的数据源改成这样： 1private List&lt;MyCell&gt; datas; Adapter 的逻辑就可以这样写了： 12345678910111213141516171819class Adapter(private var count: Int) : RecyclerView.Adapter&lt;ViewHolder&gt;() &#123; fun addItem() &#123; notifyItemInserted(++count) &#125; override fun getItemCount() = count override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; datas.get(position).onBindViewHolder(holder, position) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123; // 这里需要根据 viewType 来创建不同的 ViewHolder // 一种很直接的解决方法就是用一个map，将 viewType 与 viewHolder 对应起来 return map.get(viewType).createViewHolder() &#125;&#125; 我们只需要处理好，viewHolder 就行了。当然 Tangram 里面的逻辑不可能这么简单，但是只要你理解了这个，再看 Tangram 应该会好理解很多。 有了数据，又有了所有的 viewHolder，就只差自定义的 layoutManager 了。 vlayout 做了自定义 layoutManager 的部分，一个类型的 Card 都对应一个 layoutManager，根据不同的 Card 获取不同的 layoutManager，然后将 Card 里面的 Cell 排列好，这样页面就显示出来了。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0008-事件总线]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0008-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[事件总线(TangramBus)用于组件和组件、组件和卡片、组件和页面之间的通信。它也是默认被注册到 Tangram 的 serviceManager 里，在组件和 TangramEngine 里都可以获取到。BusSupport 与 TimerSupport 一样，都是内置在 TangramEngine 里面了的，不需要我们手动注册： com.tmall.wireless.tangram.TangramBuilder.InnerBuilder#build 12tangramEngine.register(TimerSupport.class, new TimerSupport());tangramEngine.register(BusSupport.class, new BusSupport()); 我们在其他地方就可以获取注册进去的这个对象了。 1BusSupport busSupport = serviceManager.getService(BusSupport.class); 获取到 BusSupport 之后，我们就可以使用这个对象来发送一个事件对象了，就像 EventBus 一样。 com.tmall.wireless.tangram.eventbus.BusSupport#post(com.tmall.wireless.tangram.eventbus.Event) 123public boolean post(@NonNull Event event) &#123; return mDispatcher.enqueue(event);&#125; 在深入分析之前，我们来先看看 Event 相关的东西。 Event 这个类相当简单，可以当作一个 bean 来看待。我们可以直接创建这个对象，但是比较好的做法是复用该对象，为此 Tangram 提供了一个 EventPool 来帮助我们复用 Event 对象，如下： com.tmall.wireless.tangram.eventbus.BusSupport#obtainEvent(java.lang.String, java.lang.String, android.support.v4.util.ArrayMap&lt;java.lang.String,java.lang.String&gt;, com.tmall.wireless.tangram.eventbus.EventContext) 123456789public static Event obtainEvent(String type, String sourceId, ArrayMap&lt;String, String&gt; args, EventContext eventContext) &#123; Event event = EventPool.sharedInstance().acquire(); event.type = type; event.sourceId = sourceId; event.args = args; event.eventContext = eventContext; return event;&#125; 这里，我们使用了 BusSupport 封装的方法来获取到一个 Event 对象，并对其字段赋值。 事件对象创建好了之后，使用 post 方法发送出去，那么如果去接收这个对象呢？上面我们分析到，post 方法内部是调用了 Dispatcher.enqueue 方法： com.tmall.wireless.tangram.eventbus.Dispatcher#enqueue(com.tmall.wireless.tangram.eventbus.Event) 123456@Overridepublic boolean enqueue(@NonNull Event event) &#123; Message msg = obtainMessage(); msg.obj = event; return sendMessage(msg);&#125; 由于 Dispatcher 是继承了 Handler 的，所以这里是将 Event 封装成了一个 Message，然后发送出去了。那么哪里可以接收到这个消息呢，看 Dispatcher 的构造方法： com.tmall.wireless.tangram.eventbus.Dispatcher#Dispatcher 1234public Dispatcher(IDispatcherDelegate dispatcherDelegate) &#123; super(Looper.getMainLooper()); this.mDispatcherDelegate = dispatcherDelegate;&#125; 我们看到 Looper 是主线程的 Looper 对象，所以发送出去的消息在主线程可以接收到。又因为 Hander 在发送 Message 的时候，会将接收者（target）设置为自己，所以 Dispatcher 想要处理接收到的消息的话，肯定需要重写 handleMessage 方法。 com.tmall.wireless.tangram.eventbus.Dispatcher#handleMessage 12345678@Overridepublic void handleMessage(Message msg) &#123; super.handleMessage(msg); if (mDispatcherDelegate != null) &#123; mDispatcherDelegate.dispatch((Event) msg.obj); &#125; EventPool.sharedInstance().release((Event) msg.obj);&#125; 这里做了两件事： 将接收到的消息分发出去 将事件对象回收 我们继续跟踪下去，发现 BusSupport 实现了 IDispatcherDelegate 接口： com.tmall.wireless.tangram.eventbus.BusSupport#dispatch 12345678910111213141516@Overridepublic synchronized void dispatch(@NonNull Event event) &#123; String type = event.type; List&lt;EventHandlerWrapper&gt; eventHandlers = subscribers.get(type); if (eventHandlers != null) &#123; EventHandlerWrapper handler = null; for (int i = 0, size = eventHandlers.size(); i &lt; size; i++) &#123; handler = eventHandlers.get(i); if (!TextUtils.isEmpty(handler.producer) &amp;&amp; handler.producer.equals(event.sourceId)) &#123; handler.handleEvent(event); &#125; else if (TextUtils.isEmpty(handler.producer)) &#123; handler.handleEvent(event); &#125; &#125; &#125;&#125; 这里出现了一个新类：EventHandlerWrapper，看类名就知道它是来处理事件的。 有个地方需要注意，如果我们在创建 EventHandlerWrapper 对象的时候指定了 producer，那么需要在创建 Event 的时候，也指定相应的值，否则匹配不上哦。 首先，我们获取到事件的类型，然后根据这个类型，获取到该类型对应的所有观察者，然后一个一个的将事件回调过去，很是很简单的。 了解了 BusSupport 的工作流程，我们就知道如果我们想要接收一个事件，需要定义一个事件类型，然后向 BusSupport 注册该类型的观察者： 12345678910111213141516171819202122232425262728293031private EventHandlerWrapper mSetMeta = BusSupport.wrapEventHandler("setMeta", null, this, "parseMeta");@Overrideprotected void onAdded() &#123; super.onAdded(); BusSupport busSupport = serviceManager.getService(BusSupport.class); if (busSupport != null) &#123; busSupport.register(mSetMeta); &#125;&#125;@Overrideprotected void onRemoved() &#123; super.onRemoved(); BusSupport busSupport = serviceManager.getService(BusSupport.class); if (busSupport != null) &#123; busSupport.unregister(mSetMeta); &#125;&#125;@Keeppublic void parseMeta(Event event) &#123; try &#123; if (mTotalPageCount != Integer.MAX_VALUE) &#123; storeCache(); &#125; mIndex = Integer.parseInt(event.args.get(KEY_INDEX)); mTotalPageCount = Integer.parseInt(event.args.get(KEY_PAGE_COUNT)); &#125; catch (Exception e) &#123; &#125;&#125; 由于 EventHandlerWrapper 内部是使用了反射来获取回调的方法，所以这里需要写一个 parseMeta 方法，而且为了防止代码压缩的时候被删除，需要 keep 一下。 好长时间不画图了，画个图吧，感觉这个图没有说清楚，觉得没有帮助的话当作没看见吧：]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010-与 RxJava 配合使用]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0010-%E4%B8%8E-RxJava-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[想要使用 RxJava，需要先开启：1engine.setSupportRx(true);然后还要提供依赖包，具体可以参考官方文档.响应式流中数据结构的定义在响应式流中，传递的都是数据单个对象，而传统的命令式接口里，一个操作往往有多个类型的参数，JAVA 里没有像元组那样的结构用来组合一系列对象，用 Object[] 类型的对象也难以理解维护，因此，针对这种情况，Tangram 将相关接口的参数封装成一系列 TangramOp1、TangramOp2、TangramOp3 对象，分别包含一个、两个、三个参数，用来在响应式流中传递信息，也方便原有接口的对接。具体的定义在包 com.tmall.wireless.tangram.op 下，包含了插入、更新、异步加载等接口的操作定义。下文中碰到的接口里包含的 ClickExposureCellOp、LoadGroupOp 等都是在这个背景下定义的结构。 这一段还是应该好好阅读几遍的，在我刚开始接触 Rx 的时候，就不太明白为啥会设计出这样的接口： io.reactivex.functions 在 functions 包下，还有 Function3，Function4 这样的东西。有了上面这段话，初学者应该就会比较好理解一些。 关于 Rx 的配合使用，官方文档也说的差不多了，再深入就是 Rx 相关的东西，这里就不说了。这里只说一下 demo 的 RxTangramActivity 显示的效果会是一个一个卡片加载出来的。想要做出依次加载的效果，有哪些思路呢？ 每次add一个，控制好add时机 使用动画 使用动画的话，会有一个问题，就是上下滑出滑入的时候都会执行动画，不好搞。看看 Tangram 是如何做的吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243Disposable dsp8 = Observable.create(new ObservableOnSubscribe&lt;JSONArray&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;JSONArray&gt; emitter) throws Exception &#123; String json = new String(getAssertsFile(getApplicationContext(), "data.json")); JSONArray data = null; try &#123; data = new JSONArray(json); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; emitter.onNext(data); emitter.onComplete(); &#125;&#125;).flatMap(new Function&lt;JSONArray, ObservableSource&lt;JSONObject&gt;&gt;() &#123; @Override public ObservableSource&lt;JSONObject&gt; apply(JSONArray jsonArray) throws Exception &#123; return JSONArrayObservable.fromJsonArray(jsonArray); &#125;&#125;).map(new Function&lt;JSONObject, ParseSingleGroupOp&gt;() &#123; @Override public ParseSingleGroupOp apply(JSONObject jsonObject) throws Exception &#123; return new ParseSingleGroupOp(jsonObject, engine); &#125;&#125;).compose(engine.getSingleGroupTransformer()).filter(new Predicate&lt;Card&gt;() &#123; @Override public boolean test(Card card) throws Exception &#123; return card.isValid(); &#125;&#125;).map(new Function&lt;Card, AppendGroupOp&gt;() &#123; @Override public AppendGroupOp apply(Card card) throws Exception &#123; Thread.sleep(300); return new AppendGroupOp(card); &#125;&#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(engine.asAppendGroupConsumer(), new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; throwable.printStackTrace(); &#125;&#125;); 里面的逻辑还是挺清晰的： 先从 json 模拟数据文件里面读取出数据，将数据转成 JSONArray 将 JsonArray 转成 Observerable&lt;JSONObject&gt;，具体做法就是将 JSONArray 拆成一个一个的 JSONObject 数组，然后发送出去 com.alibaba.android.rx.JSONArrayObservable.FromJsonArrayDisposable#run 12345678910111213141516void run() &#123; JSONArray a = array; int n = a.length(); for (int i = 0; i &lt; n &amp;&amp; !isDisposed(); i++) &#123; T value = (T) a.opt(i); if (value == null) &#123; actual.onError(new NullPointerException("The " + i + "th element is null")); return; &#125; actual.onNext(value); &#125; if (!isDisposed()) &#123; actual.onComplete(); &#125;&#125; 下游接收到 JSONObject 后解析成 Card 校验 Card 是否有效 将 Card 封装成一个 AppendGroupOp 对象 线程切换 下游拿到 AppendGroupOp 对象，执行添加 Card 操作 这样就完成了，那么现在，我们应该就知道了，将 json 数据解析成了 Card 需要耗时一定的时间，所以就有了一个间隔效果，而且调用 notifyItemRangeInserted 还会有有一个自带的动画效果。要是不相信的话，可以自己去写个 demo 跑一下。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-使用布局]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0009-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[对于布局来说，内置布局一般满足大部分场景，如果有特殊需求，可自定义实现。需要实现Card和LayoutHelper。Card是自定义布局的 model，LayoutHelper是自定义布局的实现，基于vlayout框架。 这部分的东西也在 vlayout 里面，所以不分析了，可以先看看官方文档介绍。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0008-度量一个算法的效率]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0008-%E5%BA%A6%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[如何去测量一个算法的效率，还是值得思考一下的。比如，我们用算法实现了一个功能，那么想要测量这个算法的运行速度，通常都会直接运行一下，看看它消耗的时间，然后得出一个主观的判断，但是这个测量的结果有用吗？显然没有，因为有很多外在的因素影响了我们测量的结果： 每个计算机运行的速度不一样 测试数据的大小对算法也有影响，有些算法在小型测试数据集合表现很好，但是数据集合大了之后就会变得效率很低 另外，还有一个问题，那就是就算我们找了某些方法，可以避免这些因素，那么还有一个问题就是，我们需要写出我们的程序，才能进行测量，这其实也是一个很严重的问题，因为如果每个算法都需要实现了才能测量，那无疑要消耗很多精力。 那么有没有不需要写出算法的程序，就能测量出算法的效率的方法呢？肯定是有的，就是我们所说的大O阶方法。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0012-线性表]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0012-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是线性表呢？可以理解为用一根线可以将所有数据串起来的数据集合。 比如：星座列表。 巨蟹座 -&gt; 白羊座 -&gt; 双子座 -&gt; 宝瓶座 -&gt; 室女座 -&gt; 狮子座 -&gt; 金牛座 -&gt; 双鱼座 -&gt; 摩羯座 -&gt; 天蝎座 -&gt; 天秤座 -&gt; 人马座]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010最坏情况与平均情况]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0010-%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[最坏情况，指的是运行时间最长的情况。 举个例子，我们要在抽屉里面找一个东西，最好的情况是将抽屉打开，一眼就看到了，最坏的情况是我们要将抽屉里的东西一个一个翻一遍才能找到。 平均情况，是比较有意义的情况，就是取一个平均值。 一般情况下，我们说的时间复杂度指的是最坏时间复杂度。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0013-线性表的抽象数据类型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0013-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这个了解了面向对象，还是非常简单的。1234567891011121314151617181920212223class Node&lt;T&gt; &#123; // 判断表是否为空 public boolean isEmpty()&#123;&#125; // 清空线性表 public void clear()&#123;&#125; // 获取指定位置的元素 public T getNode(int index)&#123;&#125; // 查找元素 public void findNode(T t)&#123;&#125; // 在指定位置添加一个元素 public void add(T t, int index)&#123;&#125; // 删除指定位置的元素，并返回它的值 public T delete(int index)&#123;&#125; // 大小 public int size()&#123;&#125;&#125; 对于不同的需求，不同的线性表会有不同的方法，上面所写的，基本是最通用的一些方法。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0014-线性表的顺序储存]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0014-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[我们说过，顺序储存，就是一个一个的挨着摆好，在 Java 里面就是对应的数组。如下图：下面，我们就用数组来实现一个线性表。首先，我们定义一个数组：123456public class MyArray&lt;T&gt; &#123; // 因为无法创建泛型数组，所以我们使用 Object 来接受 private Object[] array = new Object[5]; &#125; 然后我们来实现，他的插入方法： 123456789101112131415// 在指定位置添加一个元素public void add(T t, int index) &#123; checkIndex(index); if (isFull()) &#123; return; &#125; for (int i = size() - 1; i &gt;= index; i--) &#123; array[i + 1] = array[i]; &#125; array[index] = t;&#125; 这里面有两个新方法，一个 checkIndex，是用来判断 index 是否是有效的。一个是 size 是用来储存当前数组已被占用的大小，可以用一个 int 来储存，只要随时更新它的大小就好了。 看其他的逻辑，还是蛮简单的，当在一个指定的位置插入数据的时候，其他位置的数据都要向后移动一格。可以想象一下我们排队，有一个人插队的时候，后面的人就不得不往后退一步。如图： 再看一下删除方法： 12345678910111213141516171819// 删除指定位置的元素，并返回它的值@SuppressWarnings("unchecked")public T delete(int index) &#123; checkIndex(index); if (isEmpty()) &#123; return null; &#125; T temp = (T) array[index]; for (int i = index + 1; i &lt; size(); i++) &#123; array[i - 1] = array[i]; &#125; array[size() - 1] = null; return temp;&#125; 其实与插入的逻辑一样，只不过插入是往后移动一格，删除是往前移动一格。如下图： 实现了插入与删除之后，我们再来思考一下，这两个方法的时间复杂度。 根据前面学过的知识，我们知道，他的平均复杂时间度为 $O(\frac{n}2)$，最坏时间复杂度为 $O(n)$。 也就是说，我们每次的插入与删除操作，都可能需要面临移动所有元素的风险。这是顺序储存结构的不足。但是他也有优点，就是获取元素，非常快，只要知道元素的位置，可以立马找到，时间复杂度为 $O(1)$。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0016-单链表的读取、插入、删除]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0016-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[在开始一系列的插入删除方法之前，需要讲解一个东西，对代码的阅读非常有好处：12node1.next = node.next;node.next = node1;我们先不讨论这两行代码有什么意思。光从代码上看，发现 node.next 既可以在 = 的左边，也可以在 = 的右边。在左边与在右边有着不同的意义。 在 = 左边表示 node.next 是当作一个容器，在 = 右边表示需要使用 node.next 容器里面的值。 在链式存储结构中，读取效率为比较低，不像在顺序储存结构中，可以直接拿出来。原因就是因为我们需要知道前一个元素，才能获取到后一个元素的位置。所以我们想要获取一个元素，需要从头指针开始寻找。 读取看看读取的代码： 123456789101112131415161718192021public T getNode(int index) &#123; // 从第一个节点开始遍历 Node&lt;T&gt; temp = head.next; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; // temp 不能为 null，为 null 表示 index 超过了链表的大小 // 理论上来说，p 是不会大于 index 的 if (p &gt; index || temp == null) &#123; return null; &#125; else &#123; return temp.t; &#125;&#125; 思路解说： 拿到第一个节点，因为我们不能直接改头节点，所以需要声明一个临时变量 将 next 节点赋值给自己，这样不断的寻找下一个节点 直到到达指定的位置 时间复杂度为 $O(n)$。所以链表在获取元素的时候，效率很低。虽然它在获取元素时效率很低，但是对于插入与删除元素，效率很高哦。 插入我们先来看两张图： 可以看出，插入节点的时候，不用管其他节点，只需要插入位置的前后两个节点即可。核心代码就是： 12newNode.next = p.next; // 让新节点指向 p 后面的节点p.next = newNode; // 让 p 节点指向新节点 还是非常简单的，但是千万不要搞反了，如果我们先执行了 p.next = newNode，那么 p 后面的那个节点，我们就找不到了，相当于链条断了。插入的过程，相当于将一个链条分成了两段，我们需要这两段的头指针（p 与 p.next），执行 p.next = newNode 就相当于丢弃了后面链条的头指针。 看看完整代码： 123456789101112131415161718192021public void insertNode(T t, int index) &#123; // 从头节点开始遍历 Node&lt;T&gt; temp = head; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; if (p &gt; index || temp == null) &#123; return; &#125; Node&lt;T&gt; newNode = new Node&lt;&gt;(); newNode.t = t; newNode.next = temp.next; temp.next = newNode;&#125; 可以看到，我们还是需要先找到插入的位置的节点，才能开始进行插入。那么问题就来了，它的效率怎么就高了，不也是 $O(n)$ 么？ 其实是这样的，如果我们不知道插入位置的节点指针，那么效率是没有什么优势的。但是如果我们知道了指针的值，则效率就会高很多，比如在第 i 个位置，插入 10 个、100个元素，这样的情况下，我们就不用每次都重新找节点的指针了，而是第一次找到之后，后面只需要更新一下指针的值就好了。 删除删除过程也很简单，先看图： 思路如下： 寻找要删除的节点 创建一个临时变量Q，指向要删除节点P的下一个节点 然后将要删除节点的前一个节点R的next赋值为Q 将 P 的数据清空 代码如下： 12345678910111213141516171819202122public void deleteNode(int index) &#123; // 从头节点开始遍历 Node&lt;T&gt; temp = head; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; // 这里还需要额外判断一下 temp.next // 因为 temp.next 是要删除的节点 // 与插入不一样，插入时，temp.next为null不影响 // 删除、插入有多种写法，思路是一样的，只是细节不一样 if (p &gt; index || temp == null || temp.next == null) &#123; return; &#125; Node&lt;T&gt; delete = temp.next; temp.next = delete.next;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-大O阶方法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0009-%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在说这个测量方法之前，我们还介绍一些大家最喜欢的数学知识。函数的渐近增长比如，我们有两个函数：$$f(n) = 4*n + 8$$$$g(n) = n*n$$当 n&lt;=5 的时候，f(n) 是比 g(n) 大的，当 n &gt; 5 后，f(n) 就比 g(n) 小了。对于这两个函数，我们称 g(n) 的渐近增长要快于 f(n) 的渐近增长。 其实，可以画一个图，显然当 n 越大的时候，g(n) - f(n) 的值也是越来越大。 好的，了解了这个，我们就开始介绍大O阶方法。 常数阶看下面这个算法： 123int sum=0, n=100; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */System.out.println(sum); /* 执行一次 */ 我们用一个函数$T(N) = O(f(n))$ 来表示这个算法的时间复杂度（即算法语句的执行次数与问题规模大小之间的关系）。 可以得出$T(N) = O(3)$，简记为 $O(3)$，但是通常我们不会这么表示，而是写作 $O(1)$ ，这是为什么呢？ 假设，我们的算法是这样的： 1234int sum=0, n=100; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */System.out.println(sum); /* 执行一次 */ 那么，时间复杂度为 $O(4)$ ，但是实际上，这个算法与上面的算法都有一个特点，就是他们的执行次数都是固定的，与问题规模大小没有关系，是一个执行时间恒定的算法。 对于这样的算法，不管常熟是多大，我们都记为 $O(1)$。 所以我们总结出第一条攻略： 用常数1取代运行时间中所有加法常数 线性阶看下面这个算法： 123for(int i=0; i&lt;n; i++) &#123; /* 时间复杂度为 O(1)的程序步骤序列 */&#125; 显然，时间复杂度为 $O(n)$ 。 平方阶看下面这个算法： 1234567int i, j /* 执行一次 */for (i=1; i&lt;=n; i++) &#123; /* 执行N次 */ for (j=1; j&lt;=n; j++) &#123; /* 执行N次 */ /* 时间复杂度为 O(1)的程序步骤序列 */ &#125;&#125;System.out.println(sum); /* 执行一次 */ 可以看到，循环部分占了 $N^2$ 次，时间复杂度为 $O(n^2+2)$，但是我们不会记为 $O(n^2+2)$，而是写作 $O(n^2)$。 这是因为，我们最需要关心的是循环里面的部分，其他的可以忽略，而且，随着 N 的增大，$n^2+2$ 与 $n^2$ 的差别可以忽略不记。 所以我们总结出第二条攻略： 只保留函数中的最高阶项 比如：$O(n^2 +n)$，我们也写作 $O(n^2)$，显然 n 越大，他们的区别越小。 还有一个比较特殊的情况，如下： 123456int i, j /* 执行一次 */for (i=0; i&lt;n; i++) &#123; /* 执行N次 */ for (j=i; j&lt;n; j++) &#123; /* 执行N-i次 */ /* 时间复杂度为 O(1)的程序步骤序列 */ &#125;&#125; 那么，它的时间复杂度为多少呢？看上去这个不好下手，但是却可以这样算： 当 i = 0，内层循环 n 次 当 i = 1，内层循环 n - 1 次 ….. 所以内层循环一共循环了 n + (n-1) + … + 1 次，为 $\frac{n(n+1)}2$ 次。 记为 $O(\frac{n^2}2)$，与省略低阶项同样的道理，我们也可以省略这个相乘的常数，记为 $O(n^2)$。 对数阶下面的代码： 12345int count = 1;while (count &lt; n) &#123; count *= 2; /* 时间复杂度为 O(1)的程序步骤序列 */&#125; 假设循环执行了 x 次，则 $2^x = n$，所以算法时间复杂度为 $O(log_2n)$，通常，我们省略底数2，记为 $O(logn)$。 最后，总结一下： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数中，只保留最高阶项 如果最高阶存在且不是1，则去除与这个项相乘的常数 其实，大O阶考察的还是我们的数学功底。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-空间复杂度]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0011-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[如果我们想要判某年是不是闰年，可以有两种做法： 写一个算法，输入一个年份，就可以得出结果 建一个数组，数组的大小比现实年份多一点，把所有的年份按照下标的数字对应，如果是闰年就将值赋值为1，不是就赋值为0 这两种做法，一个空间复杂度基本是 O(1)，另一个空间复杂度基本是 o(2022)，假设给数组的大小为 2022。 空间复杂度指的是：一个程序在机器上执行时，除了储存程序本身的指令，变量等，还需要一个额外的内存来帮助实现这个算法，这些消耗的额外内存就是空间复杂度。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-算法设计的要求]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0007-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[这个不要跟算法的特性搞混了，这里说的是一个好的算法有哪些要求。上一篇说的是算法的基本特性，即基本要求，如果连这个都不满足，那就更不用说好坏了。 正确性：能够得出正确答案。 可读性：可以方便阅读，供人交流，写的只有自己能看懂，那就只能与计算机交流了。 健壮性：对于一些不合法的输入，可以做合适的处理，而不是直接抛出异常。 时间效率高与储存量低：耗时肯定是越少越好，同时对空间的要求也越低越好。就是传说中的，用最少的钱把事办了，而且还要办的漂漂亮亮的，越快越好。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-算法的特性]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0006-%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[算法的定义我就不写了，写了也记不住，就理解为解决某个问题的具体步骤，可以翻译为计算机语言。 拿破仑说过，不想当厨子的司机不是好裁缝。那么一个算法应该具备什么样的特性，才算是一个合格的算法呢？ 输入输出：可以不需要输入（生成随机数之类的），但是一定要有输出，不然写这个算法搞毛。 有穷性：可以在一个合理的时间内运算完成。写一个需要耗时几十年的算法，那就没什么意思了。 确定性：同样的输入会得出同样的输出。 可行性：这个有点不好理解，有些算法是无法转换为程序的，由于现在科技与人类认知的局限性。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0017-单链表的整表创建与整表删除]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0017-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[整表创建其实可以理解为一下子插入n个节点就好了。头插法思路： 创建一个新节点 将新节点插入到头节点后面 不断的循环这个过程n次 看看代码吧：123456789public void createList(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Node&lt;T&gt; newNode = createNewNode(); newNode.next = head.next; head.next = newNode; &#125; &#125; 非常 easy 啊。这种创建 List 的方法叫做头插法，如下图： 尾插法既然有头插法，肯定就有尾插法，嘿嘿嘿。了解了头插法，尾插法也差不多，我们理理思路： 创建一个新节点 将新节点插入到头节点后面 不断的循环这个过程n次 看起来很美好，但是有个问题，我们需要一个指针指向尾部，不然每次都要从头找起，就太沙雕了。 看看代码： 12345678910public void createList2(int n) &#123; Node&lt;T&gt; tail = head; for (int i = 0; i &lt; n; i++) &#123; Node&lt;T&gt; newNode = createNewNode(); newNode.next = tail.next; tail.next = newNode; tail = newNode; &#125;&#125; 这个就是尾插法了，还是非常简单的，就多了一个变量而已。如下图： 删除删除一个 list，思路与创建一个表反过来就好了。 因为我们持有了头节点，只要不断的删除头节点后面的那个节点就好了。 我们看看代码吧： 123456789101112public void clearAll() &#123; Node&lt;T&gt; delete = head.next; Node&lt;T&gt; next; while (delete != null) &#123; next = delete.next; // 这个假设节点需要释放内存 free(delete); delete = next; &#125;&#125; 如果没有其他的需要，可以直接 head.next = null 就好了。嗯，应该可以的，反正是可以自动回收内存（没有别的地方引用Node）。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005为啥需要算法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0005-%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写一个从1加到100的程序。 我们是这样写的： 123for(int i=1; i&lt;=100; i++) &#123; sum += i&#125; 大佬高斯是这样写的： 12int sum = 0, n= 100sum = (1 + n) * n / 2 哪个算的快，不用我多说了吧！！！]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-数据结构与算法的关系]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0004-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[如果一部电影光有特效没有剧情，看完了之后，让你说一下这部电影，你会发现不知道怎么说起，感觉自己都知道，但是却没什么好说的。 学数据结构就是这样，如果只讲数据结构，那么学完了就会发现没啥感觉，你不知道这个东西可以做什么，没有内涵。 PS：现在供人消遣的短视频，娱乐节目什么的越来越多，我们花在看视频的时间上越来越多，这会对我们自身有个非常不好的影响，就是会变的越来越不想自己思考，而是借着视频放空脑子，不去思考什么。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-抽象数据类型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0003-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[因为我们是用的 Java，所以这个就不介绍了哈，面向对象牛逼！！！]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中点圆算法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当我们在手机屏幕上绘制一个圆的时候，有没有想过这个圆是怎么绘制出来的呢？由于屏幕的像素是一粒一粒的，所以不像我们在一张纸上，可以利用 sin/cos 函数计算出来。看一张图：将手机屏幕放大了看，你就会看到上图所示的情景，那么这些像素点的位置是如何计算出来的呢？其实就是使用了中点圆算法。在计算机图形学中，中点圆算法是一种用于确定绘制一个圆所需的像素点的算法。 算法概念该算法的目标是找到一个通过使用像素网格的使得每个像素点尽可能接近 $x^2 + y^2 = R^2$ 的路径。 准备工作由于圆具有对称性，所以我们只要考虑1/8个圆即可，我们选择y轴正方向到延其顺时针旋转45°的这个区间为例。就是上图中的 2nd octant 区域。 我们先假设要画的圆的圆心在坐标原点，最后再平移到其应该存在的位置。 设要画的圆的圆心在原点(0，0)，半径为R，起点在(0，R)处，终点在 $(\frac{R}{\sqrt2}, \frac{R}{\sqrt2})$ 处，顺时针生成八分之一圆，利用对称性画出全部的圆。 为了应用中点画圆法，我们还需要定义一个检测函数：$$F(x, y) = x^2 + y^2 - R^2$$任何点 (x，y) 的相对位置可由圆函数的符号来检测： &lt;0 点(x，y)位于数学圆内 =0 点(x，y)位于数学圆上 &gt;0 点(x，y)位于数学圆外 算法演示如下图所示，图中有两条圆弧A和B，假定当前取点为$P_i(x_i, y_i)$，如果顺时针生成圆，那么下一点只能取正右方的点 $E(x_i, y_i)$ 或者右下方的 $SE(x_i+1, y_i-1)$。 假设M是E和SE的中点，即，则： 对圆A来说，F(M)&lt;0，M在圆A内，这说明点E距离圆更近，应取点E作为下一象素点； 对圆B来说，当F(M)&gt;0，M在圆B外，表明SE点离圆更近，应取SE点为下一象素点； 而当F(M)=0时，在E点与SE点之中随便取一个即可，我们约定取SE点。 算法推导我们将中点M代入检测函数可以得到一个值，用 $d_i$表示，它就是该点的决策变量。 然后我们再用它来推导出下一个中点决策变量 $d_{i+1}$ 。 $$ d_i = F(x_i+1， y_i-\frac{1}{2}) = (x_i+1)^2 + (y_i - \frac{1}{2})^2 - R^2 $$ 下面分两种情况来讨论在迭代计算中决策变量 $d_{i+1}$ 的推导。 看上面的算法演示图： 如果 $d_i &lt; 0$，则选择E点，接着下一个中点就是 $M_E(x_i+2,y_i-\frac{1}{2})$，这时新的决策变量为： $$ d_{i+1} = F(x_i+2， y_i-\frac{1}{2}) = (x_i+2)^2 + (y_i - \frac{1}{2})^2 - R^2 $$ 用 $d_{i+1}$ - $d_i$，可以得到： $$ d_{i+1} = d_i + 2x_i + 3$$ 如果 $d_i &gt; 0$ ，则选择 SE 点，接着下一个中点就是$M_{SE}(x_i+2,y_i-\frac{3}{2})$，这时新的决策变量为： $$d_{i+1} = F(x_i+2, y_i-\frac{3}{2}) = (x_i+2)^2 + (y_i-\frac{3}{2})^2 - R^2$$ 用 $d_{i+1}$ - $d_i$，可以得到： $$d_{i+1} = d_i + 2(x_i-y_i) + 5$$ 我们利用递推迭代计算这八分之一圆弧上的每个点，每次迭代需要两步处理： （1）用前一次迭代算出的决策变量的正负来决定本次选择的点 （2）对本次选择的点，递推计算得出新的决策变量的值 接下来只要计算出初始决策变量$d_0$的值即可，对于初始坐标$(0,R)$，显然顺时针生成的下一个决策点坐标是$(1, R-\frac{1}{2})$，此时决策变量 $d_0$为：$d_0 = (1)^2 + (R-\frac{1}{2})^2 - R^2 = \frac{5}{4} - R$ 。显然，如果半径大于 $\frac{5}{4}$，则我们应该取 E 点，否则取 SE 点。 就这样不断的递推下去，就可以得到八分之一圆弧的所有点。 算法表示输入：圆半径$R$、圆心$(x_0，y_0)$， 确定初值：$x=0$，$y=R$，$d=\frac{5}{4}$， 1234567891011while(x &lt;= y)&#123; if(d &gt;= 0)&#123; x = x + 1; y = y - 1; d = d + 2 * (x - y) + 5; &#125; else &#123; x = x + 1; d = d + 2 * x + 3; &#125; println("(" + x + ", " + y + ")");&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005-并发编程模型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0005-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[嗯，说实话。这个我没看太懂，原文地址如下： http://tutorials.jenkov.com/java-concurrency/concurrency-models.html 我只说我看懂的部分吧。并发模型与分布式系统中使用的体系结构很相似。并发系统中是线程之间相互通信，分布式系统中是进程之间相互通信（进程有可能在不同的机器中）。线程与进程又有很多相似的特性，也就是为什么很多并发模型通常类似于各种分布式系统架构。 并行工作者 在这个模型中，每个 Worker 线程都负责一个完整的工作。 如果我们拿汽车工厂举例，那么就是每台车都交给一个工人来生产，工人们都从 0 开始，攒一个完整的车出来。 这个模型很容易理解，代码也易于阅读，提高并发度只需要增加线程就好了。 并行工作者模型虽然看起来简单，却隐藏着一些缺点。 如果，Worker 需要访问共享数据的话，这个模型就会变得复杂： Worker 之间需要避免竞态，死锁等问题。而且，在访问共享数据的时候，如果这个时候竞争很激烈的话，会导致出现线程串行化的现象。 流水线模式看下模型图： 这个就类似于工厂里面的那种流水线了，每个 Worker 负责不同的部分，当前面的 Worker 完成了自己的任务之后就会将结果交给下一个 Worker。这样的话，就不会与别的 Worker 共享数据。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-如何创建并运行 java 线程]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0006-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%20java%20%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java 中线程也是一个类（Thread），继承至 Object 类。我们创建一个线程实例，需要继承至 Thread 类。1Tread thread = new Thread();执行这个线程，需要调用 thread 的 start 方法。1thread.start();在上面的例子中，我们并没有为线程编写运行代码，因此调用该方法后线程就终止了。 想要给线程编写执行代码，有两种方案： 创建Thread子类的一个实例并重写run方法 创建 Thread 实例的时候，传入一个 Runnable 对象 创建 Thread 子类1234567Thread thread = new Thread() &#123; @Override public void run() &#123; System.out.println("MyThread running"); &#125;&#125;;thread.start(); 一旦thread线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回，就好像run方法是在另外一个cpu上执行一样。 当run方法执行后，将会打印出字符串MyThread running。 实现 Runnable 接口123456789public class MyRunnable implements Runnable &#123; public void run()&#123; System.out.println("MyRunnable running"); &#125;&#125;// 为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。Thread thread = new Thread(new MyRunnable());thread.start(); 当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。 那么，这两种方案，哪种好呢？ 对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。我自己倾向于 实现 Runnable 接口 的方式，因为它将任务从线程里面分离出来了。 常见错误创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法，如下所示： 12Thread newThread = new Thread(MyRunnable());newThread.run(); //should be start(); 起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。 线程起名当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。例子如下： 1234MyRunnable runnable = new MyRunnable();Thread thread = new Thread(runnable, "New Thread");thread.start();System.out.println(thread.getName()); 我们可以使用如下方法来获取当前线程的名字： 1String threadName = Thread.currentThread().getName(); 例子这里是一个小小的例子。首先输出执行main()方法线程名字。这个线程是JVM分配的。然后开启10个线程，命名为1~10。每个线程输出自己的名字后就退出。 123456789101112public class ThreadExample &#123; public static void main(String[] args)&#123; System.out.println(Thread.currentThread().getName()); for(int i=0; i&lt;10; i++)&#123; new Thread("" + i)&#123; public void run()&#123; System.out.println("Thread: " + getName() + "running"); &#125; &#125;.start(); &#125; &#125;&#125; 需要注意的是，尽管启动线程的顺序是有序的，但是执行的顺序并非是有序的。也就是说，1号线程并不一定是第一个将自己名字输出到控制台的线程。这是因为线程是并行执行而非顺序的。Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-竟态条件与临界区]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0007-%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[在一个程序中运行多个线程本身不会有问题，有问题的是这些线程同时访问了同样的资源。比如：同一个变量，同一个数据库。当然如果这些线程都只是读取，那不会有问题，但是如果有一个或者多个写线程就会有问题。多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125; 想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 123从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存 假设线程交替执行： 12345678this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。 然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。 然后各自加了2和3，并分别写回内存。 最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 竟态条件与临界区当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。 导致竞态条件发生的代码区称作临界区。 上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-数据结构的起源]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0001-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B5%B7%E6%BA%90%2F</url>
    <content type="text"><![CDATA[学习任何一种知识，了解一下起源总是会感觉更加有兴趣一些（心里安慰）。 早期的计算机一般都是用来做数值计算的，但是数值计算只能解决一部分问题，还有一部分问题是无法化解为数值计算问题。有时候某些问题涉及到的数据，是无法用纯数据来表示的。比如我们想要将一份表格数据输入到程序中，表格一般会有很多列，所有列的同一行数据都是属于某一项数据的。这个时候，只输入纯数据值肯定是不行的，这样数据值之间的关系就丢失了。 还有的问题需要对数据做一些特殊处理，比如需要对数据一个个按顺序处理，我们就需要一种结构（表，树，图等等），将这些数据存起来以便取用。 然后，1968年，一位大佬就写了一本书，系统的阐述了数据的逻辑结构和储存结构及其操作，正式开宗立派。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0000-前言]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0000-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[因为会做成一个系列，所以每篇的东西会比较少，嗯，大概吧。 尽量不copy书里面的文字，用自己的话来说一遍。 文章中的例子是我自己写的，只是经过了简单的测试，并不保证一定完全正确。可以作为参考，但是还是需要自己想想再写。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO 阻塞]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FIO%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[昨天在整理自己的博客的时候，想到的一个问题：进程在从磁盘中读取内容的时候，CPU 在干什么？？？之所以会这样问，是因为，CPU的速度比磁盘要快很多，具体有多块，看这篇文章。 磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。 这是从文中截取的一段，可以体会一下。 那么我的问题的本质是，在这段等带的时间中，CPU 是去搞别的是事情了（执行别的线程），还是空等呢？？？IO 阻塞与线程遇到锁产生的阻塞是一样的吗？ 经过查询资料，Linux系统下，CPU与磁盘交互时大致发生了如下事情： 进程调用库函数向内核发起读文件请求（切换到内核态）； 在 Page Cache（它位于内存和文件之间缓冲区，文件IO操作实际上只和page cache交互，不直接和内存交互。） 中查询数据是否存在。 如果页缓存命中，那么直接返回文件内容；如果页缓存缺失，那么产生一个页缺失异常，需要从磁盘读取数据。 CPU向磁盘发送数据读取指令。 然后，发送完指令后，CPU会转去执行其它任务（为了提高效率），磁盘则会将逻辑块号转换成对应的盘片、磁道、扇区组成的三元组，从而定位到了数据所在的扇区。之后磁盘会采用DMA（直接存储器访问技术，其不需要CPU干预）传送数据到CPU指定的主存地址。 最后，磁盘传送完毕后，会直接发送一个中断信号给CPU芯片的一个外部引脚，把CPU“召唤”回来重新执行先前未完成的任务。 上面的过程不一定准确，但是比较符合我的期望了，准备恶补一下计算机的相关原理。 所以，在 IO 阻塞的时间之内，CPU 也没有闲着（反过来想一下，如果CPU无法干别的事情的话，那么只要IO线程大于CPU线程，那么就卡死了）。 线程状态其实这里面也有提到，我之前没有注意。 线程的状态分为： 可运行（就绪）：线程被创建之后，调用Start（）函数就到了这个状态。 运行：Start（）函数之后，CPU切换到了这个线程开始执行里面的Run方法就称为运行状态。 阻塞：阻塞状态是指线程因为某种原因放弃了cpu执行权，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 执行权 转到运行(running)状态。阻塞的情况分三种。 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 结束 线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 线程的个数一般说来，大家认为线程池的大小经验值应该这样设置：（其中N为CPU的个数） 如果是CPU密集型应用，则线程池大小设置为N+1 如果是IO密集型应用，则线程池大小设置为2N+1 我们简单的思考一下，为什么会这样？？？ 对于CPU密集型任务，尽量使用较小的线程池，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。 IO密集型任务可以使用稍大的线程池，IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。 但是，其实最让我疑惑的是，为何要 +1？ 然后我看到了这句话： 即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。 额，这里节省的时间能够补回来由于多了一个线程导致的线程切换的开销吗？？？]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合编译器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[我们先来看一看编译器的发展历程，顺便也看一下虚拟机（与它有关系）的。虚拟机的变迁：编译器的变迁：我们知道，Java是有自己的虚拟机的，那么Google为何放着现有的JVM不用，而是设计一个新的虚拟机？？？在解答这问题之前，我们先来看看 Dalvik 与 JVM 的不同之处吧。 JVM Dalvik 基于堆栈的Java指令(1个字节) 基于寄存器的Dalvik指令(2、4或者6个字节) 执行同样的功能， Java虚拟机需要更多的指令（主要是load和store指令），需要更多指令意味着要多占用CPU的时间。 执行同样的功能，Dalvik虚拟机需要更多的指令空间，需要更多指令空间意味着指令缓冲（i-cache）更易失效 使用class格式的类文件 使用dex（Dalvik Executable）格式的类文件 从这个表格中，能看出为什么不？ 一个dex文件可以包含若干个类，而一个class文件只包括一个类。由于一个dex文件可以包含若干个类，因此它可以将各个类中重复的字符串只保存一次，从而节省了空间，适合在内存有限的移动设备使用。提前调整好字节序和字对齐方式，使得它们更适合于本地机器，以便提高指令执行速度。 Dalvik虽然设计精巧，但是每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高，会让用户经常感到系统卡顿。 为了解决这个的问题，Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。 但是它也有自己的问题： 使用JIT也不一定加快执行速度，如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行dex的时间。所以JIT不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码。 dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要进行JIT编译。 对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间。 JIT 虽然在某种程度上弥补了 Dalvik 的不足，但是仍然浪费了不少性能，所以从 Android 5.0 开始，就摒弃了 Dalvik 虚拟机，开发出了 ART 虚拟机。 与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，直接使用本地机器码运行，因此运行速度提高。 ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%。由于有了一个转码的过程，所以应用安装时间难免会延长。 安装的时候，字节码会预先编译成机器码就是由 AOT 编译器执行的，对比JIT就很好理解了，一个是运行时编译，一个是安装时编译。 编译好的文件是OAT文件，该文件本质上是一个ELF文件，这里与dex(Odex)文件最大的区别是OAT文件不再是字节码文件，而是一个可执行文件，可以更底层的与硬件接触，运行时也省去了预编译和转译的时间。 ART + AOT 虽然解决了 Dalvik + JIT 的不足，但是它也带来了新的问题： 更多需要解决的问题： 有一张图，我们应该会非常熟悉，大多数人应该都碰到过这样的场景： 这就是由于使用 ART + AOT 导致的。由于系统更新时，所有的应用都需要重新安装，这会导致所有的应用都需要在重新编译一遍，导致更新时间非常久。 那么，应该如何去解决这些问题呢？ 首先，我们思考一个问题：用户会使用App里面的每个功能吗？ 绝大多数用户只会使用App的部分功能。只有被用户频繁使用的功能（这个功能背后的代码）才值得被编译成本地代码。 所以，我们就可以不用预编译整个app，这样做： 在 JIT 阶段，我们可以先找出被频繁执行的代码，然后在使用预编译来优化和加速这些被频繁执行的代码，从而避免编译那些很少被用户使用的代码带来的额外消耗（储存空间，编译行为等等）。 当用户安装App的时候，不再进行预编译了，这个和KitKat的时候一样。当用户安装之后立即使用该App，仍然使用JIT编译模式来执行App，但是同时会生成一个离线的 profile 文件，这个 profile 文件会记录JIT运行时的所有 hot code（热点代码）信息。然后在未来的某个时间点，Android Framework 会基于这个 profile 文件来启动一个预编译行为，它只便于记录的热点代码。 在 JIT 阶段，它带来的好处： 快速安装 系统快速更新 在 AOT 阶段，它带来的好处： 快速启动，更好的运行性能 低消耗：CPU，储存空间，电量… 可以看到，它们 JIT 与 AOT 互相弥补了自己的不足。 获取有的人会觉得，JIT 是即时编译会比较慢，但是真的是这样吗？下面看一组数据测试： AOT与JIT在Micro Benchmark测试中各有优劣，所以预编译还不一定快。 下面贴出几组使用混合编译后的数据： 提升还是非常明显的。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-引言]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0001-%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[这个系列为并发入门系列，有些东西不会深入介绍，主要是有一个对并发全局的掌握，有兴趣可以自行深入了解。 该系列参考文章为： http://tutorials.jenkov.com/java-concurrency/index.html]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-并发介绍]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0002-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[在远古时代，我们的计算机只有一个 CPU，而且一次只能运行一个程序。接着多任务系统被引入，单个 CPU 可以同时运行多个程序了，虽然并不是真正意义上的“同一时间点”。它是这样工作的：多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。 从多任务系统开始，程序设计者就需要考虑该程序不能独占所有的CPU时间、所有的内存和其他计算机资源，因为别的程序也要运行。 再接着，多线程被引入：使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。但是需要注意的是，虽然名义上叫多线程，因为只有一个CPU，所以两个线程从来不会得到真正的并行执行。 （之所以能够这么设计，是因为 CPU 实在是太快了，看过 三体 么，里面的智子只有一个，但是却监控了整个地球，就是因为它跑的太快了，让人感觉到它无处不在，同样的，CPU 在切换线程的时候，我们根本就感觉不到） 再接着，多核 CPU 出现了，意味着不同的线程能被不同的CPU核得到真正意义的并行执行。以前的程序可能会出现一些从未见过的问题：因为多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。 如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003多线程的优点]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0003-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[尽管使用多线程会遇到很多困难，但是由于它带来的好处实在是太大了，所以掌握多线程是必须的。下面我们举几个例子来说一下多线程的好处：更高的资源利用率想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：1234561 | 5s读取文件A2 | 2s处理文件A3 | 5s读取文件B4 | 2s处理文件B-----------------一共耗时 5 + 5 + 2 + 2 = 14s 我们思考一下可以优化的地方： 从磁盘中读取文件的时候，这段时间内，CPU 是没有做任何事情的，就白白浪费了 在这段时间里，CPU非常的空闲。它可以做一些别的事情。那么，怎么利用这段时间，用 CPU 去做别的事情呢。 通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序： 1234561 | 5秒读取文件A2 | 5秒读取文件B + 2秒处理文件A3 | 2秒处理文件B----------------------------一共耗时 5 + 5 + 2 秒(仔细想了一下，这个例子应该是单CPU的情况下的顺序) CPU等待第一个文件被读取完，然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 更简单的程序设计在单线程应用程序中，如果你想编写程序处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。 但是如果你启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。 其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 更快的响应速度假设我们有一个服务器，我们写了一个服务应用用来处理用户的请求，它的大致流程如下： 1234while(server is active) &#123; listen for request process request&#125; 假如处理有的用户请求需要占用很长的时间，那么在这段时间之内，服务器就无法响应别的用户的请求了。 所以我们可以这样设计： 1234while(server is active)&#123; listen for request hand request to worker thread&#125; 我们为每个请求单独分配一个线程去处理，然后服务端线程立刻再去监听用户请求。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。 我们的应用也是如此。如果我们点击了一个按钮，要去开始一个非常耗时的任务，如果我们直接在 UI 线程执行，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。 但是如果我们开启一个工作线程去处理，当工作者线程在繁忙地处理任务的时候，UI线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。UI线程便可以更新应用程序窗口，并显示任务的结果。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-多线程的代价]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0004-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[多线程的代价虽然没有这么大，但是也有很多让人头疼的地方。我们在使用多线程的时候，最好先衡量一下。除非我们确定了使用多线程带来的好处要比付出的代价大，才应该使用。如果不确定，应该测试一下更改前后的程序性能，不要仅靠猜测。（我就有一次，优化程序的某个地方，花了两天时间，改成多线程之后，最后测量的时候发现速度只提升了 200ms，说实话，挫败感很大，原以为会有很大的提升，最后为了避免改动过大带来的影响，把代码回退了） 使代码变复杂虽然有些多线程程序写起来要比单线程简单，但是毕竟是少数情况，一般情况下，设计一个多线程程序需要考虑很多东西。 特别是关于共享数据的问题，这部分的代码需要特别注意。线程之间的交互可能非常复杂，需要理清楚的之后正确的使用同步。 还有一个问题就是，多线程产生的bug，可能难以复现，可能线上出现了几次，然后就再也不出现了，自己怎么弄都复现不出来，多线程的bug难以解决。 上下文切换开销当 CPU 从一个线程切换到另一个线程的时候，需要做很多事，不是仅仅换个线程执行就好了。 这是因为在切换的时候，我们需要保存关于这个线程的所有信息，比如：这个线程执行到哪里了，线程里面的栈数据。（它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。）如果不储存这些信息，那么 CPU 再次切回来的时候，就一脸懵逼了。 上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。 增加资源消耗曾经，我遇到过有人问这样的一个问题： 我们创建线程的数量有限制吗？ 线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。而且操作系统也需要管理这些线程。 我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。 就算线程不占别的资源，它也是一个类吧，创建一个类对象也需要资源。我们能创建无限个对象吗，显然不行。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在 【Android V1 V2 签名机制】里面分析了美团在 V1 签名机制下的多渠道打包，但是没有分析 V2 机制的多渠道打包。由于 V2 机制下多渠道打包涉及到 APK 结构，所以这里专门新起一篇。由于 APK 也是一个压缩包，所以我们先来看一下 ZIP 文件的结构。ZIP 文件结构一个普通的 ZIP 文件结构如下： 1[文件头+文件数据+数据描述符]&#123;此处可重复n次&#125; + 中央目录 + 中央目录结束标识 我们对着这个图看一下，apk在签名前和一个普通的 zip 文件的结构一样，中央目录 与 中央目录结束标识 对应后面两块。 ZIP 文件分3块，每块内容大致如下： 123数据区（Contents of ZIP entries）：存储文件压缩内容中央目录区（Central Directory Header）：存储zip文件里面包含的所有目录中央目录结束标识（End of Central Directory Record：ECDR）：存储zip文件的整体信息 其中，中央目录结束标识的结构是我们最需要搞清楚的。 我们拿一个例子来分析 中央目录结束标识 里面都有什么东西。 新建一个名为123.txt的文本文件，内容为123456，将123.txt压缩为123.zip 使用notepad++打开该文件，如下图： 有8根红线，每根红线对应的数据意义如下： 地址 字节数 字节内容 意义 00000062 4 50 4b 05 06 中央目录结束标记（0x06054b50，固定内容） 00000084 2 00 00 当前磁盘编号 00000088 2 00 00 中央目录开始位置的磁盘编号 0000008a 2 01 00 该磁盘上所记录的核心目录数量 0000008c 2 01 00 中央目录结构总数 0000008e 4 59 00 00 00 中央目录的大小 00000090 4 2b 00 00 00 中央目录开始位置相对于archive开始的位移 00000094 2 00 00 注释长度 中央目录结束标识 这一块的数据长度是不固定的，因为注释的长度不固定。 但是 中央目录结束标识 的起始位置的内容是固定的，我们就可以从 ZIP 文件的最后往前遍历，直到找到 4 个连续直接的内容与 0x06054b50 相等。找到了起始地址，从这个起始地址往后偏移 20 个字节，我们就知道了注释的长度。 我们看一下 walle 的代码吧： 123456789101112131415161718192021222324252627282930313233for (int expectedCommentLength = 0; expectedCommentLength &lt;= maxCommentLength; expectedCommentLength++) &#123; // 这里假设 注释的长度为 expectedCommentLength，从 0 开始一个一个试 // 我们从文件的倒数第 22 个字节开始往前遍历 final long eocdStartPos = eocdWithEmptyCommentStartPosition - expectedCommentLength; // 分配4个字节 final ByteBuffer byteBuffer = ByteBuffer.allocate(4); // 定位到倒数第22、23、24...个字节的位置 fileChannel.position(eocdStartPos); // 读取4个字节到buffer中 fileChannel.read(byteBuffer); // 将字节排序，因为 zip 文件的字节排序与我们阅读的顺序不一样 // 比如：0X0ff8，在 zip 文件中是这样存放的：f8 0f byteBuffer.order(ByteOrder.LITTLE_ENDIAN); // 判断该 4 个字节的值是不是 0x06054b50 if (byteBuffer.getInt(0) == ZIP_EOCD_REC_SIG) &#123; // 分配2个字节 final ByteBuffer commentLengthByteBuffer = ByteBuffer.allocate(2); // 往前 22 个字节，定位到存放 注释长度 的字节处 fileChannel.position(eocdStartPos + ZIP_EOCD_COMMENT_LENGTH_FIELD_OFFSET); fileChannel.read(commentLengthByteBuffer); commentLengthByteBuffer.order(ByteOrder.LITTLE_ENDIAN); // 获取 final int actualCommentLength = commentLengthByteBuffer.getShort(0); if (actualCommentLength == expectedCommentLength) &#123; return actualCommentLength; &#125; &#125;&#125; 拿到注释长度之后，我们就可以准确的定位到记录“中央目录开始位置”的字节处（其实上面如果不往后20个字节，只往后16个字节，就可以直接拿到，但是这里为了分析源码）。 再看代码： 123456 final ByteBuffer zipCentralDirectoryStart = ByteBuffer.allocate(4); zipCentralDirectoryStart.order(ByteOrder.LITTLE_ENDIAN);// 6 = 2 (Comment length) + 4 (Offset of start of central directory, relative to start of archive) fileChannel.position(fileChannel.size() - commentLength - 6); fileChannel.read(zipCentralDirectoryStart); final long centralDirStartOffset = zipCentralDirectoryStart.getInt(0); 这都不用说了，很清晰，ZIP 文件的长度 - 注释的长度 - 存放注释长度的2个字节 - 存放中央目录偏移位置的4个字节，就是存放中央目录偏移位置的字节起始位置了。 我们知道，apk 签名之后是多了一块叫做 ‘APK Signing Block’ 的东西，这块内容正好在中央目录的前面。而上面我们又知道了中央目录的偏移位置，所以只要我们知道 ‘APK Signing Block’ 的大小，我们就能将 ‘APK Signing Block’ 这一块里面的所有字节都取出来。 要想知道 ‘APK Signing Block’ 的大小，我们还是要了解 ‘APK Signing Block’ 的结构： 偏移 字节数 描述 @+0 （从前往后第0个字节） 8 这个 block 的长度 （不包括这8个字节） @+8 （从前往后第8个字节） n 一组 ID-VALUE @-24 （从后往前第24个字节） 8 这个 block 的长度（与上面的值一样） @-16 （从后往前第16个字节） 16 魔数 “APK Sig Block 42” 可以看出，APK Signing Block 分为4小块，第1、3块都储存的是 APK Signing Block 的大小。第 4 块是固定的。第 3块是不固定的，我们的渠道信息就是写在这个键值对区域的。 我们知道了中央目录的偏移位置，知道了中央目录的偏移位置前是一个固定的魔数，魔数前就是 APK Signing Block 的大小，这样，我们就可以拿到整个 APK Signing Block 块里面的所有东西了。 看看代码： 12345678910111213141516171819// 中央目录偏移位置往前24个字节，就是存 APK Signing Block 的长度的字节起始位置fileChannel.position(centralDirOffset - 24);// 分配24个字节空间final ByteBuffer footer = ByteBuffer.allocate(24);fileChannel.read(footer);// 读取前8个字节，就是 APK Signing Block 的长度final long apkSigBlockSizeInFooter = footer.getLong(0);// 拿到储存的 APK Signing Block 的长度，还要加上 8 个字节，才是整个 APK Signing Block 的长度final int totalSize = (int) (apkSigBlockSizeInFooter + 8);// 计算 APK Signing Block 的起始偏移位置final long apkSigBlockOffset = centralDirOffset - totalSize;// 定位到 APK Signing Block 的起始偏移位置fileChannel.position(apkSigBlockOffset);final ByteBuffer apkSigBlock = ByteBuffer.allocate(totalSize);// 读取整个 APK Signing Block 块fileChannel.read(apkSigBlock);apkSigBlock.order(ByteOrder.LITTLE_ENDIAN); 拿到了 APK Signing Block 块，我们就可以拿到里面 ID-VALUE 键值对了，由于我们在打包时放入了渠道名，现在我们就可以取出来。 我们先看看一个 ID-VALUE 键值对的结构： 字节数 描述 8 该 ID-VALUE 的长度（不包括自己） 4 ID n - 4 VALUE 看看代码： 123456789101112131415161718192021// 去掉前8与后24个字节final ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24);int entryCount = 0;while (pairs.hasRemaining()) &#123; entryCount++; // 取当前这个 ID-VALUE 对的长度 final long lenLong = pairs.getLong(); final int len = (int) lenLong; // 下一个 ID-VALUE 对的起始位置 final int nextEntryPos = pairs.position() + len; // 取 ID 的值 final int id = pairs.getInt(); // 取 VALUE 的值 idValues.put(id, getByteBuffer(pairs, len - 4)); pairs.position(nextEntryPos);&#125; 这里还需要判断一下，是否有V2签名标识： https://source.android.com/security/apksigning/v2.html#apk-signing-block 根据官方文档的描述，V2签名信息储存在 ID 为 0x7109871a 的键值对中。 我们可以判断一下： 1234567// Find the APK Signature Scheme v2 Block inside the APK Signing Block.final ByteBuffer apkSignatureSchemeV2Block = originIdValues.get(ApkUtil.APK_SIGNATURE_SCHEME_V2_BLOCK_ID);if (apkSignatureSchemeV2Block == null) &#123; throw new IOException( "No APK Signature Scheme v2 block in APK Signing Block");&#125; 到此为止，我们就完整了分析了多渠道相关的知识，现在我们看看 walle 是如何注入 ID-VALUE 渠道信息的，因为注入信息之后，必然需要更新相关的地址值，否则就错乱了。 我们可以回想一下，需要更新哪些值。 当我们写完渠道信息之后，中央目录起始偏移肯定变了，所以需要更新储存这个值的字节。 APK Signing Block 块的大小也变了，也需要更新，这有两个地方存，所以一共需要更新3个地方。 但是由于我们有了 APK Signing Block 的所有字节信息，所以我们可以直接覆盖原来的 APK Signing Block 块，最后更新 中央目录起始偏移 位置就好了。 12345678910111213141516171819202122232425// 将中央目录与中央目录结尾标识的所有字节存起来centralDirBytes = new byte[(int) (fileChannel.size() - centralDirStartOffset)];fIn.read(centralDirBytes);// 写更新之后的 APK Signing BlockfileChannel.position(apkSigningBlockOffset);final long length = apkSigningBlock.writeApkSigningBlock(fIn);// 写中央目录与中央目录结尾标识fIn.write(centralDirBytes);// 更新长度fIn.setLength(fIn.getFilePointer());// 定位到储存中央目录结束标志的字节位置fIn.seek(fileChannel.size() - commentLength - 6);// 更新该值// 6 = 2(Comment length) + 4 (Offset of start of central directory, relative to start of archive)final ByteBuffer temp = ByteBuffer.allocate(4);temp.order(ByteOrder.LITTLE_ENDIAN);temp.putInt((int) (centralDirStartOffset + length + 8 - (centralDirStartOffset - apkSigningBlockOffset)));// 8 = size of block in bytes (excluding this field) (uint64)temp.flip();fIn.write(temp.array()); 好了， walle 的核心代码就分析的差不多了，多渠道打包的原理也讲的差不多了。 手动的分析一个apk随便取一个 apk，用 notepad++ 打开，定位到文件末尾： 可以看到，确实是有一个固定的标识的。 然后我们找到 中央目录的偏移位置： 中央目录结束标记 0x06054b50 的后面 16 个就是中央目录的偏移地址了。 偏移位置为 74 ee 50 02，但是我们知道这个地址是反过来的，所以正确的地址为 0x0250ee74。 我们搜索这个地址： 在这个地址的前面，应该是也是固定的字节，为魔数”APK Sig Block 42”，将它换成字节，是 41 50 4B 20 53 69 67 20 42 6C 6F 63 6B 20 34 32，我们对比一下： 果然是一摸一样的。 魔数前面8个字节存放的是 APK Signing Block 的长度，我们往前找8个字节看看： 看来，APK Signing Block 的长度为 0x0ff8。由于中央目录偏移地址为 0x025ee74，减去这个地址得到0x0250de7c： 再搜索这个地址： 可以看到，这个地址往前8个字节也是储存的 APK Signing Block 的长度，这样就说明，我们分析的过程是正确的。所以 APK Signing Block 的所有字节如下： 图中 1 和 2 之间的内容，就是 ID-VALUE 键值对了。由于我分析的这个 apk 没有写入渠道信息，所以我找了一个网上的图片： 这个里面，写入了渠道信息： ID 为：0x71777777 渠道信息为：{&quot;channel&quot;:&quot;meituan&quot;} 我们直接在 ID-VALUE 里面搜索 0x71777777，就可以得到上面的图了。 长度：00 00 00 00 00 00 00 19=25 （长度是25字节） ID：71 77 77 77 （我们自定义的ID） 存入内容： {“channel”:”meituan”} 21字节 21+4=25，刚好等于长度的值 至此，我们就成功的通过分析APK的二进制数据，得到了walle注入的数据。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle Transform API ：直接修改 class 文件]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FGradle%20Transform%20API%20%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%20class%20%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首先，我要说的是，我没想到写这篇文章会遇到那么多的难点。其次在写这篇文章的时候，我还是处于一个半吊子的状态，但是我想应该还是会比现有的大部分blog要好的多。我几乎将Google到的索引到的前几页文章全部看了一遍，但是大部分都是相同的内容，就只有一篇我印象比较深，写的比较全面，但是我仍然还有很多疑问。 下面的文章我会提出我自己在学习这个知识点时想要问的问题，有些问题我可以自己解答，但是有些还是摸棱两可。 首先列出阅读这篇文章所需要的基础知识，如果你连这些都没有掌握的话，就不建议往下看了，会很痛苦，除非你只是想了解一下。 Goorvy 基本语法 Gradle 构建 ASM 前两个知识点有一个快速掌握的方法，阅读这个 PDF 文件，写的还是非常不错的，我花了一个小时看完，我看的比较快，因为我看过《Gradle权威指南》这本书。 好了，从这里开始，我就当你已经掌握了上面的相关知识点。 Gradle 工作流程Gradle 是一个框架，它定义一套自己的游戏规则。我们要玩转 Gradle，必须要遵守它设计的规则。 下面我们来讲讲 Gradle 的基本组件： Gradle 中，每一个待编译的工程都叫一个 Project。每一个 Project 在构建的时候都包含一系列的 Task。比如一个 Android APK 的编译可能包含：Java 源码编译 Task、资源编译 Task、JNI 编译 Task、lint 检查 Task、打包生成 APK 的 Task、签名 Task 等。 一个 Project 到底包含多少个 Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义 Task，并具体执行这些 Task 的东西。 Gradle 作为框架，它负责定义流程和规则，而具体的编译工作则是通过插件的方式来完成的。比如编译 Java 有 Java 插件，编译 Groovy 有 Groovy 插件，编译 Android APP 有 Android APP 插件，编译 Android Library 有 Android Library 插件。好了，到现在为止，你知道 Gradle 中每一个待编译的工程都是一个 Project，一个具体的编译过程是由一个一个的 Task 来定义和执行的。 在 Android Stuido 中，每个 moudle 都有自己的 build.gradle 文件。在构建的时候，每一个 build.gradle 文件都会转换成一个 Project 对象。 一个 Project 会包含若干 Tasks。另外，由于 Project 对应具体的工程，所以需要为 Project 加载所需要的插件，比如：为 Java 工程加载 Java 插件，为 Android 工程加载 Android 插件。 这里就为该工程加载了 3 个插件。一般的插件可以直接使用，但是有的插件可能还需要配置扩展。 如上图所示，这是属于 com.android.application 插件的一个 android 扩展。在这里我们就可以配置该扩展的一些属性。 了解了这些，我们继续。 Gradle 工作包含三个阶段： 首先是Initiliazation阶段：对我们前面的 multi-project build 而言，就是执行 settings.gradle。 然后是 Configration 阶段：Configration 阶段的目标是解析每个 project 中的 build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过 API 来添加的。 Configuration 阶段完了后，整个 build 的 project 以及内部的 Task 关系就确定了。前面说过，一个Project 包含很多 Task，每个 Task 之间有依赖关系。Configuration 会建立一个有向图来描述 Task 之间的依赖关系。所以，我们可以添加一个 HOOK，即当 Task 关系图建立好后，执行一些操作。 最后一个阶段就是执行任务了。 Transform API 为什么可以修改 class 文件我们知道，一个 project 的构建是由很多 task 组成的，而这些 task 是有依赖关系的。我们结合一下 App 的打包流程来看一下，各个 task 是发生在什么时候。 在 App 打包的时候，首先需要先将 java 文件编译为 class 文件（这里不关心一些其他的 AIDL 之类的），然后将 jar 与 class 文件达成 dex 文件。由于工程是 Gradle 构建的，Gradle 的构建是基于 Task 的，所以这些编译java文件，打包 class 文件都是在 task 中执行的。 在构建的过程中，这些 Task 都是由 TaskManager 管理的： com.android.build.gradle.internal.TaskManager#createCompileTask 123456protected void createCompileTask(@NonNull VariantScope variantScope) &#123; TaskProvider&lt;? extends JavaCompile&gt; javacTask = createJavacTask(variantScope); addJavacClassesStream(variantScope); setJavaCompilerTask(javacTask, variantScope); createPostCompilationTasks(variantScope);&#125; 这里是先执行了 javac 的编译任务，然后执行 post 编译任务。 com.android.build.gradle.internal.TaskManager#createPostCompilationTasks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void createPostCompilationTasks( @NonNull TaskFactory tasks, @NonNull final VariantScope variantScope) &#123; ... // ----- External Transforms ----- // 添加自定义的 Transform List&lt;Transform&gt; customTransforms = extension.getTransforms(); List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies(); for (int i = 0, count = customTransforms.size() ; i &lt; count ; i++) &#123; Transform transform = customTransforms.get(i); AndroidTask&lt;TransformTask&gt; task = transformManager .addTransform(tasks, variantScope, transform); ... &#125; ... // ----- Minify next ----- // minifyEnabled 为 true 表示开启混淆 // 添加 Proguard Transform if (isMinifyEnabled) &#123; boolean outputToJarFile = isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode; createMinifyTransform(tasks, variantScope, outputToJarFile); &#125; ... // non Library test are running as native multi-dex if (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123; ... // 添加 JarMergeTransform // create a transform to jar the inputs into a single jar. if (!isMinifyEnabled) &#123; // merge the classes only, no need to package the resources since they are // not used during the computation. JarMergingTransform jarMergingTransform = new JarMergingTransform( TransformManager.SCOPE_FULL_PROJECT); variantScope.addColdSwapBuildTask( transformManager.addTransform(tasks, variantScope, jarMergingTransform)); &#125; // 添加 MultiDex Transform // create the transform that's going to take the code and the proguard keep list // from above and compute the main class list. MultiDexTransform multiDexTransform = new MultiDexTransform( variantScope, extension.getDexOptions(), null); multiDexClassListTask = transformManager.addTransform( tasks, variantScope, multiDexTransform); multiDexClassListTask.optionalDependsOn(tasks, manifestKeepListTask); variantScope.addColdSwapBuildTask(multiDexClassListTask); &#125; ... // 添加 Dex Transform // create dex transform DefaultDexOptions dexOptions = DefaultDexOptions.copyOf(extension.getDexOptions()); ...&#125; 这个方法会遍历所有的 Transform，然后一一添加进 TransformManager。 添加完自定义的 Transform 之后，再添加 Proguard, JarMergeTransform, MultiDex, Dex 等 Transform。所以 Transform API 可以接触到 class 文件，这个时机是最好的处理时机。 Transform API 的使用根据 Transform API 的 文档，我们先自定义一个 Transform，然后将这个 Transform 注册到 android 扩展中即可。 自定义 Transform 我们后面会说到，这里我们想说如何注册。文档中对注册的描述只有一句话： To insert a transform into a build, you simply create a new class implementing one of the Transform interfaces, and register it with android.registerTransform(theTransform) or android.registerTransform(theTransform, dependencies). 但是实际上设计到的问题很多。比如：如何拿到 android 扩展？？？ 要拿到 android 扩展，一般我们是使用自定义一个插件的方式。由于 android 扩展中提供了 registerTransform 方法，所以是可以直接在 build.gradle 中调用的，但是它蛋疼的地方是这样搞的话，所有的逻辑都糅合在一起了。 下面我们介绍如何自定义一个插件，但是我们先来了解一下 Gradle 编程模型会好很多。 Gradle 编程模型Gradle 基于 Groovy，Groovy 又基于 Java。所以，Gradle 执行的时候和 Groovy 一样，会把脚本转换成 Java对象。Gradle 主要有三种对象，这三种对象和三种不同的脚本文件对应，在 gradle 执行的时候，会将脚本转换成对应的对端： Gradle 对象：当我们执行 gradle xxx 或者什么的时候，gradle 会从默认的配置脚本中构造出一个 Gradle对象。在整个执行过程中，只有这么一个对象。Gradle 对象的数据类型就是 Gradle。我们一般很少去定制这个默认的配置脚本。 Project 对象：每一个 build.gradle 会转换成一个 Project 对象。 Settings 对象：显然，每一个 settings.gradle 都会转换成一个 Settings 对象。 自定义 Gradle 插件新建一个 module删除其他目录，只留下 src/main 目录与 build.gradle 文件。 然后在 main 目录下面，新建 groovy 目录 与 resouce 目录。 groovy 就是用来放 groovy 文件的，与 java 目录的作用一样。 resources 目录是用来配置插件的相关信息的。接着我们在 resources 目录下新建一个 META-INF 目录，再在 META-INF 目录下新建一个 gradle-plugins 目录。然后在 gradle-plugins 新建一个 aaa.bbb.properties 文件。 需要注意的是，这个文件的名字很重要，aaa.bbb 是你定义的插件的名字。什么意思呢？还记得我们是如何加载一个插件的吗？ 1apply plugin: 'log.inject' 看，这个文件的名字就是加载插件时用到的名字。 文件的内容，比较简单，由于我们是要自定义一个插件，所以需要在这里声明一下插件的名字。 1implementation-class=com.aprz.log.LogPlugin 这样，我们的第一步就完成了。 实现一个插件类一般的，我们需要自定义一个东西，都会有一个父类给我们使用，插件也不例外。我们需要实现 Plugin 接口： 12345678910111213141516171819202122class LogPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; println('welcome to log inject plugin...') // 找到项目中的 某个继承至 BaseExtension 的扩展 def ext = project.extensions.getByType(BaseExtension) // 往该扩展中添加 transform // 这里其实就是将我们自定义的这个 transform 添加到了集合中 // 但是这里让我想不明白的是，为什么这个添加 transform 的方法是在 extension 里面 // 而不是 project 里面，如果像 Java 工程，没有使用有扩展的插件该怎么办 // 查看源码发现了这样的代码：com.android.build.gradle.internal.TaskManager.createPostCompilationTasks // AndroidConfig extension = variantScope.getGlobalScope().getExtension(); // 它获取到了 android 扩展，然后拿到了其中的所有 transform // 嗯，看来这个是针对 Android 构建的 ext.registerTransform(new LogsTransform(project)) &#125;&#125; 当这个插件按被加载（build.gradle 执行到 apply plugin: &#39;xxxx&#39;）的时候，它的 apply 方法就会被调用，我们在这里可以注册我们的 Transform 了。其实如果不需要注册 transform，我们只想打印一下 log 的话，它也是一个插件，只不过是一个没啥屌用的插件而已。 要想自定义一个有用的插件，还需要对 Groovy 语法，gradle 文档有相当的了解才行。 发布插件前面我们自定义了一个插件，但是需要发布之后，自己以及别人的项目才能使用，这里简单的说一下，如何发布到本地自己使用，想要发布到 bintray 等网站，可以自行查阅文档。 为了方便，我是使用了第三方的辅助插件。首先我们在根目录的 build.gradle 中添加依赖： TransformAPIDemo\build.gradle 12345dependencies &#123; classpath 'com.novoda:bintray-release:0.9' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125; 然后在插件工程的 build.gradle 中添加配置： TransformAPIDemo\log_transform\build.gradle 12345678910111213141516171819202122apply plugin: 'com.novoda.bintray-release'uploadArchives &#123; repositories &#123; mavenDeployer &#123; pom.groupId = 'com.aprz.log.inject' pom.artifactId = 'log' pom.version = '1.0.0' repository(url: uri('E:/maven/repository')) &#125; &#125;&#125;publish &#123; userOrg = 'aprz512' groupId = 'com.aprz.log.inject' artifactId = 'log' publishVersion = '1.0.0' desc = 'log inject demo' website = 'https://github.com/aprz512/Transform-API-demo' repoName = 'gradle_plugins'&#125; groupId,artifactId,version这3个应该经常接触，就不说了，这里看 repository 的配置，是可以配置本地路径的。这里我配置的是 E 盘。执行发布命令： 点击这个玩意，查看控制台输出： 然后就可以在E盘看到发布的插件了。 自定义 Transform上面我们自定义插件时提到了 Transform 的注册，里面创建了一个 Transform，但是我们没有深究，这里会仔细的分析一下。 自定义 Transform 同样的也需要继承一个父类： 1234567891011121314151617181920212223242526272829303132class LogsTransform extends Transform &#123; LogsTransform() &#123; &#125; @Override String getName() &#123; return this.getClass().getSimpleName() &#125; @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; @Override Set&lt;QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT &#125; @Override boolean isIncremental() &#123; return false &#125; @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) &#125; &#125; 我们先用一张图来说明，transform 是如何工作的，然后再细说上面的每个方法是什么意思。 Transform每次都是将一个输入进行处理，然后将处理结果输出，而输出的结果将会作为另一个Transform的输入。每个 Transform 会处理某些特定的资源流，如何指定需要处理的资源流是通过 getInputTypes 与 getScopes 一起决定的。 下面一一解释上面的几个方法： getName 指明本Transform的名字，随意，但是不能包含某些特殊字符，否则会报错。 getInputTypes 指明Transform的输入类型，例如，返回 TransformManager.CONTENT_CLASS 表示配置 Transform 的输入类型为 Class。 getScopes 指明Transform的作用域，例如，返回 TransformManager.SCOPE_FULL_PROJECT 表示配置 Transform 的作用域为全工程。 isIncremental 指明是否是增量构建 transform 用于处理具体的输入输出，核心操作都在这里。上例中，配置 Transform 的输入类型为 Class， 作用域为全工程，因此在transform方法中，inputs 会传入工程内所有的 class 文件。 通过 Scope 和 ContentType 可以组成一个资源流。例如，PROJECT 和 CLASSES，表示了主项目中java 编译成的 class 组成的一个资源流。再如，SUB_PROJECTS 和 CLASSES ，表示的是本地子项目中的 java 编译成的 class 组成的一个资源流。Transform 用来处理和转换这些流。 查看我们的代码中指定的域与类型，表示我们处理的是整个工程的 java 编译成的 class 文件。 接下来，我们来实现一个实例，自定义一个 Transform，这个 Transform 的作用是可以给所有父类是 androidx.appcompat.app.AppCompatActivity的类的 onCreate 方法都加入一个 log 语句。比如，原来的代码是这样： 12345678class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; &#125; 改变 class 之后应该是这样： 123456789class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; Log.e("log_inject", "onCreate") super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; &#125; 废话不多说，我们直接进入正题，由于 Transform 的主要内容都在 com.aprz.log.LogsTransform#transform 方法里面，我们就直接说这个方法： com.aprz.log.LogsTransform#transform 12345678910111213141516171819202122232425262728293031@Overridevoid transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) // inputs 包含了 jar 包和目录。 // 子 module 的 java 文件在编译过程中也会生成一个 jar 包然后编译到主工程中。 transformInvocation.inputs.each &#123; input -&gt; // 遍历目录 // 文件夹里面包含的是我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等 input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; directoryInput.file.eachFileRecurse &#123; File file -&gt; if (checkFileName(file.name)) &#123; injectClassFile(file) &#125; &#125; copyDirectory(directoryInput, transformInvocation.outputProvider) &#125; // 遍历 jar，我们不需要对 jar 进行处理，所以直接跳过 // 但是后面的 transform 可能需要处理，所以需要从输入流原封不动的写到输出流 input.jarInputs.each &#123; jarInput -&gt; copyJar(jarInput, transformInvocation.outputProvider) &#125; &#125;&#125; 需要注意的是，inputs 分为两种类型的资源，一种是目录（目录里面都是生成的 class 文件），一种是 jar 包，它们需要分开遍历。由于我们只需要要处理目录，所以只针对目录讲解。 首先，我们对目录集合进行遍历，在对集合中的每个目录进行递归处理，最终到每个 class 文件，拿到这个 class 文件，我们就可以使用 ASM 修改这个 class 文件了。 com.aprz.log.LogsTransform#injectClassFile 123456789101112static void injectClassFile(File file) &#123; ClassReader classReader = new ClassReader(file.bytes) ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) ClassVisitor cv = new LogClassVisitor(classWriter) // 访问者模式 classReader.accept(cv, ClassReader.EXPAND_FRAMES) byte[] code = classWriter.toByteArray() FileOutputStream fos = new FileOutputStream( file.parentFile.absolutePath + File.separator + file.name) fos.write(code) fos.close()&#125; 从这里开始，就是 ASM 的使用了。 ASM 的使用这里不介绍 API 的使用了，网上很多，还有官方文档，哪个都比我写得好。 这里介绍一下 ASM 的设计思想。 从上面的代码可以看到，ClassReader 的 accept 方法中传进来了一个参数ClassVisitor。在内部，ClassVisitor会不断的读取ClassReader的二进制byte[]，然后在解析后通过参数classVisitor的抽象visitXXX方法将属性全部转发出去，将其中的visitXXX方法按顺序抽离出来就是： 123456789classVisitor.visit(readInt(items[1] - 7), access, name, signature,superClass, interfaces);classVisitor.visitSource(sourceFile, sourceDebug);classVisitor.visitOuterClass(enclosingOwner, enclosingName,enclosingDesc);classVisitor.visitTypeAnnotation(context.typeRef,context.typePath, readUTF8(v, c);classVisitor.visitAttribute(attributes);classVisitor.visitInnerClass(readClass(v, c),readClass(v + 2, c), readUTF8(v + 4, c),readUnsignedShort(v + 6));classVisitor.visitField(access, name, desc,signature, value);classVisitor.visitMethod(context.access,context.name, context.desc, signature, exceptions);classVisitor.visitEnd(); 这里有很多 visit 方法，但是与真正的 class 文件的处理有关的，只有几个，比如：visitMethod，visitField 等。 这些 visit 方法，会创建一个相对应的 Writer 对象。 Writer 对象是什么呢？？？Writer 对象是 Visitor 的一个实现类。 ASM 在读取一个 class 文件的时候，会创建出一个 ClassWriter 对象，但是它不会把对元素（字段，方法，注解）的访问放到 ClassWriter 中，而是使用 访问者模式，将对这个元素的访问放到了 ClassVisitor 中。为何这样做，可以去看访问者模式。 当 ClassWriter 处理 class 文件的字节码的时候，比如遇到了一个方法，就会调用 ClassVisitor 的 visitMethod 方法。而 visitor 的实现实际上是 writer 类，所以会调用 writer 类的对应方法。这些方法会将字节码对应的部分给保存起来。而最后 classWriter.toByteArray 就会将所有的 writer 保存的字节码全部合并在一起，生成一个新的 class 文件。 如果，我们自定义一个 MethodVisitor 就可以改变字节码。 这里，我们覆盖 ClassVisitor 的 visitMethod 方法： com.aprz.log.asm.LogClassVisitor#visitMethod 12345678910111213141516171819@OverrideMethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; if (!checkSuperClass(this.superName)) &#123; return super.visitMethod(access, name, desc, signature, exceptions) &#125; // 由于是一个例子，我们就只处理 onCreate 方法了，想要深入应该去研究一下一个正规的开源项目 // 我的 demo 是 kotlin，tools里面有工具可以直接查看字节码，就非常方便 if ('onCreate(Landroid/os/Bundle;)V' == (name + desc)) &#123; println "log &gt;&gt;&gt; method name = $&#123;name + desc&#125;" MethodVisitor methodVisitor = this.cv.visitMethod(access, name, desc, signature, exceptions) return new LogMethodVisitor(methodVisitor, name) &#125; return super.visitMethod(access, name, desc, signature, exceptions)&#125; 可以看到，我们返回了我们自己定义的 LogMethodVisitor，将原来的 MethodVisitor 作为成员变量保存起来 。当 MethodVisitor 的相关方法被调用的时候，实际上会调用 LogMethodVisitor 的方法。这样，我们就可以搞事情了。比如：在刚进入方法的时候，会触发 visitCode 的调用： com.aprz.log.asm.LogMethodVisitor#visitCode 1234567891011121314151617181920/** * L2 * LINENUMBER 13 L2 * LDC "log_inject" * LDC "onCreate" * INVOKESTATIC android/util/Log.e (Ljava/lang/String;Ljava/lang/String;)I * POP */@Overridevoid visitCode() &#123; super.visitCode() // 在方法之前插入 Log.e("", "") // 这两个是参数 this.mv.visitLdcInsn('log_inject') this.mv.visitLdcInsn(this.name) this.mv.visitMethodInsn(Opcodes.INVOKESTATIC, 'android/util/Log', 'e', '(Ljava/lang/String;Ljava/lang/String;)I', false) // 这里的用法有点奇怪，还需要研究一下 // visitXXX 实际上会触发 MethodWriter 的方法，这些方法会将我们想要写入的字节码存放起来 // 最后统一的写入到输出的 class 文件中&#125; 在这里，我们就可以插入我们的字节码了。 到这里，东西就都介绍完毕了，只说了皮毛，要深入还是要看一个真正的项目才行。 demoTransform-API-demo]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CompletableFuture 的使用]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FCompletableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[遇到这样的一个实际问题：写一个任务控制器，支持添加多个任务异步执行，任务间可以设置依赖，没有依赖的任务并行，有依赖的串行。我刚开始一想，发现这个不是很简单么，写了包装类包装一下 Runnable，然后给它加一个添加依赖的功能不就好了么。后来发现没有我想的这么简单，首先循环依赖没有解决，这个问题这里就不深入了，就假设它没有循环依赖。 有了这个假设作为前提，我写出了第一版代码： 1234567891011121314151617181920212223class Task(private var name: String) : Runnable &#123; private var dependencies = mutableListOf&lt;Task&gt;() fun addDependency(vararg task: Task) &#123; dependencies.addAll(task) &#125; override fun run() &#123; // 让 dependencies 先运行 dependencies.forEach &#123; it.run() &#125; // 自己再运行 doSome() &#125; protected fun doSome() &#123; println(name) &#125;&#125; 当我，发给另一个小伙伴看的时候，他就说了，这个没有处理并发的执行啊，我一想，果然是这样。这里都没有多线程，全是一个线程。 问题的关键就是在于，需要将循环的那部分代码变为多线程代码。 本来，我想的是使用一些别的方法来做，比如，搞几个 future，等他们全部拿到结果了，在执行 doSome 的逻辑，但是这样写就有点麻烦了。突然，我想起了看《Java并发实践》这本书的时候，有提到过一个叫做 CompletableFuture 的类，它可以控制多个 Future，用在之类正好啊。 先看一下说明： future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的： 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第 一个的结果。 等待 Future 集合中的所有任务都完成。 仅等待 Future 集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同 一个值），并返回它的结果。 通过编程方式完成一个 Future 任务的执行（即以手工设定异步操作结果的方式）。 应对 Future 的完成事件（即当 Future 的完成事件发生时会收到通知，并能使用 Future 计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果） 新的 CompletableFuture 将使得这些成为可能。 来看一下，改版之后的代码吧： 1234567891011121314@RequiresApi(Build.VERSION_CODES.N) override fun run() &#123; // 让 dependencies 先运行 val cfs = dependencies.stream() .map &#123; CompletableFuture.runAsync(it) &#125; .collect(Collectors.toList()) val array = cfs.toTypedArray() CompletableFuture.allOf(*array).join() // 自己再运行 doSome() &#125; 这里就是不直接执行 it.run() 了，而是交给 CompletableFuture 里面的 pool 去执行，这样就是并发的了。 拿到所有结果之后，自己的代码才能执行，所以我们使用了 join 方法。 逻辑还是非常清晰的，对 Stream 不了解的就需要去学习一下了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（三）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882.5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的分析 IoScheduler 类。首先要说明的是，RxJava2 中虽然使用到了 Java 的线程池，但是还有很多其他的东西，比如，接下来你就会看到 IoScheduler 中自己实现一个简单的线程池。从使用说起1234567// RxJavaScheduler.Worker worker = Schedulers.io().createWorker();worker.schedule();// JavaScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);scheduledExecutorService.schedule() 先不谈运行原理，这里我们比较一下它与我们平时使用的线程池的不同之处。 一般我们使用的时候，都是先获取线程池的对象，然后传递一个 runnable 给它，让它取执行。 但是 RxJava 里面，似乎有点不一样。它需要先创建 worker 对象，然后才能将 action 传递给它。与Java方式比较，它多了一个创建 worker 的过程，那么显然本文的核心就是弄清楚，worker 对象是做什么的？为什么设计成需要 worker 对象才能提交任务？ 先说说每个类具体的作用： 类名 作用 Worker 抽象类，提供了执行 action 的几个方法，支持单次执行，定时多次执行。定时多次执行是基于单次执行，默认已经在该类中实现。 NewThreadWorker Worker 的子类，实现了单次执行方法，使用的是 Executors.newScheduledThreadPool 方法。 ThreadWorker NewThreadWorker 的子类，增强了一下，提供了过期时间的判断方法。 SequentialDisposable 一种容器，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。经过不断的替换引用，从而达到可以支持 Worker 多次执行任务仍然能够 dispose 的功能。 ScheduledRunnable 该类是一个集大成的类，它是一个可以取消任务，也可以取消订阅的 runnable。 AbstractDirectTask 这货虽然名字是 task，然是实际上与 ScheduledRunnable 是一路货色，当成 runnable 也可以。 ScheduledDirectTask AbstractDirectTask 的子类 EventLoopWorker Worker 的子类，使用的是 NewThreadWorker 实现了单次执行。 CachedWorkerPool Rxjava自己实现的一个线程池。 从内部类开始IoSchedulerIoScheduler 源码不长，但是它有3个内部类，我们从内部类开始，因为每个内部类的功能都是比较单一的，分析起来很方便，知道了内部类的作用，外部类的分析就更简单了。 IoScheduler.java 123456789public final class IoScheduler extends Scheduler &#123; static final class CachedWorkerPool implements Runnable &#123;...&#125; static final class EventLoopWorker extends Scheduler.Worker &#123;...&#125; static final class ThreadWorker extends NewThreadWorker &#123;...&#125; &#125; IoScheduler.ThreadWorker我们从代码量最少的 ThreadWorker 来开始： ThreadWorker.java 可以看出来，ThreadWorker 是对 NewThreadWorker 的一个增强，增加了过期的功能。 123456789101112131415161718static final class ThreadWorker extends NewThreadWorker &#123; private long expirationTime; ThreadWorker(ThreadFactory threadFactory) &#123; super(threadFactory); this.expirationTime = 0L; &#125; // 获取过期时间 public long getExpirationTime() &#123; return expirationTime; &#125; // 设置过期时间 public void setExpirationTime(long expirationTime) &#123; this.expirationTime = expirationTime; &#125;&#125; ThreadWorker 继承了 NewThreadWorker，那我们就需要看看 NewThreadWorker 是用来做什么的。 NewThreadWorker NewThreadWorker.java 它继承了 Scheduler.Worker。 从注释上来看，它持有一个单线程的ScheduledExecutorService。 123456/** * Base class that manages a single-threaded ScheduledExecutorService as a * worker but doesn't perform task-tracking operations. * */public class NewThreadWorker extends Scheduler.Worker implements Disposable &#123;...&#125; ####Scheduler.Worker 由于 NewThreadWorker 类继承了 Scheduler.Worker，Scheduler.Worker 是一个抽象类，它的核心方法如下： io.reactivex.Scheduler.Worker.java 12345678910111213141516171819202122232425 public abstract static class Worker implements Disposable &#123; @NonNull public Disposable schedule(@NonNull Runnable run) &#123; // 调用了抽象方法 return schedule(run, 0L, TimeUnit.NANOSECONDS); &#125;// 子类需要实现该方法 @NonNull public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);// 有一个默认实现周期性的方法，子类如果有特殊需要，可以覆盖该方法 @NonNull public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; ... return sd; &#125; public long now(@NonNull TimeUnit unit) &#123; return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; &#125; 所以我们只需要分析两个方法： io.reactivex.Scheduler.Worker#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit) io.reactivex.Scheduler.Worker#schedulePeriodically 第一个方法是抽象的，所以我们先放着。 我们先看 schedulePeriodically 这个方法是如何实现周期性的。 io.reactivex.Scheduler.Worker.java 1234567public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; final SequentialDisposable first = new SequentialDisposable(); ... return sd;&#125; 第一行就出现了一个新的类，SequentialDisposable，这个类比较简单，我们看看： SequentialDisposable SequentialDisposable.java 该类是一种容器，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。 1234567891011121314151617181920212223242526272829303132333435363738public final class SequentialDisposableextends AtomicReference&lt;Disposable&gt;implements Disposable &#123; private static final long serialVersionUID = -754898800686245608L; public SequentialDisposable() &#123; // nothing to do &#125; public SequentialDisposable(Disposable initial) &#123; lazySet(initial); &#125; /** * 原子的：将引用值换成next，会对之前的引用对象调用 dispose */ public boolean update(Disposable next) &#123; return DisposableHelper.set(this, next); &#125; /** * 原子的：将引用值换成next，不会对之前的引用对象调用 dispose */ public boolean replace(Disposable next) &#123; return DisposableHelper.replace(this, next); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125;&#125; 这个类很是很简单的，没有什么复杂的代码，我们把它当作一个容器就好了。 再回到 schedulePeriodically 方法中： 123456789101112131415161718192021222324252627282930313233 public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; // 创建一个容器，引用值为null final SequentialDisposable first = new SequentialDisposable();// 创建一个容易，引用值为 first final SequentialDisposable sd = new SequentialDisposable(first); // 这个暂时没啥作用，当作 decoratedRun = run 理解就好 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 计算时间，我就不细说了，有兴趣自己算一算 final long periodInNanoseconds = unit.toNanos(period); final long firstNowNanoseconds = now(TimeUnit.NANOSECONDS); final long firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay); // 这里调用了 schedule ，它是一个抽象方法 // 暂时不会去分析 schedule，我们这里可以把它理解为 pool 的 execute 方法 // 反正它会去执行我们传递的 runnable // PeriodicTask 就是一个 runnable // 后面的参数，是指定延时长度与单位 Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds), initialDelay, unit); if (d == EmptyDisposable.INSTANCE) &#123; return d; &#125; // 将 first 的引用值改为 d // 这里之所以要赋值，是因为第一次执行时，如果使用者调用了 dispose，那么我们必须取消订阅 // 由于返回了 sd，所以 sd 会调用 first 的 dispose，first 会调用 d 的 dispose // 这样就取消订阅了 first.replace(d); return sd; &#125; 上面注释写的比较详细了，下面我们看 PeriodicTask 是如何周期执行的，这里我们可以想一下我们使用 Hander 写一个定时器的做法，其实是一样的。 Scheduler.Worker.PeriodicTask io.reactivex.Scheduler.Worker.PeriodicTask PeriodicTask 是 Worker 的一个内部类，Worker 是 Scheduler 的内部类。 该类就是用来实现周期任务的。 1final class PeriodicTask implements Runnable &#123;...&#125; 既然是实现了 Runnable，那我们只看 run 方法。 io.reactivex.Scheduler.Worker.PeriodicTask#run 123456789101112131415161718192021222324252627282930313233@Overridepublic void run() &#123; // 这里就是 run 执行的位置，我们需要执行的 runnable 就是在这里执行的 decoratedRun.run(); // 没有取消订阅 if (!sd.isDisposed()) &#123; // 下面的一段是计算下一次运行的时间，嗯，自己看看吧 long nextTick; long nowNanoseconds = now(TimeUnit.NANOSECONDS); // If the clock moved in a direction quite a bit, rebase the repetition period if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS &lt; lastNowNanoseconds || nowNanoseconds &gt;= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) &#123; nextTick = nowNanoseconds + periodInNanoseconds; /* * Shift the start point back by the drift as if the whole thing * started count periods ago. */ startInNanoseconds = nextTick - (periodInNanoseconds * (++count)); &#125; else &#123; nextTick = startInNanoseconds + (++count * periodInNanoseconds); &#125; lastNowNanoseconds = nowNanoseconds; long delay = nextTick - nowNanoseconds; // 这里将 sd 的引用替换为新的 disposable // 因为旧的任务在第一行代码已经执行完了，所以替换掉 // schedule 方法有安排了下一次的任务，这样就成了一个循环，达到了周期性的目的 sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS)); &#125;&#125; 嗯，到了这里，io.reactivex.Scheduler.Worker类就分析完了，下面回到我们的 NewThreadWorker 类中。 ####NewThreadWorker 看构造方法： NewThreadWorker.java 123public NewThreadWorker(ThreadFactory threadFactory) &#123; executor = SchedulerPoolFactory.create(threadFactory);&#125; 构造函数中调用 SchedulerPoolFactory 的 create 方法，创建了一个 executor 对象。 SchedulerPoolFactory看看 SchedulerPoolFactory 的 create 方法： SchedulerPoolFactory .java 123456789public static ScheduledExecutorService create(ThreadFactory factory) &#123; final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); // PURGE_ENABLED 的值与系统有关，暂且不提 if (PURGE_ENABLED &amp;&amp; exec instanceof ScheduledThreadPoolExecutor) &#123; ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec; POOLS.put(e, exec); &#125; return exec;&#125; 这里我们只关注第一行代码，与注释说的一样，它创建了一个单线程的 ScheduledExecutorService 对象。 ####NewThreadWorker 构造方法与父类，我们都分析完了，现在看看它是怎么实现那个抽象方法的。 NewThreadWorker 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@NonNull@Overridepublic Disposable schedule(@NonNull final Runnable run) &#123; // 这里它覆盖了原来的默认实现，传递了一个null // 没看懂，方法参数不接受 null 啊 return schedule(run, 0, null);&#125;@NonNull@Overridepublic Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; // disposed 就没啥说的 if (disposed) &#123; return EmptyDisposable.INSTANCE; &#125; // 调用了 scheduleActual 方法 return scheduleActual(action, delayTime, unit, null);&#125;/** * 将runnnable 包装成 ScheduledRunnable，交给 ScheduledExecutorService 去执行 * 如果调度被驳回， ScheduledRunnable.wasScheduled 的值为 false。 */@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123; // 直接理解成 decoratedRun = run Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 将 decoratedRun 包装一下 ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); // 传递的参数为 null，这一段跳过 if (parent != null) &#123; if (!parent.add(sr)) &#123; return sr; &#125; &#125; Future&lt;?&gt; f; try &#123; if (delayTime &lt;= 0) &#123; // 不延迟就直接执行 f = executor.submit((Callable&lt;Object&gt;)sr); &#125; else &#123; // 延迟执行 f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); &#125; // 设置 future，便于获取执行结果 sr.setFuture(f); &#125; catch (RejectedExecutionException ex) &#123; if (parent != null) &#123; parent.remove(sr); &#125; RxJavaPlugins.onError(ex); &#125; return sr;&#125; 嗯，现在，我们需要看看 ScheduledRunnable 到底是个什么，起什么作用。 ScheduledRunnable ScheduledRunnable 12public final class ScheduledRunnable extends AtomicReferenceArray&lt;Object&gt;implements Runnable, Callable&lt;Object&gt;, Disposable &#123;...&#125; 这个类的源码比较奇特，我就不展开了，我们把它当作一个 Callable 使用就可以了，但是它也支持 Disposable。源码里面都是一些原子性的赋值更新处理。 回到 NewThreadWorker 类，它的 schedule 方法就是将我们传递的 runnable 包装一下，然后将这个包装好的 ScheduledRunnable 交给 ScheduledExecutorService 去处理。 因为 ScheduledRunnable 实现了 Disposable，所以直接返回它，可以用于取消订阅。ScheduledRunnable 还实现了 Callable 是因为我们取消订阅的时候，可以用于线程池取消任务（f.cancel(true)）。 NewThreadWorker到了这里 NewThreadWorker 的一系列 schedule 方法就分析完了，然而，我们发现，它除了 schedule 方法之外，还提供了一些别的public的方法，顺便看了算求。 io.reactivex.internal.schedulers.NewThreadWorker#scheduleDirect 这个方法也是提交一个 runnable 给线程池执行，然是不是使用了 ScheduledRunnable 来包装， 而是使用的 ScheduledDirectTask 123456789101112131415161718public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; // 这里出了一个新类 ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; // 下面的代码与之前分析的一样，就跳过 Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 那我们就来分析分析 ScheduledDirectTask 类。 ScheduledDirectTask ScheduledDirectTask 继承了 AbstractDirectTask 类 主要是实现了 call 方法，给 runner 赋值，调用 runnable 的 run 方法 12345678910111213141516171819202122public final class ScheduledDirectTask extends AbstractDirectTask implements Callable&lt;Void&gt; &#123; private static final long serialVersionUID = 1811839108042568751L; public ScheduledDirectTask(Runnable runnable) &#123; super(runnable); &#125; @Override public Void call() throws Exception &#123; runner = Thread.currentThread(); try &#123; runnable.run(); &#125; finally &#123; // 设置为完成状态 // 还是没有搞太明白，set 与 lazySet 的区别，什么内存屏障啊 lazySet(FINISHED); runner = null; &#125; return null; &#125;&#125; AbstractDirectTask AbstractDirectTask 源码不长，我就全部贴出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class AbstractDirectTaskextends AtomicReference&lt;Future&lt;?&gt;&gt;implements Disposable &#123; private static final long serialVersionUID = 1811839108042568751L; protected final Runnable runnable; protected Thread runner; // 哦，我还不知道有个 Functions.EMPTY_RUNNABLE 可以用 protected static final FutureTask&lt;Void&gt; FINISHED = new FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, null); protected static final FutureTask&lt;Void&gt; DISPOSED = new FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, null); AbstractDirectTask(Runnable runnable) &#123; this.runnable = runnable; &#125; @Override public final void dispose() &#123; Future&lt;?&gt; f = get(); if (f != FINISHED &amp;&amp; f != DISPOSED) &#123; // 将状态设置为取消 if (compareAndSet(f, DISPOSED)) &#123; // 取消线程池里的任务 if (f != null) &#123; f.cancel(runner != Thread.currentThread()); &#125; &#125; &#125; &#125; @Override public final boolean isDisposed() &#123; Future&lt;?&gt; f = get(); return f == FINISHED || f == DISPOSED; &#125; public final void setFuture(Future&lt;?&gt; future) &#123; for (;;) &#123; Future&lt;?&gt; f = get(); if (f == FINISHED) &#123; break; &#125; if (f == DISPOSED) &#123; // 取消线程池里的任务 future.cancel(runner != Thread.currentThread()); break; &#125; // 设置引用值为 f if (compareAndSet(f, future)) &#123; break; &#125; &#125; &#125;&#125; 感觉，ScheduledDirectTask 这个类的功能与 ScheduledRunnable 的功能差不多啊，ScheduledRunnable 更强力一点。至少在我们分析的这个流程里面，感觉不到区别，嗯，不过想到 scheduleActual 方法比 scheduleDirect多了一个参数，想来，玄机应该在这里，有兴趣的自己再去找找。 如果实在心里想不通的，把 ScheduledDirectTask 与 ScheduledRunnable 都当成具有解除订阅与取消任务的增强型 Runnable 就好了。 NewThreadWorker再次回到 NewThreadWorker，还有一个方法没有说到： io.reactivex.internal.schedulers.NewThreadWorker#schedulePeriodicallyDirect 该方法用于周期性的执行任务 123456789101112131415161718192021222324252627282930313233public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, long period, TimeUnit unit) &#123; final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 这里如果周期性设置为0，也就是说没有间隔的重复执行任务 if (period &lt;= 0L) &#123; // 没有间隔的话，使用 InstantPeriodicTask InstantPeriodicTask periodicWrapper = new InstantPeriodicTask(decoratedRun, executor); try &#123; Future&lt;?&gt; f; if (initialDelay &lt;= 0L) &#123; f = executor.submit(periodicWrapper); &#125; else &#123; f = executor.schedule(periodicWrapper, initialDelay, unit); &#125; periodicWrapper.setFirst(f); &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125; return periodicWrapper; &#125; // 有间隔的话，使用 ScheduledDirectPeriodicTask ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun); try &#123; Future&lt;?&gt; f = executor.scheduleAtFixedRate(task, initialDelay, period, unit); task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 里面，线程池的使用，Task 的分析就不展开了，因为之前已经分析过一个 Task，想一想都能知道里面的代码大概长什么样，有兴趣的自己去看看吧。 好了，到这里，NewThreadWorker 类，我们就分析完了，没想到这么短的一个内部类，里面有这么多东西。不过，总结一下，里面的东西其实并不多。 schedule 等方法，用于提交任务，内部使用的是 ScheduledExecutorService 线程池 schedule 等方法返回一个 Disposable，用于解除订阅，解除订阅时，也会取消该任务。 周期性的实现，有两种方式，一种是自己调用自己实现的，一种是使用 ScheduledExecutorService 的 scheduleAtFixedRate 方法实现的。 IoScheduler.EventLoopWorker接下来，我们趁热打铁，看另外一个继承至 Scheduler.Worker 的内部类。 io.reactivex.internal.schedulers.IoScheduler.EventLoopWorker EventLoopWorker 继承至 Scheduler.Worker Worker 上面分析过，是用来执行任务的。 123456789101112131415161718192021222324252627282930313233343536373839404142 static final class EventLoopWorker extends Scheduler.Worker &#123; private final CompositeDisposable tasks; // 这里有一个新东西 private final CachedWorkerPool pool; private final ThreadWorker threadWorker; final AtomicBoolean once = new AtomicBoolean(); EventLoopWorker(CachedWorkerPool pool) &#123; this.pool = pool; this.tasks = new CompositeDisposable(); this.threadWorker = pool.get(); &#125; @Override public void dispose() &#123; if (once.compareAndSet(false, true)) &#123; tasks.dispose(); // releasing the pool should be the last action // 将线程返回线程池里面去 pool.release(threadWorker); &#125; &#125; @Override public boolean isDisposed() &#123; return once.get(); &#125; @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125;// 让 ThreadWorker 去执行一个 aciton 任务，这里最后一个参数注意一下 // threadWorker 里面只有一个线程，所以，任务是顺序执行的 return threadWorker.scheduleActual(action, delayTime, unit, tasks); &#125; &#125; 看里面的代码还是非常简单的，它的构造方法接收一个 CachedWorkerPool，这个是 EventLoopWorker 类里面，唯一一个陌生类，看看这个类： IoScheduler.CachedWorkerPool欸，太好了，这个也是 IoScheduler 的内部类，这样的话，把这个类分析完了之后， IoScheduler 的内部类就分析完成了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static final class CachedWorkerPool implements Runnable &#123; private final long keepAliveTime; // 队列 private final ConcurrentLinkedQueue&lt;ThreadWorker&gt; expiringWorkerQueue; final CompositeDisposable allWorkers; // java 的线程池 private final ScheduledExecutorService evictorService; private final Future&lt;?&gt; evictorTask; // 线程工程，一般就 new 一个 Thread，然后给个名字就完事了 private final ThreadFactory threadFactory; CachedWorkerPool(long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) &#123; this.keepAliveTime = unit != null ? unit.toNanos(keepAliveTime) : 0L; this.expiringWorkerQueue = new ConcurrentLinkedQueue&lt;ThreadWorker&gt;(); this.allWorkers = new CompositeDisposable(); this.threadFactory = threadFactory; ScheduledExecutorService evictor = null; Future&lt;?&gt; task = null; if (unit != null) &#123; // 这里也创建了一个单个线程的线程池 evictor = Executors.newScheduledThreadPool(1, EVICTOR_THREAD_FACTORY); // 创建定时任务，runnable 是 this，就是 run 里面的代码 task = evictor.scheduleWithFixedDelay(this, this.keepAliveTime, this.keepAliveTime, TimeUnit.NANOSECONDS); &#125; evictorService = evictor; evictorTask = task; &#125; @Override public void run() &#123; evictExpiredWorkers(); &#125; ThreadWorker get() &#123; // 如果线程池关闭了，则返回一个关闭的线程池 if (allWorkers.isDisposed()) &#123; return SHUTDOWN_THREAD_WORKER; &#125; // 队列不为空，从队列中取一个 worker 出来 while (!expiringWorkerQueue.isEmpty()) &#123; ThreadWorker threadWorker = expiringWorkerQueue.poll(); if (threadWorker != null) &#123; return threadWorker; &#125; &#125; // 队列没有 worker，new 一个出来 // No cached worker found, so create a new one. ThreadWorker w = new ThreadWorker(threadFactory); // ThreadWorker 继承 NewThreadWorker // NewThreadWorker 实现了 Disposable // 调用 dispose 会关闭里面的线程池 allWorkers.add(w); return w; &#125; /** * 将 worker 重新放入到线程池（队列）中，将过期时间重置 */ void release(ThreadWorker threadWorker) &#123; // Refresh expire time before putting worker back in pool threadWorker.setExpirationTime(now() + keepAliveTime); expiringWorkerQueue.offer(threadWorker); &#125; /** * 移除过期 worker */ void evictExpiredWorkers() &#123; if (!expiringWorkerQueue.isEmpty()) &#123; long currentTimestamp = now(); // 遍历队列 for (ThreadWorker threadWorker : expiringWorkerQueue) &#123; // 看看 threadWorker 过期了没有 if (threadWorker.getExpirationTime() &lt;= currentTimestamp) &#123; // 过期了就移除 if (expiringWorkerQueue.remove(threadWorker)) &#123; // 从队列移除成功后，将 Disposable 也移除掉 allWorkers.remove(threadWorker); &#125; &#125; else &#123; // 因为队列是按照时间排列的，所以找到第一个没有过期的就可以退出循环了 // Queue is ordered with the worker that will expire first in the beginning, so when we // find a non-expired worker we can stop evicting. break; &#125; &#125; &#125; &#125; long now() &#123; return System.nanoTime(); &#125; /** * 关闭线程池 */ void shutdown() &#123; allWorkers.dispose(); if (evictorTask != null) &#123; evictorTask.cancel(true); &#125; if (evictorService != null) &#123; evictorService.shutdownNow(); &#125; &#125;&#125; 注释很清晰，如果你阅读过Java的线程池源码，会更容易理解，这里就是教我们如果实现一个自己的 CacheThreadPool 线程池啊。只不过这个线程池（ConcurrentLinkedQueue）的每一个 worker 都是一个线程池（NewThreadWorker）。 嗯，到这里，IoScheduler 的内部类就讲完了，我们看看它的其他方法吧。 首先，IoScheduler 是继承至 Scheduler 的，所以我们先从它对抽象方法的实现看起。 IoScheduler IoScheduler 123public Worker createWorker() &#123; return new EventLoopWorker(pool.get());&#125; 它是直接创建一个 EventLoopWorker 对象并返回。 根据我们上面的分析，EventLoopWorker 将任务给了 ThreadWorker 去执行，ThreadWorker 又将任务给了一个单个线程的线程池去执行。 而且，ThreadWorker 是线程池中的线程池，因为它就一个线程，所以可以把它当作单个线程而不是线程池，那么就是说，IoScheduler 的线程池就是一个功能与Java中的Executors.newCachedThreadPool()方法创建出来的线程池功能是差不多的。 好吧，虽然差不多，但是毕竟这里里面的线程池与线程提供了对 Disposable 接口的支持。 感觉，EventLoopWorker 的作用，只是一个代理啊，最后还是将任务转给了 CachedWorkerPool。可能为了支持 dispose 操作花费了很多心思。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（一）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是第二次写源码分析，之前的一次已经是一年前了。为何要重写？主要是由于今天看到了一些关于线程池的东西，我联想到了RxJava2中的线程分类。再想到项目中的线程池相关的地方，感觉很乱，所以有一个整合的想法，想将原来自己创建的线程池替换成RxJava2中的线程池，于是就有了翻看源码的心思。择日不如撞日，反正是看源码，顺便把以前的东西再整理一下，还有就是以前写的东西，思路太乱，看着不舒服。 回想起来，RxJava2的源码有很多套路，只要掌握了这个套路，阅读源码起来就会有一切尽在掌握的感觉，否则，就会觉得源码很绕。 所以第一篇文章的主要目的，是讲明白这个套路，然后配上图，能够更容易让人理解，如果以后忘记了，再回来看一遍也能迅速跟上思路，不会又要再次撸一遍源码。 从一个简单的例子开始1234567891011121314151617181920212223242526272829// 观察者 -- 蝙蝠侠// 这里之所以没有用 Consumer，是怕引起歧义// 毕竟源码利用将我们传递进去的 Consumer， 又封装了一层，封装成了 Observerval observerBatMan = object : Observer&lt;Int&gt; &#123; override fun onComplete() &#123; &#125; override fun onNext(t: Int) &#123; Assert.assertEquals(1, t) &#125; override fun onError(e: Throwable) &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125;&#125;// 数据源 -- 小丑val sourceClown = ObservableOnSubscribe&lt;Int&gt; &#123; it.onNext(1) it.onComplete()&#125;// 开始观察Observable.create&lt;Int&gt;(sourceClown) .subscribe(observerBatMan) 嗯，果然 kotlin 还是看起来舒服。 这个例子非常简单了，数据源发送一个int值 1，然后接收者判断值是不是1。 现在开始分析源码了，先看 Observable 的 create 方法： Observable.java 该方法创建一个 Observeable 对象。分析完成之后，你就会发现实际上就是创建了一个 ObservableCreate 对象。 12345public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; // 这个是判空，嗯，没啥好说的，我一般用注解。 ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 套路一 别看有些人表面上风风光光，背地里却连只大熊猫都没有。 上面的 create 方法中，看起来有两行代码，感觉做了一些了不得的东西，但是实际上只有半行代码在起主要作用。 第二行代码的前半行： RxJavaPlugins.java 该方法在 onObservableAssembly 不会空的情况下会对 source 做一个变换，否则返回 source。 12345678public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 因为 onObservableAssembly 绝大部分情况下为空，其实就是返回了传进来的参数。所以该方法基本可以忽略。 需要注意，这个套路在源码中很常见。 所以最后，我们可以把 Observeable 的 create 方法理解为： Observable.java create 简化后的代码 123public static &lt;T&gt; Observable&lt;T&gt; create(@NotNull ObservableOnSubscribe&lt;T&gt; source) &#123; return new ObservableCreate&lt;T&gt;(source);&#125; 这样看是不是很简单！！！ 继续深入，看看 ObservableCreate 有何德何能！ ObservableCreate .java ObservableCreate 继承至 Observable。这个继承还有一个非常重要的作用，就是方便链式调用。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;...&#125; 别看 Observable 有1w 多行代码，但是实际上只有一个抽象方法，其他的都是用来做操作符等等。 下面来看看这个抽象方法，后面会分析到。 Observable.java 该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx); subscribe 就会调用 subscribeActual 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 套路二 遵循模板： 将source封装一下，变成一个 Observable 将 observer 封装一下，变成一个Emitter， 然后调用 source 的 onSubscribe 方法， 然后调用 source 的 subscribe 方法，将 Emitter 传进去。 其实只要你知道 observer 是谁，source 是谁，很简单的啦。 ObservableCreate 的核心代码就在这个被覆盖的抽象方法里面，嗯，一起来看看吧。 ObservableCreate.java 该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx); 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 看上面的代码，需要搞清楚几个变量，不然绕着绕着就糊涂了。 source 是我们创建并传递进来的。额，忘记贴构造函数了，里面有赋值，这个 source 就是我们在 create 方法里面创建的对象啦。 ObservableCreate.java 构造方法 123public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source;&#125; observer 这里暂时分析不出来，因为是父类调用了这个方法，所以我们去父类看看 Observable.java 这个方法的主要作用，就是将数据源与观察者关联起来 它还调用了 subscribeActual 方法，子类必须实现 subscribeActual 方法。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 使用套路一，我们简化一下代码： Observable.java subscribe 简化后的代码 12345678910111213 public final void subscribe(Observer&lt;? super T&gt; observer) &#123; try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; ... RxJavaPlugins.onError(e);... throw npe; &#125; &#125; 如果，是走正常流程，没有错误，还可以简化（第一次分析主流程，就是要这样简化简化再简化）： Observable.java subscribe 简化后的代码 1234public final void subscribe(Observer&lt;? super T&gt; observer) &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer);&#125; 实际上，RxJavaPlugins.onSubscribe 也含有套路一，所以再次简化： Observable.java subscribe 简化后的代码 12345public final void subscribe(Observer&lt;? super T&gt; observer) &#123; // 可以忽略 observer = observer; subscribeActual(observer);&#125; 所以，最终实际上 subscribe 方法，就是调用了 subscribeActual 方法而已，只不过它增加了错误与钩子处理。 看到这里，不知道你有没有反应过来，这个 subscribe(observer) 方法是不是很熟悉呢？ 这个方法，就是我们上面例子中的： 我们写的 demo 的代码 1234// 开始观察Observable.create&lt;Int&gt;(sourceClown) // 这里就是调用的 subscribe 方法 .subscribe(observerBatMan) 是不是有点恍然大悟的感觉呢！ 所以到这里，心里应该由一个大致框架了。 同时也会发现，ObservableCreate 的 subscribeActual 方法中的 observer 参数，也是我们new出来的对象。 分析到了这里，一个轮廓就出来了!!! ObservableCreate 的 subscribeActual 方法中的 参数分别对应如下： ObservableCreate.java ObservableCreate 继承至 Observable，所以它必须实现 subscribeActual 方法。 这个方法也是核心，是链式调用的核心，线程切换的核心 123456789101112131415@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // observer 就是 observerBatMan CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; // source 就是 sourceClown // 这个 subscribe 就将两个包装的观察者与数据源对象关联起来了 source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 如果，不考虑错误的情况，我们简化一下代码： ObservableCreate.java subscribeActual 简化后的代码 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // observer 就是 observerBatMan CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 调用 observerBatMan 的 onSubscribe 方法，这个是一个钩子方法 // 一般专门用来告诉 observerBatMan，我，sourceClown，要搞事情了 observer.onSubscribe(parent); // source 就是 sourceClown source.subscribe(parent);&#125; 由于，onSubscribe 我们暂时也不用，所以去掉，再简化： ObservableCreate.java subscribeActual 简化后的代码 123456@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 注意这里 subscribe 传递的是 parent source.subscribe(parent);&#125; 嘿嘿嘿，这样就舒服多了，就3个变量，两个是我们自己创建的，知根知底，还有一个货，CreateEmitter我们先放一放，为啥呢，因为关于 source 的代码还没有分析完成呢。 别看 source.subscribe(parent);就一行代码，但是由于 source 对象是我们自己创建的，所以这个方法实际上调用了我们写的代码： ObservableOnSubscribe.java 123public interface ObservableOnSubscribe&lt;T&gt; &#123; void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;&#125; ObservableOnSubscribe是一个接口，所以，我们实际上是创建了一个匿名内部类，传递给了 source，然后 source 又调用了 subscribe 方法，所以也就调用了我们写的代码。 嗯，用伪代码表示如下： 1234567891. 匿名内部类 = new ObservableOnSubscribe()&#123;&#125;2. oc = Observerable.create(匿名内部类)3. oc.subscribe(xxx)，这个方法会调用到 -&gt; subscribeActual4. subscribeActual 会调用到 -&gt; 匿名内部类.subscribe(emiiter)5. 我们的代码 我们自己写的 demo 代码 123// 这里的 it 是 ObservableEmitterit.onNext(1)it.onComplete() 那么，当 it.onNext(1) 执行之后，又会发生什么呢？ 这个 it 就是 CreateEmitter，嗯，虽然有点突然，但是这个应该没有疑问吧？！！ 我们把 sourceClown 传进去，并且调用了 ObservableEmitter 的 onNext 等方法 sourceClown 被封装成了 CreateEmitter source 的 subscribe 方法接收的是 CreateEmitter， 所以，ObservableEmitter 在运行时就是 CreateEmitter 对象。 我们先不忙着去看它的 onNext 方法，先看看这个类。 套路三 由老父亲来替你打理一切 我们知道在套路二里面，我们传递的 sourceClown 被封装了一下，变成了一个 CreateEmitter 。 CreateEmitter 这个变量名就很叼，一看就是 observer 的老父亲，那么，可以先猜一猜，为啥它要起这样一个名呢？ 由于ObservableOnSubscribe 的 subscribe方法只接受 ObservableEmitter ，所以 CreateEmitter 必须要实现这个接口。 好，我们看源代码： CreateEmitter.java 123static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123;...&#125; AtomicReference是java类，就不展开讲了，不知道的人（比如我）这个时候应该打开了文档，开始学习了。 继续看构造方法： CreateEmitter.java 123CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer;&#125; 嗯，很好，observer 被保存起来了。 由于，在 sourceClown 中我们调用了： 我们写的 demo 的代码 1it.onNext(1) 上面说过，it 就是 CreateEmitter，所以 CreateEmitter的 onNext 方法会被调用。 现在，我们来分析它的 onNext 方法： CreateEmitter.java 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; RxJava2 中不允许数据源发射的数据为 null，所以我们简化一下： CreateEmitter.java onNext 简化后的代码 123456@Overridepublic void onNext(T t) &#123; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法，就是判断观察者有没有解除订阅，毕竟，蝙蝠侠也会心累。 这上面做了这么多判断，现在知道为啥起名叫 parent 了不？ 在我们的例子中，我们没有解除订阅，再简化一下，就是： CreateEmitter.java onNext 简化后的代码 1234@Overridepublic void onNext(T t) &#123; observer.onNext(t);&#125; 这下，够直白了吧，直接调用了 observer 的 onNext 方法。 还记得 observer 是谁吗，就是你，蝙蝠侠，observerBatMan。所以它的 onNext 方法会被调用。 我们写的 demo 的代码 123override fun onNext(t: Int) &#123; Assert.assertEquals(1, t)&#125; 那么，整个流程就跑通了。 至于，onComplete 方法，差不多的啦。 最后上一张图： 最后，还有一个很重要的东西，就是这个小demo 的起始点，并不是 sourceClown，上面的图不是程序执行流程图，而是一种关系图。 现在我们来看看，程序的起始点在哪？ 我们写的 demo 代码 123// 开始观察Observable.create&lt;Int&gt;(sourceClown) .subscribe(observerBatMan) 程序的起始点是 subscribe 方法，这个方法是属于 ObservableCreate 的，所以程序的起始点在 ObservableCreate 的 subscribe 方法。 下面，贴上程序执行流程图：]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（四）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的本篇主要分析 RxJava2 中的线程池与线程调度时的源码流程。顺便介绍RxJava2中常用的几个线程池。上一篇文章，我们的demo中，指定线程时，使用的是 Schedulers 这个类。那我们直接从这个类入手。 Schedulers.java 12345/** * Static factory methods for returning standard Scheduler instances. * &lt;p&gt; */public final class Schedulers &#123;...&#125; 一般看一个类的时候，先看注释会让你对这个类又一个全局的概念，它起一个什么作用。 上面的注释说的比较清楚了，它是一个工厂方法，返回一些 Scheduler 对象的实例。 那么下面我们看看 Scheduler 类。 Scheduler.java 这个类提供了API，用来调度工作单元。你可以指定延迟时间，周期性。 我们可以想到很多别的东西，Timer，Executors.newScheduledThreadPool(2)等等 1public abstract class Scheduler &#123;...&#125; 这个类的代码不多，我们打开 Structure 视图，可以看到该类的一个结构，这里展示一下 Scheduler 最核心的定义部分： Scheduler.java 12345678910111213141516171819202122232425262728293031323334public abstract class Scheduler &#123; @NonNull public abstract Worker createWorker(); public Disposable scheduleDirect(@NonNull Runnable run) &#123; ... &#125; public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; ... &#125; @NonNull public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) &#123; ... &#125; public abstract static class Worker implements Disposable &#123; @NonNull public Disposable schedule(@NonNull Runnable run) &#123; ... &#125; @NonNull public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit); @NonNull public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; ... &#125; &#125;&#125; 从上面的定义可以看出，Scheduler 本质上就是用来调度 Runnable 的，支持立即、延时和周期形式的调用。 我们从其中一个方法入手，就选择最简单的 public Disposable scheduleDirect(@NonNull Runnable run) {...} 方法。分析完这个方法之后，在看其他的方法，应该就是差不多的了。 Scheduler.java 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 上面说过，Scheduler 支持延迟调用，那么这里传递0，就表示不延迟。 Scheduler.java 123456789101112131415public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; // ① 创建了一个 Worker final Worker w = createWorker(); // 装饰一下，但是通常会将 run 原封不动的返回 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // ② 创建 Task DisposeTask task = new DisposeTask(decoratedRun, w); // ③ 执行 task w.schedule(task, delay, unit); return task;&#125; 上面的代码中，我加了一点注释，下面来一行一行的分析。 io.reactivex.Scheduler#scheduleDirect(java.lang.Runnable, long, java.util.concurrent.TimeUnit) 1final Worker w = createWorker(); 由于，Scheduler 是一个抽象类，所以只有它的子类才知道具体的实现，这里我们用 Schedulers.io 为例。 由于篇幅问题，如果这里深入的话，会很容易丢失目标，所以我将 IoScheduler 这个类的分析提出来了，放到了[另外一篇文章](https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-源码解析/RxJava2/RxJava2 源码分析（2.5）.md)中。 看完这篇文章之后，就知道 Worker 有点像命令，它里面指定了任务需要执行的线程池（因为Worker是Scheduler的子类创建的，Scheduler的子类创建了自己的线程池），当我们调用 work.schedule 的时候，就会将任务交给work中指定的线程池去执行。 这样一来，①处与③处的代码都说清楚了。现在还剩②处的代码。看看 DisposeTask 这个类吧。 DisposeTask DisposeTask 看它的构造方法与类结构，可以大概猜到它可能会起一个代理委托的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142static final class DisposeTask implements Runnable, Disposable &#123; final Runnable decoratedRun; final Worker w; Thread runner; DisposeTask(Runnable decoratedRun, Worker w) &#123; this.decoratedRun = decoratedRun; this.w = w; &#125; @Override public void run() &#123; runner = Thread.currentThread(); try &#123; // 运行 task 中的代码 decoratedRun.run(); &#125; finally &#123; // 执行完之后，调用 dispose dispose(); runner = null; &#125; &#125; @Override public void dispose() &#123; if (runner == Thread.currentThread() &amp;&amp; w instanceof NewThreadWorker) &#123; // 如果 worker 是 NewThreadWorker，则关闭自己 ((NewThreadWorker)w).shutdown(); &#125; else &#123; // 调用 worker 的 dispose // 之前我们分析过 IoScheduler.EventLoopWorker 类 // 它的 dispose 会将自己重新放到线程池中，重复利用 w.dispose(); &#125; &#125; @Override public boolean isDisposed() &#123; return w.isDisposed(); &#125;&#125; 所以这个类的主要作用是起到一个让 worker 重复利用的作用，但是这只是针对 IoScheduler 的 Worker 来说，别的 Worker 可能会不一样。 因为它调用了 Worker 的 dispose 方法，所以 Worker 的收尾工作可以全部放到这个方法中。 Scheduler类的重要方法都分析完了，其他的方法，就交给你们了。看完了这几篇文章，你应该具有了能够看懂其他 Scheduler 的能力，GOOD LUCK !!! 参考文档https://juejin.im/post/5b75207ce51d45565d23e093]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（二）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的这篇文章的主要目的就是弄清楚链式调用与线程切换。如果你读懂了第一篇文章，这篇文章阅读起来还是非常简单的。因为链式调用和线程切换无非就是多了些 “数据源-观察者” 对。线程切换还涉及到线程池相关的东西，由于篇幅问题，线程池相关的东西会放到下一篇。从一个例子开始：1234567891011121314151617181920212223242526272829303132333435363738 // 观察者 -- 蝙蝠侠 val observerBatMan = object : Observer&lt;Int&gt; &#123; override fun onComplete() &#123; &#125; override fun onNext(t: Int) &#123; System.out.println(Thread.currentThread().name + "--observer") &#125; override fun onError(e: Throwable) &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125; &#125; // 数据源 -- 小丑 val sourceClown = ObservableOnSubscribe&lt;Int&gt; &#123; it.onNext(1) it.onComplete() System.out.println(Thread.currentThread().name + "--source") &#125; // 开始观察 Observable // ① .create&lt;Int&gt;(sourceClown) // ② 指定数据源执行的线程 .subscribeOn(Schedulers.computation()) // ③ 指定观察者执行的线程 .observeOn(Schedulers.io()) // ④ .subscribe(observerBatMan)&#125; 嗯，和上一篇文章的例子差不多，就多了几行线程切换而已，我们先给出数据的日志。有一个大致的印象，再来深入分析。 12RxComputationThreadPool-1--sourceRxCachedThreadScheduler-1--observer demo 里面的 ② 处有了第一篇的基础，那么我们直接从 demo 里面的 ② 处入手： Observable.java 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 你使用了套路一，效果拔群，得到结果如下： Observable.java 简化之后的 subscribeOn 代码，实际上就是创建并返回了一个 ObservableSubscribeOn 对象 123public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; return new ObservableSubscribeOn&lt;T&gt;(this, scheduler);&#125; 我们继续看 ObservableSubscribeOn。 ObservableSubscribeOn.java AbstractObservableWithUpstream.java 12345// ObservableSubscribeOn 继承了 AbstractObservableWithUpstreampublic final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123;...&#125;// AbstractObservableWithUpstream 继承了 Observableabstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123;...&#125; 所以，ObservableSubscribeOn 最终还是继承至 Observable的。 在第一篇文章中，我们分析的对象是 ObservableCreate，而现在我们分析的对象是 ObservableSubscribeOn。为了能够更加清晰的列出不同点，还是搞一个表格吧： ObservableSubscribeOn ObservableCreate 直接父类 AbstractObservableWithUpstream（最终还是继承 Observable） Observable 构造方法参数个数 两个：(ObservableSource&lt;T&gt; source, Scheduler scheduler) 一个：(ObservableOnSubscribe&lt;T&gt; source) 主要的不同点，还是在构造参数这里。 参数个数不同，这个好理解，因为需要切换线程，肯定需要指定切换到哪个线程，所以多一个参数 source 类类型不同，这个需要深入分析，往下看 看看 source 类有哪些不同之处： ObservableOnSubscribe.java ObservableSource.java 1234567public interface ObservableOnSubscribe&lt;T&gt; &#123; void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;&#125;public interface ObservableSource&lt;T&gt; &#123; void subscribe(@NonNull Observer&lt;? super T&gt; observer);&#125; 这两个类都是接口，都只有一个 subscribe 方法，看起来比较类似。 除了类名不同之外，就只有方法的参数不同了。 ObservableOnSubscribe 接收的参数 ObservableEmitter，上一篇文章说过，是将 Observer 包装了一层。 ObservableSource 直接接收了 Observer，嗯，很牛逼，后面我们来分析看看，它为啥不要包装，你也可以思考一下，嘿嘿嘿。 经过上面的分析，总的来说，区别不大，所以我们仍然可以套第一篇的套路来分析。 到这里先上个图，为后面做好心理准备。 demo 里面的 ③ 处接下来，我们看 demo 里面的 ③ 处： Observable.java 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; 调用了同名方法： Observable.java 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 使用套路一，简化代码： Observable.java observeOn 简化后的代码 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; return new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize);&#125; 可以看出，实际上就是创建了一个 ObservableObserveOn 对象。 看看这个对象吧，不出意外，和 ObservableOnSubscribe 应该很像。 先看类的结构： ObservableObserveOn.java 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123;...&#125; 与 ObservableOnSubscribe 一样，继承同一个类。 再看类的构造方法： ObservableObserveOn.java 123456public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) &#123; super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize;&#125; 这个方法的参数就更多了，前面两个我们应该熟悉了，看看后面的两个参数是什么意思。虽然这里没有注释，但是这个参数的值是从别处传来的，所以只要找到源头，还是可以找到相关注释的。 delayError 1indicates if the onError notification may not cut ahead of onNext notification on the other side of the scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received from upstream 额，我只能明白一个大概：若存在Error事件，则如常执行，执行完后再抛出错误异常 bufferSize 缓存大小，暂时还不知道缓存在哪里，所以先放着。 到了这里，我们再上一个图吧，后面的流程要起飞了。 demo 里面的 ④ 处接下来，就到了一个转折点，就是 demo 中的 ④ 处，它调用了 subscribe 方法。 在第一篇中，我们分析过，subscribe 方法会调用 subscribeActual 方法，所以这里，我们直接进入到 ObservableObserveOn 的 subscribeActual 方法中，看看它做了什么。 ObservableObserveOn .java 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 由于，我们传递的 scheduler 肯定不是 TrampolineScheduler，所以会直接进入到 else 分支。 else 分支里面的代码也很简单，我们先跳过线程池相关的东西，所以需要分析的就只有一行代码： ObservableObserveOn.java subscribeActual 方法的 else 分支 1source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); 按照套路二，ObserveOnObserver 其实就是对 observer 做了一个包装。 这个 observer 就是我们自己创建的 observerBatMan，上个图： 现在比较绕的是，ObservableObserveOn 类中的 subscribeActual 方法中的 source 变量是谁。由于 source 是从构造函数传递进来的，我们再回到 Observerable 的 observeOn 方法： Observable.java 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 可以看到，在创建 ObservableObserveOn 对象的时候，第一个参数传递的是 this。 这里有一个稍微绕的点，因为 observerOn 方法是 ObservableSubscribeOn 对象调用的，所以 this，指向的是 ObservableSubscribeOn。 所以，这里相当于 ObservableObserveOn 是一个桥梁，让 ObservableSubscribeOn 与 ObservableOnObserve 搭上了关系。 上一个图： 同样的，我们再来分析 ObservableSubscribeOn类的 subscribeActual 方法： ObservableSubscribeOn.java 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这个 subscribeActual 内部的代码风格与想象的完全不一样啊，虽然前2行很熟悉，但是第3行完全没见过啊。 现在，我们来分析第3行代码，先看 parent.setDisposable(xxx)： SubscribeOnObserver.java 123void setDisposable(Disposable d) &#123; DisposableHelper.setOnce(this, d);&#125; DisposableHelper.java 该方法，用来将 field 的值，设置为 d。 如果，设置的时候，field 已经有值了，返回false。 如果 field 有值， 并且值不是 DISPOSED，抛出异常。 123456789101112public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; // 抛出异常 reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这样来看，其实 parent.setDisposable(xxx)这行代码也没做什么，正常情况下，就是将 scheduler.scheduleDirect(new SubscribeTask(parent)) 的值设置给了 parent。 下面，继续看 scheduler.scheduleDirect()做了什么，由于篇幅问题，这里不分析线程池的东西，只说一下这个方法的作用，其实就是将一个 runnable，放到线程池中去执行，这里可以知道，线程切换了。 再继续，看看 SubscribeTask 类： SubscribeTask.java 1234567891011121314151617public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; ... // 内部类 final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; // source 变量是 ObservableSubscribeOn 的变量 source.subscribe(parent); &#125; &#125;&#125; 继承了 Runnable，在 run 方法中，我们终于看到了 subscribe 方法。 继续深入，看看 source 对象是谁： Observable.java 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; source 参数传递的是this，所以 source 对象是 ObservableCreate 对象。 到这里，还可以解释上面的问题：为啥 ObservableSource 的 subscribe 方法的参数是一个 Observer？ ObservableSource.java 为了方便，我又把这个接口代码贴了一遍 123public interface ObservableSource&lt;T&gt; &#123; void subscribe(@NonNull Observer&lt;? super T&gt; observer);&#125; 在我们的例子中，observer 参数就是 ObservableCreate 对象。 其实，从这个类名都可以看出 ObservableSource 这个接口表示的是数据源，因为 Observerable 类就实现了这个接口，所以这个接口的 subscribe 方法的实现就是 Observable 的内部实现。 当我们调用 subscribeOn 与 observeOn 这两个方法的时候，其实是将调者这做为数据源的意思。 另外，可以推出 ObservableOnSubscribe 这个接口，应该是专门用来处理数据源的源头的（方便我们调用 emitter.onNext 等方法），两个接口的意义不一样。 所以，我们可以得到这样的一个图： 把这几个类，整合到调用图里面，得到如下图： 上面的图，看起来还算清晰，但是没有线程切换的内容，下面会说到。 与上一篇一样，我们再来整理一下这个demo的执行流程图，你可以先自行想一下这个图应该是什么样子的。 图中灰色的长方体，表示的是调用 subscribeOn 与 observerOn 产生的 “数据源-观察者”对。 图中 subscribeOn 蓝色方块表示的是 subscribeOn 指定的线程切换的地方，可以看到，它指定的线程会影响到后续的所有流程。 图中 observerOn 黄色的方块表示的是 observerOn 指定的线程切换的地方，它会影响后续流程。 在回想一下，其实每次 observerOn 或者 subscribeOn 都创建了一个链条一样的节点，然后在 subscribeActual 将这些节点连接起来： 好了，这篇文章的东西就差不多了，关于线程剩下的东西，本章中都只是一笔带过，详细的内容，留到下一篇。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（六）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的分析Flowable的相关源码，了解一下背压的知识。从例子开始 demo 123456789Flowable .create&lt;Int&gt;(&#123; it.onNext(1) it.onNext(2) it.onComplete() &#125;, BackpressureStrategy.BUFFER) .subscribe &#123; System.out.println(it) &#125; 看看 create 方法创建了一个什么对象： Flowable io.reactivex.Flowable#create 12345public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) &#123; ObjectHelper.requireNonNull(source, "source is null"); ObjectHelper.requireNonNull(mode, "mode is null"); return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));&#125; 创建了一个 FlowableCreate 对象，由于 Flowable 与 Observerable 差不多，所以下面我们按照分析 Observerable 的思路来分析 Flowable。 ####FlowableCreate 类结构 1public final class FlowableCreate&lt;T&gt; extends Flowable&lt;T&gt; &#123;...&#125; 这个没啥说的，与 Observerable 一样。 构造函数 1234public FlowableCreate(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy backpressure) &#123; this.source = source; this.backpressure = backpressure;&#125; 也与 Observerable 差不多，就是两套代码吧。一个以 Observerable 开头，一个以 Flowable 开头，嗯，现在我对源码的探究就只到了这个程度，可能还有别的不同，暂时还未发现。 subscribeActual 方法 demo 中 backpressure 我们传递的是 BackpressureStrategy.BUFFER，所以 emitter 的值是 BufferAsyncEmitter。 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void subscribeActual(Subscriber&lt;? super T&gt; t) &#123; BaseEmitter&lt;T&gt; emitter; switch (backpressure) &#123; case MISSING: &#123; emitter = new MissingEmitter&lt;T&gt;(t); break; &#125; case ERROR: &#123; emitter = new ErrorAsyncEmitter&lt;T&gt;(t); break; &#125; case DROP: &#123; emitter = new DropAsyncEmitter&lt;T&gt;(t); break; &#125; case LATEST: &#123; emitter = new LatestAsyncEmitter&lt;T&gt;(t); break; &#125; default: &#123; // 走这里 emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize()); break; &#125; &#125; // 下面的就不分析了，参考前面的文章 t.onSubscribe(emitter); try &#123; source.subscribe(emitter); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); emitter.onError(ex); &#125;&#125; 所以，我们只需要分析 BufferAsyncEmitter 这个类就好了。 ####FlowableCreate.BufferAsyncEmitter 类结构 这个类是 FlowableCreate 的内部类，可以想到其他的 Emitter 应该也是内部类 继承了 BaseEmitter 1static final class BufferAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; &#123;...&#125; ####FlowableCreate.BaseEmitter 类结构 注意这个类继承至 AtomicLong 123abstract static class BaseEmitter&lt;T&gt;extends AtomicLongimplements FlowableEmitter&lt;T&gt;, Subscription &#123;...&#125; 这个类实现了一些通用的方法，比如 onError，onComplete，cancel等等。 其中只有一个方法需要看看： BaseEmitter#request 1234567891011@Overridepublic final void request(long n) &#123; // 判断 n 是不是正数 if (SubscriptionHelper.validate(n)) &#123; // 是正数，将 n 设置给自己 // 上面有说，这个类继承了 AtomicLong，所以它可以持有一个 Long 型的引用 BackpressureHelper.add(this, n); // 钩子方法 onRequested(); &#125;&#125; 好了，到这里 BaseEmitter 的方法就分析的差不多了，这个类只是提供了一些默认的实现方法，没有别的逻辑，把它当成一个普通的父类就好了。 ####FlowableCreate.BufferAsyncEmitter 再回到 BufferAsyncEmitter 里面，看构造函数 构造函数 123456BufferAsyncEmitter(Subscriber&lt;? super T&gt; actual, int capacityHint) &#123; super(actual); // 这里有一个新类 this.queue = new SpscLinkedArrayQueue&lt;T&gt;(capacityHint); this.wip = new AtomicInteger();&#125; SpscLinkedArrayQueue 这个类不展开介绍了，贴一段注释就明白了。 123A single-producer single-consumer array-backed queue which can allocate new arrays in case the consumer is slowerthan the producer.一个单生产者单消费者数组支持的队列，它可以在消费者比生产者慢的情况下分配新的数组（自动增长）。 机翻都能看的懂吧，源码就是实现了这样功能的队列，有兴趣的可以看看。 我们把 SpscLinkedArrayQueue 当成一个队列就好。注意这里的初始容量是 128，但是会自动增长。 看完构造方法，再看 onNext 方法。 onNext 12345678910111213141516171819202122@Overridepublic void onNext(T t) &#123; // isCancelled 是父类的方法 // 当我们调用 setDisposable 方法的时候，父类就会保存这个 Disposable 的引用到 serial 字段 // 如果该 Disposable 调用了 dispose 方法，那么 isCancelled 会返回 true // 调用父类的 cancel 方法，isCancelled 也会返回 true（内部调用了 serial.dispose()） // 数据发送完毕或者发生错误，isCancelled 也会返回 true（内部调用了 serial.dispose()） // done 只有数据发生完毕或者发生错误才会为true if (done || isCancelled()) &#123; return; &#125; // 不允许发送的数据为null if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; // 先将数据添加到队列里面 queue.offer(t); // 调用 drain 方法 drain();&#125; 看来，onNext 的主要目的，就是先将数据加入到队列里面，然后调用 drain 方法。继续看 drain 方法。 drain 这个方法有点长，变量名也有点蛋疼，但是慢慢分析，不难 在阅读源码的时候，一定要有耐心。阅读源码的过程其实是一个提升自己理解力的过程。 既然你需要阅读别人的源代码，那么你的理解力肯定是处于弱势的，不然的话，你一看就懂，那就说明源码的东西在作者写出来之前你都已经掌握了，那么阅读源码对自己没有任何好处。 所以，阅读源码的过程，就是需要慢慢提升自己的理解力，来达到与作者的理解力一样的程度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100void drain() &#123; // wip 这个变量到后面分析，因为涉及到别的方法，单看这一个方法看不出什么东西来 if (wip.getAndIncrement() != 0) &#123; return; &#125; int missed = 1; // 这两个变量名有点吊 final Subscriber&lt;? super T&gt; a = actual; final SpscLinkedArrayQueue&lt;T&gt; q = queue; for (;;) &#123; // 这里，获取设置的引用值，因为这个类是继承的 AtomicLong // 前面我们分析过，只有 request 方法才会设置引用值 // 至于哪里调用了 request 方法，我们后面分析 // 这里将这个值当作 Long.MAX_VALUE long r = get(); long e = 0L; // 进入循环 while (e != r) &#123; // 判断是否取消了 if (isCancelled()) &#123; // 取消了就清空队列 q.clear(); return; &#125; // 时候发送完毕了，或者出现了错误 boolean d = done; // 从队列中取出一个数据 T o = q.poll(); // 队列是否为空 boolean empty = o == null; // 数据发送完毕了，并且队列为空 if (d &amp;&amp; empty) &#123; Throwable ex = error; if (ex != null) &#123; // 调用父类 error 方法，会调用 onError error(ex); &#125; else &#123; // 调用父类 complete 方法，会调用 onComplete complete(); &#125; return; &#125; // 队列为空，则跳出循环 if (empty) &#123; break; &#125; // 调用 onNext 方法，o 是从队列取出来的数据 a.onNext(o); // e 的值累加 e++; &#125; // 这里要判断一下 e 与 r 是否相等， // 因为如果队列为空的话，e 是不等于 r 的 // 相等的话，说明请求的个数刚好等于发送的个数，做一下收尾工作就好了 if (e == r) &#123; // 下面的一段与上面的很相似，不一句一句写了 if (isCancelled()) &#123; q.clear(); return; &#125; boolean d = done; boolean empty = q.isEmpty(); if (d &amp;&amp; empty) &#123; Throwable ex = error; if (ex != null) &#123; error(ex); &#125; else &#123; complete(); &#125; return; &#125; &#125; if (e != 0) &#123; // 因为发送了 e 个数据，所以将引用值更新 // 内部就是将引用自减少了 e BackpressureHelper.produced(this, e); &#125; // 这个后面分析 missed = wip.addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; drain 的主要作用，就是当我们调用 request(num) 请求 num 个数据的时候，这个方法会从队列中取出 num 个数据出来给我们。 可以思考一下，如果我们没有调用，request 方法，会怎么样？ drain 简化后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142void drain() &#123; ... for (;;) &#123; long r = get(); long e = 0L; // 没有调用 request，导致 r 为 0，这里进不去 while (e != r) &#123; ... &#125; // 相等 if (e == r) &#123; // 没有取消 if (isCancelled()) &#123; ... &#125; boolean d = done; // 队列不为空 boolean empty = q.isEmpty(); // 进不去 if (d &amp;&amp; empty) &#123; ... &#125; &#125; // 进不去 if (e != 0) &#123; ... &#125; missed = wip.addAndGet(-missed); // 满足，跳出循环 if (missed == 0) &#123; break; &#125; &#125;&#125; 可以看到，如果我们没有调用 request 方法，虽然 onNext 方法被调用了，将数据加入到了队列中，但是却无法从队列中取出数据，即下游的观察者收不到任何数据。 还有两个遗留的问题： wip 变量的作用？ request 方法在哪里调用的？ 先看第一个问题： drain 123456789101112131415161718192021222324 void drain() &#123; // 将值加 1，返回未加 1 之前的值 // 就是判断 wip 的引用值是否是0，然后加1 if (wip.getAndIncrement() != 0) &#123; return; &#125; // 到了这里 wip 引用的值理论上为1 // 但是多线程的情况下， onUnsubscribed 会将 wip 加 1 int missed = 1; ... for (;;) &#123; ... // 将 wip 的值减 - missed // 这里处在一个循环中，最终 wip 的值会变成 0，missed 也会变成0，跳出循环 missed = wip.addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125; &#125;&#125; onUnsubscribed 123456789@Overridevoid onUnsubscribed() &#123; // 取消的时候，wip 的值为 0 的话，清空队列 // 就是说，此时，drain 方法运行到了 for 循环的最后几行 // 这里应该是为了保证，数据从队列里面取出来，一定要发送出去才行 if (wip.getAndIncrement() == 0) &#123; queue.clear(); &#125;&#125; 在 BufferAsyncEmitter 这个类中，使用到 wip 这个变量的，只有上面这几个地方。 onUnsubscribed 会在父类的 cancel 方法中调用，所以我们调用 cancel 就会改变 wip 的值： FlowableCreate.BaseEmitter cancel 12345@Overridepublic final void cancel() &#123; serial.dispose(); onUnsubscribed();&#125; 好了，第一个问题说完了，我们来看看第2个问题： 首先我们回到 demo 中，既然 create 方法中没有调用 request 的地方，那么我们只能从 subscribe 方法入手了。 ####Flowable io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;) 1234public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123; return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);&#125; 它调用了名方法： io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;, io.reactivex.functions.Consumer&lt;? super java.lang.Throwable&gt;, io.reactivex.functions.Action, io.reactivex.functions.Consumer&lt;? super org.reactivestreams.Subscription&gt;) 12345678910111213public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123; ObjectHelper.requireNonNull(onNext, "onNext is null"); ObjectHelper.requireNonNull(onError, "onError is null"); ObjectHelper.requireNonNull(onComplete, "onComplete is null"); ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null"); LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls;&#125; 创建了一个 LambdaSubscriber 对象，并调用了 subscribe 方法，将 ls 传递了进去。 所以这个方法其实就是将我们的 consumer 包装成了 LambdaSubscriber，然后调用真正的 subscribe 方法。 LambdaSubscriber看看 LambdaSubscriber 类： 构造方法 123456789public LambdaSubscriber(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123; super(); this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onSubscribe = onSubscribe;&#125; 保存了一些变量，onSubscribe 值得注意，因为这个 Consumer 在订阅的时候会回调，是调用 request 的最好时机。 直接看 onSubscribe 的实现。 onSubscribe 123456789101112@Overridepublic void onSubscribe(Subscription s) &#123; if (SubscriptionHelper.setOnce(this, s)) &#123; try &#123; onSubscribe.accept(this); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.cancel(); onError(ex); &#125; &#125;&#125; 这里调用了 onSubscribe 对象的 accept 方法。我们看看这个对象的实现吧。 FlowableInternalHelper.RequestMax.INSTANCE从前面的代码中（Flowable.subscribe()方法中），我们知道 onSubscribe 对象是 FlowableInternalHelper.RequestMax.INSTANCE。所以看看这个类的代码吧。 FlowableInternalHelper.RequestMax.INSTANCE 1234567public enum RequestMax implements Consumer&lt;Subscription&gt; &#123; INSTANCE; @Override public void accept(Subscription t) throws Exception &#123; t.request(Long.MAX_VALUE); &#125;&#125; 嗯，果然是这里调用了 request 方法。 到这里，Flowable 的分析就告一段落。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（五）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的本文主要分析操作符的实现原理，关于操作符的使用不做讲解，想了解的可以参考Github上的例子项目以及官方文档。从一个例子开始这里我们以最常用的 map 为例。首先我们写一个demo： Demo 这个demo演示了如何将一个int转成string。Kotlin 赛高！！！ 虽然看起来没有什么屌用，但是如果int值是一个图片的资源id，我们要将这个id转成一个Bitmap，那么也可以用map操作法，再配上前几篇文章说的线程切换，岂不美哉！~ 1234567Observable.just(1).map &#123; // map 的作用主要是做一个变化，这里是将发射的 int 值变成 string "$it-covert"&#125;.subscribe &#123; // 打印接收到的 string System.out.println(it)&#125; 这个为了简单我用到了 just 操作符，其实和 create 差不多，如果你强迫症想搞清楚，可以自己戳戳源码，前面的文章如果你真的看懂了，戳进去几分钟就知道它的原理啦。 这里我们直接从 map 方法开始分析： Observable Observable 1234public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, "mapper is null"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; 按住 ctrl 键，点击鼠标左键： ObservableMap 类结构 它也是继承了 AbstractObservableWithUpstream，这个是我们的老相好了，就不介绍了 1public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123;...&#125; 下面看构造函数： 构造函数 123456public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; // source 不多说 super(source); // 这里就是我们做变换的函数 this.function = function;&#125; 接下来就是看 subscribeActual 方法了，看，只要掌握了套路，分析起源码来，还是比较轻松的。 subscribeActual 方法 1234@Overridepublic void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function));&#125; 这个方法很直接，不做作，直接将 t 与 functiaon 全部扔进 MapObserver 里面，交给 MapObserver 去处理。下面来分析分析 MapObserver 这个类。 ObservableMap.MapObserver 类结构 MapObserver 继承了 BasicFuseableObserver 1static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123;...&#125; BasicFuseableObserver书里说过，信息太多与信息太少，都会对理解力造成阻碍。 这个类的蛋疼之处就在于，里面的代码不多，很简单，但是又没简单到你可以一下子就能明白这个类的作用。所以如果我把这个类的代码贴出来，作用也不大，我说不出一个道道来。 这里我说一下我自己对这个类的理解： 1Base class for a fuseable intermediate observer. 上面的一串英文是类的注释，翻译过来就是说 一个用于可融合的中间观察者的基类，反正我还是没太明白。 既然它是一个中间观察者，我们就看看它作为一个“中介”，搞了一些啥事情。 BasicFuseableObserver#onSubscribe 在这个方法里面，它作为第三者，插入到了原来的 parent 与 observer 之间 1234567891011121314151617181920212223242526@Overridepublic final void onSubscribe(Disposable s) &#123; // 该方法用于判断 this.s 为 null，并且 s 不为 null if (DisposableHelper.validate(this.s, s)) &#123; // 这行代码很重要 this.s = s; // QueueDisposable 是一个接口，后面会讲 if (s instanceof QueueDisposable) &#123; this.qs = (QueueDisposable&lt;T&gt;)s; &#125; // 这里有两个钩子 if (beforeDownstream()) &#123; // 调用了 actual 的 onSubscribe // 这个方法我们在之前分析 subscribeActual 方法的时候，都是跳过的 // 下面我们会分析这个方法的作用 actual.onSubscribe(this); afterDownstream(); &#125; &#125;&#125; 由于在之前的文章中，我们忽略了 onSubscribe，而这个类用到了这个方法，所以现在我们拿 ObservableCreate 来分析一下 onSubscribe 这个方法的作用。 ObservableCreate ObservableCreate#subscribeActual 1234567@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); ...&#125; 其实从这两行代码就可以看出，onSubscribe 的参数就是我们的老父亲 parent。 之前我们说过，CreateEmitter 就是将 observer 包装了一下，即 CreateEmitter 持有 observer 。 现在看 onSubscribe 方法就是反过来，即 observer “参数持有” CreateEmitter 。 让我们再次回到 BasicFuseableObserver 类中的 onSubscribe 方法里面： ####BasicFuseableObserver BasicFuseableObserver#onSubscribe 12345678// 这行代码很重要// s 是原来的 parent，它把这个对象保存起来this.s = s;// actual 是我们 demo 中创建的匿名内部类（虽然真正的情况是将 consumer 包成了 observer）// 将 this 作为 parent 传递进去// 所以，这样他就成了一个中间观察者actual.onSubscribe(this); 上面的代码，你可以联想一下链表的插入操作。 前面的文章里面，onSubscribe 的调用都是放在 subscribeActual 中的，这里为啥要放到 Observer 类里面呢？我猜想是因为操作符会导致数据源的不稳定（同步，异步数据），因为 BasicFuseableObserver 还实现了 QueueDisposable 这个接口，这个接口类注释比较多，可以详细看看。 那么，分析到了这里，我们就将 MapObserver 当作一个普通的 Observer 的包装类来看待吧。反正这里我们还用不到里面的 poll 方法。 ObservableMap.MapObserver我们直接看 onNext 方法： onNext 这里该方法由 MapObserver 的包装类调用，我们了解了套路，更不需要从头跟踪源码，就知道它由谁调用。只要知道它会被调用，在具体的代码中会被谁调用，分析源码的时候管他调用者是谁呢。 123456789101112131415161718192021222324@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; // 在这个 demo 中，sourceMode 一直为 NONE if (sourceMode != NONE) &#123; actual.onNext(null); return; &#125; U v; try &#123; // 这里就执行变化了，注意变换结果不能返回null v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value."); &#125; catch (Throwable ex) &#123; fail(ex); return; &#125; // 将变化的结果返回 actual.onNext(v);&#125; 嗯，到这里，demo的流程就分析完了，还是很简单的，主要是例子简单。 其实，该类还有一个 poll 方法，应该会在某些情况下调用，这里没有用到，里面的水应该还有点深。 其他的操作符，这里就不讲了。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FileProvider]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FFileProvider%2F</url>
    <content type="text"><![CDATA[从 Android N（7.0） 开始，将严格执行 StrictMode 模式，也就是说，将对安全做更严格的校验。而从 Android N 开始，将不允许在 App 间，使用 file:// 的方式，传递一个 File ，否者会抛出 FileUriExposedException 的错误，会直接引发 Crash。只能使用FileProvider 将file:// 替换为 content://。 FileProvider 本质上就是一个 ContentProvider ，它其实也继承了 ContentProvider 的特性。ContentProvider 其实就是在可控的范围内，向外部其他的 App 分享数据。而 FileProvider 将这样的数据变成了一个 File 文件而已。 下面的代码演示了如何使用 FileProvier： 12345678910111213141516&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapp"&gt; &lt;application ...&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.myapp.fileprovider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths" /&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; provider 标签下，配置了几个属性： name ：配置当前 FileProvider 的实现类。 authorities：配置一个 FileProvider 的名字，它在当前系统内需要是唯一值。 exported：表示该 FileProvider 是否需要公开出去，这里不需要，所以是 false。 granUriPermissions：是否允许授权文件的临时访问权限。这里需要，所以是 true。 在配置 Provider 的时候，还需要额外配置一个 &lt;meta-data/&gt; 标签，它用于配置 FileProvider 支持分享出去的目录。这个 &lt;meta-data/&gt; 标签的 name 值是固定的，resource 需要指向一个 根节点为 paths 的 xml 资源文件。在 src/main/res/xml/文件夹下面: 1234&lt;paths&gt; &lt;!-- 表示 files/images/myimages 下的路径 --&gt; &lt;files-path path="images/" name="myimages" /&gt;&lt;/paths&gt; path下面可以配置多个节点： root-path：表示根目录，『/』。 files-path：表示 content.getFileDir() 获取到的目录。 cache-path：表示 content.getCacheDir() 获取到的目录 external-path：表示Environment.getExternalStorageDirectory() 指向的目录。 external-files-path：表示 ContextCompat.getExternalFilesDirs() 获取到的目录。 external-cache-path：表示 ContextCompat.getExternalCacheDirs() 获取到的目录。 具体可以参考 FileProvider 的官方说明文档 。 定义好需要分享的文件之后，在ClientApp请求文件的时候，我们就可以返回一个 Uri 给它。 1234567891011val requestFile = File(imageFilenames[position])val fileUri: Uri? = try &#123; FileProvider.getUriForFile( this@MainActivity, "com.example.myapp.fileprovider", requestFile)&#125; catch (e: IllegalArgumentException) &#123; Log.e("File Selector", "The selected file can't be shared: $requestFile") null&#125; 获取文件的 Uri 一定要使用 FileProvider.getUriForFile 这个方法，不要使用Uri.fromFile()这个方法。因为这个方法要求 ClientApp 具有读权限，并且无法跨App分享文件。 在返回Uri之后，还需要给 Intent 加上临时权限： 123456// Grant temporary read permission to the content URIresultIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)// Put the Uri and MIME type in the result IntentresultIntent.setDataAndType(fileUri, contentResolver.getType(fileUri))// Set the resultsetResult(Activity.RESULT_OK, resultIntent) 还有另外一种授权方式，但是不建议使用： 使用 Context.grantUriPermission() 为其他 App 授予 Uri 对象的访问权限。这种情况下，授权的有效期限，从授权一刻开始，截止于设备重启或者手动调用 Context.revokeUriPermission() 方法，才会收回对此 Uri 的授权。 而使用 Flag 的方式，当 ClientApp 的任务栈结束的时候，就会自动收回权限。 ClientApp 获取到 Uri 之后，就可以访问文件了： 1234567891011121314151617181920212223// Get the file's content URI from the incoming IntentreturnIntent.data?.also &#123; returnUri -&gt; /* * Try to open the file for "read" access using the * returned URI. If the file isn't found, write to the * error log and return. */ inputPFD = try &#123; /* * Get the content resolver instance for this context, and use it * to get a ParcelFileDescriptor for the file. */ contentResolver.openFileDescriptor(returnUri, "r") &#125; catch (e: FileNotFoundException) &#123; e.printStackTrace() Log.e("MainActivity", "File not found.") return &#125; // Get a regular file descriptor for the file val fd = inputPFD.fileDescriptor ...&#125;]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（基础知识）笔记]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 Java程序设计概述面向对象设计用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。即时编译解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。 字节码可以（在运行时刻）动态的翻译成对应运行这个应用的特定CPU机器码。 即时编译器还可以消除函数调用（即“内联”）。 第三章 Java的基本程序设计结构####一个简单的Java应用程序 根据Java语言规范，Java虚拟机将从指定类中的main方法开始执行。 不过，当main方法不是public时，有些版本的Java解释器也可以执行Java应用。这是因为Java虚拟机规范并没有要求main方法一定是public。这个问题已经得到了修复，在Java SE 1.4及以后的版本中强制main方法时public的。 ####整形 从Java 7开始，加上前缀0B或者0b就可以写二进制数。例如：0b1001就是9。同样，从Java 7开始，还可以为数字字面量加下划线，如用1_000_000表示一百万。 ####浮点类型 所有”非数值“的值都认为是不同的。 1if (x == Double.NaN) // is never true 可以使用 Double.isNaN() 来判断（长得帅的肯定会戳进去看一下源码，很有意思哦）。 浮点数不适用于无法接受舍入误差的金融计算中。例如， 1double result = 2.0 - 1.9; // result = 0.10000000000000009 这是因为二进制无法精确的表示 1/10。 可移植性是Java的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位储存一个数值，而有些处理器使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如： 1ddoble w = x * y / z; 使用严格浮点计算，截断中间数，可以了解一下 strictfp 关键字。 ####char类型 转义字符\u可以出现在加引号的字符常量或字符串之外（其他的转义字符不行）。例如： 1public static void main(String\u005B\u005D args) \u005B\u005D其实就是[]，所以上面的代码就是程序的入口main函数。（可以编译成class文件并运行，但是不被IDE识别） Unicode转义字符会在解析代码之前得到处理，举个吓死人的例子： 1// file in c:\user 当你在代码里面加上这行注释的时候，点击运行按钮就会发现，编译过不了！！！我的理解是先会将文件里面的转义字符全部处理一下，当处理到这行注释的时候，发现了 \u 会当成转义字符来处理，但是 \u 后面的字符不合法，所以就报错了。 Unicode的基本平面，辅助平面，码点的概念，可以看维基百科。 一个字符可能有多个码点，一个char只能表示一个码点。 ####运算符 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或者NaN结果。 ####数值类型之间的转换 两个操作数有一个是 double ，则两个数按照 double 处理， 否则，有一个是 float，则两个数按照 float 处理， 否则，有一个是 long，则两个数按照 long 处理， 否则，两个数按照 int 处理。 123byte a = 1;byte b = 2;byte c = a + b; // error 12byte a = 1;a += 1; // ok，因为 += 会自动进行强制转换 ####位运算符 处理整形类型时，可以直接对组成整形数值的各个位完成操作，浮点数不行。 1234int a = 1;a &lt;&lt; 1; // okdouble b = 3;b &lt;&lt; 1; // error 位移运算符的右操作数要完成模32的运算（如果左操作是long型，则需要模64）。 11 &lt;&lt; 35 相当于 1 &lt;&lt; 3 ####字符串 编译器可以让字符串共享，只有字符串常量是共享的，+或者substring等操作产生的结果并不是共享的。 ####格式化输出： 使用参数索引来对一个参数进行多次格式化： 1System.out.print("%1$s %2$tB %2$te %2$tY", "Due date:", new Date()); 可以看到第二个索引对new Date()参数格式化了多次。使用&lt;标志也可以达到同样的效果。 1System.out.print("%s %tB %&lt;te %&lt;tY", "Due date:", new Date()); ####数组 Java中，允许数组长度为0，数组长度为0和null不同。 ####数组排序 1Arrays.sort(a); // 这个方法使用了优化的快速排序算法 利用数组写一个抽彩游戏（这个算法还是很有想法的）： 123456789101112131415int[] numbers = new int[n];for(int i=0; i&lt;n; i++) &#123; numbers[i] = i + 1;&#125;int[] result = new int[k];for (int i=0; i&lt;k; i++) &#123; int r = (int)(Math.random() * n); result[i] = numbers[r]; // 最关键的代码，将上面随机出来的数用最后一个数覆盖 numbers[r] = numbers[n - 1]; // 将 n 减一，相当于去掉最后一个数 n--;&#125; 第四章 类与对象####面向对象程序设计概述 OOP将数据放在第一位，然后再考虑操作数据的算法。 ####对象 对象状态的改变必须通过调用方法实现，如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。 ####类之间的关系 最常见的关系有： 依赖（“use-a”） 聚合（“has-a”） 继承（“is-a”） ####Java类库中的LocalDate类 将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。 ####用户自定义类 在一个源文件中，只能有一个公有类，但可以有任意数目的非共有类。 第一眼看到这句话我是懵逼的，后来仔细看了代码，发现应该说的是非内部类。 12345678// Main.javapublic class Main&#123; public class Inner&#123;&#125;&#125;class Main2 &#123; &#125; 上面的源文件是Ok的。但是把Main2改成public的就不行。 ####封装的优点 可以改变内部实现，除了该类的方法之外，不会影响其他代码。 更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。 ####静态常量 我们常使用的System类 1234public class System &#123; ... public static final PrintStream out = ...;&#125; 我们知道 final 修饰的变量是不允许将别的值赋给它的，但是System类有这样的一个方法： 1public static void setOut(PrintStream out) &#123;...&#125; 它可以将System.out设置为不同的流，原因是setOut是一个本地方法，它可以绕过Java语言的存取控制机制。 ####方法参数 Java程序设计语言总是采用按值调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的，下面给出例子： 12345public static void swap(Car a, Car b) &#123; Car temp = a; a = b; b = temp;&#125; 如果Java对对象采用的是按照引用传递，那么这个方法应该够实现交换数据的效果，但是，并没有。参数被初始化为对象引用的拷贝。 ####初始化块 调用构造器的具体处理步骤： 所有数据域被初始化为默认值（0，false或null）。 按照在类声明中出现的顺序，依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主题。 123456789101112public class Main &#123; &#123; a = 2; &#125; private int a = 3; public int getA() &#123; return a; &#125;&#125;// Main m = new Main(); 问，m.getA() 的值？ 对象析构与 finalize 方法在实际应用中，不要依赖使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。 我一直觉得，final，finally，finalize有啥区别，这个问题很傻×，因为他们毛关系没有，区别从何谈起。问问 final 与 volitile的区别吧！！！ ####将类放入包中 假定有一个源文件开头有下列语句： 1package com.aprz; 编译器在编译源文件的时候不检查目录结构，即使这个源文件没有在子目录 com/aprz 下，也可以进行编译。但是，最终的程序将无法运行。如果包与目录不匹配，虚拟机就找不到类。 ####包作用域 如果，把一个类文件放置在类路径的某处的 java/awt 子目录下，那么我们就可以访问 java.awt 包的内部了。非常危险！ 从 1.2 版开始，JDK 的实现者修改了类加载器，明确禁止加载用户自定义的、包名以“java”开始的类！ ####类路径 javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。 下面看一个类路径示例： 1/home/user/classdir:.:/home/user/archives/archive.jar 假定虚拟机要搜寻 com.horstmann.corejava.Employee类文件。它首先要查看储存在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找一下文件： 123/home/user/classdir/com/horstmann/corejava/Employee.classcom/horstmann/corejava/Employee.class从当前目录开始com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar 编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类。例如，假定源文件包含指令: 12import java.util.*;import com.horstmann.corejava.*; 并且源代码引用了Employe类。编译器将试图查找jva.lang.Employee (因为java lang包被默认入）、java.util.Employee、com.hostmann.corejava.Employee和当前包中的Employee。对这个类路径的所有位置中所列出的每个类进行逐查看。 如果找到了一个以上的类，就会产生编译错误(因为类必须是唯一的， 而import语句的次序却无关紧要)。 编译器的任务不止这些，它还要查看源文件( Source files) 是否比类文件新。如果是这样的话，那么源文件就会自动地重新编译。 在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以从当前包中导入非公有类。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类。 这一段很长，我只能说QQ的图片文字识别真的牛逼。 第五章 继承类、超类和子类前缀“超”与“子”来源于计算机科学和数学理论中的集合语言的术语。 覆盖方法尽管子类对象有父类的私有域，但是却无法在子类中访问这个域。（这句话是我总结的，可能并不严谨） 有些人（包括我）认为super与this应用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个只是编译器调用超类方法的特殊关键字。 动态绑定虚拟机知道一个引用的对象类型，所以能够正确的调用相应的方法。 多态在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如： 12345public class A &#123;&#125;public class B extends A &#123;&#125;B[] bs = new B[8];A[] as = bs; 但是这样会有一个问题，如下： 1as[0] = new A(); 编译器是会接纳这个赋值操作的。由于bs与as指向同一个数组，当调用B中特有的方法时，就会出现错误。而且在运行时还会报出 ArrayStoreException 错误。 理解方法调用 编译器查看对象的声明类型和方法名。假设调用 x.f(param)，且隐私参数x声明为C类的对象。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析。 允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 123456// A.javapublic Father find() &#123;...&#125;--------------------------------// B.java@Overridepublic Son find() &#123;...&#125; 如果是 private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式就是静态绑定。 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用的时候，虚拟机仅查找这个表就行了。 阻止继承：final类和方法在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程为称为内联。例如，内联调用 e.getName()将被替换为访问e.name域。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略。然面，如果getName在另外个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢?优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。 Object：所有类的超类所有的数组类型，不管时对象数组还是基本类型的数组都扩展了Object类。 equals方法在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。 相等测试与继承如果隐私和显式的参数不属于同一个类，equals方法将如何处理呢？这是一个很有争议的话题！ 许多程序员喜欢使用 instanceof 进行检测： 123if(!(otherObject instanceof Person)) &#123; return false;&#125; 这样做不但没有解决 otherObject 是子类的情况，并且还有可能会招来一些额外的麻烦。 Java语言规范要求 equals 方法具有下面的特性： 自反性 对称性 传递性 一致性 对于任意非空引用x，x.equals(null)，应该返回false。 就对称性来说，当参数不属于同一个类的时候需要仔细思考一下。 1e.quals(m); e 是父类，m是子类。如果这两个对象的实例域都一样，当使用 instanceof 操作符的时候，会返回 true，那么意味着，m.equals(e)，也会返回true。但是实际上，反过来调用是无法通过 instanceof 操作符的。 建议的规则： 如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass进行检测 如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 一个完美equals方法的编写模板： 显示参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象。 123if (this == otherObject) &#123; return true;&#125; 检测otheObject是否为null，如果为null，返回false。 123if(otherObject == null) &#123; return false;&#125; 比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测。如果所有的子类拥有统一的语义，就使用instanceof检测。 将otherObject转换为相应类型的变量 ClassName other = (ClassName) otherObject; 开始对所有需要比较的域进行比较，如果在子类中重新定义equals，就要在其中包含调用 super.equals(other)。 一种常见的错误是将equals方法的参数类型改为具体需要比较的类型： 1public boolean equals(Person p) &#123;...&#125; 注意上面的方法不是覆盖，因为参数类型不一样，Object类中equal方法的参数是Object。 hashCode12StringBuilder sb = new StringBuilder("ok");StringBuffer tb = new StringBuffer("ok"); 注意，sb与tb的hashCode不一样，这是因为StringBuffer没有定义自己的hashCode方法。 equals方法相等则hashCode必须一致。 泛型数组列表一旦确定数组列表的大小不再发生变化，就可以调用 trimToSize 方法。这个方法将储存区域的大小调整为当权元素数量所需要的储存空间数目。垃圾回收器将回收多余的储存空间。 对象包装器与自动装箱对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类。 自动装箱规范要求 boolean、byte、char &lt;= 127，介于-128~127之间的short和int被包装到固定的对象中。这句话乍一看很诡异，其实都是同一个意思。 char 的范围是从 0 ~ 65535。 在运行时使用反射分析对象setAccessible方法时AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。 利用get方法可以访问域的值，但是有一个需要解决的问题。如果域是一个String类型，把它当作Object返回没有什么问题，但是，假设这个域是double类型的，而Java中数值类型不是对象，该怎么办呢？其实反射机制会自动地将这个域值打包到相应的对象包装器中。invoke 方法也是如此。 继承的设计技巧 将公共操作和域放在超类 不要使用受保护的域 protect 在某种程度上破坏了封装，因为同一个包类的代码也可以访问该域。 子类也可以随便访问超类的protect域。 使用继承实现“is-a”关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多的使用反射 第六章 接口、lambda表达式与内部类Comparable&lt;T&gt; 接口 如果子类之间的比较含义不一样，那就属于不同类对象的非法比较。每个compareTo方法都应该在开始时进行下列检测： 123if (getClass() != other.getClass) &#123; throw new ClassCastException();&#125; 如果存在一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。 静态方法在Java SE8中，允许在接口中增加静态方法。只是有违于将接口作为抽象规范的初衷。 目前为止，通常的做饭都是将静态方法放在伴随类中。Collection/Collections…… 默认方法可以为接口提供一个默认方法。必须用default修饰符标记这样的一个方法。 一般来说，这并没有太大的用处。但是当一个接口的方法特别多是就可以很有用。 1234567public interface Listener &#123; void fa(); void fb(); void fc(); void fd(); void fe();&#125; 大多数情况下，我们只关心其中的一两个方法。在Java SE8 中我们就可以将它声明为默认方法，什么也不做。 1234567public interface Listener &#123; default void fa() &#123;&#125;; default void fb() &#123;&#125;; default void fc() &#123;&#125;; default void fd() &#123;&#125;; default void fe() &#123;&#125;;&#125; 这样一来，使用者就只需要覆盖真正关心的方法。 默认方法的一个重要作用是“接口演化”。以Collection接口为例，假设你有一个类实现了这个接口： 1public class Bag implements Collection &#123;...&#125; 后来，在Java SE8中，又为这个接口增加了一个stream方法。 假设steam不是默认方法。那么Bag类将无法编译，因为它没有实现这个方法。为接口增加一个非默认方法不能保证源代码兼容。 不过，如果不重新编译这个类，而是使用原来的包含这个类的JAR文件，这个类仍然可以正常加载。为接口增加方法可以保证二进制兼容。不过，如果调用了steam方法，就会抛出一个AbstractMethodError。 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况呢？ 超类优先。如果超类提供了具体的方法，会忽略接口的默认方法。可以保证与Java SE7的兼容性。 接口冲突。如果一个接口提供了默认方法，另一个接口提供了一个同名且参数类型相同的方法（不管是不是默认的），必须覆盖这个方法来解决冲突。 千万不要让一个默认方法重新定义Object类中方法！！！ 对象克隆clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。 默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。 Cloneable接口并没有什么作用，它只是一个标记，指示类设计者了解克隆过程，clone方法是从Object类中继承过来的。 必须当心子类的克隆。 为什么引入lambda表达式lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。 lambda表达式的语法如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如： 12Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); 无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。 如果，一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。 1(int x) -&gt; &#123; if(x &gt;= 0) return 1;&#125; 函数式表达式对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口成为函数式接口。 最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。 不过，Java现在对lambda表达式能做的也只是转换为函数式接口。 Java API 在 java.util.function 包中定义了很多通用的函数式接口。例如：BiFunction&lt;T,U,R&gt;。 方法引用有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如： 1Timer t = new Timer(1000, event -&gt; System.out.println(event)); 这样，看起来很简洁了，但是如果能把 println 方法传递到 Timer 的构造器就更好了，如下： 1Timer t = new Timer(1000, System.out::println); 表达式 System.out::println 是一个方法引用，它等价于 x-&gt; System.out.println(x); 方法引用的写法有3中： objcet::instanceMethod Class::staticMethod Class::instanceMethod 前两种情况，方法引用等价于提供方法参数的lambda表达式。 对于第三种情况，第一个参数会成为方法的目标。例如： 12String::compareToIgnoreCase 等价于(x, y) -&gt; x.compareToIgnoreCase(y); 可以在方法引用种使用 this 与 super。 构造器引用构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。但是它具体引用的是哪个构造器与上下文有关。 12ArrayList&lt;String&gt; names = ..;Stream&lt;Person&gt; stream = names.steam().map(Person::new); map方法会调用Person(String) 构造器。 可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。 Java有一个限制，无法构造泛型类型T的数组。new T[] 会产生错误。 变量作用域有时候，我们会在lambda表达式种访问外围方法或类中的变量。例如： 1234567String text = "ok";ActionListener listener = event -&gt; &#123; Sysout.out.println(text); &#125;;// 1000年之后new Timer(delay, listener); 仔细想想，这里会有问题。lambda表达式的代码可能会在很久之后才运行，那个时候，text可能已经不存在了。要了解发生了什么，我们先来了解lambda表达式的组成： 一个代码块 参数 自由变量的值，这是指非参数而且不在代码中定义的变量。 lambda表达式的数据结构必须存储自由变量的值。 关于代码块与自由变量在别的语言里面有一个术语叫闭包。 lambda表达式引用了自由变量，无法对这个自由变量进行更改，因为会引发多线程问题。 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。 1234567public class Application &#123; public void init &#123; ActionListener listener = event -&gt; &#123; Sysout.out.println(this.toString()); &#125; &#125;&#125; 表达式会调用Application的toString，而不是 ActionListener的toString。 处理lambda表达式如果设计你自己的接口，其中只有一个抽象方法，可以用 @FunctionalInterface 注解来标记这个接口。 再谈Comparator静态 comparing 方法取一个“键提取器”函数，它将类型T映射为一个可比较的类型。对要比较的对象应用这个函数，然后对返回的键完成比较。 1Arrays.sort(people, Comparator.comparing(Person::name)); 还有很多其他的方法，需要自己去戳源码。 内部类的特殊规则语法可以通过显示的命名将外围类引用设置为其他的对象。 12345678public class Out&#123; public class In &#123; &#125;&#125;-----------------------------Out o = new Out();Out.In in = o.new In(); 非静态内部类的所有静态域都必须是final的。 非静态内部类不能有static方法。 非static的内部类，在外部类加载的时候，并不会加载它，所以它里面不能有静态变量或者静态方法。 static类型的属性和方法，在类加载的时候就会存在于内存中。 要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。 基于以上两点，可以看出，如果一个非static的内部类如果具有static的属性或者方法，那么就会出现一种情况：内部类未加载，但是却试图在内存中创建static的属性和方法，这当然是错误的。原因：类还不存在，但却希望操作它的属性和方法。 内部类是否有用、必要和安全内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 符号分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。 内部类是如何访问外部的？ 123456789101112class Out &#123; private int a; class In &#123; &#125; // 这是编译器自动生成的方法，我们在内部类中调用a，实际上是使用了这个方法 static int access$0(Out); &#125; 匿名内部类由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是将构造参数传递给超类构造器。 对于静态方法的日志问题，如果我们希望在静态方法中输出当前类的类名，但是静态方法没有this，可以使用如下方法： 1new Object()&#123;&#125;.getClass().getEnclosingClass(); 代理的特性所有的代理类都覆盖了Object类中的方法 toString、equals和hashCode。 对于特定的类加载器和预设的一组接口来说，只能有一个代理类。如果使用同一个类加载器和接口数组调用两次 newProxyInstance 方法的话，那么只能得到同一个类的两个对象。 如果代理类实现的所有接口都是public的，那么代理类不属于某个特定的包。否则。所有非公有的接口都必须属于同一个包，代理类也属于这个包。 第七章 异常、断言和日志异常分类 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。 Exception分为两个分支： 一个分支派生于RuntimeException，另一个包含其他异常。 划分规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像IO错误这类问题的异常属于其他异常。 声明受查异常如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。 如果超类方法没有抛出任何受查异常，子类也不能抛出任何异常。 捕获异常通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续传递。 捕获多个异常在Java SE 7中，同一个catch子句中可以捕获多个异常类型。 只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。 捕获多个异常类型时，异常变量隐含为final。 再次抛出异常与异常链在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。 12345try &#123; ...&#125; catch (AException a) &#123; throw new BException("msg");&#125; 不过，有一种更好的处理方法，并且将原始异常设置为新异常的“原因”： 1234567try &#123; ...&#125; catch (AException a) &#123; Throwable t = new BException("msg"); t.initCause(a); throw t;&#125; 这样我们调用 e.getCause() 就可以拿到原始异常。强烈推荐使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。 在Java SE 7之前，无法抛出声明异常之外的类型（虽然现在也是，但是编译器的行为不一样了）： 1234567public void update() throws SQLException &#123; try &#123; ... &#125; catch(Exception e) &#123; throw e; &#125;&#125; 在Java SE 7之前，会有一个问题，编译器会指出这个方法可以抛出任何异常，而不仅仅是SQLException。 现在编译器会跟踪到 e 来自 try 块。假设这个try中仅有的已检查异常是 SQLException的实例，另外，e没有被改变，那么这个方法就是合法的。 finally子句强烈建议解耦 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。 12345678910InputStream in = ...;try &#123; try &#123; ... &#125; finally &#123; ... &#125;&#125; catch (Exception e) &#123; ...&#125; 这种设计方式不仅清楚，而且还有一个功能，可以捕获 finally 里面的异常。 当 finally 子句包含return语句时： 12345678try &#123; int r = n * n; return r;&#125; finally &#123; if (n == 2) &#123; return 0; &#125;&#125; 在方法返回之前，finally 子句的内容将会执行。如果finally子句中也有一个return语句，这返回值将会覆盖原始的返回值。 finally 子句的异常可能会覆盖try中的异常： 123456InputStream in = ...;try &#123; ...&#125; finally &#123; in.close();&#125; 假设try块中抛出了非IOException，而close方法也出了异常，那么最后抛出的是 close 方法的 IOException。一般我们对 try 块中的异常更感兴趣，但是这时异常已经被丢失了，除非给 close 也加上 try 语句，这样就会非常繁琐。 带资源的 try 语句如果资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。 123try (Resource res = ...) &#123; ...&#125; try 块退出时，或者存在一个异常，都会自动调用 res.close();，资源会被关闭。 这种 try 语句自身也可以带 catch 和 finally 语句，但是一般不用。 第八章 泛型程序设计定义简单泛型类泛型类可以看作普通类的工厂。 类型变量的限定一个类型变量或通配符可以有多个限定： 1T extends Comparable &amp; Serializable 限定类型用 &amp; 分隔，而逗号用来分隔类型变量。如果用一个类来做限定，它必须是限定列表中的第一个。 类型擦除虚拟机没有泛型对象，它会擦除类型变量，并替换为限定类型（无限定类型的变量用Object）。 如果有多个限定，会怎么样呢？ 1class Interval&lt;T extends Serializable &amp; Compareable&gt; 原始类型用 Serialzable 替换 T，编译器会在必要的时候将其强制转换为 Comparable。为了提高效率，应该将标签接口（没有方法的接口）放在边界列表的末尾。 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。 翻译泛型方法假设我们有这样的一个类： 123456789101112131415161718192021222324class Pair&lt;T&gt; &#123; private T first; private T second; ... public void setSecond(T second) &#123; this.second = second; &#125; &#125;-----------------------------------// 擦除之后，这里 T 擦除之后是 Objectclass Pair &#123; private Object first; private Object second; ... public void setSecond(Object second) &#123; this.second = second; &#125; &#125; 使用一个类继承它： 12345678910class Date extend Pair &#123; &#125;-----------------------------------------------class Date extend Pair&lt;LocalDate&gt; &#123; // 这里不是重写，只是展示有一个从父类继承过来的方法 public void setSecond(LocalDate second) &#123; ... &#125;&#125; 于是问题就来了，假设我使用父类引用子类的变量，然后调用 setSecond 方法，那么它本来应该走到子类的方法里面去，但是由于泛型的擦除，导致子类方法签名不一致了（父类是 Object，子类是 LocalDate）。 1234Date date = new Date();Pare&lt;LocalDate&gt; pair = date;// 猜猜它会调用那个方法pair.setSecond(aDate); 现在多态与泛型擦除出现了冲突，解决方法是需要编译器在 Date类中生成一个桥方法。 123public void setSecond(Object second) &#123; setSecond((Date)second);&#125; 然而，桥方法也会引出别的问题！ 假设 Date 类覆盖了 getSecond 方法： 1234567class Date extend Pair &#123; // 这里是重写 @Override public LocalDate getSecond() &#123; ... &#125;&#125; 那么，Date 类里面就有两个同名方法了，参数一样，只有返回值不一样。编译器是不允许这样的，但是，在Java虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机可以正确处理这样的情况。 如果你记忆力比较好的话，前面也提到过在覆盖父类的方法时，可以返回更加严格的类型，这也是利用的桥方法。 Java泛型转换的事实： 虚拟机中没有泛型，只有普通的类和方法 所有的类型参数都用它们的限定类型替换 桥方法被合成类保持多态 为保持类型安全性，必要时插入强制类型转换 不能用基本类型实例化类型参数其原因是类型擦除，擦除之后，没有限定类型的使用 Object 代替，而 Object 不能引用基本类型。 运行时类型查询只适用于原始类型1if (a instanceof Pair&lt;String&gt;) 这里只是测试了 a 是否时一个 Pair 对象，与 String 毫无关系。 同样的道理，getClass 也总是返回原始类型。 Varargs 警告Java 不允许创建泛型数组，其原因可以自己研究研究（泛型擦除）。假设我们有这样方法： 1public static &lt;T&gt; void addAll(Collection coll, T... ts) &#123;&#125; ts 实际上时一个数组，考虑一下调用： 1234Collection&lt;Pair&lt;String&gt;&gt; table = ...;Pair&lt;String&gt; p1 = ...;Pair&lt;String&gt; p2 = ...;addAll(table, p1, p2); 所以，Java虚拟机必须建立一个Pair&lt;String&gt; 数组，这就违反了不循序创建泛型数组的规定。不过对于这种情况，只是会显示一个警告。 不能构造泛型数组最好让用户提供一个数组构造器的表达式。 泛型类的静态上下文中类型变量无效不能在静态域中引用类型变量。 123public class Singleton&lt;T&gt; &#123; private static T singleInstance; // ERROR&#125; 因为如果能使用的话，不同的实例会有不同的类型。 不能抛出或捕获泛型类的实例泛型类扩展 Throwable 都是不合法的。 1class P&lt;T&gt; extends Exception &#123;&#125; // ERROR 在异常规范中使用类型变量是合法的。 1public static &lt;T extends Throwable&gt; void fun(T t) throws T &#123;&#125; // OK 可以消除对受查异常的检查1234@SuppressWarnings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable t) throws T &#123; throw (T)t;&#125; 编译器会认为t是一个非受查异常。 再利用下面的代码就会把所有异常转换为编译器所认为的非受查异常： 12345try &#123; do work&#125; catch (Throwable t) &#123; throwAs(t);&#125; 这样，在某些不允许抛出任何受查异常的方法中，就可以使用这个方法来抛出受查异常。 注意擦除后的冲突123public class Pair&lt;T&gt; &#123; public boolean equals(T t);&#125; 擦除之后，就是 public boolean equals(Object t); 与 Object 的方法重复了，会引发错误。 通配符概念1void set(? extends Person) &#123;...&#125; 这个 set 方法不能传递任何参数，因为编译器只知道需要某个 Person 的子类，但是不知道具体是什么类型。 1void set(? super Person) &#123;...&#125; 该方法只能传递Person或者Person的子对象。 直观的讲，带有超类型限定的通配符可以向泛型写入，带有子类型限定的通配符可以从泛型对象读取。 举一个 super 限定符的应用： LocalDate 实现了 ChronoLocalDate，而 ChronoLocalDate 扩展了 Comparable&lt;ChronoLocalDate&gt;。 因此，LocalDate 实现的是 Comparable&lt;ChronoLocalDate&gt;，而不是 Comparable&lt;LocalDate&gt;。 在这种情况下，可以使用超类限定符来救助（要注意泛型的 extends 与类的 extends 的不同意义）： 1public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a) &#123;...&#125; 上个图来意思意思： 无限定通配符123? getFirst()void setFirst(?) getFirst 的返回值只能赋值给 Object。setFirst不能被调用，Object 也不行。 通配符捕获123public static void swap(Pair&lt;?&gt; p)public staic &lt;T&gt; void swapHelper(Pair&lt;T&gt; p) 比较有趣的是，可以在 swap 里面调用 swapHelper。这种情况下，参数 T 捕获通配符。 通配符捕获只有在有许多限制的情况下才是合法的，编译器必须能够确信通配符表达的是单个、确定的类型。 第九章 集合迭代器对 next 方法和 remove 方法的调用具有互相依赖性。 集合框架中的接口List接口定义了多个用于随机访问的方法： 1234void add(int index, E element);void remove(int index);E get(int index);E set(int index, E element); 坦率的讲，集合框架的这个方面设计的很不好。 集合框架中有两种类型的集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。而链表尽管也是有序的，但是随机访问会很慢，所以最好使用迭代器来遍历。所以如果原先就提供了两个接口就会容易理解些了。 为了避免对链表完成随机访问操作，Java SE 1.4 引入了一个标记接口 RandomAccess。用来测试一个特定的集合是否支持高效的随机访问： 12345if (c instanceof RandomAccess) &#123; // 支持&#125; else &#123; // 不支持&#125; Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。 add 方法不允许增加重复的元素 equals 方法：只要两个集合包含相同的元素就认为是相等的，而不要求这些元素有相同的顺序 hashCode 方法：要保证含相同元素的两个集会得到相同的散列码 既然两个接口的方法签名是一样的，为什么还要建立一个单独的接口呢？ 从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接收集的方法。 链表在 Java 程序设计语言中，所有链表实际上都是双向链接的。 ListIterator 是 Iterator 的一个子接口，它新增了一些方法。LinkedList 的 listIterator 方法会返回一个 ListIterator 的实例。注意，在使用 ListIterator 的 remove 方法时需要谨慎。 在调用 next 之后，remove 方法会删除迭代器左侧的元素，但是，如果调用 previous 会删除迭代器右侧的元素。 ConcurrentModificationException 异常的检测有一个特例： 链表只负责跟踪对列表的结构性修改，例如，添加元素，删除元素。set方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有的结点的内容进行修改。 不要使用下面的方法来遍历链表： 123for (int i=0; i&lt;list.size(); i++) &#123; Element e = get(i);&#125; 虽然 get 方法做了微小的优化（如果 i 大于 size()/2，会从后面开始遍历），但是这样写每次循环都要遍历一次。 散列表在 Java中，散列表用链表数组实现。 树集Java SE 8 中使用的是红黑树。 将一个元素添加到树中要比添加到散列表中慢，不过与检查数组或链表中重复元素相比还是快很多。 优先级队列优先级队列并没有对所有的元素进行排序。它使用了一个优雅且高效的数据结构——堆。 映射 （Map）总感觉翻译有点奇怪！！！ 更新映射项看一个例子，统计单词出现的频率： 1counts.put(word, counts.get(word) + 1); 这会有一个问题，就是 get 可能会返回 null。于是可以这样写，给一个默认值： 1counts.put(word, counts.getOrDefault(word, 0) + 1); 另一种方法就是先调用 putIfAbsent： 12counts.putIfAbsent(word, 0);counts.put(word, counts.get(word) + 1); 不过，还可以有更简单的方式，使用 merge 方法，可以简化这个常见的操作： 1counts.merge(word, 1, Integer::sum); 如果键值不存在，则将 word 置为 1，否则使用 Integer::sum 函数组合原值和 1。 映射视图集合框架不认为Map本身是一个集合。 Map提供了方法用来获取映射视图，映射视图是实现了Collection接口或某个子接口的对象。 123Set&lt;K&gt; keySet();Collection&lt;V&gt; values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 这3个方法会分别返回3个视图。要注意这些视图并不是 TreeSet 或者 HashSet 的实例，而是实现了 Set 接口的另外某个类的实例。 视图与包装器再来说说 keySet 方法。初看起来，好像这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet 方法返回一个实现 Set 接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。 轻量级集合包装器1List&lt;Card&gt; cardList = Arrays.asList(cardDeck); asList 返回的并不是一个 ArrayList。它是一个视图对象，带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个 UnsupportedOperationException 异常。 子范围12List group2 = staff.subList(10, 20);group2.clear(); 元素自动的从 staff 列表中清除，并且 group2 为空。 不可修改的视图简而言之，就是对所有更改器方法直接抛出一个异常。 由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。 注意，视图并没有重新定义 Object 的 equals 和 hashCode 方法（内容是否相等的检测在分层结构的这一层上没有定义妥当）。 受查视图“受查”视图用来对泛型类型发生问题时提供调试支持。 123ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();ArrayList rawList = strings;rawList.add(new Date()); 这个错误在 add 的时候检测不到。相反，只有在调用 get 方法的时候才会抛出异常。受查视图可以探测这类问题。 123List&lt;String&gt; safeStrings = Collections.checkList(strings, String.class);ArrayList rawList = safeStrings;rawList.add(new Date()); // Error 虚拟机在运行到 add 方法时，就会抛出异常。 排序与混排可以使用归并排序对链表进行高效的排序。但是Java中不是这样做的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制会链表。 集合类库中使用的排序算法比快速排序要慢一些，快速排序时通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。 二分查找只有采用随机访问，二分查找才有意义。 第十四章 并发中断线程没有可以强制线程终止的方法。然而，interrupt 方法可以用来请求线程终止。 但是，如果线程被阻塞，就无法检测中断状态。 当在一个被阻塞的线程（sleep或者wait）上调用 interrupt 方法时，阻塞调用将会被 Interrupted Exception 异常中断。 如果在每次工作迭代之后都调用 sleep 方法（或者其他可中断方法），isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并抛出InterruptedException。 不要将 InterruptedException 捕获在低层次上！ 要么捕获然后再次设置中断状态，要么直接抛出。 可运行线程在任何给定时刻，一个可运行的线程可能在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行）。 被阻塞线程和等待线程被阻塞状态与等待状态是有很大不同的。其实这句话我还不太能够理解，是本质上不同，还是Java行为上不同？ 线程优先级每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。 守护线程守护线程应该永远不去访问固有资源，如文件，数据库，因为它会在任何时候甚至在一个操作的中间发生中断。 setDaemon 必须在线程启动之前调用。 未捕获异常处理器线程的 run 方法不会抛出任何受查异常，非受查异常会导致线程终止。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。 setUncaughtExceptionHandler 方法会未任何线程安装一个默认的处理器。 也可以用Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有的线程安装一个默认的处理器。 如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。 ThreadGroup 类实现 Thread.UncaughtExceptionHanlder 接口。它的 uncaughtException 方法做如下操作： 如果该线程组有父线程组，那么父线程组的 uncaughtException 方法被调用。 否则，如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器，则调用该处理器。 否则，如果 Throwable 是 ThreadDeath 的一个实例，什么都不做。 否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。 锁对象 （ReentrantLock）如果使用锁，就不能使用带资源的 try 语句。 一是无法释放锁，二是会新创建一个变量。 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。 条件对象使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。 一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。 signalAll 方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。 每一个对象有一个内部锁，并且该锁有一个内部条件。初学者常常对条件感到困惑，推荐先学习ReentrantLock 的 Condition。 wait、nofity、notifyAll 方法都需要当前线程持有锁，否则会抛出异常。 同步阻塞举一个有趣的例子： 123456789101112131415public class Sync &#123; private Map&lt;String, Person&gt; pList = Collections.synchronizedList(new HashMap&lt;&gt;()); public synchronized void putIfAbsent(String key, Person p) &#123; if(!pList.contains(p)) &#123; pList.put(p); &#125; &#125; public Person get(String key) &#123; pList.get(key); &#125; &#125; 先不管这个程序有什么意义，只问一个问题，这个类是线程安全的吗？ 虽然看起来很像是线程安全的，但是实际上不是，因为 Collections.synchronizedList 使用的锁，肯定不是 Sync 的实例。 Volatile 域仅仅为了读写一个或两个实例域就使用同步，显得开销过大了。Volatile 可以帮助我们在这种情况下避免使用锁。 先来看看多个线程为什么会出现值不一致的原因： 多处理器的计算机能够暂时在寄存器或本地内存缓存区中保存内存的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显示的修改指令时才会改变。然而，内存的值可以被另一个线程改变！ 早期的CPU使用的是总线锁的方式来保证 Volatile 域的一致性，现在都使用的是缓存一致性。 final 变量如果在某个类中，将一个域声明为 final 类型，那么会起到这样的一个效果： 其他的线程会在该类的构造函数执行完毕之后才能看到这个 final 域的值。 原子性假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 volatile。 java.util.concurrent.atomic 包中有很多类使用了很高级的机器级指令（不是使用锁）来保证其他操作的原子性。 稍微提一下，使用 compareAndSet 实现乐观锁的常用写法： 1234do &#123; oldValue = largest.get(); newValue = Math.max(oldValue, observed);&#125; while (!largest.compareAndSet(oldValue, newValue)); compareAndSet 的工作原理：期望内存中的值是 oldValue，是则用 newValue 替换它，返回 true，不是则返回 false。 如果有大量线程要访问相同的原子值，函数性能会大幅下降，因为乐观更新需要太多次重试。 锁测试与超时lock 方法不能被中断，在获得锁之前会一直阻塞，如果出现死锁，则 lock 方法无法终止。可以使用 tryLock 来响应中断。 tryLock 还有一个隐藏特性：这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此。 为什么弃用 stop 和 suspend 方法stop 方法：该方法终止所有未结束的方法，包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。 例如：从 A 转账到 B，线程突然被终止，钱已经转出去了，却没有进入 B 账户，那么 Bank 对象就被破坏了。 suspend 方法：如果用该方法挂起一个持有锁的线程，那么该锁在恢复之前是不可用的。如果调用 suspend 方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。 ConcurrentHashMap1234// map 是 ConcurrentHashMap 的实例Long oldValue = map.get(word);Long newValue = oldValue == null ? 1 : oldValue + 1;map.put(word, newValue); 在上面的例子中，由于操作不是原子的，所以最终的结果不可预料。但是，要理解 ConcurrentHashMap 与 HashMap 的区别，这里的 get 与 put 都是原子操作，在多线程情况下不会破坏 map 的结构，而 HashMap 在多线程情况下会出现循环链表等问题。 ConcurrentHashMap 返回的迭代器具有弱一致性。这意味着迭代器不一定能反映出它们被构造之后的所有的修改（可以认为是某一特定时刻的快照），它们不会将同一个值返回两次，不会抛出 ConcurrentModificationException。 CopyOnWriteArrayList 和 CopyOnWriteArraySetCopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。 线程池调用 shutdown 方法，该线程池不再接收新任务。当所有任务完成后，线程池死亡。 调用 shutdownNow 方法，该线程池取消尚未开始的所有任务，并视图中断正在运行的线程。 ExecutorCompletionService如果有大量的 Callable 要执行，可以使用这个类。 Fork-Join 框架这个框架用来分解子任务，提高线程利用率。 123456789101112131415class Counter extends RecursiveTasks&lt;Integer&gt; &#123; protected Integer compute() &#123; if (to - from &lt; THRESHOLD) &#123; // ..... &#125; else &#123; int mid = (from + to) / 2; Counter first = new Counter(values, from, mid, filter); Counter second = new Counter(values, mid, to, filter); // 阻塞 invokeAll(first, second); // 合并 return first.join() + second.join(); &#125; &#125;&#125; 信号量任何线程可以释放任何数量的许可，这可能会增加许可数目以至于超出初始数目。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E7%9F%A5%E8%AF%86%E7%82%B9%2FBitmap%2F</url>
    <content type="text"><![CDATA[记录一下以前看到过的知识点。Bitmap 像素数据的储存位置先看官方文档： 在Android Android 2.2（API级别8）及更低版本上，当 GC 发生时，应用程序的线程会停止。这会导致延迟，从而降低性能。 Android 2.3添加了并发GC，这意味着在位图不再被引用后很快就会被回收。 2.3之前的像素存储需要的内存是在native上分配的，并且生命周期不太可控，可能需要用户自己回收。 2.3-7.1之间，Bitmap的像素存储在Dalvik的Java堆上，而8.0之后的像素内存又重新回到native上去分配，不需要用户主动回收，8.0之后图像资源的管理更加优秀，极大降低了OOM。 假设我们有这样的一个手机，它的 system/build.prop 配置如下： 1234567891011121314151617// 表示应用程序启动后为其分配的初始大小为8mdalvik.vm.heapstartsize=8m// 每个应用程序最大内存可分配到64mdalvik.vm.heapgrowthlimit=192m// 单个虚拟机可分配的最大内存256m// 使用大堆时，极限堆大小。一旦dalvik heap size超过这个值，直接引发oom。// 在android开发中，如果要使用大堆，需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。dalvik.vm.heapsize=512m// 设定内存利用率的百分比，当实际的利用率偏离这个百分比的时候，虚拟机会在GC的时候调整堆内存大小，让实际占用率向个百分比靠拢。dalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=512kdalvik.vm.heapmaxfree=8m 我们不断的解析图片并持有所有图片的引用： 1234567void test&#123; Map&lt;String, Bitmap&gt; map = new HashMap&lt;&gt;(); for(int i=0 ; i&lt;10;i++) &#123; Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.green); map.put("" + System.currentTimeMillis(), bitmap); &#125;&#125; 在 6.0 的手机中，实际测试应用出现OOM的时候，是在 200M 左右。对于现在动辄6G内存的手机而言，存在严重的资源浪费。所以8.0之后，Android也向这个方向靠拢，最好的下手对象就是Bitmap，因为它是耗内存大户。图片内存被转移到native之后，一个APP的图片处理不仅能使用系统绝大多数内存，还能降低Java层内存使用，减少OOM风险。 在 8.0 的手机中，实际测试应用出现OOM的时候，是在 2G 左右，所以，内存无限增长的情况下，也会导致APP崩溃，但是这种崩溃已经不是OOM崩溃了，Java虚拟机也不会捕获。 注意，上面的测试都是针对图片而言。 Bitmap 的复用 一是使用缓存：使用LruCache对Bitmap进行缓存，当再次使用到这个Bitmap的时候直接获取，而不用重走编码流程。 二是使用 inBitmap 字段：Android3.0(API 11之后)引入了BitmapFactory.Options.inBitmap字段，设置此字段之后解码方法会尝试复用一张存在的Bitmap。这意味着Bitmap的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。不过，使用这个字段有几点限制： 12345声明可被复用的Bitmap必须设置inMutable为true；Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用；Android4.4(API 19)之前被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap设置的inPreferredConfig；Android4.4(API 19)之前待加载Bitmap的Options.inSampleSize必须明确指定为1。Android4.4(API 19)之后被复用的Bitmap的内存必须大于需要申请内存的Bitmap的内存； 使用 inBitmap 之前： 使用 inBitmap 之后： 我刚开始看到这两张图的时候是很蛋疼的，因为它看起来就像是3张图片同时使用了一块内存，这特么怎么可能呢。但是实际上它是这样工作的： 假设我们需要在Android应用程序中加载一些图。 当我们加载bitmap1时，它将为bitmap1分配内存。 然后，如果我们不再需要bitmap1，请不要回收位图（因为回收涉及调用GC）。相反，使用此bitmap1作为bitmap2的inBitmap。这样，bitmap2可以复用bitmap1的内存位置。 Bitmap 占用的内存大小 getByteCount()：代表存储Bitmap的像素需要的最少内存。 getAllocationByteCount()：代表在内存中为Bitmap分配的内存大小。 一般情况下两者是相等的。但是通过复用Bitmap来解码图片，如果被复用的Bitmap的内存比待分配内存的Bitmap大,那么getByteCount()表示新解码图片占用内存的大小（并非实际内存大小,实际大小是复用的那个Bitmap的大小），getAllocationByteCount()表示被复用Bitmap真实占用的内存大小（即mBuffer的长度）。 如何计算Bitmap占用的内存大小公式：占用的内存 = width * height * 一个像素所占的内存。 一般情况下是正确的，但是有时候还需要考虑屏幕密度问题。比如，我们从资源文件中加载一张图片（BitmapFactory.decodeResource）： 它占用的内存 = width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存 nTargetDensity/inDensity 实际上就是图片被缩放了，因为屏幕密度与图片资源文件夹密度不一致时，系统就会缩放图片，所以这里就会影响到计算结果。 除了加载本地资源文件的解码方法会默认使用资源所处文件夹对应密度和手机系统密度进行缩放之外，别的解码方法默认都不会。 Bitmap 的压缩inSampleSize不多说了，注意会将所设置的值自动更正为2的幂次方（接近并且小于所设置的值），有人说不是所有版本都这样，但也无从考究了。 compress压缩了文件的质量。这个玩意要了解还需要一定的储备知识，让我们从头说起。 首先我们需要了解的是图片各种相关的大小，文件大小、占用硬盘大小、占用内存大小。对于文件的大小实际就是它本身的包含的信息的大小，即实际具有的字节数，它以Byte为衡量单位，只要文件内容和格式不发生变化，文件大小就不会发生变化。我们可以直接拿File的length()方法就能获得文件的大小。那么硬盘的大小是什么呢？不管在什么系统中，我们经常会看到文件大小和占用磁盘空间的大小不一致，这是为什么呢？ 文件在磁盘上的所占空间不是以Byte为衡量单位的，它最小的计量单位是“簇(Cluster)”。 扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。从上面的图可以看出，Windows 的一簇是4KB，所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。 这样我们就理解了为什么文件大小和实际占用硬盘大小不一样了。那么现在就剩内存的大小了。图片在内存里占用的大小和它本身的大小没有关系。我们知道图像是由一个一个的像素组成的，我们的图片的尺寸就是像素的多少，例如宽高是1024*1024的图像就是横竖都有1024个像素的图片，根据图片的编码格式不同，每个像素所占的内存大小是不一样的： ALPHA_8：表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度 ARGB_4444：表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节 ARGB_8888：表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节 RGB_565：表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节 其中A代表透明度；R代表红色；G代表绿色；B代表蓝色。 最终，图片在内存所占空间的大小是：图片长度 x 图片宽度 x 一个像素点占用的字节数。即，例如我们有一个1024*1024大小的ARGB的图，那么它在内存里的大小为1024*1024*4=4M，但是在硬盘上的大小甚至可以小到6.4k。 这是为什么，为什么差别这么大？因为图片在内存中时是完整的图片信息，例如即使一个图是全白不透明或全黑全透明也会全部在内存中 (FFFFFFFF/00000000) 占用空间。但是在硬盘上却是被压缩的状态，例如平时我们常见的jpg和png，都是将图片信息进行了压缩，然后存储在了硬盘上。所以说一个图片在内存中占用的空间要远大于在硬盘的空间。 以上说了这么多，最后的引出的结论很关键：jpg和png都是对图片信息进行压缩然后存储到硬盘上的。它们有什么区别呢？jpg实际是有损压缩，而png是无损压缩。现在来看最上面的图片压缩的方法，可以看到Bitmap的压缩格式是JPEG（即jpg）。为什么是jpg，因为只有jpg才支持压缩，png是无损的，根本就不能进行再压缩。所以说Bitmap的compress方法只能对jpg起作用，当然，局限不仅仅是这一点。我们不禁要问，jpg能再压缩，那到底压缩了什么呢？ 首先jpg与png不同，png支持透明度，但是jpg不支持，所以jpg本身就比png小了四分之一的空间。其次jpg是有损压缩，除了透明度被干掉外，本身的RGB颜色也被压缩了，当然了，压缩的算法非常复杂，不在本文的研究范围内。压缩本身也是有等级的，压缩的越厉害，图像失真也越厉害，但是最终压缩都是有上限的，就是说从算法上来说就不支持任意一个图片压缩到任意小。我们可以参考PS工具最后保存jpg图片的质量（品质）那个选项，可以选择从0到100，0当然代表质量最差了，我们选择0那么就会出来最小的图片，这个应该就是这张jpg图片能够压缩到的最小值。有人说可以把压缩到0后的图片再去重复一遍这个步骤就好了嘛。实际这样是不行的，这里要说明的是0到100是一个绝对值，就是说一个图片的质量（品质）就是0到100，不能循环压缩，你可以试一下，用一个已经是0得图片再次压缩到50，那么它的大小不但不会小，反而会增大！！！ 最后，compress方法是质量压缩，压缩后改变大小的是jpg文件的大小，图片在内存中的大小还是不变的！因为宽高和每个像素占的空间都是没有变化的！ inDensity 与 inTargetDensity这个是我在《Android权威编程指南》上看到的。 上面说的，inSampleSize 只能缩放 2 的幂次方。这个在某些情况下可能不好满足需求，比如：一张1200 * 1200 的图，想要缩放到 500 * 500。这个时候使用 inSampleSize 就搞不定了！ 所以可以借助于 inDensity 和 inTargetDensity，用 inDensity 与 inTargetDensity 就能做到任意等比缩放。 可以先使用 inSampleSize 缩小到 600 * 600（不直接使用 inDensity 与 inTargetDensity的原因书上没有说，但是我猜想应该是它的效率高），然后再使用 inDensity 与 inTargetDensity ，将 inDensity 设置成 600，将 inTargetDensity 设置成 500，就可以了。 实际上原理，就是与 android.graphics.BitmapFactory#decodeResourceStream 差不多啦。 给出项目代码： 123456789101112131415public static int calInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 12345678910public static BitmapFactory.Options getOptions( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; options.inSampleSize = calInSampleSize(options, reqWidth, reqHeight); options.inScaled = true; // 这里使用设置要缩放的宽高比，与 decodeResource 的缩放一样 options.inDensity = options.outHeight; options.inTargetDensity = reqHeight * options.inSampleSize; options.inJustDecodeBounds = false; return options;&#125; 使用这个方法就可以做出任意的等比例缩放了。]]></content>
      <tags>
        <tag>Android-知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[productFlavors与buildTypes]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FGradle%2FproductFlavors%E4%B8%8EbuildTypes%2F</url>
    <content type="text"><![CDATA[modify at 2019-8-26 节操社要祸祸“食戟之灵”了，我TM…口吐芬芳 之所以会想到要写这个，是发现了很多以前没注意过的东西，记录一下。 起因是由于一个紧急版本，然后我需要配置一下一个新增的H5地址，发现在配置的过程中非常的麻烦。 config.gradle 中添加地址 app / build.gradle 添加 manifestPlaceholders ，为不同的 productFlavors 配置不同的地址 AndroidManifest.xml 中添加 meta-data Java 中添加Key 这是在是太麻烦了，很容易哪一步就忘记了。于是问了一下，为啥要写在 AndroidManifest.xml 里面？然后给出的答案是为了安全！ 嗯，无稽之谈，于是我就收集了一些证据： 将 debug，release，加固后的release包都拖到 AS 中，打开 AndroidManifest.xml，显然里面的每一根毛都看的清清楚楚 使用压缩文件解压apk包，用notepad++等工具打开，显示是二进制 显然用文本编辑器打开，看不出什么，就是所谓的“安全”了。当是这种东西就相当于序列化一个 Java 对象，你看不出什么来，不代表别人看不出来，写一个工具就好了，里面的二进制数据都是有规则的，不然怎么读取里面的东西。 好了，有了这个作为前提，由于我们的包是加固的，所以放在 Java 里面比 AndroidManifest.xml 要安全很多，至少你要懂脱壳（这里不讨论别的了）。于是我就想将地址放在 BuildConfig 里面，减少配置的步骤，我使用一个单独的 gradle 文件配置一下，然后每个 variant 取相应的地址就好了。（虽然后来才发现，需要在base库里面生成才能有用，但是在学习的过程中还是很有收获的。） 比如，我在 urls.gradle 中这样写： 1234567891011121314151617ext &#123; urls = [ HOME: [ DEBUG_HOST : "https://www.debug.com", RELEASE_HOST: "https://www.release.com", PATHS : [ a: '/1', b: '/2', c: '/3', d: '/4' ] ] ]&#125; 然后在BuildConfig里面生成这样的东西： 1234public static final String HOME_a = "https://www.debug.com/1";public static final String HOME_b = "https://www.debug.com/2";public static final String HOME_c = "https://www.debug.com/3";public static final String HOME_d = "https://www.debug.com/4"; 当我将 Build Variant 切换为 release 的时候，BuildConfig 会变为： 1234public static final String HOME_a = "https://www.release.com/1";public static final String HOME_b = "https://www.release.com/2";public static final String HOME_c = "https://www.release.com/3";public static final String HOME_d = "https://www.release.com/4"; 那么，如何才能做到上面的效果呢？我们先从 build type 说起。 BuildType首先，我们需要知道的是，当我们创建一个 module 的时候，AS 会自动的为我们创建 debug 与 release 这两个构建类型，不管我们写没写，就算你把它给删了，仍然会有。从源码里面没有找到对应的地方，可能是在插件的代码里面，不管这个，我们继续。 我们点击 release 进入源码，发现它是一个 com.android.build.gradle.internal.dsl.BuildType 对象。 里面会有很多我们熟悉的方法，比如： 1234567@NonNullpublic BuildType proguardFiles(@NonNull Object... files) &#123; checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, "proguardFiles"); for (Object file : files) &#123; proguardFile(file); &#125; return this; 这个货，就对应着我们配置的混淆文件。如下： 1proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' 由于上面的方法是一个可变参数作为参数，所以我们可以在 proguardFiles后面，添加多个 proguard 文件。 除了 proguardFiles，还有其他的很多属性可以配置： 123456789minifyEnabled falseapplicationIdSuffix ".debug"debuggable truebuildConfigField "boolean", "DEBUG", "true"// release版的签名signingConfig signingConfigs.app// 还有一个 initWith 属性initWith debug 说一下这个 initWith 属性，比如上面我们指定了 debug，那么就是说将 debug 里面的所有属性都继承过来，算是一种复用。 再说 product flavors。 Product Flavorsbuild type，我们比较好理解，debug 用于开发，release 用于发布，一般这两个就够用了。那么 product flavors 又是什么鬼呢？可以这样想，幸平创真在创造一道新菜的时候，在创造的过程中，会慢慢的调配各种配料的比例，这中间烧的菜就是 debug，当创造完成之后可以端给客人吃了，烧的菜就是 release。但是经过观察后，幸平创真发现，不同的人口味不同，然后他就又为不同的人调配了不同口味的蘸料，这些不同口味的蘸料就是 product flavors。 我们看看配置代码： 123456789101112131415productFlavors &#123; demo &#123; // productFlavors 需要指定 dimension // 如果你的 flavorDimensions 只有一个值， // 那么可以不用指定，会自动赋值，但是一定要声明 flavorDimensions dimension "version" applicationIdSuffix ".demo" versionNameSuffix "-demo" &#125; full &#123; dimension "version" applicationIdSuffix ".full" versionNameSuffix "-full" &#125;&#125; 配置好了 product flavors 之后，你就可以打多个不同的包了，包的个数为 【build type 的个数】x 【product flavors 的个数】，相当于交叉的集合： demoDebug demoRelease fullDebug fullRelease 这个很好理解，拿煎饼举例： 开发版鸡蛋煎饼 完成版鸡蛋煎饼 开发版培根煎饼 完成版培根煎饼 下面再说说 flavorDimensions 的作用，不知道从哪个版本开始，productFlavors 需要配合 flavorDimensions 使用才行。一般的，没有特殊需求的话，buildTypes加上 productFlavors 已经完全够用了，flavorDimensions 是用于这样的需求的： 还是拿煎饼举例，有的人喜欢鸡蛋煎饼，有的人喜欢培根煎饼，但是有的人都喜欢，那怎么办呢？总不能买两个吧，所以好的办法是做一个加鸡蛋和培根的煎饼。这个就是 flavorDimensions 的作用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960android &#123; ... buildTypes &#123; debug &#123;...&#125; release &#123;...&#125; &#125; // Specifies the flavor dimensions you want to use. The order in which you // list each dimension determines its priority, from highest to lowest, // when Gradle merges variant sources and configurations. You must assign // each product flavor you configure to one of the flavor dimensions. flavorDimensions "api", "mode" productFlavors &#123; demo &#123; // Assigns this product flavor to the "mode" flavor dimension. dimension "mode" ... &#125; full &#123; dimension "mode" ... &#125; // Configurations in the "api" product flavors override those in "mode" // flavors and the defaultConfig block. Gradle determines the priority // between flavor dimensions based on the order in which they appear next // to the flavorDimensions property above--the first dimension has a higher // priority than the second, and so on. minApi24 &#123; dimension "api" minSdkVersion 24 // To ensure the target device receives the version of the app with // the highest compatible API level, assign version codes in increasing // value with API level. To learn more about assigning version codes to // support app updates and uploading to Google Play, read Multiple APK Support versionCode 30000 + android.defaultConfig.versionCode versionNameSuffix "-minApi24" ... &#125; minApi23 &#123; dimension "api" minSdkVersion 23 versionCode 20000 + android.defaultConfig.versionCode versionNameSuffix "-minApi23" ... &#125; minApi21 &#123; dimension "api" minSdkVersion 21 versionCode 10000 + android.defaultConfig.versionCode versionNameSuffix "-minApi21" ... &#125; &#125;&#125;... 这样我们就可以打更多的包了： Build variant: [minApi24, minApi23, minApi21][Demo, Full][Debug, Release] Corresponding APK: app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk flavorDimensions 有两个值，一个值有 3 个对应的 productFlavor，一个值有 2 个对应的 productFlavor。buildTypes 有 2 个 ，所以共有 3 x 2 x 2 = 12 个构建变体。 我们知道，productFlavors 相当于蘸料，作为一个蘸料，它肯定要与主食材配合，互相激发各自的味道才行，那么 productFlavors是如何影响打包内容的呢？我们介绍一下 sourceSet。 SourceSets中的属性，可以指定哪些文件夹下的源文件、资源要被编译，哪些源文件要被排除。 从我们的工程目录可以看出来，com.android.application插件默认就给我们定了3个 sourceSet： main androidTest test 默认情况下，main里面的东西大概是这样的： 123456main &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java.srcDirs = ['src/main/java'] res.srcDirs = ['src/main/res'] assets.srcDirs = ['src/main/assets']&#125; 可以看到这都是我们熟悉的目录，既然 sourceSet 是可以配置的，就说明只要我们有需求，我们的 Java 文件就可以写到其他地方，而不是只能在 src/main/java 中。比如我们再添加一个 java 目录： 123456main &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java.srcDirs = ['src/main/java', 'src/main/java2'] res.srcDirs = ['src/main/res'] assets.srcDirs = ['src/main/assets']&#125; 这样，我们就有了两个 java 目录，用于存放不同作用的文件集合。这个功能配合 productFlavors 管理不同作用版本的源代码就很方便了。比如，我出一个 free 版的应用，功能简单，代码都放在 java 里面，我再出一个 pro 版的，高级功能，代码放在 java2 里面，打包的时候将 java2 与 java 都打进去，就是一个完整版的。 我们的 src 是存放所有源代码与资源的目录，默认它有3个子目录，但是我们也可以添加自己的目录。比如： src/demoDebug/ 这个就是 productFlavors 为 demo，buildTypes为 debug 的构建变体的目录。 src/debug/ 这个是 buildTypes为 debug 的构建变体的目录。 当我们构建的时候，会根据选择的构建类型来合并某些目录，比如构建 demoDemo，会合并 main + debug + debugDemo，合并的时候会有优先级的，构建变体越具体的优先级越高，demoDebug 就比 debug 要具体，所以 demoDebug 的优先级高，而 debug 又比 mian 高。资源会替换，但是 Java 类会报类重复的错。 当然 sourceSet 还有更多的用法，这里就不深入了。 还有一个很重要的知识需要补充，因为我最早是认为为不同 build type 产生不同的 BuildConfig 文件内容是不可行的，因为我们的 BuildConfig 需要在APP结构的最底层生成，这样才能被其他组件所引用到。而我是一直认为 library 工程只能打 release 包的，所以它只能生成 release 版的 BuilConfig 文件。直到我看到了官方文档的描述： Android plugin 3.0.0 and higher include a new dependency mechanism that automatically matches variants when consuming a library. 也就是说从 3.0.0 的插件开始，就可以自动匹配了，而不是一直打 release 版的了，Nice~ 另外说一句，如果 library 没有匹配的，可以使用 matchingFallbacks 指定备用匹配的。 123456789101112131415// In the app's build.gradle file.android &#123; buildTypes &#123; debug &#123;&#125; release &#123;&#125; staging &#123; // Specifies a sorted list of fallback build types that the // plugin should try to use when a dependency does not include a // "staging" build type. You may specify as many fallbacks as you // like, and the plugin selects the first build type that's // available in the dependency. matchingFallbacks = ['debug', 'qa', 'release'] &#125; &#125;&#125; 下面我们正式进入主题，实现我们所说的功能，有了上面的基础，我们缺的就只是 gradle api 的熟悉程度了，这个没什么办法，只能自己查资料了。 首先，根据官方文档的例子，我们知道，android 为我们提供了一个叫做 variantFilter的东西，就是一个过滤器，显然是用来过滤哪些我们不想打的包： 1234567891011121314151617181920212223android &#123; ... buildTypes &#123;...&#125; flavorDimensions "api", "mode" productFlavors &#123; demo &#123;...&#125; full &#123;...&#125; minApi24 &#123;...&#125; minApi23 &#123;...&#125; minApi21 &#123;...&#125; &#125; variantFilter &#123; variant -&gt; def names = variant.flavors*.name // To check for a certain build type, use variant.buildType.name == "&lt;buildType&gt;" if (names.contains("minApi21") &amp;&amp; names.contains("demo")) &#123; // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) &#125; &#125;&#125;... 嗯，不符合我们的要求，但是它给了我们一个提示，既然有过滤器，那么应该也有一个遍历所有构建变体的方法，我们在遍历的时候，去读取 urls.gradle 里面的 map，然后动态的添加进去不就好了吗！！ 经过搜索之后，我就发现了这个东西： 123456789101112131415161718applicationVariants.all &#123; variant -&gt; def buildType = getBuildType() rootProject.ext.urls.each &#123; entry -&gt; entry.value['PATHS'].each &#123; path -&gt; def key = "$&#123;entry.key&#125;_$&#123;path.key&#125;" def value if (getFlavorName() == 'full' &amp;&amp; buildType.name == 'release') &#123; value = "$&#123;entry.value['PRODUCT_HOST']&#125;$&#123;path.value&#125;" &#125; else &#123; value = "$&#123;entry.value['SIT_HOST']&#125;$&#123;path.value&#125;" &#125; variant.buildConfigField "String", key, "\"$&#123;value&#125;\"" &#125; &#125;&#125; applicationVariants 里面有所有需要打包的变体，我们遍历一下，既可以获取变体对象，然后动态的添加我们想要添加的 buildConfigField。 需要注意的是，我最开始以为 com.android.build.gradle.api.BaseVariant#getBuildType返回的是com.android.build.gradle.internal.dsl.BuildType ，但是没想到返回的是com.android.builder.model.BuildType，稍不注意就搞错了。 com.android.builder.model.BuildType里面是无法添加 buildConfigField 的。]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的事件分发]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[事件的传递流Activity -&gt; Window -&gt; ViewGroup - &gt; View Activity.java 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; // 交给 window if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; PhoneWindow.java 因为 PhoneWindow 暂时是 Window 类的唯一实现： 1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 这里的 mDecor 就是 DecorView 了，它继承至 FrameLayout，所以它是一个 ViewGroup。 然后 ViewGroup 可能会将事件就传递给它的子 View。 onTouch &amp; onTouchEvent &amp; onClick在 View 的 dispatchTouchEvent 方法中，在调用 onTouchEvent 之前，会先调用 mListenerInfo.mOnTouchListener.onTouch 方法，这个就是我们在外部设置的监听了。如果这个方法返回了 true，那么 onTouchEvent 方法就不会调用。 12345678910 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125;// result 为 true 是无法进入这个条件的 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; onClick 是在 onTouchEvent 中调用的，现在的 Android studio 在我们复写 View 的 onTouchEvent 的时候，都会给这么一个警告： Custom view MotionView overrides onTouchEvent but not performClick less… (Ctrl+F1)Inspection info:If a View that overrides onTouchEvent or uses an OnTouchListener does not also implement performClick and call it when clicks are detected, the View may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in View#performClick as some accessibility services invoke performClick when a click action should occur. 简单来说就是，复写这个方法可能会导致 performClick 方法不会触发。从而影响 accessibility 的动作行为。 onClick &amp; onLongClick一般的，手指点击然后抬起，就会触发一个 onClick 时间，但是不知道你有没有想过，onLongClick 是如何触发的呢？系统是如何判断我们是长按，而不是点击？ 话说，肯定是一句时间来判断，但是具体的思路是怎么样的呢？ 使用 Handler post 一个延时 xxx ms消息，如果收到这个延时消息就会触发一个事件。 然而某些情况下，会提前将该消息 remove 掉，这样就收不到这个消息，无法触发事件。 拿长按事件举例：比如长按1s算一个长按事件，那么我们就可以post一个延时1000ms的消息，收到这个消息就触发长按回调，如果没到1s用户就放开了手指，那么就移除这个消息，这样就不会触发长按回调了。 onLongClick 方法有返回值，返回 true 表示消耗这个事件，那么 onClick 就无法触发了。 clickable &amp; enable一个 View 只有是 clickable 才会消耗事件，与 enable 没有关系。 onInterceptTouchEvent 的调用onInterceptTouchEvent 这个方法只有 ViewGroup 才有。 这个方法的调用条件有两个： 1if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 第一个是按下事件才会触发，第二个是有可以消耗这次事件的子 View。 根据这个我们可以推理出如下结论： 当一个 ViewGroup 拦截事件的时候，它会将事件交给自己处理，那么它不会把事件传递给子 View，也就是说，它没有可以消耗这次事件的子View。即在接下来的 MOVE、UP等事件，都不会调用这个方法。 requestDisallowInterceptTouchEvent当子View调用这个方法之后，ViewGroup 无法拦截除了 ACTION_DOWN 以外的事件。 这是因为，ACTION_DOWN 事件会重置和清除一些状态，其中就包括 FLAG_DISALLOW_INTERCEPT。 ViewGroup 拦截事件当 ViewGroup 决定拦截事件，那么 mFirstTouchTarget == null，那么 ViewGroup 的 dispatchTouchEvent 方法会调用 super.dispatchTouchEvent(event); 方法。 12345if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 123if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; 这里的 super 就是 View，因为 ViewGroup 也是继承至 View 的。 所以就调用到了 View 的 dispatchTouchEvent 方法，我们都知道，View 的 dispatchTouchEvent 方法会直接调用自己的 onTouchEvent 方法，而这里自己表示ViewGroup。所以，当 ViewGroup 决定拦截事件，会将事件交给自己处理。 ACTION_DOWN当某个 View 可以消耗事件的时候，这个 View 的父布局的 mFirstTouchTarget 变量就指向了这个 View，然后接下来的事件都会交给这个 View 来处理。 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 可以看到，直接调用 child （mFirstTouchTarget 指向的值） 的 dispatchTouchEvent。 当 View 不消耗 ACTION_DOWN 事件的时候，它的父布局的 mFirstTouchTarget 就为null，后面的事件该View 的 父布局就不会再往下传递了。它也就接受不到后续事件了。 ACTION_CANCEL当一个 ViewGroup 不拦截 ACTION_DOWN 事件，并且有可以消耗 ACTION_DOWN 的子 View 时，接下来的事件都会交给这个子 View 来处理，但是每次都会询问父布局是否拦截： 1234567891011if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 因为 mFirstTouchTarget 不会空，所以会走这里 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; 而如果在后续的事件中，父布局突然拦截了事件，即 intercepted 为 true，那么先前可以处理该事件的子View会收到一个 ACTION_CANCEL 事件。后面的事件就都会传递给父布局，而不往下传递。 12345// intercepted 为 true，则 cancelChild 也为 truefinal boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true;&#125; 123456789101112final int oldAction = event.getAction();if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; // 强制将 action 改成 cancel event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled;&#125; 可以看到，这里它将 ACTION_CANCEL 传递给了子 View。 传递 cancel 成功之后，会重置一些状态，包括 mFirstTouchTarget，将它的值清空。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MultiDex]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FMultiDex%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[出现的原因Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，其中包含用来运行您的应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内可引用的方法总数限制在 65,536，其中包括 Android 框架方法、库方法以及您自己代码中的方法。 单个Dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。 对于Dex文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是使用Dex工具将class文件转化为Dex文件的过程中， 单个Dex文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536。 这就是65536问题的根本来源。 另外还有一种情况，有时候方法数没有达到 65536，并且编译器也正常的完成了编译工作，但是应用在低版本手机安装是异常终止，异常信息如下： 12E/dalvikvm: Optimization failedE/installd: dexopt failed on '/data/dalvik-cache/data@app@com.aprz.test.apk@classes.dex' res = 65433 为什么会出现这种情况呢？其实是这样的，dexopt是一个程序，应用在安装时，系统会通过dexopt 来优化dex文件，在优化的过程中 dexopt 采用一个固定大小的缓冲去来储存应用中的所有方法的信息，这个缓冲区就是 LinearAlloc。LinearAlloc缓冲区在新版本的 Android 系统中其大小时是 8MB 或者 16MB，但是在 Android 2.2和2.3中却只有5MB，当待安装的apk方法数比较多的时候，尽管它没有达到65536的限制，但是它的储存空间仍然有可能超过5MB，这中情况下dexopt程序就会报错。 Android 5.0 之前版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 限制应用的每个 APK 只能使用单个 classes.dex 字节码文件。想要绕过这个限制，就需要使用Google提供的Dalvik 可执行文件分包支持库。 因为Android系统在启动应用时只加载了主dex（Classes.dex），其他的 dex 需要我们在应用启动后进行动态加载安装。 123456789public class MyApplication extends SomeOtherApplication &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // 加载其他的dex文件 // 原理就是：通过反射手动添加其他Dex文件中的class到 ClassLoader 的 pathList字段中，就可以实现类的动态加载 MultiDex.install(this); &#125;&#125; 这个过程一般只在第一次冷启动应用的时候比较耗时，除了要抽取其他的 dex 文件，Dalvik 虚拟机还会使用 dex2oat 将 dex 文件优化成 odex 文件，将生成的文件放在手机的data/dalvik-cache目录下，便于以后使用。以后再次运行时，因为不用再次生成 odex，所以运行速度很快。 Android 5.0 及更高版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，后者原生支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 classesN.dex 文件，并将它们编译成单个 .oat 文件，供 Android 设备执行。因此，如果您的 minSdkVersion 为 21 或更高值，则不需要 Dalvik 可执行文件分包支持库。只需要在模块级 build.gradle 文件中将 multiDexEnabled 设置为 true，如此处所示： 123456789android &#123; defaultConfig &#123; ... minSdkVersion 21 targetSdkVersion 28 multiDexEnabled true &#125; ...&#125; MultiDex.install 带来的问题当我们使用了分包支持库之后，在运行app时可能会出现这样的错误 java.lang.NoClassDefFoundError出现这个问题的原因是： 在应用启动期间，需要该类，但是这个类不在 MainDex 中，所以解决方案就是将这个类放到 MainDex 中。 具体可以参考官方文档： 声明主 DEX 文件中需要的类 。 dexopt faileddalvik的dexopt程序分配一块内存来统计你的app的dex里面的classes的信息，由于classes太多方法太多超过这个linearAlloc 的限制 。 解决方案就是减少 dex 的大小。 12345678910android.applicationVariants.all &#123; variant -&gt; dex.doFirst&#123; dex-&gt; if (dex.additionalParameters == null) &#123; dex.additionalParameters = [] &#125; dex.additionalParameters += '--set-max-idx-number=48000' &#125;&#125; 启动过程中 ANR启动期间在设备数据分区中安装 DEX 文件的过程相当复杂，如果辅助 DEX 文件较大，可能会导致应用无响应 (ANR) 错误。在此情况下，您应该通过 ProGuard 应用代码压缩以尽量减小 DEX 文件的大小，并移除未使用的那部分代码。 这个是官方给出的建议，但是显然不太合适中国程序员国情，所以需要使用别的方案： 异步加载方案 多进程加载方案 插件化 这两个实现其实差不多，都是提供了一种避免在其他Dex文件未加载完成时，造成的ClassNotFoundException的手段。 分包后 MainDex 仍然爆掉 MainDex 瘦身 自行分包，直接指定哪些类放到 MainDex]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 无障碍服务]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FAndroid%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[由于某种原因，我们需要屏蔽某些界面上的无障碍服务的使用，刚开始我以为是做不到的。因为我们的思路出了问题，就直接想着要去停止系统的这个服务。但是经过一番搜索之后，没有发现任何结果。官方文档也说了： The lifecycle of an accessibility service is managed exclusively by the system and follows the established service life cycle. 无障碍服务是只由系统管理的。 然后我就又开始搜索其他方面的资料，比如：无障碍的原理与使用。巧合的是，我搜索到了这篇文章： 随手记Android无障碍实践 看着看着，我发现这是一篇关系如何优化自己的App，让应用可以被障碍人士使用的文章。当我失望的准备关掉页面的时候，突然我想到了，既然他能优化使用，那我是不是能做一个反优化，让它不能使用呢！！！ 于是，我仔细的看了文章，果然找到了一个令我感兴趣的东西。 在它们改造非标准组件的选中状态的时候，是这样做的： 给控件添加无障碍代理（AccessibilityDelegate），在onInitializeAccessibilityNodeInfo()方法中调用AccessibilityNodeInfo对象的setChecked方法设置选中状态。 12345678rootView.setAccessibilityDelegate(new View.AccessibilityDelegate() &#123; @Override public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(host, info); info.setCheckable(true); info.setChecked(itemData.isSelected()); &#125;&#125;); 看到没有，View 是可以设置一个关于无障碍的代理的。 既然可以设置代理，那么思路就很清晰了，一个好的代理，可以省很多事，但是我也可以搞一个吊都不吊你的代理。 在设置了一个代理之后，在用我们自己写的无障碍app测试的时候，果然无效了，而且自动化测试也失效了，效果还是可以的，对原来的逻辑也基本没有影响。 后来，我又找了一些关系 AccessibilityService 的文章，也看官方文档的东西，总算对这个东西有了一个整体的了解。贴一个比较有趣的图： 这个图讲的是 AccessibilityEvent 事件产生后是如何发送到 AccessibilityService 的。 刚开始，我有点无法理解这个图，因为我对无障碍的理解，最初是从抢红包开始的，总觉得它是一个可以用来在别的App里面搞一些操作的东西。所以我总搞不明白为啥事件是从 App 里面传到 Service 里面，而不是 Service 传递到 App 里面，如果不是这样，它是怎么点别的 App 里面的东西的呢？？？ 在我看完了官方文档，我才知道能够点击别的App的方法是在后来才加进去的，原本是没有这些操作的。也就是说 AccessibilityService 最初涉及出来是用来做一些辅助操作的，比如我们有一个 App，我们可以在这个 App 里面自己实现一个 AccessibilityService，当用户点击了某个按钮的时候，我们就可以提示用户你点击了啥按钮，你点击的按钮是啥颜色的等等…，这样的话事件的传递才是有用的，正确的。 后面加入的按钮点击操作，应该与 AccessibilityEvent 无关。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 应用是如何编译与运行的]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FAndroid%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Android Studio 负责如何构建与部署我们的应用。但是你有没有想过当你按下Run按钮时发生了什么？构建Java compilation我们的代码是用Java编写的。但是，Java代码的编译和运行方式与Web应用程序相同吗？Android应用程序的编译过程与其他Java应用程序有很大不同。但是它们的开始过程都是一样的： 使用javac命令将Java源代码文件编译为.class文件。 它会将下面的java代码： 1234public MainActivity() &#123; super(); currentPosition = 0;&#125; 转换成这样的java字节码： 12345678public com.hfad.bitsandpizzas.MainActivity(); Code: 0: aload_0 1: invokespecial #5; //Method android/app/Activity.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: iconst_0 6: putfield #3; //Field currentPosition:I 9: return Conversion to Dalvik bytecodes.class文件包含标准的Oracle JVM Java字节码。但Android设备不使用此字节码格式。相反，Android有自己独特的字节码格式，称为Dalvik。 Dalvik字节码，与Oracle JVM字节码一样，是理论处理器的机器代码指令。 编译过程需要将.class文件和任何.jar库转换为包含Dalvik字节码的单个classes.dex文件。这是通过dx命令完成的： dx命令将所有.class和.jar文件拼接成一个以Dalvik字节码格式编写的classes.dex文件。 1230x0000: iput-object v1, v0, Lcom/hfad/bitsandpizzas/MainActivity; com.hfad.bitsandpizzas.MainActivity$2.this$0 // field@48690x0002: invoke-direct &#123;v0&#125;, void java.lang.Object.&lt;init&gt;() // method@136820x0005: return-void Put classes.dex and resources into a package file然后将classes.dex文件和应用程序中的资源（如图像和布局）压缩为类似zip的文件，称为Android Package或.apk文件。这是通过 Android Asset Packaging Tool 或 aapt 完成的： 这个步骤完成之后，.apk文件就可以安装了。但是，还有一个步骤需要做… You might then also sign the .apk file如果想要通过Google Play商店分发应用，则需要对其进行签名。对应用程序包进行签名意味着您在.apk中存储了一个附加文件，该文件基于.apk内容的校验和以及单独生成的私钥。 .apk文件使用标准的jarsigner工具，该工具是Oracle Java Development Kit的一部分。创建jarsigner工具是为了签署.jar文件，但它也可以使用.apk文件，因为它们也是压缩文件。 如果您对.apk文件进行签名，则还需要通过名为zipalign的工具运行它，这将确保文件的压缩部分在字节边界上排列。 Android希望它们按字节对齐，以便它可以轻松读取它们而无需解压缩文件。 网上还有上面所有步骤的详细图： 部署The adb server starts if it’s not already running该应用程序将通过Android Debug Bridge部署到Android设备。 在我们的开发端上开启一个 adb 服务进程，在 Android 设备上开启一个类似的 adb 服务（adbd）。 如果您的计算机上未运行adb进程，则adb命令将启动它。 adb进程将打开网络套接字，并在端口5037上侦听命令。您输入的每个adb命令都会将其指令发送到此端口。 The .apk file is transferred to the deviceadb命令用于将.apk文件传输到Android设备上的文件系统中。该位置由应用程序的包名定义。 因此，例如，如果包是com.hfad.bitsandpizzas，则.apk文件将放在/data/app/com.hfad.bitsandpizzas中。 运行Android应用程序的运行方式最近发生了变化。 从API级别21开始，旧的Dalvik虚拟机已被新的Android Runtime取代。 让我们看一下应用程序运行时一步一步发生的事情。 A user asks for an app to be launched一个名为Zygote的过程用于启动应用程序。 Zygote是Android进程的不完整版本 —— 其内存空间包含任何应用程序所需的所有核心库，但它尚未包含特定于特定应用程序的任何代码。 Zygote使用fork系统调用创建自己的副本。 Android是一个Linux系统，fork调用可以很快复制像Zygote这样的进程。这就是使用Zygote进程的原因：复制像Zygote这样的半启动进程比从主系统文件加载新进程要快得多。 Zygote意味着您的应用程序启动速度更快。 Android converts the .dex code to native OAT format新的app进程现在需要加载我们的应用程序的代码。请记住，您的应用代码存储在.apk包中的classes.dex文件中。因此，会从.apk中提取classes.dex文件并放入一个单独的目录中。但是，不是简单地放置classes.dex文件的副本，Android会将classes.dex中的Dalvik字节码转换为本机机器码。 所有以Java代码开头的代码现在都转换为一段本机编译代码。从技术上讲，classes.dex将转换为ELF共享对象。 Android调用此库格式OAT，转换classes.dex文件的工具称为dex2oat。（Android 5.0 开始，dex -&gt; oat 这个转换过程发生在安装过程中） 转换后的文件存储在如下的目录中： 1/data/dalvik-cache/x86/data@app@com.hfad.bitsandpizzas@base.apk@classes.dex 该路径将包含应用程序的包名称，以确保它不会覆盖任何其他应用程序。 转换后的代码将在特定于Android设备CPU的机器代码中。例如，如果Android设备是x86，则OAT文件将如下所示： 123456789100x001db888: 85842400E0FFFF test eax, [esp + -8192]suspend point dex PC: 0x0000GC map objects: v0 (r5), v1 (r6)0x001db88f: 83EC1C sub esp, 280x001db892: 896C2410 mov [esp + 16], ebp0x001db896: 89742414 mov [esp + 20], esi0x001db89a: 897C2418 mov [esp + 24], edi0x001db89e: 8BF8 mov edi, eax0x001db8a0: 890424 mov [esp], eax... The app loads the native library然后将 native library 直接映射到应用程序进程的内存中。 此时开始，应用程序将启动初始界面，应用程序将出现在屏幕上。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义LayoutManager]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2F%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%2F</url>
    <content type="text"><![CDATA[在做了这么长时间的Android开发，还没有遇到过这个需求，不过看了别人的很多效果，感觉很棒，所以找了时间就研究了一下，现在做一些记录，等以后有了相关需要可以快速回顾。在我学习的过程中，不可避免的遇到了很多问题，有的已经解决，有的还未解决，所以这个 Demo 就是看个乐呵吧。自定义一个 LayoutManager 整体给我的感觉是与实现自定义 ViewGroup 的 onLayout 比较像。其他的测量绘制方法都不需要我们实现，测量方法还有很多可以直接使用的： 12androidx.recyclerview.widget.RecyclerView.LayoutManager#measureChildandroidx.recyclerview.widget.RecyclerView.LayoutManager#measureChildWithMargins 这两个方法可以测量 child 的大小，一个不计算 child.layoutParams，一个计算。 测量完成之后，我们就可以获取 child 的大小了： 12androidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredWidthandroidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredHeight 这里不直接使用 child.getMeasureWidth 显然是因为 RecyclerView 是有一个 ItemDecorate 可以设置，不设置就是获取的 getMeasureWidth 的值。 更完美的是，layout child 的时候，也有相应的方法： 1androidx.recyclerview.widget.RecyclerView.LayoutManager#layoutDecoratedWithMargins 使用这个方法，我们就可以将 child 摆到我们想要摆放的位置了，我们只需要传递四大金刚的位置：l,t,r,b。网上看到一个效果就是，它计算出某个 path 的所有点，然后存起来，根据滚动的距离，来取相应的点，然后根据这个点以及child的大小，就可以将这个 child 摆到 path 的路径上，实现一个 item 跟随 path 的效果。只要想清楚了还是不难的。 了解这些，我们还需要了解一下 RecyclerView 的回收机制，因为 RecyclerView 最吊的地方就是回收复用，如果你搞了一个 LayoutManager 但是却无法回收复用，那岂不是很沙雕，关于回收这里就不仔细讲了，看[我的另一篇文章](https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-View/RecyclerView 的缓存机制.md) 吧。 有了上面这些基础，我们就可以开始动手写了。 首先，我们需要确定我们想要的效果，我们先看一下这个效果图： 可以看到： 最左边，是有几个 item 堆在一起了的，那么是怎么实现的呢，其实就是 layout 的时候将 item 之间摆进一点就好了。比如：item 的宽度是 100，高度是 150，第一个item的位置为 【（0，0），（100， 150）】，第二个 item 的位置（假设 item 的 divider 宽度为 0）为 【（100, 0），（200, 150）】。但是我在摆第二个 item 的时候，我偏不从 100 开始摆，我从 20 开始摆，那么第二个 item 就叠在第一个 item 上面了。 右边的就简单了，按照通常的摆法就好了，不搞啥幺蛾子。 对效果了然于胸，我们就可以开始敲代码了，首先自然是继承父类： androidx.recyclerview.widget.RecyclerView.LayoutManager#LayoutManager 它只有一个抽象方法： 123456override fun generateDefaultLayoutParams(): LayoutParams &#123; return LayoutParams( LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT )&#125; 首先，网上一致都是这样实现的，我就很蛋疼了，都不说为什么。 然后，我就去查看了注释，它是这样说的：为 RecyclerView 的 child 生成一个默认的 LayoutParams。那么为何要生成一个默认的 LayoutParams 呢？比如，有的同学在 Adapter 里面加载布局的时候，parent 会传 null，这个时候 child 的就是没有 LayoutParams 的，所以需要生成一个。同样的，PopupWindow 也会遇到。这里我就清楚了，传递 WRAP_CONTENT 是一个保险行为，有最好，没有就使用这个。 注释还说了，这个返回的是 RecyclerView.LayoutParams，所以如果你还想带一些自带的信息在 LayoutParams 里面，你可以继承这个 LayoutParams，然后实现下面3个方法： 123androidx.recyclerview.widget.RecyclerView.LayoutManager#checkLayoutParamsandroidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.view.ViewGroup.LayoutParams)androidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.content.Context, android.util.AttributeSet) 就 OK 了。 搞定了唯一的一个抽象方法，我们就可以正常运行了，但是没啥效果，我们还需要实现 child 的摆放与回收。首先我们搞定 child 的摆放。child 的摆放是在 androidx.recyclerview.widget.RecyclerView.LayoutManager#onLayoutChildren 这个方法里面。我们复写一下： 123override fun onLayoutChildren(recycler: Recycler?, state: State?) &#123; super.onLayoutChildren(recycler, state)&#125; 好奇的点进去看看父类做了什么： 123public void onLayoutChildren(Recycler recycler, State state) &#123; Log.e(TAG, "You must override onLayoutChildren(Recycler recycler, State state) ");&#125; 嗯，他要我们必须重写这个方法，但是又不是抽象的方法，嗯…有趣的女人… 一开始，我是完全不知道应该怎么搞了，所以我看了别人的 demo，发现他们都在最开头搞了这样的一个开头： 123456789// 这个方法看不出来有啥意义啊，应该是根据// androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren// copy 出来的if (state?.itemCount == 0) &#123; recycler?.apply &#123; removeAndRecycleAllViews(this) &#125; return&#125; 嗯，我是很奇怪的，为啥要写这个玩意啊，后来我戳到 LinearLayoutManager 学习了一下，发现它有一个类似的代码，但是它是嵌套在 if 里面的： 123456if (mPendingSavedState != null || mPendingScrollPosition != RecyclerView.NO_POSITION) &#123; if (state.getItemCount() == 0) &#123; removeAndRecycleAllViews(recycler); return; &#125;&#125; 这里，我是真的没有搞懂哦。除非是 itemCount 突然变成 0 了，那么需要将所有 child 都移除并且放到 recycler 里面，但是为啥 LinearLayoutManager 是有条件的呢？？？嗯，猜一下与动画相关吧… 好的，我们继续往下，这里只不过是一个前置处理，处理某些特殊情况，下面我们开始摆放 child，为了方便我们写一个方法： 123456789101112131415override fun onLayoutChildren(recycler: Recycler?, state: State?) &#123; super.onLayoutChildren(recycler, state) // 这个方法看不出来有啥意义啊，应该是根据 // androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren // copy 出来的 if (state?.itemCount == 0) &#123; recycler?.apply &#123; removeAndRecycleAllViews(this) &#125; return &#125; layoutChildren(recycler, state)&#125; 这样看着会舒服一点，一般我不知道咋下手的时候，就会抽一个方法出来，把能写的都写了，至少思路清晰。 开始摆放 child，我们需要计算出第一个 item 的 left： 1var left = paddingLeft 嗯，很简单。 这个时候，就有一个问题浮现出来了，我们的每个 item 是一样大吗？？？ 如果是的话，好说，但是 RecyclerView 就成了岳不群了。如果不是的话，那就复杂了。这里为了简单，我们要求 item 是一样的，毕竟，不一样大也没法堆叠。所以其实仔细想想，实现一个看起来特别酷的效果，限制也很多。 我们定义两个索引值，一个指向屏幕上的第一个 item，一个指向屏幕上的最后一个 item 的后一个位置，就像一个半开区间。 12private var firstVisiblePos = 0private var lastVisiblePos = 0 然后，我们随便取一个 item，测量一下它的大小： 123456// 需要每个child一样大小val firstView: View = recycler.getViewForPosition(firstVisiblePos)measureChildWithMargins(firstView, 0, 0)unitDistance = getDecoratedMeasuredWidth(firstView) + gap// 这个时候，还没有开始摆放，所以用完了再放回去，为了后面的逻辑统一处理recycler.recycleView(firstView) 这里的逻辑很简单，算出 child 的大小，加上 item 之间的距离，算作一个单元距离，就是一个item从一个位置移动到相邻位置的绝对距离。 这里要说的一个重要的点就是，如果我们需要摆一个 child，只能像 recycler 要，并且，用完了还给 recycler，这样我们神不知鬼不觉的就达成了复用的效果。 接着，我们根据滚动的距离来计算出第一个item的索引： 12// 根据 scroll 的距离来计算 firstPos 的位置firstVisiblePos = floor(abs(scrollX).toDouble() / unitDistance).toInt() 这里，我们也可以利用 RecyclerView 的宽度算出 lastVisiblePos 的值，但是就有点重复了，我们在摆放 child 的时候去动态的计算会更好一点，所以这里，我们将 lastVisiblePos 赋值为 itemCount。 12// 该值会动态更新lastVisiblePos = state.itemCount 计算好了两个索引值，我们还需要处理一个问题，就是根据滚动的距离来计算出 View 的偏移距离。 123val frac: Float = (abs(scrollX) % unitDistance) / (unitDistance * 1f)val stackOffset = (frac * stackGap).toInt()val viewOffset = (frac * unitDistance).toInt() unitDistance 是相邻item的单位距离，frac就表示移动到的百分比。利用这个百分比换算出堆叠区域和普通区域布局起始位置的偏移量，然后可以开始布局了。 1234567// 属于堆叠区域if (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123; // 手指向左滑动，则 scrollX 的值会越来越大，frac 也会慢慢变大（0 -&gt; 1 为一个周期） // item 会向右移动 // 这里需要减去，item 才会向左移动 left -= stackOffset&#125; 这里又有几个问题： 这个 layoutManager 一初始化就会堆叠起来，导致前面几个的内容看不到了， 解决办法就是做出一个无限循环的效果，这样就会对数目有所限制，至少是知道有多少数据，或者是做成动态的，一开始不会堆叠， 滑动的时候再考虑如何堆叠。 stackOffset 只需要减去一次，后面的 item 不用重复减去该值，这里我使用了笨办法，搞一个变量标识一下 1234567if (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123; if (!stackOffsetDone) &#123; left -= stackOffset stackOffsetDone = true &#125; left += stackGap&#125; 这个 left 就是 child 布局时用到的值了。对于非堆叠区域同样处理。 后面的代码就简单了： 123456789val view = recycler.getViewForPosition(i)addView(view)measureChildWithMargins(view, 0, 0)val l = leftval t = paddingTopval r = l + getDecoratedMeasuredWidth(view)val b = t + getDecoratedMeasuredHeight(view)layoutDecoratedWithMargins(view, l, t, r, b) 把上面的这些逻辑放入循环就搞定了。 这里效果基本就实现了，但是实际上测试的时候会发现，回收复用会有问题。这个有两个方面的问题： 在 layout 的时候需要将所有 view 全部 detach 再重新布局 detach 的 view 被放入了 scrap 中，我们需要将 scrap 中残留的 item 全部放入 pool 中。 所以，我们可以不用自己一个一个的手动回收，而是可以这样： 在 layout 的前面调用 detachAndScrapAttachedViews ，然后在最后回收。 1234567891011121314151617181920private fun layoutChildren( recycler: Recycler?, state: State?) &#123; if (recycler == null || state == null) &#123; return &#125; detachAndScrapAttachedViews(recycler) ... val scrapList = recycler.scrapList for (i in scrapList.indices) &#123; val holder = scrapList[i] removeAndRecycleView(holder.itemView, recycler) &#125;&#125; 实际上我测试的效果比之前好了很多，但是我还是不太满意，因为有的时候还是会出现 createViewHolder 的调用，虽然次数极少，但是肯定是哪里出了问题，不然是不会这样的。 所以建议还是手动的一个个标记回收。我也对回收这个问题还有疑问，所以这里就不说下去了。 除了回收还有一个问题，就是关于 fling 效果。我测试这个demo 的时候，发现我从最后一个一下滑动到第一个的时候，item停留的位置总是不对，我一直以为是我的计算有问题： 1234567891011121314151617181920212223242526272829303132333435363738/** * dx(dy) 表示本次较于上一次的偏移量，&lt;0为 向右(下) 滚动，&gt;0为向左(上) 滚动； * 这个算法还是无法满足 fling 的要求，fling 的时候 停留的位置不对 * 查了一些资料，可能还需要自定义一个 SnapHelper -&gt; https://www.jianshu.com/p/0e4a93d8e2de */private fun consume(dx: Int): Int &#123; val consumed: Int // dx &lt; 0 表示向右滚动，需要显示左边的内容 if (dx &lt; 0) &#123; // 到了最左边 if (scrollX + dx &lt; 0) &#123; consumed = if (scrollX &gt; 0) &#123; dx - scrollX &#125; else &#123; 0 &#125; scrollX = 0 return consumed &#125; &#125; // dx &gt; 0 表示向左滚动，右边的内容需要显示出来 if (dx &gt; 0) &#123; if (scrollX + dx &gt; maxScrollX) &#123; consumed = if (scrollX &lt; maxScrollX) &#123; maxScrollX - scrollX &#125; else &#123; 0 &#125; scrollX = maxScrollX return consumed &#125; &#125; scrollX += dx return dx&#125; 但是，经过我的打印，发现，这个计算是没有问题了。 顺便说一下，要想滑动，需要重写 LayoutManager 的方法： 123override fun canScrollHorizontally(): Boolean &#123; return true&#125; 然后，在 scrollHorizontallyBy 返回消耗的值： 12345678910override fun scrollHorizontallyBy(dx: Int, recycler: Recycler?, state: State?): Int &#123; if (dx == 0 || state?.itemCount == 0) &#123; return 0 &#125; layoutChildren(recycler, state) return consume(dx)&#125; 我就感觉这个与 NestedScrolling 接口很相似。 跑题了，关于 fling，查了一些资料，可能还需要自定义一个 SnapHelper -&gt; https://www.jianshu.com/p/0e4a93d8e2de。 当然你也可以自己监控滑动状态，然后自动的调整滑动位置，就像画廊一样。 项目地址： https://github.com/aprz512/LayoutManagerDemo]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewGroup 的 generateLayoutParams 方法的作用]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FViewGroup%20%E7%9A%84%20generateLayoutParams%20%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[不知道大家在编写布局的时候有没有这样的疑问：在 RelativeLayout 布局里面可以对子控件使用 layout_alignParentRight 等属性，但是在 FrameLayout 或者 LinearLayout 中就没有，这是为什么呢？12345678910&lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentRight="true" /&gt;&lt;/RelativeLayout&gt; 而且，在代码中，我们获取子控件的 LayoutParams 的时候，默认是 ViewGroup.LayoutParams 类型的，我们想要使用某些特殊的字段，还需要转换为 RelativeLayout.LayoutParams 或其他具体的 LayoutParams 才行。这又是为什么呢？ 下面，我们一一道来。 当我们自定义一个控件的时候，如果我们做的灵活一点，一般会提供一些属性配置方法。 1234567891011121314public TagGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TagGroup); int targetColorInt = typedArray.getInt(R.styleable.TagGroup_targetColor, 0); if (targetColorInt != 0) &#123; targetColor = context.getResources().getColor(targetColorInt); &#125; else &#123; targetColor = Color.WHITE; &#125; typedArray.recycle();&#125; 在 attrs.xml 中配置： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="TagGroup"&gt; &lt;attr name="targetColor" format="integer"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 但是使用这种方式的话，不管你在什么 ViewGroup 下使用，它都有这个属性。而且，在xml中，这个属性只能给自己用，无法给它的子控件使用。 显然，RelativeLayout 没有使用这种方式。那它是怎么做的呢？答案是通过复写 ViewGroup 的 generateLayoutParams 方法实现的。 这里我们据一个例子来说明，我们自定义一个控件： com.aprz.myapplication.MyViewGroup 1234567891011class MyViewGroup @JvmOverloads constructor( context: Context, attributeSet: AttributeSet? = null, defStyleAttr: Int = 0) : ViewGroup(context, attributeSet, defStyleAttr) &#123; override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123; // TODO("not implemented") &#125; &#125; 由于我们关注的重点不在控件的功能，所以我们不重写 onLayout 方法。这里我们需要重写的是它的 generateLayoutParams 方法： com.aprz.myapplication.MyViewGroup#generateLayoutParams 123override fun generateLayoutParams(attrs: AttributeSet?): LayoutParams &#123; return MyLayoutParams(context, attrs)&#125; 这里我们返回了我们自己创建的 MyLayoutParams 对象。它的实现如下： com.aprz.myapplication.MyViewGroup.MyLayoutParams 123456789101112131415161718class MyLayoutParams(context: Context, attrs:AttributeSet?) : ViewGroup.MarginLayoutParams(context, attrs) &#123; private var stayLeft : Int = 0 private var stayRight : Int = 0 init &#123; val a = context.obtainStyledAttributes( attrs, R.styleable.MyViewGroup_Layout ) stayLeft = a.getResourceId(R.styleable.MyViewGroup_Layout_stayLeft, 0) stayRight = a.getResourceId(R.styleable.MyViewGroup_Layout_stayRight, 0) a.recycle() &#125;&#125; 这里的代码应该就很熟悉了，与自定义控件的属性的配置方式与流程基本是一摸一样的。同样的也需要在 attrs.xml 中配置： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="MyViewGroup_Layout"&gt; &lt;attr name="stayLeft" format="reference" /&gt; &lt;attr name="stayRight" format="reference" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这样，我们在 xml 中使用该布局的时候，就可以给子控件配置这两个属性了： 123456789101112131415&lt;com.aprz.myapplication.MyViewGroup android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tv1" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;TextView app:stayRight="@id/tv1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/com.aprz.myapplication.MyViewGroup&gt; 其实generateLayoutParams方法的作用其实就是定义你的控件下所有子控件所使用的layoutParams类，通过这种形式使你的控件可以按自己想要的方式和属性来操作它的子view，你甚至不需要关心子view本身，只要你重写过generateLayoutParams方法，他们就会使用你给的LayoutParams来修饰自己。 但是，这里有个问题，就是 IDE 好像无法识别自定义的属性，在 xml 中使用的时候会报红线，但是可以运行。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的工作原理]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRootImpl &amp; DecorView当我们在 Activity 中调用 setContentView 方法的时候，实际上 Activity 是将这个方法转发给了 Window。 android.app.Activity#setContentView(int) 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 而 Window 的 setContentView 方法会创建 DecorView 对象。 1234567891011@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 这个方法里面就实例化了一个 DecorView installDecor(); &#125; ... &#125; 那么，有了 DecorView 之后，后面的流程就是解析我们在 xml 中写的布局，将xml转换成真正的 View 对象，然后添加到 DecorView 中（DecorView 是继承至 FrameLayout）。 但是我们都知道，在 onCreate 中我们是无法看到布局的，就像我们在内存中创建了一个 View 对象，我们是看不到它的，只有将它添加到界面上我们才能看到。 那么，如何将一个 View 添加到界面上呢？想必大家都知道以前手机上的悬浮按钮很流行，我们自己想要做一个这样的效果，一般都是通过 WindowManager 来实现的。所以说，使用 WindowManger 就可以将一个 View 显示到界面上了。当一个 View 已经显示到界面上之后，在给他添加子 View 就不用 WindowManager 了，可以直接添加，这就是我们可以动态更改布局，而不用通过WindowManager 的原因，因为 Activity 已经通过 WindowManager 将 DecorView 添加到了 PhoneWindow 上。我们操作的是 DecorView 的子 View。 android.app.ActivityThread#handleResumeActivity 12// 这里的 l 是 WindowManager.LayoutParams 对象的类型wm.addView(decor, l); 可以看到在 Activity 的 onResume 执行后，View 才会被添加到 Window 上，所以在这之前，我们是看不到界面的，故而不要在这之前做太多的事件，以免黑（白）屏时间太长，给用户一个不好的体验。 看到这里，我们已经知道 DecorView 与 WindowManager 是如何产生关系的了！ 那么 ViewRootImpl 又是如何插一脚的呢？ 上面的 addView 方法中，其实创建了一个 ViewRootImpl 对象： android.view.WindowManagerGlobal#addView 1234567ViewRootImpl root;...root = new ViewRootImpl(view.getContext(), display);...// 这个 view 就是上面的 DecorView 对象// 这里将 view 保存到了自己的成员变量 mView 中root.setView(view, wparams, panelParentView); 我们先来看看官方对 ViewRootImpl 的介绍： ViewRootImpl是View中的最高层级，属于所有View的根（但ViewRootImpl不是View，只是实现了ViewParent接口），实现了View和WindowManager之间的通信协议，实现的具体细节在WindowManagerGlobal这个类当中。 也就是说，View 并不会与 WindowManager 直接交流，他们有一个中间人，就是 ViewRootImpl，但是它的功能不止于此，它还负责 View 的测量-布局-绘制流程。可以看作是 View 树的操纵者。 View的测量过程对于 DecorView ，其 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来共同决定。 对于普通的 View，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。 具体一点来说： 当 View 采用具体数值的宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是EXACTLY并且其大小遵循 LayoutParams 中的大小。 当 View 的宽/高是 match_parent 时，如果父容器的模式是EXACTLY模式，那么 View 也是EXACTLY模式并且其大小是父容器的剩余空间。如果父容器是AT_MOST模式，那么View 也是AT_MOST模式并且大小为父容器的剩余空间（可以看出，View 与 父容器的模式一样）。 当 View 的宽/高是 warp_content 是时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是 AT_MOST 模式并且大小为父容器的剩余空间。 决定了 View 的 MeasureSpec 值之后，就可以开始执行 View 的 measure 方法了。 measure 方法就是执行测量过程的方法，它会调用 onMeasure 方法，经常自定义控件的就很熟悉这个方法了。我们可以通过复写 onMeasure 这个方法来绝定一个控件在各种情况下应该有多大。 onMeasure 方法有两个参数： android.view.View#onMeasure 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; widthMeasureSpec 与 heightMeasureSpec 这两个值就是根据上面的规则得到的（虽然上面我们只说了测量模式，没有测量大小）。View 有了这两个值就可以知道自己在各种情况下应该占多大的位置了。 一般情况下，View 测量出来的大小就是 widthMeasureSpec / heightMeasureSpec 中的 size 值。 但是也有例外，这个时候，View 的宽/高由 minWidth 与 background 一起决定，如果 background 为空，那么值就是 minWidth/minHeight，如果有 background，那么值就取 minWidth/minHeight 与 background 的原始宽/高 中的较大者。 当我们继承一个 View 来自定义控件的时候，如果不复写 onMeasure 就会出现一个问题： 在使用 wrap_content 属性的时候，是不生效的，效果与 match_parent 一样！！ 导致这个的原因是：View 为 wrap_content 的时候，模式是 AT_MOST，大小为父容器的剩余空间。这样的话，与match_parent 的表现形式是一样的。 所以，可以这样解决： 12345678910111213141516171819202122@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int modeW = MeasureSpec.getMode(widthMeasureSpec); int sizeW = MeasureSpec.getSize(widthMeasureSpec); int modeH = MeasureSpec.getMode(heightMeasureSpec); int sizeH = MeasureSpec.getSize(heightMeasureSpec); int width, height; if (modeW == MeasureSpec.AT_MOST) &#123; width = mMyWidth; &#125; else &#123; width = sizeW; &#125; if (modeH == MeasureSpec.AT_MOST) &#123; height = mMyHeight; &#125; else &#123; width = sizeH; &#125; setMeasuredDimension(width, height);&#125; 其实，只是指定了 AT_MOST 模式下的值，其他的没有改变。 ViewGroup 的测量过程ViewGroup 在测量的时候，会先去测量所有的 Child。调用 child 的 measure 方法来测量 child 的大小，然后根据 child 的大小以及自己的布局规则来决定自己的大小。 之所以，还涉及 ViewGroup 的布局规则，是因为每个ViewGroup 都不一样，比如：LinearLayout 是按照线程布局，FrameLayout是按照层叠布局，即使他们的所有child都一样，测量出来的结果肯定不是一样的。 android.view.ViewGroup#measureChildren 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; android.view.ViewGroup#measureChild 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 显然，measureChild 就是取出LayoutParams，然后和 parentMeasureSpec 一起来决定child 的 MeasureSpec，这个过程与 View 的测量过程是一样的。 android.view.ViewRootImpl#performTraversals 是谁触发的我们知道在 ViewRootImpl 创建出来之前，View是不会执行测量等一系列流程的，这是因为View的测量等都是由 ViewRootImpl 操纵的。 那么，View的第一次测量是从什么时候开始的呢？ android.view.ViewRootImpl#setView 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); 当 View 被添加到 window 上之前，ViewRootImpl 会执行一次 requestLayout，这个货会触发一系列连锁反应，最后调用到 performTraversals 里面。 为什么使用 view.post(xxx) 可以获取到 view 的宽高？？？这是因为 view 将 runnable 都存到了自己维护的一个队列中。 android.view.HandlerActionQueue#postDelayed 1234567891011public void postDelayed(Runnable action, long delayMillis) &#123; final HandlerAction handlerAction = new HandlerAction(action, delayMillis); synchronized (this) &#123; if (mActions == null) &#123; mActions = new HandlerAction[4]; &#125; mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction); mCount++; &#125;&#125; 等到 view 显示出来的时候，才会取出来执行。 android.view.ViewRootImpl#performTraversals 12// Execute enqueued actions on every traversal in case a detached view enqueued an actiongetRunQueue().executeActions(mAttachInfo.mHandler); 可以看到，每次执行 performTraversals 的时候，就调用了 View 维护的队列的 executeActions 方法。 123456789101112public void executeActions(Handler handler) &#123; synchronized (this) &#123; final HandlerAction[] actions = mActions; for (int i = 0, count = mCount; i &lt; count; i++) &#123; final HandlerAction handlerAction = actions[i]; handler.postDelayed(handlerAction.action, handlerAction.delay); &#125; mActions = null; mCount = 0; &#125;&#125; 而这个队列，将 runnable 交给了 handler 去执行，这个 handler 是主线程的 handler。那么这个 runnable 会什么时候执行呢？这里我们先不管，我能只需要知道这个 runnable 与 测量流程 那个先执行就好了。 performTraversals 在调用了 executeActions 之后，将 runnable 放入主线程的队列，然后就接续往下执行，下面就是 View 的测量-布局-绘制流程了，所以说不管 runnable 什么时候执行，它肯定是在测量流程的后面执行，这也是为什么能在 view.post 的 runnable 可以拿到 view 的宽高的原因。 View 的 layout 过程一个 view 在 layout 方法中会决定自己在父布局的位置，如果这个 view 还有 child，那么它会在 onLayout 方法中调用 child 的 layout 方法，决定 child 的位置。这样达到一个循环… 其实自定义一个 ViewGroup，它的 onLayout 实现还是比较简单的，只要按照业务流程，慢慢写就好了，就和摆东西一样，每个东西的大小你都知道了，想怎么摆就怎么摆。就是里面的 margin 比较蛋疼，需要细心一点。 View 的 draw 过程 先绘制背景（肯定的，不然内容被背景盖住了） 绘制自己（onDraw） 绘制 children （dispatchDraw） 绘制装饰 （onDrawScrollBars） 与这个过程有关的有一个很重要的东西，就是补间动画执行的原理。 1234567891011121314151617181920212223242526272829303132333435363738boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ... //获取当前Animation final Animation a = getAnimation(); if (a != null) &#123; more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); ... &#125; ... //处理滑动 if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy); &#125; else &#123; if (!drawingWithRenderNode) &#123; //处理滑动 canvas.translate(mLeft, mTop); &#125; if (scalingRequired) &#123; ... // mAttachInfo cannot be null, otherwise scalingRequired == false final float scale = 1.0f / mAttachInfo.mApplicationScale; //处理缩放 canvas.scale(scale, scale); &#125; &#125; //处理透明度 float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha()); ... if (drawingWithRenderNode) &#123; renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha()); &#125; else if (layerType == LAYER_TYPE_NONE) &#123; canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha); &#125; ... return more;&#125; 可以看到，在 View 的绘制过程中，会获取 view 相关的动画，然后根据动画来计算当前 view 应该所处的位置，透明度等等。所以，如果一个 view 不执行重绘，动画是显示不出来的。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navigation 的使用记录]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FNavigation%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[接到一个处理流程的需求，有好几个界面，界面之间的跳转有点复杂，还需要支持回退，于是想到使用 Jetpack 的 Navigation 包。具体的使用可以参考官方文档 。暂时不做介绍，考虑做一个翻译系列，将 Jetpack 全部翻译一遍，不过现在没有精力。等使用 Navigation 写完全部的跳转之后，发现一个严重的问题，那么就是 Navigation 不支持 Fragment 的状态保存。也就是说我在 FragmentA 做了一些操作，然后调到 FragmentB，在 FragmentB 中准备做一些操作的时候，突然发现有问题，想回到 FragmentA ，于是我点击了返回键回到 FragmentA ，就会发现 FragmentA 中的数据被重置了，我在 FragmentA 的操作没有了，这是用户无法接受的。 然后我去看了官方的 demo，发现它居然可以记录操作，我对比了一下工程代码，发现官方demo里面的是 EditText，我的项目里面是 CheckBox，只有控件的区别，于是我果断在官方的demo里面添加了CheckBox控件，发现也无法保存CheckBox的状态。这就让我无法理解了，为啥 EditText 可以保存状态，CheckBox 就不行？这个问题我现在还没有答案。 我又去翻了一下，Navigation 的相关源码，控制 Fragment 跳转的是androidx.navigation.fragment.FragmentNavigator。 它有一个 navigate 方法： androidx.navigation.fragment.FragmentNavigator#navigate 123456789101112131415161718 @Nullable @Override public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; ... final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); final FragmentTransaction ft = mFragmentManager.beginTransaction();... ft.replace(mContainerId, frag); ft.setPrimaryNavigationFragment(frag); ... ft.commit(); ... &#125; 这个逻辑很明显了，首先实例化要跳转到的 Fragment，然后直接替换原来的 fragment。 这里说一下，当使用 replace 的时候会发生什么： 假设 A 已经添加到了 mContainerId，这个时候调用了 replace B。 Fragment B 123onAttachonCreate Fragment A 123456789onPauseonStoponDestroyViewonDestroyonDetach Fragment B 1234567onCreateViewonActivityCreatedonStartonResume 可以看到，Fragment A 执行了 onDestroyView 与 onDetach，也就是说它完全从 Activity 上脱离了。再显示出来需要重新走一遍生命周期流程，但是这里需要注意的是，这个生命周期流程是没有添加到会退栈的，添加到会退栈的有点不一样。 因为 FragmentNavigator 内部将 Fragment A 添加到了会退栈，所以调用 replace B 的生命周期流程如下： Fragment B 123onAttachonCreate Fragment A 12345onPauseonStoponDestroyView Fragment B 1234567onCreateViewonActivityCreatedonStartonResume 可以看到与上面的区别是，Fragment A 只执行到了 onDestroyView，并没有走下面的 onDestroy 等方法。虽然它只执行到了 onDestroyView，但是它重新显示的时候，肯定要重新走 onCreateView，而一般我们的初始化逻辑都是在 onCreateView 中执行的，所以操作就都被重置了。 要想解决这个问题，现在就有两种选择：一是放弃 Navigation，二是自定义 FragmentNavigation，虽然我知道 第二种方法比较蛋疼，但是我还是想试一下，虽然最后还是失败了，但是还是记录一下过程。 自定义 Navigation 的文档在 这里，也可以参考这个项目 。 首先要处理 Fragment 每次都实例化的问题，这里可以自己缓存起来。 然后是想办法将 replace 替换为 add 之类的方法。我是覆盖了 navigate 方法，然后copy出了一部分源码，效果是达到了。 最后是处理返回键，这个我没有处理好。其实，不继承 FragmentNavigation，而是继承 Navigator，完全自己实现一个，或许会更简单一些，不过需要对 Fragment 的理解比较深入。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drawable 介绍]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FDrawable%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Drawable 的内部宽高比较重要，通过 getIntrinsicWidth 等可以获取。不是所有的 Drawble 都有内部宽高，对于图片形成的 drawble ，它的内部宽高就是图片的宽高，对于颜色形成的 drawable，它没有内部宽高。Drawble 没有大小的概念，都会拉伸到与 View 一样大。 BitmapDrawable属性介绍： antialias： 抗锯齿，就是画线的时候锯齿会减少，特别是画斜线与园 dither： 开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一样的时候，开启这个可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果。 比如：图片的色彩模式为 ARGB8888，手机屏幕只支持 RGB555，这个时候，开启抖动选项可以让图片显示不会太过失真。 filter：图片拉伸或者压缩时可以保持较好的效果 gravity：与 scaleType 类似 tileMode：平铺模式，有重复平铺（repeat），镜像平铺（mirror），边缘拉伸（clamp），禁止（disable） BitmapDrawable 用起来比较简单。 .9 图片需要特殊说明以下： left 线：表示纵向可拉伸区域 top 线：表示横向可拉伸区域 bottom 线 与 right 线交叉的区域：表示内容显示的区域 具体的请点击这里 。 ShapeDrawable比较常用，可以画各种图形，渐变，只有 size 属性需要说一下。 size ： 这个属性可以设置 getIntrinsicWidth 的返回值。表示 drawble 的内部宽高。 这里有个比较神奇的地方： 首先，我们写一个 shape： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:dither="true" android:shape="rectangle"&gt; &lt;size android:width="1dp" android:height="1dp" /&gt; &lt;solid android:color="@color/colorAccent" /&gt; &lt;corners android:radius="5dp" /&gt; &lt;stroke android:width="2dp" android:color="@color/colorPrimaryDark" android:dashWidth="3dp" android:dashGap="3dp" /&gt;&lt;/shape&gt; 然后，设置到一个 View 上面： 12345678&lt;TextView android:id="@+id/tv" android:layout_width="200dp" android:layout_height="100dp" android:layout_centerInParent="true" android:background="@drawable/shape_drawable" android:gravity="center" android:text="Hello World!" /&gt; 然后，获取它的 background： 12TextView tv = (TextView)findViewById(R.id.tv);Drawble drawable = (GradientDrawable) tv.getBackground(); 你会发现，它获取到的不是 ShapeDrawable，而是 GradientDrawable。 LayerDrawable层叠的 drawble。它可以画出单一边线的效果，其实就是利用几个大小差一点点的矩形做成的效果： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--底层使用蓝色填充色--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color="#02a0ef"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--上面一层距离底层的顶部1dp,类似marginTop,填充色为白色，这样就形成了一个带有蓝色顶部边线的白色背景的图--&gt; &lt;item android:top="1dp"&gt; &lt;shape&gt; &lt;solid android:color="#fff"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; ![](F:\note-markdown\Drawable 介绍\20161206100146670.jpg) StateListDrawble就是对应于 selector 标签，还是非常常用的。 不过需要注意的是，系统会根据当前的状态从selector中选择对应的 item，系统会按照从上往下的顺序查找，知道找到第一条匹配的 item。 这里就要注意了，如果你把默认的item放在第一条的话，系统寻找的时候，无论是选中，按压等所有的情况都会匹配第一条，因为默认的不带任何状态，系统认为它匹配所有的状态。 LevelListDrawble对应于 level-list 标签。 可以用于切换图片，一个等级对应一张图，换图的时候只需要调用 img.setImageLevel 就好了。 TransitionDrawable对应于 transition 标签。 可以用于给一张图切换到另一张图时的过渡动画。 InsetDrawable对应于 inset 标签。 当一个 View 需要背景比内容区域要小的时候，可以使用这个。 ScaleDrawable对应于 scale 标签。 ScaleDrawable 有一个等级的概念，等级不仅会影响缩放的比例，还会影响绘制。 android.graphics.drawable.ScaleDrawable#draw 1234567@Overridepublic void draw(Canvas canvas) &#123; final Drawable d = getDrawable(); if (d != null &amp;&amp; d.getLevel() != 0) &#123; d.draw(canvas); &#125;&#125; 显然，如果 level 是 0 的时候，不会绘制 drawble。 对于缩放比例，它内部还有这样的一个公式： 12// 伪代码w -= (int) (w * (10000 - level) * mScaleState.mScaleWidth / 10000) 可以看到，如果 level 越接近于0（需要大于0），那么缩放的比例就与 （1- mScaleState.mScaleWidth） 越相近。如果 level 为 10000，那么就是不缩放，不管 mScaleState.mScaleWidth 的值为多少。 mScaleState.mScaleWidth 就是我们在 xml 中设置的 scaleWidth 等属性。 看一个例子，将一张图缩小为原来的30%左右（之所以是为左右，是因为 level 最小为1，所有会有 1/10000的 误差）： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/logo" android:scaleGravity="center_vertical|center_horizontal" android:scaleHeight="70%" android:scaleWidth="70%"/&gt; 注意，这里是缩小 70%。由于 level 默认为0，所以我们还需要用代码设置以下： 1scaleDrawable.setLevel(1); ClipDrawable对应于 clip 标签。 对一个drawable进行裁剪。其中 gravity 属性表示裁剪方向。 需要设置 leve 来表示裁剪多少，范围是 0~10000，0表示完全裁剪，即整个drawable都不见了，而 10000 表示不裁剪。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的 onMeasure 方法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%20onMeasure%20%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[View 的测量过程中，有一个比较重要的类需要掌握：MeasureSpec。我们在阅读源码的时候会发现，在 View 的测量过程中，MeasureSpec 是一个会经常出现的类，如果不先掌握这个类的话，是没法阅读下去的。MeasureSpec 会在很大程度上决定一个 View 的尺寸规格，之所以是很大程度上是因为这个过程还受父容器的影响，因为父容器影响 View 的 MesaureSpec 的创建过程。 在测量过程中，系统会将 View 的 LayoutParams 根据父容器所施加的规则转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来测量出 View 的宽/高。 MeasureSpecMeasureSpec 是一个int值，但是这个int值被分为了两部分，一部分表示 SpecMode （测量模式），一部分表示 SpecSize（在某种测量模式下的大小）。 可能有很多人想不通，一个int型整数怎么可以表示两个东西（大小模式和大小的值），一个int类型我们知道有32位。而模式有三种，要表示三种状态，至少得2位二进制位。于是系统采用了最高的2位表示模式。如图： 最高两位是00的时候表示”未指定模式”，即MeasureSpec.UNSPECIFIED。 最高两位是01的时候表示”‘精确模式”，即MeasureSpec.EXACTLY。 最高两位是11的时候表示”最大模式”，即MeasureSpec.AT_MOST。 精确模式（MeasureSpec.EXACTLY） 在这种模式下，尺寸的值是多少，那么这个组件的长或宽就是多少。 最大模式（MeasureSpec.AT_MOST） 这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。 未指定模式（MeasureSpec.UNSPECIFIED） 这个就是说，当前组件，可以随便用空间，不受限制。 MeasureSpec 通过将 SpecMode 与 SpecSize 打包成一个 int 值来避免过多的对象内存分配。为了方便操作，它还提供了对应的打包与解包方法。 12345678// 将 size 与 mode 组合成一个 MeasureSpec 对象android.view.View.MeasureSpec#makeMeasureSpec// 从 MeasureSpec 中获取 modeandroid.view.View.MeasureSpec#getMode// 从 MeasureSpec 中获取 sizeandroid.view.View.MeasureSpec#getSize 在 View 测量的时候，系统会将 LayoutParams 在父容器的约束下转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来确定 View 测量后的大小。（这里需要注意，MeasureSpec 不是由 LayoutParams 唯一决定的，而是由 LayoutParams 与父布局一起决定的） 各种 View 测量的区别顶层 View我们知道一般的 View 都会有父布局，但是最顶层的 View 是没有的，那么它是如何测量的呢？ 首先它会获取 LayoutParams，再判断 LayoutParams 宽高的值： 如果为 LayoutParams.MATCH_PARENT，这表示精确模式，大小就是窗口大小。 如果为 LayoutParams.WRAP_CONTENT，这表示最大模式，大小未定，但是不能超过窗口大小。 这就比较简单了，顶层View的测量，一般宽高都是 LayoutParams.MATCH_PARENT，大小为窗口大小。 子 View对于普通的 View 来说，它的测量与父布局有关，而每个父布局的特性又不同，无法每个都涉及到，所以这里采取一个“管中窥豹，可见一斑”的方法。 这里介绍一下 ViewGroup 的 measureChildWithMargins 方法。 android.view.ViewGroup#measureChildWithMargins 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 方法中的 getChildMeasureSpec 方法比较长，就不贴代码了，下面会有文字说明。 getChildMeasureSpec 其实最后就是生成了一个 MeasureSpec 对象。 它的 size 由两部分决定，一个是 parentWidthMeasureSpec，一个是 lp.width / lp.height。 具体的规则用表说明： 从这个表中我们可以看到，在构造 child 的 MeasureSpec 还是优先考虑了 child 自身的 size 的，特别是 child 直接要求一个固定的值的时候。 我们深入思考一下，比如我们经常使用到的 LinearLayout（竖向），它在决定 child 的大小的时，肯定不能让 child 的高度与自己的高度一样大，那么它是如何处理的呢？我们看看源码： android.widget.LinearLayout#measureVertical 123final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,lp.width);child.measure(childWidthMeasureSpec, childHeightMeasureSpec); 可以看到，LinearLayout 并没有使用 ViewGroup 提供的 measureChild 方法，因为它并不符合 LinearLayout 的特性。那么哪一个布局符合呢？？？FrameLayout！！！ android.widget.FrameLayout#onMeasure 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); ... for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);... &#125; &#125; ...&#125; 可以看到，它就是直接使用了 measureChildWithMargins 方法，因为它的特性只是做了一个层叠，并没有其他对 child 有其他限制，所以可以直接使用。 例子说了这么多，我们来看看一个实际的应用场景吧。 我们知道，TextView 是有自己的 onMeasure 方法的。系统提供的 TextView，文字是从做到右的，那么我们现在想做这样的一个效果，将 TextView 的显示旋转一下，从上到下。如下图： 变成这样： 那么，有的同学就说话了，这旋转一下不就不可以了吗！是这样吗？在我们的屏幕中，不可能只会有一个 TextView，所以这个 TextView 很可能会与其他控件一起排列，当我们在旋转之前，假设它的宽与高是 100*300，那么旋转之后，它的高度变成了300，这个时候，由于父布局的限制，我们很可能看不到整个 TextView。而且我们在 xml 中也不好去预览它的效果。 那么下面，我们就来实现一下这个效果。 首先我们需要处理该控件的大小。 12345@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.measure(heightMeasureSpec, widthMeasureSpec); setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());&#125; 我们首先来看这个方法：super.measure(heightMeasureSpec, widthMeasureSpec);。 这行代码非常容易引起误解，有的人就以为，我们将 widthMeasureSpec 与 heightMeasureSpec 换了一下，那么它测量出来的宽高自然就会互换。这是错误的理解！！！ 比如，我们在 xml 中是这样使用这个自定义控件的： 12345678910111213&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res/com.yoog.widget" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;com.yoog.widget.VerticalTextView android:text="20:59" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt; 我们假设20：59这串文字的长度为 300，高度为 100。父布局的宽高均大于 300。 所以，TextView 测量出来的就是 300*100，VerticalTextView 测量出来的值应该是 100 * 300。 但是，如果父布局的高度只有 250 的时候，横着测量的时候，是完全没有问题的，仍然测量出 300 * 100，但是竖着测量的时候，高度只能有 250，它需要换行，所以，结果是 200 * 250。 所以说，将 widthMeasureSpec 与 heightMeasureSpec 互换，只是为了正确的将父布局对 child 的影响正确的传递进去。 由于，正确的传递了父容器的宽与高，走 TextView 的方法自然就会测量出正确的值，然后我们调用 setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth()); 方法，就可以将宽与高换过来了。 至于 onDraw 方法，我们就不深入了，只需要在 view 的左上角旋转一下画布就好了。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压缩、混淆、优化你的App]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%B1%89%E5%8C%96%2F%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86%E3%80%81%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84App%2F</url>
    <content type="text"><![CDATA[为了让App的体积尽可能的小，我们在打 release 包的时候，应该开启 shrinking 选项来移除无用代码和资源。当开启 shrinking 后，还会带来一些额外好处，比如混淆，它会缩短App里面类与成员的名字，比如优化，它会采取一些激进的策略来进一步减小App的大小。当我们的项目使用的是 Android Gradle plugin 3.4.0 及以上的时候，gradle 插件不再使用 ProGuard 来执行编译时的代码优化，而是使用 R8 编译器来处理下面的编译时任务： 代码压缩：检测 App 与依赖的 library 中的无用类，字段，方法，属性并移除它们（可以缓解一下 64K 问题）。比如：如果我们只使用了一个依赖库中的少量方法，代码压缩就可以识别这些使用的代码，并且移除哪些未使用的代码。 资源压缩：移除打包App中的未使用的资源，包括library中未使用的资源。它最好与代码压缩一起使用，因为代码被移除之后，这些代码引用的资源也就可以安全移除了。 混淆：缩短类与成员的名字的长度，也就可以减少 dex 的大小。 优化：检查并重写代码，来进一步减小 dex 的大小。比如：R8发现 else{} 是一段无法到达的代码（永远不会走这个分支），那么它会移除这个 else{}分支。 当构建 release 版本的时候，R8 会默认执行上面说的任务。你也可以通过 ProGuard 规则文件禁止这些任务的执行。实际上，R8 编译器与 ProGuard 一样，都会受到 ProGuard 规则文件的影响。 开启压缩，混淆与优化当使用Android Studio 3.4或Android Gradle插件3.4.0及更高版本时，将项目的Java字节码转换为在Android平台上运行的DEX文件的默认编译器是 R8。但是，使用Android Studio创建新项目时，默认情况下不会启用这些优化。这是因为这些编译时优化会增加项目的构建时间，而且如果你不知道如何去自定义的保留代码，可能会导致运行时错误。 所以，最好是在准备发布，打包App的最终版本的时候，开启这些选项（module下的 build.gradle）： 123456789101112131415161718192021android &#123; buildTypes &#123; release &#123; // Enables code shrinking, obfuscation, and optimization for only // your project's release build type. minifyEnabled true // Enables resource shrinking, which is performed by the // Android Gradle plugin. shrinkResources true // Includes the default ProGuard rules files that are packaged with // the Android Gradle plugin. To learn more, go to the section about // R8 configuration files. proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; ...&#125; R8 配置文件R8使用 ProGuard 规则文件来修改其默认行为，还可以更好地了解应用程序的结构，例如那些作为应用程序代码入口点的类。尽管这些规则文件可以修改，但是有些规则文件是编译工具自动生成的，比如 AAPT2，还有些是从 library 中继承过来的。 下面这个表描述了 R8 使用的规则文件的来源： Source Location Description Android Studio &lt;module-dir&gt;/proguard-rules.pro 创建一个新的工程的时候，IDE会在 module 目录下生成一个文件，里面默认是没有应用任何规则，但是我们可以添加自定义规则。 Android Gradle plugin Gradle 插件在编译时生成文件 Android Gradle插件会生成proguard-android-optimize.txt，其中包含对大多数Android项目有用的基本规则，并且还启用了 @Keep 注解。 Library dependencies AAR libraries: &lt;library-dir&gt;/proguard.txt JAR libraries: &lt;library-dir&gt;/META-INF/proguard/ 如果AAR库在发布时使用自己的ProGuard规则文件，当我们的项目依赖该 AAR 时，则R8会在编译项目时自动应用其规则。为AAR库配置打包的规则文件非常有用，因为它意味着——库开发人员已经为我们执行了故障排除步骤。但是，我们应该知道，因为ProGuard规则是附加的，所以AAR库依赖项包含的某些规则无法删除，并且可能会影响应用程序其他部分的编译。例如，如果库包含禁用代码优化的规则，则该规则将禁用整个项目的优化。 Android Asset Package Tool 2 (AAPT2) 设置 minifyEnabled 为 true，构建之后，会生成文件 &lt;module-dir&gt;/build/intermediates/proguard-rules/debug/aapt_rules.txt AAPT2根据应用程序manifest，布局和其他应用程序资源中的类的引用生成保留规则。例如，AAPT2为应用程序manifest中作为入口点注册的每个Activity都有保留规则。 自定义配置文件 与第一个一样，我们可以额外的创建一些文件用来指定规则，创建之后需要在 build.gradle 中配置 可以包含其他配置，R8会在编译时应用它们。 将minifyEnabled属性设置为true时，R8会合并上面列出的所有可用来源的规则。当使用R8进行故障排除时，你一定要了解这些，以免出现一些你无法理解的行为，比如 library 中的规则影响到整个工程。 你可以使用下面的命令来输出一份详细的关于 R8 编译的报告文件： 12// You can specify any path and filename.-printconfiguration ~/tmp/full-r8-config.txt 包含其他配置使用Android Studio创建新项目或模块时，IDE会创建| /proguard-rules.pro文件，以便我们包含自己的规则。我们还可以通过将其他规则文件添加到模块的build.gradle文件中的proguardFiles属性中来包含其他的规则。 例如，可以通过在相应的productFlavor块中添加另一个proguardFiles属性来为指定的构建变体添加额外的规则。下面的示例将flavor2-rules.pro添加到flavor2的 product flavor中。现在，flavor2 就有了3个规则文件，因为 release 块中配置的文件也包含在里面。 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), // List additional ProGuard rules for the given build type here. By default, // Android Studio creates and includes an empty rules file for you (located // at the root directory of each module). 'proguard-rules.pro' &#125; &#125; flavorDimensions "version" productFlavors &#123; flavor1 &#123; ... &#125; flavor2 &#123; proguardFile 'flavor2-rules.pro' &#125; &#125;&#125; 压缩代码将minifyEnabled属性设置为true时，默认情况下会启用使用R8的代码压缩。 代码压缩是 R8 删除在运行时不需要的代码的过程。整个过程可以极大的减少App的体积，特别是你引入很多库，但是每个库都只使用了少量的功能。 要压缩应用程序的代码，R8首先根据组合的配置文件集确定应用程序代码中的所有入口点。这些入口点包括Android平台可用于打开应用程序的所有Activity或Service。R8会从每个入口点开始检查应用程序的代码，检测应用程序可能在运行时访问的所有方法，成员变量和其他类，然后构建一个图。未连接到该图的代码被视为无法访问，可能会从应用中删除。如下图所示： 上图中建立的图结构中，OkayApi 类没有在其中，所以它会被删除。 R8 通过工程的配置文件集来决定所有入口点，也就是说，keep规则指定R8在缩小应用程序时不应丢弃的类，R8将这些类视为应用程序的可能入口点。Android Gradle插件和AAPT2会自动生成大多数应用项目所需的保留规则，例如应用的activities，views和services。当然，如果又需要，你也可以添加自己的规则。 或者，您可以将@Keep注释添加到要保留的代码中。在类上添加@Keep会使整个类保持原样。在方法或字段上添加它将保持方法/字段（及其名称）以及类名完整。请注意，此注释仅在使用AndroidX注释库时以及包含随Android Gradle插件打包的ProGuard规则文件时才可用。 压缩资源资源压缩只有配合代码压缩才会起作用。在代码缩减器删除所有未使用的代码之后，资源缩减器可以识别应用程序仍在使用哪些资源。添加包含资源的代码库时尤其如此 - 必须删除未使用的库代码，以便库的资源不会被引用，从而这些资源可以被资源缩减器移除。 想要开启资源缩减，只需要配置一下： 1234567891011android &#123; ... buildTypes &#123; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 自定义需要保留的资源通过配置一个 xml 文件，你可以自定义需要保留或者丢弃的资源。 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:keep="@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*" tools:discard="@layout/unused2" /&gt; tools:keep 与 tools:discard都可以指定多个资源，使用分号隔开。还可以使用 * 号作为通配符。 将该文件放置到工程的资源目中，比如：res/raw/keep.xml。 该文件不会被打包到 APK 中。 指定哪些资源需要被删除，看起来没啥屌用，因为我们可以直接的手动删除这个资源。但是如果我们在构建多个 variants 的时候就非常有用了，比如，我们可能将所有资源放在了一个 common 工程中，然后创建了 keep.xml 来为每个 variant 来指定需要保留与丢弃的资源。因为这个时候，资源都在代码里面被引用了，所以资源缩减器不会移除这些资源。还有另外一种情况，构建工具可能无法区别资源id的引用与 int 值的区别，如果刚好某个资源的id与我们代码中int值相等，它也不会移除这个资源。 开启严格引用检查通常情况下，资源缩减器可以正确的识别哪些资源被引用了。但是，如果我们这样引用资源： 1Resources.getIdentifier() 或者，我们的依赖库中有这样使用的（AppCompat就是）。遇到这种情况，资源缩减器默认情况下会采取防御措施，并将所有具有匹配名称格式的资源标记为可能已使用且无法删除。 举个例子： 12val name = String.format("img_%1d", angle + 1)val res = resources.getIdentifier(name, "drawable", packageName) 这会将具有img_前缀的所有资源标记为已使用。 资源缩减器还会查看代码中的所有字符串常量以及各种res/ raw/资源，以及类似于file:///android_res/drawable//ic_plus_anim_016.png的格式的资源URL。如果它发现像这样的字符串或者 url，它就不会移除这些资源。 这个行为默认是开启的，但是如果想要关闭它，就可以使用 strict 模式： 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:shrinkMode="strict" /&gt; 开启了严格模式之后，使用上面的方式引用的资源也会被删除，所以我们需要在 keep.xml 里面保留这些资源。 移除未使用的可选资源Gradle资源缩减器仅删除应用程序代码未引用的资源，这意味着它不会删除不同设备配置的备用资源。 如有必要，您可以使用Android Gradle插件的resConfigs属性来删除您的应用不需要的备用资源文件。 例如，如果您使用的是包含语言资源的库（例如AppCompat或Google Play服务），那么您的APK会包含这些库中所有翻译语言的字符串。如果您只想保留应用正式支持的语言，可以使用resConfig属性指定这些语言，删除未指定语言的资源。 下面的代码就展示了如何只保留两种语言资源： 123456android &#123; defaultConfig &#123; ... resConfigs "en", "fr" &#125;&#125; 只保留了英语与法语。同样的，我们还可以只保留某一屏幕密度下的资源。 合并重复资源默认情况下，Gradle还会合并具有相同名称的资源，例如可能位于不同资源文件夹中的同名的drawable（这里应该指的是不同library的资源）。此行为不受shrinkResources属性控制，并且无法禁用，因为当多个资源与您的代码查找的名称匹配时，必须避免这种情况。 仅当两个或多个文件共享相同的资源名称，类型和限定符时，才会发生资源合并。 Gradle选择它认为最合适的一个并保留。 Gradle 从下面的路径来寻找重复的资源： src/main/res build flavor 与 build type 依赖库 资源优先级从低到高： 依赖库 → Main → Build flavor → Build type 举个例子：如果Main和build flavor中出现重复的资源，Gradle将选择build flavor中的资源。 如果重复资源在同一层次出现，比如src/main/res/ 和 src/main/res2/，则 gradle 无法完成资源合并，这时会报资源合并错误。 代码混淆混淆的目的是通过缩短APP的类，方法和字段的名称来减少应用程序的大小。以下是使用R8进行混淆处理的示例： 12345678910androidx.appcompat.app.ActionBarDrawerToggle$DelegateProvider -&gt; a.a.a.b:androidx.appcompat.app.AlertController -&gt; androidx.appcompat.app.AlertController: android.content.Context mContext -&gt; a int mListItemLayout -&gt; O int mViewSpacingRight -&gt; l android.widget.Button mButtonNeutral -&gt; w int mMultiChoiceItemLayout -&gt; M boolean mShowTitle -&gt; P int mViewSpacingLeft -&gt; j int mButtonPanelSideLayout -&gt; K 虽然混淆不会从程序中删除代码，但是如果你的程序中有许多类，方法和字段，那么节省的大小还是很可观的。但是需要注意是，由于代码进行了混淆，那么运行时发生了错误，打印出来的堆栈，我们就看不懂了，需要一些额外的工具来帮助我们进行还原代码信息。 另外，如果你写的代码需要依赖原本类或者方法的名字（比如，反射等），那么你就需要在 ProGuard 文件中 keep 你使用到的类或者方法。 解码混淆后的堆栈信息在 R8 混淆了代码之后，阅读堆栈信息几乎是不可能的了，因为方法名类名都换成了很简单的英文字母了。除了重命名，R8 还会改变堆栈信息代码所在的行号。不过还好，我们可以通过 mapping.txt 文件来还原堆栈信息，我们每次构建App的时候，都会生成一个 mapping.txt 文件，里面会包含所有类，方法，字段的混淆前与混淆后的映射关系，当然，里面也有行号的对应关系。该文件一般在 &lt;module- name&gt;/build/outputs/mapping/&lt;build-type&gt;/ 目录下面。 R8每次构建项目时都会覆盖生成的mapping.txt文件，因此每次发布新版本时都必须小心保存副本。通过为每个发布版本保留mapping.txt文件的副本，如果用户从旧版本的应用程序提交混淆后的堆栈信息，您将能够追踪调试问题。 在Google Play上发布您的应用时，您可以为每个版本的APK上传mapping.txt文件。然后，Google Play会根据用户报告的问题对传入的堆栈跟踪进行反混淆处理，以便您可以在Google Play控制台中查看这些堆栈信息。有关详细信息，请参阅帮助中心的文章，了解如何对崩溃堆栈跟踪进行反混淆处理。 要将混淆的堆栈跟踪转换为可读的堆栈跟踪，请使用 ReTrace 脚本，在SDK/tools/proguard/bin 目录下。 代码压缩为了进一步的减小 App 的体积，R8 会在更深的层次上来检查你的代码，然后移除无用代码，甚至有时候会重写我们的代码，让其更简洁。下面举几个例子： 如果你写了一个 else{} 块，但是任何情况下都不会走这个分支，那么R8可能会将它删除。 如果某个方法只在唯一一个地方被调用，那么 R8 可能会将方法内联到调用的地方，并将这个方法移除。 如果某个类只有一个子类，并且该类没有被实例化（举个例子，一个抽象类，只有一个子类），那么 R8 会将这两个类合成一个类。 更多内容请看大神的博客 R8 optimization blog posts R8不允许您禁用或启用离散优化，或修改优化的行为。实际上，R8忽略了任何试图修改默认优化的ProGuard规则，例如-optimizations和 - optimizepasses。此限制很重要，因为随着R8的不断改进，维护标准的优化行为有助于Android Studio团队轻松排除故障并解决您可能遇到的任何问题。 启动更加激进的优化策略R8 里面还包含一些默认没有开启的优化行为。你可以开启它们，自需要在 gradle.properties 里面添加： 1android.enableR8.fullMode=true 假设您的代码通过Java Reflection API引用了一个类。默认情况下，R8假定您打算在运行时检查和操作该类的对象 - 即使您的代码实际上没有 - 并且它会自动保留该类及其静态初始化程序。 但是，当使用“完整模式”时，R8不会做出这种假设，如果R8断言你的代码在运行时从不使用该类，它会从你应用程序的最终DEX中删除该类。也就是说，如果要保留类及其静态初始化程序，则需要在规则文件中包含保留规则才能执行此操作。 有问题，查看文档，并报告问题。 If you encounter any issues while using R8’s “full mode”, refer to the R8 FAQ page for a possible solution. If you are unable to resolve the issue, please report a bug. 使用R8进行故障排除当我们开启了代码压缩，资源压缩等选项的时候，可能会遇到一些问题，可以查看帮助文档。 If you do not find a solution to your issue below, also read the R8 FAQ page and ProGuard’s troubleshooting guide. 生成被移除代码报告记录为了帮助您解决某些R8带来问题，查看R8从您的应用中删除的所有代码的报告可能会很有用。将-printusage &lt;output-dir&gt; /usage.txt添加到自定义规则文件中，就可以为模块生成报告记录。当您启用R8并构建应用程序时，R8会输出一个包含您指定的路径和文件名的报告。已删除代码的报告类似于以下内容： 1234567891011121314androidx.drawerlayout.R$attrandroidx.vectordrawable.Randroidx.appcompat.app.AppCompatDelegateImpl public void setSupportActionBar(androidx.appcompat.widget.Toolbar) public boolean hasWindowFeature(int) public void setHandleNativeActionModesEnabled(boolean) android.view.ViewGroup getSubDecor() public void setLocalNightMode(int) final androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager getAutoNightModeManager() public final androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() private static final boolean DEBUG private static final java.lang.String KEY_LOCAL_NIGHT_MODE static final java.lang.String EXCEPTION_HANDLER_MESSAGE_SUFFIX... 如果你想查看，R8保留了哪些类，可以添加 -printseeds &lt;output-dir&gt;/seeds.txt 到自定义规则文件中。文件内容大致如下： 1234567com.example.myapplication.MainActivityandroidx.appcompat.R$layout: int abc_action_menu_item_layoutandroidx.appcompat.R$attr: int activityChooserViewStyleandroidx.appcompat.R$styleable: int MenuItem_android_idandroidx.appcompat.R$styleable: int[] CoordinatorLayout_Layoutandroidx.lifecycle.FullLifecycleObserverAdapter... 资源故障排除压缩资源时，“构建”窗口 会显示从APK中删除的资源的摘要。 比如： 123:android:shrinkDebugResourcesRemoved unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%:android:validateDebugSigning Gradle还在&lt;module-name&gt; / build / outputs / mapping / release /（与ProGuard的输出文件相同的文件夹）中创建名为resources.txt的诊断文件。此文件包含详细信息，例如哪些资源引用其他资源以及使用或删除了哪些资源。 比如，你想知道为啥 @drawable/ic_plus_anim_016 这个文件被打包到了 APK 中，你可以打开 resource.txt 文件，然后搜索这个文件名。你就可以找到谁引用了这个资源： 1216:25:48.005 [QUIET] [system.out] &amp;#64;drawable/add_schedule_fab_icon_anim : reachable=true16:25:48.009 [QUIET] [system.out] &amp;#64;drawable/ic_plus_anim_016 这个说明了，add_schedule_fab_icon_anim 引用了 ic_plus_anim_016，现在你要找出为什么 add_schedule_fab_icon_anim 是可达的！继续向上搜索，你会发现这个资源在 The root reachable resources are: 下面的列表中。这表示有代码引用了 add_schedule_fab_icon_anim 。 如果我们没有使用 strict 检查，还有一种情况下资源id也可能被标记为可达的： 1210:32:50.590 [QUIET] [system.out] Marking drawable:ic_plus_anim_016:2130837506 used because it format-string matches string pool constant ic_plus_anim_%1$d. 这个显然就是使用资源名来动态加载资源的情况。遇到这种情况，你需要手动的指定该资源需要被移除。]]></content>
      <tags>
        <tag>Android-汉化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程与应用的生命周期]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%B1%89%E5%8C%96%2FAndroid%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[官方文档在这里。本来，官方文档的部分内容已经汉化了，但是翻译实在是惨不忍睹，而且有些内容与原文还不一致，真不晓得是怎么回事。大多数情况下，每个 Android 应用程序运行在自己的 Liunx 进程当中。在应用中的某些代码需要运行的时候，这个进程就会被创建出来，它会一直运行，直到该进程不再被需要了或者系统需要释放该进程占用的内存以便让别的应用运行。 Android 有一个特殊的基本特征：应用程序进程的生命周期不是由自己本身直接控制的。取而代之的，是由系统通过几个方面的综合考量来决定的：系统知道的正在运行的应用程序，这些应用程序对用户的重要性，系统可用的剩余内存。 开发者需要理解应用程序的不同组件（特别是 Activity，Service，BroadcastReceiver）对应用程序进程生命周期的影响。如果没有正确的使用这些组件，可能会导致你在执行某些很重要的任务时突然进程被系统给干掉了。 这里有一个例子，是关于进程生命周期的 bug 的。我们在使用 BroadcastReceiver 的时候，当它的 onReceive 方法被触发，我们会开启一个线程去执行任务，onReceive 方法会直接返回。一旦 onReceive 方法返回了，系统就会认为 BroadcastReceiver 不再处于活动状态，所以，它所在的进程也就不需要了（除非进程里面还有其他的组件处于活动状态）。然后系统可能在任何时候杀掉这个进程来回收内存，这样就会终止进程里面正在运行的线程。这个问题的解决方案是使用 JobService，使用了 JobSerive 之后，系统就会知道进程里面仍然有活要干。 为了确定在内存不足的时候应该干掉哪些进程，Android 会根据进程中运行的组件以及这个组件的状态来给每个进程分配一个级别（按重要性排序）： 前台进程：用户正在与之交互的进程。前台进程有多种产生的情况： 有一个用户正在交互的处于屏幕最顶部的 Activity（onResume 执行过了） 有一个正在运行的广播（BroadcastReceiver.onReceive() 方法正在执行） 有一个正在执行回调方法代码（onCreate，onStart，onDestroy）的 Service 系统中这样的进程非常少，只有当可用内存极少，而且这些进程都无法正常运行的时候，才会将它们杀掉。 文档还有一句话，我不是很理解： Generally, at this point, the device has reached a memory paging state, so this action is required in order to keep the user interface responsive. 内存分页我知道，内存分页状态是个啥？？？ 可见进程：可见进程中运行的任务用户是可以注意到的，所以杀掉它会给用户体验产生明显的负面影响。满足下面的一些条件的是可见进程： Activity 可见但是不处于前台，比如：一个前台的 activity 以 dialog 的形式显示出来，那么在它后面的那个 activity 就是可见状态。 Service 调用了 Service.startForeground() 方法。这会让系统意识到该服务是会让用户注意到或者可见的。 It is hosting a service that the system is using for a particular feature that the user is aware, such as a live wallpaper, input method service, etc. 这个我不太明白意思。 可见进程的数量比前台进程要多，但是也多不了多少，处于可管控的范围之内。这些进程是非常重要的，只有在前台进程无法正常运行的时候，才会杀掉它们。 服务进程：一个Service通过 startService() 方法启动即为服务进程。尽管它们对用户不可见，但是它们通常都在后台做一些用户关系的事情（比如：上传与下载）。所以系统一般也不会杀掉它们，除非系统无法保证所有的前台与可见进程正常运行。 长时间运行的服务（超过30分钟）其优先级会降低（在下面所说的 LRU 表中会向后移动）。这有助于避免出现内存泄漏或其他问题的长时间运行的服务占用大量RAM而导致系统无法有效使用缓存进程的情形。 缓存进程：缓存进程是指当前不需要的，当系统需要内存的时候是可以随意杀掉的进程。在一个正常运行的系统中，内存管理应该只会涉及到缓存进程：运行良好的系统将始终提供多个缓存进程（以便在应用程序之间进行更高效的切换），并根据需要定期终止最旧的进程。只有在非常极端（且不可取）的情况下，系统才会杀死所有缓存进程，而且必须开始终止服务进程。 这些进程通常保留了一个或者多个 Activity 的实例（onStop 方法被调用而且返回了），这些 Activity 对用户都不可见。如果开发者正确的实现了 Activity 的生命周期，当系统杀掉这些进程的时候，用户是感知不到的，而且当用户返回这个 App 的时候，也不会影响用户体验：因为系统保存了当前 Activity 的状态，会重新创建该 Activity。 这些进程保存在伪LRU列表中，列表中的最后一个进程是第一个被回收内存的进程。这个列表通常会将更有用的进程（桌面应用程序，用户最后一个使用的 app）放到其他进程的前面。杀掉进程可能还会有其他的策略（依赖于具体平台的实现）：对进程的数量进行限制，对进程可缓存的时间进行限制。 在决定如何对进程进行分类时，系统将根据进程中当前活动的所有组件中找到的最重要级别做出决策。具体查看 Activity, Service, and BroadcastReceiver 的文档。它们的文档都详细地描述了它们是如何影响应用程序的整个生命周期的。 当一个进程被其他进程依赖时，该进程的优先级可能会增加。例如，进程A使用Context.BIND_AUTO_CREATE标志绑定到Service，或者正在使用进程B中的ContentProvider，则进程B的重要级别将始终至少与进程A一样重要。]]></content>
      <tags>
        <tag>Android-汉化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewModel 与数据保存思考]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FViewModel%20%E4%B8%8E%20setRetainInstance%2F</url>
    <content type="text"><![CDATA[今天在做一个需求的时候，为了用户的体验，我想在进程被回收的时候保存一下数据，等 activity 重新创建的时候再取出来。我之前看过一些文章，关于 ViewModel 的，说是 ViewModel 在屏幕方向发生变化的时候不用重新储存数据（与版本有关系）。我也是看了相关代码，确实是这样。我们可以看看 ViewModel 是如何创建与保存的。 当我们调用 ViewModelProviders.of(this).get(xxx.class);来获取（创建一个）viewModel 的时候： android.arch.lifecycle.ViewModelProvider#get(java.lang.String, java.lang.Class) 123456789101112131415161718public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 可以看到这个方法内部实际上是缓存了 ViewModel 对象的，所以你多次调用get方法，不会创建多个。再看看 key 值： 1DEFAULT_KEY + ":" + canonicalName 可以看到 key 只与 class 有关，所以只要 class 一样，就会获取到同一个对象。 那么，即使屏幕旋转之后，activity创建了新的对象，但是它的 class 是不会变的，所以仍然可以引用到同一个 ViewModel。 嗯，上面是有关activity方向的处理，但是我的需求是内存不足被回收，如果进程都被回收掉了，堆里面的对象就也都被回收了，ViewModel 对象也就不存在了，也就是说，ViewModel 无法满足我的需求。 但是我又想到了一件事，ViewModel 之所以能感知宿主的声明周期，是因为它内部创建了 android.arch.lifecycle.HolderFragment 对象（不了解原理的可以去看 Glide 源码）。而这个对象的构造方法里面有这样的一行代码： android.arch.lifecycle.HolderFragment#HolderFragment 1setRetainInstance(true); 我以前一直对这个方法有误解，没有理解它的真正作用，现在来看看为什么写这个方法： 调用了这个方法的fragment不会随着activity一起被销毁。相反，它会一直保留(进程不消亡的前提下)，并在需要时原封不动地传递给新的Activity。 当设备配置发生变化时，FragmentManager首先销毁队列中fragment的视图（因为可能有更合适的匹配资源）；紧接着，FragmentManager将检查每个fragment的retainInstance属性值。 如果retainInstance属性值为false，FragmentManager会立即销毁该fragment实例。 随后，为适应新的设备配置，新的Activity的新的FragmentManager会创建一个新的fragment及其视图。 如果retainInstance属性值为true，则该fragment的视图立即被销毁，但fragment本身不会被销毁。 为适应新的设备配置，当新的Activity创建后，新的FragmentManager会找到被保留的fragment，并重新创建其试图。 虽然保留的fragment没有被销毁，但它已脱离消亡中的activity并处于保留状态。 尽管此时的fragment仍然存在，但已经没有任何activity托管它。 只有调用了fragment的setRetainInstance(true)方法， 并且因设备配置改变，托管Activity正在被销毁的条件下，fragment才会短暂的处于保留状态。 如果activity是因操作系统需要回收内存而被销毁，则所有的fragment也会随之销毁。 理解了上面的话，现在想一下，为何要保存 fragment 的实例？是因为 android.arch.lifecycle.HolderFragment 1private ViewModelStore mViewModelStore = new ViewModelStore(); 它有这样的一个变量，而这个 ViewModelStore 实际上就是一个 map，它保存它对应的 ViewMode 对象。如果 fragment被回收了，那么这个 ViewModel 肯定也会被回收（没有其他地方引用它了），这样ViewModel就达不到设计的目的了。 所以最终，还是要配合 onSaveInstanceState 来保存数据，因为 onSaveInstanceState 是将数据存到了系统进程中。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcelable与Serializable]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FParcelable%E4%B8%8ESerializable%2F</url>
    <content type="text"><![CDATA[通常，在Android里面传递数据都是使用的 Intent，而 Intent 里面想要放一个 Java 对象，那这个对象要么实现 Parcelable 要么实现 Serializable 。一般我们都是选择实现 Parcelable，因为它的效率高，而且不会产生很多的临时对象。当然这些都是网上说的，并没有证明，现在我们来测试一下，从传输效率开始。当然我也懒得做测试的，所以我找了一篇文章，个人觉得还是可以的，有好奇心的小伙伴可以自己测试一下。 测试过程如下： 模拟将对象传递给Activity的过程：直接调用 [Bundle#writeToParcel(Parcel, int)](https://developer.android.com/reference/android/os/Bundle.html#writeToParcel(android.os.Parcel, int))，然后再取出来。 循环 1000 次 做10次测试，取平均值 在多个设备上测试 下面给出该作者测试的结果： Nexus 10Serializable: 1.0004ms, Parcelable: 0.0850ms - 10.16x improvement. Nexus 4Serializable: 1.8539ms - Parcelable: 0.1824ms - 11.80x improvement. Desire ZSerializable: 5.1224ms - Parcelable: 0.2938ms - 17.36x improvement. 可以看出，区别还是很明显的。可能几ms对我们人类来说，感觉不到什么，但是对于CPU就像是过了几个月了。特别是Android需要16ms来绘制一帧，你传递一个对象就花了几ms，就没剩多少时间了。 好了说完了效率，我们再说说为啥 Serializable 会产生很多临时对象。 看一个简单的对象： 12345678910111213public class Phone implements Serializable&#123; public String name; public String address; public Phone() &#123; &#125; public Phone(String name, String address) &#123; this.name = name; this.address = address; &#125;&#125; 当我们把这个对象序列化到文件中的时候，它的内容如下： 1234567aced 0005 7372 0011 636f 6d2e 6578 616d706c 652e 5068 6f6e 6551 4868 16d4 8afd8702 0002 4c00 0761 6464 7265 7373 7400124c 6a61 7661 2f6c 616e 672f 5374 72696e67 3b4c 0004 6e61 6d65 7100 7e00 01787074 0007 6265 696a 696e 6774 0008 7a68616e 6773 616e 我就不解释一个个解释它们代表什么了，这些数据包含了如下内容： 序列化协议，固定值 序列化协议版本 对象的开始标记，类的开始标记 类名长度，类名 有多少个字段 每个字段长度，字段名，字段值 嗯，还有一些东西，特别是有父类的，更蛋疼。可以看到，本来我们只需要传递 name 与 address 的值，它给我们搞了一大堆东西，非常的浪费。还有反序列的时候，由于它使用了反射机制，所以会产生很多的临时变量，可能会增加GC的频率。 Parcelable 的序列化与反序列化的过程就不一样了，它不像 Serializable 那么严格，它只存放了变量的值，其他的都没有存放。我们看一下实现 Parcelable 的过程。 123456@Overridepublic void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeString(type); dest.writeString(accessId);&#125; 可以看到，我们将对象的属性值写入到了 parcel 中。 而 parcel 里面可以理解为有一块内存空间，用来储存这些属性值，还有一个指针指向准备写入的位置，写入一个属性后就往后偏移一段距离。所以读取的时候，一定要按照写入的顺序，否则会出错。 然后在使用 parcel 读取出来： 123456789public Account createFromParcel(Parcel source) &#123; return new Account(source);&#125;public Account(Parcel in) &#123; this.name = in.readString(); this.type = in.readString(); this.accessId = in.readString();&#125; 序列化与反序列化的核心都是 Parcel。 Parcel 的注释上说了，它是消息的容器，可以通过 IBinder 来传输。 我们再来思考一下，Bundle 中的 Serializable 数据是如何传输的。 android.os.Parcel#writeValue 12345else if (v instanceof Serializable) &#123; // Must be last writeInt(VAL_SERIALIZABLE); writeSerializable((Serializable) v); &#125; writeSerializable 里面仍然是调用了 java.io.ObjectOutputStream#writeObject 方法来写对象。 android.os.Parcel#readSerializable(java.lang.ClassLoader) 同样的，读取一个 Serializable 对象的时候，也是通过 java.io.ObjectInputStream#readObject 来获取的，走的是 Java 的序列化与反序列化逻辑。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（二）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoordinatorLayout.BehaviorCoordinatorLayout 根据 官方文档 的描述，它是一个“超级FrameLayout“，专门用来帮助实现布局中的View相互交互。我们只需要为布局里面的 Views 创建自定义的或者分配现有的 *Behavior** 即可。Behavior 是 *Material Design 独一无二的核心，例如滑动抽屉和面板，滑动消失元素，和跟随其他空间移动的按钮等等。 我们先来看看 Behavior 是如何工作的，后面还会配上几个例子便于理解。 Behavior 用来表示同一个布局中2个或者2个以上的控件之间的交互。通常分为以下几类： Layout-Based Behaviors:先来看一个效果图： 当 snackbar 从底部出现的时候，FAB 会立即向上平移一个 SnackBar 的高度。 Anchoring 是 Layout-Based Behaviors 的一种，比如我们将 FAB anchored to AppBarLayout，看下面的效果图（注意观察红色的类似短信图标的按钮）： 可以看到 FAB 随着 AppBarLayout 在移动，而且最后还会消失。这种 anchored to 的行为，在 CoordinatorLayout 中对应着一个属性，我们下面会说到。 Scroll-Based Behaviors还是看上面的图，这次不看 FAB，而是观察下面的长文本。TextView 本身是不可滚动的，所以它的外面有一层 NestedScrollView 包裹。 一个 CoordinatorLayout 中有两个可以滚动的控件，一个是 AppBarLayout，一个是 NestedScrollView 。通过效果图，可以看出，他们并没有产生冲突，而是将滑动联动起来了，我们向上滚动 NestedScrollView 的时候，会向将 AppBarLayout 往上推，推到顶部之后，NestedScrollView 才开始滚动，之间没有停顿，无缝衔接。 之所以能够产生这样的行为，是因为这两个控件都被分配了一个 Behavior。 12@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)public class AppBarLayout extends LinearLayout &#123; 12345&lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" &gt; Implementing the Behaviors介绍完了两类 Behaviors，接下来我们看看如何自定义一个 Behavior。 首先，我们的 Behavior 必须继承至 Coordinator.Behaviors&lt;V&gt;，V 就是需要这个Behavior 的控件的类型。比如我想给 TextView 指定一个 Behavior，那么 V 就是 TextView 类型。 然后，Coordinator.Behaviors&lt;V&gt; 有一些方法需要覆盖来达到我们想要的效果，其中有3个方法尤其重要（额，还有滚动相关的方法，与第一篇是以一样的就不介绍了）。 layoutDependsOn(…)这个方法用来决定，当前 View 需要依赖哪个 View。比如你需要根据同一布局中的 ImageView 的位置来决定自己的位置，那么就可以这样写： 123override fun layoutDependsOn(parent: CoordinatorLayout, child: View, dependency: View): Boolean &#123; return dependency is ImageView&#125; 这个方法的返回值，true 表示当前 View 是有依赖对象的，反之则无。但它返回 false 的时候，onDependentViewChanged 方法不会被调用。 嗯，有一种情况我还没有搞清楚，当我们新建一个空项目的时候，模板选择第一个，那么我们的MainActivity 的布局是这样的： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:id="@+id/cl" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.google.android.material.appbar.AppBarLayout android:layout_height="wrap_content" android:layout_width="match_parent" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:popupTheme="@style/AppTheme.PopupOverlay"/&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;include layout="@layout/content_main"/&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" app:srcCompat="@android:drawable/ic_dialog_email"/&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 可以看到最下面有一个 FloatingActionButton。 MainActivity 的部分代码如下： 123456789101112override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) fab.setOnClickListener &#123; view -&gt; Log.e("e", "h = $&#123;cl.measuredHeight&#125;") Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG) .setAction("Action", null).show() Log.e("e", "h = $&#123;cl.measuredHeight&#125;") &#125;&#125; 当我们点击 FAB 的时候，发现，随着 Snackbar 的出现， FAB 上移了，而且 CoordinatorLayout 的高度并没有改变，也就是说，FAB ”依赖“了 Snackbar ，随着 Snackbar 的上移，FAB 也移动了自己的位置。 那么，我找了以下 FAB 的 Behavior 源码，发现它的 layoutDependsOn 返回了 false（它根本就没有复写这个方法）。那么它是怎么做到的呢？ 我在源码里面发现了这样的一个字段： androidx.coordinatorlayout.widget.CoordinatorLayout.LayoutParams 123456/** * A &#123;@link Gravity&#125; value describing how this child view dodges any inset child views in * the CoordinatorLayout. Any views which are inset on the same edge as this view is set to * dodge will result in this view being moved so that the views do not overlap. */public int dodgeInsetEdges = Gravity.NO_GRAVITY; 然后我在布局里面添加了一个 View，设置了如下属性： 12345678&lt;View android:id="@+id/test" android:layout_width="wrap_content" android:layout_height="100dp" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" android:background="@color/colorPrimary" app:layout_dodgeInsetEdges="bottom"/&gt; 运行之后，果然可以跟随 Snackbar 。那么现在可以得出结论，FAB 跟随 Snackbar 是 CoordinatorLayout 自带的功能，与 Behavior 没有关系。 但是这里还是有一个疑问，CoordinatorLayout 是从哪里获取到 Snackbar 的高度的？？？ onDependentViewChanged(…)一旦我们确定了依赖关系，那么就可以根据依赖关系来处理交互逻辑了。比如：我想让一个 TextView 跟随 ImageView 的底部： 123456override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; // 让 child 跟随 dependency 的底部 val bottom = dependency.y.roundToInt() + dependency.height child.top = bottom return true&#125; 这里我们让 child （TextView）的 top 值等于 dependency （ImageView）的 bottom 值就可以达到我们想要的效果了。 onDependentViewRemoved(…)这个方法看名字就很好理解了，就是当依赖的View被删除的时候，会调用这个方法。 例子项目NestedScrollingDemos 这个项目里面的例子有很详细的注释，可以参考。]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（三）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ViewDragHelper 定义Android 官方对 ViewDragHelper 的定义是： 可以用于自定义 ViewGroup 可以进行拖拽移动或者重新定位ViewGroup中子视图View 提供有效操作和状态追踪 ##使用 ViewDragHelper下面说说，如何使用 ViewDragHelper（下面简称 VDH） 。 创建一个 VDH 对象： androidx.customview.widget.ViewDragHelper#create(android.view.ViewGroup, androidx.customview.widget.ViewDragHelper.Callback) 123public static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull Callback cb) &#123; return new ViewDragHelper(forParent.getContext(), forParent, cb);&#125; VDH 构造函数是私有的，但是有多个可供访问的静态方法。使用它就可以创建一个 VDH 对象。 上面的静态方法中，cb 参数很重要，因为，ViewDragHelper.Callback是用来连接ViewDragHelper和parent view的。 要让VDH能够处理相关的拖动事件就需要将拖动时触发事件状态传给VDH，所以我们要针对onInterceptTouchEvent、onTouchEvent 做特别的处理。 123override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123; return viewDragHelper.shouldInterceptTouchEvent(ev!!)&#125; 直接委托给 vdh，让它判断是否需要拦截事件，如果这里有自己的逻辑，也可以添加，比如： 1234override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123; val myIntercept = someCondition(ev) return myIntercept and viewDragHelper.shouldInterceptTouchEvent(ev!!)&#125; 然后，就是 onTouchEvent，一般情况下，自定义ViewGroup，而 ViewGroup 默认不会处理事件，所以我们需要在 ACTION_DOWN 的时候，处理这个事件： 12345678910111213@SuppressLint("ClickableViewAccessibility")override fun onTouchEvent(event: MotionEvent?): Boolean &#123; // 在这里，将事件传递给 VDH，让它去处理 viewDragHelper.processTouchEvent(event!!) // 处理下 down 事件按，让后续事件都传过来 if (event.action == MotionEvent.ACTION_DOWN) &#123; return true &#125; return super.onTouchEvent(event)&#125; 下面，看看 ViewDragHelper.Callback 中的几个常用方法： pointerId：区分多点触控时的 id position 1234override fun tryCaptureView(child: View, pointerId: Int): Boolean &#123; // 限制指定的控件才可以拖动 return child.id == R.id.video&#125; 123override fun getViewVerticalDragRange(child: View): Int &#123; return verticalRange&#125; 这个方法，需要返回一个大于0的数，然后指定的 View 才会在垂直方向移动。我试过，只要大于 0 即可，似乎没有别的要求。暂时没有去探究这个值有什么意义。 top： 表示拖动指定 view 时，view 的 top 值 dy ：是每次的差值 12345override fun clampViewPositionVertical(child: View, top: Int, dy: Int): Int &#123; // 限制竖向拖动的范围为 【0，verticalRange】 val min = Math.min(top, verticalRange) return Math.max(0, min)&#125; 上面的代码，是将 top 的值限制了，避免 view 被拖出指定的范围。 12345678override fun onViewPositionChanged(changedView: View, left: Int, top: Int, dx: Int, dy: Int) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy) changeVideo(changedView, top) changeVideoDetail(top) changeVideoTitle(top) changePlayButton(top) changeCloseButton(top) &#125; 这个方法表示，当指定的 View 被拖动时，这个方法就会被回调，然后我们就可以在这个方法里面做一些操作，比如改变另外的View 的位置，这样就可以实现一个联动效果。 123override fun onViewReleased(releasedChild: View, xvel: Float, yvel: Float) &#123; super.onViewReleased(releasedChild, xvel, yvel)&#125; 当指定的View 被释放的时候（手指抬起等），这个方法会被回调。如果我们想要一个回弹效果，在这里处理是一个很好的解决方法。比如： 12345override fun onViewReleased(releasedChild: View, xvel: Float, yvel: Float) &#123; super.onViewReleased(releasedChild, xvel, yvel) dragHelper.settleCapturedViewAt(mDragOriLeft , mDragOriLeft) invalidate()&#125; settleCapturedViewAt 是 VDH 提供的一个方法，实际上是使用的 scroller，所以调用这个方法，还需要和使用 Scroller 一样，实现 computeScroll 方法。 还有一些判断边缘拖拽的方法就不介绍了，我实现了一些效果，给我的感觉用起来还是挺方便的。 但是这里有一个问题，就是如果你想实现一些很复杂的效果，其实核心不在拖拽的处理上，而是在一些计算方面，就比如你想要一个回弹效果，直接使用 scroller 可以实现，但是这个回弹效果很普通，UI想要更加炫酷的回弹效果。这个时候考验的不是你对View的理解，而是你对数学的理解。就像我刚接触自定义控件的时候，看的aige的系列文章，其中有一个翻书效果，要想实现这个效果，如果你没有空间想象能力，没有一定的数学知识，无论你对View的绘制，对各种工具有多么熟练，你仍然无从下手。 我实现的一些demo： NestedScrollingDemos]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（一）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NestedScrollingNestedScrolling 是从Lollipop开始出现的，用来专门处理嵌套滑动的一套机制。NestedScrolling 仍然是基于View与ViewGroup的事件滑动机制，但是它将一个滑动事件的参与者分成了两个角色，child 与 parent。比如：ScrollView 中嵌套了 RecyclerView，ScrollView 在这里扮演 parent，RecyclerView扮演 child。 要想触发 NestedScrolling，首先 child 需要要能够处理滑动事件，因为 NestedScrolling 的思想是： 由 child 来接收滑动事件，然后在它的 onTouchEvent 中，做滑动处理。 做任何处理之前，先询问 parent，看parent能不能处理 所以整个流程就是，在一个move产生后： child 先询问 parent，能够消耗多少，没有消耗完 child 自己消耗，没有消耗完 child 再次询问 parent，我这还有没消耗完的，你能消耗多少，如果 parent 还是没有消耗完 child 自己处理 可以仔细思考一下整个处理流程，刚开始可能会觉得有些怪异，但是要想让嵌套滚动无缝衔接，这样的逻辑是必要的。 了解了 NestedScrolling 的流程之后，那么就会产生许多问题： 第一个是：child 是如何认定 parent 的？ 答案就是通过接口： 12androidx.core.view.NestedScrollingChildandroidx.core.view.NestedScrollingParent 当然现在，这两个接口已经发展到第3个版本了，NestedScrollingChild3 与 NestedScrollingParent3。 在我们上面的例子中，RecyclerView 就需要实现 NestedScrollingChild 这个接口，ScrollView 需要实现 NestedScrollingParent 接口。 然后，通过循环遍历 parent 的方式找到实现了 NestedScrollingParent 接口的 parent ： 12345678ViewParent p = mView.getParent();while (p != null) &#123; if (parent instanceof NestedScrollingParent) &#123; ... return true; &#125; p = p.getParent();&#125; 从这里，可以看出，嵌套关系不需要是直接关系，隔几层也没有问题。 当然，上面的代码是不需要我们自己实现的，Google已经替我们实现了两个工具类，后面会详细说到。 第二个是：child 与 parent 是如何传递各自需要消耗的距离的？ 这个问题比较复杂了，虽然Google替我们实现了两个工具，但是遗憾的是，由于业务的逻辑的多样性，工具里面只封装了一些通用的操作，所以我们需要学习如何使用这两个工具来实现我们想要的效果。 但是幸运的是，使用这两个工具是有模板的，我们只要照着来，问题不大。 下面，我们就参考 RecyclerView 的做法来仔细说道说道。 先看ACTION_DOWN的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 123case MotionEvent.ACTION_DOWN: &#123; startNestedScroll(nestedScrollAxis, TYPE_TOUCH);&#125; break; 一般的，我们在 ACTION_DOWN 事件中来开启嵌套滚动，那么具体怎么开启呢？使用工具类就好了： androidx.recyclerview.widget.RecyclerView#startNestedScroll(int, int) 1234@Overridepublic boolean startNestedScroll(int axes, int type) &#123; return getScrollingChildHelper().startNestedScroll(axes, type);&#125; 可以看到，它是直接使用了 NestedScrollingChildHelper 的 startNestedScroll 方法。所以说，使用很简单。 但是这里需要注意了，startNestedScroll 方法内部会先判断该控件是否开启了支持嵌套滚动，如果没有开启的话也是不行的，具体请看 NestedScrollingChild 接口的 isNestedScrollingEnabled 方法，要想支持嵌套滚动，这个方法返回 true 就好了。 然后，startNestedScroll 方法内部还会调用 ViewParentCompat.onStartNestedScroll(p, child, mView, axes, type) 这个方法。 androidx.core.view.ViewParentCompat#onStartNestedScroll(android.view.ViewParent, android.view.View, android.view.View, int, int) 这个方法里面做了一些转发操作。 12345if (parent instanceof NestedScrollingParent2) &#123; // First try the NestedScrollingParent2 API return ((NestedScrollingParent2) parent).onStartNestedScroll(child, target, nestedScrollAxes, type);&#125; 可以看到，它拿到了 parent，然后调用了 parent 的 onStartNestedScroll 方法，它将一些滑动信息传递到了 parent 中。 androidx.core.view.NestedScrollingParent2#onStartNestedScroll 12boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); 仔细介绍一下这个方法的各个参数： child：是 parent 的某个直接子View，这里parent 就是 ViewParentCompat.onStartNestedScroll 中的参数 p。 target：就是嵌套的控件，在我们的例子中，就是 RecyclerView。 axes：是滚动的方向，横向与竖向 type：是触摸类型，一种是用户触摸，另一种一般是惯性滑动 返回值：true，表示 parent 接收滑动操作，false 则不会，后面分发滚动的流程也就不会走了。 PS: 一般的，我们在实现 parent 的 NestedScrollingParent 接口时，onStartNestedScroll 这个方法一般根据滚动方向来返回值，比如：(axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0; 再看ACTION_MOVE的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 12345case MotionEvent.ACTION_MOVE: &#123; if (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123; &#125;&#125; 一般，在 ACTION_MOVE 中来分发滑动事件，这里的分发与事件分发不是一个东西。 androidx.recyclerview.widget.RecyclerView#dispatchNestedPreScroll(int, int, int[], int[], int) 123456@Overridepublic boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow, int type) &#123; return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type);&#125; 同样的，这里我们使用工具来帮助我们处理。它的内部调用了 ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type); 方法。 androidx.core.view.ViewParentCompat#onNestedPreScroll(android.view.ViewParent, android.view.View, int, int, int[], int) 1234if (parent instanceof NestedScrollingParent2) &#123; // First try the NestedScrollingParent2 API ((NestedScrollingParent2) parent).onNestedPreScroll(target, dx, dy, consumed, type);&#125; 它调用了 NestedScrollingParent2 的 onNestedPreScroll 方法。 androidx.core.view.NestedScrollingParent2#onNestedPreScroll 12void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); 基本上是与前面的 startNestedScroll 是一样的流程，所以也好理解。这里重要的是需要搞清楚这个方法的参数是什么意思！！！ target： 就是嵌套的控件，在我们的例子中，就是 RecyclerView。 dx：**滑动的x方向距离，一般计算如下： 12345678910111213141516171819switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; mLastTouchX = (int) (e.getX() + 0.5f); mLastTouchY = (int) (e.getY() + 0.5f); &#125; break; case MotionEvent.ACTION_MOVE: &#123; final int x = (int) (e.getX(index) + 0.5f); final int y = (int) (e.getY(index) + 0.5f); int dx = mLastTouchX - x; int dy = mLastTouchY - y; mLastTouchX = x; mLastTouchY = y;&#125; dy：滑动的y方向的距离，计算方式同 dx consumed：这个就比较奇特了，它是由child创建的，然后作为参数传递进取，方法内部需要改变它的值。嗯，有点抽象，举个例子，比如由一个函数 fun1，它没有返回值，但是它接收一数组作为参数，函数的内部会给这个数组赋值。consumed 的工作方式就是这样。一般情况下，我们声明一个成员变量 final int[] mReusableIntPair = new int[2]; 传递给 consumed就好了。 type：是触摸类型，一种是用户触摸，另一种一般是惯性滑动 consumed 被传递到了 parent 中，我们根据需要来处理这个值，比如我们需要竖向消耗 pdy个距离，那么我们在 parent 的 onNestedPreScroll 方法中调用 consumed[1] = pdy 就好了，全部消耗则 consumed[1] = dy。 然后 child 中就需要减去 parent 中消耗的值： androidx.recyclerview.widget.RecyclerView#onTouchEvent 123456case MotionEvent.ACTION_MOVE: &#123; if (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123; dx -= mReusableIntPair[0]; dy -= mReusableIntPair[1]; &#125;&#125; 然后，判断自己是否可以滚动，并且对应的滚动方向的值是否有剩余： 1if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) 如果有剩余，自己来处理滚动： 123mReusableIntPair[0] = 0;mReusableIntPair[1] = 0;scrollStep(x, y, mReusableIntPair); 然后再次分发滑动事件： 12dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset, TYPE_TOUCH, mReusableIntPair); 同样的，这个方法会调用到 parent 的 onNestedScroll 方法，我就不贴逻辑了，与上面的传递步骤还是一样的。 说一下该方法的参数： androidx.core.view.NestedScrollingParent2#onNestedScroll 12void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); target：不说了 dxConsumed：就是child处理自己的滚动，横向消耗的值 dyConsumed：就是child处理自己的滚动，竖向消耗的值 dxUnconsumed：就是一次滑动的距离 - parent 在 onNestedPreScroll 未消耗 - child也未消耗的，最后剩余的横向的值 dxUnconsumed：同 dxUnconsumed type：不说了 最后，再判断一下，还有没有剩余的，如果还有剩余的，child 自己处理： 1pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY); RecyclerView 这里是利用未消耗完的给出了一个 overScroll 效果。 PS：在自己能够处理滑动事件的时候，不能让parent拦截掉事件 1getParent().requestDisallowInterceptTouchEvent(true); 再看ACTION_UP等的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 123case MotionEvent.ACTION_UP: &#123; stopNestedScroll(TYPE_TOUCH);&#125; break; 同样的，也借用工具的方法： 1234@Overridepublic void stopNestedScroll(int type) &#123; getScrollingChildHelper().stopNestedScroll(type);&#125; 最后，也会调用到 parent 的 onStopNestedScroll 方法。 现在，回过头来看看这两个接口： NestedScrollingChild 123456789public void setNestedScrollingEnabled(boolean enabled);public boolean isNestedScrollingEnabled();public boolean startNestedScroll(int axes);public void stopNestedScroll();public boolean hasNestedScrollingParent();public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);public boolean dispatchNestedPreFling(float velocityX, float velocityY); NestedScrollingParent 12345678public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);public void onStopNestedScroll(View target);public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);public boolean onNestedPreFling(View target, float velocityX, float velocityY);public int getNestedScrollAxes(); 这些方法都是有调用关系的，理清楚了就好了。 这里关于 NestedScrollingParent，我说的不太多，只是说了方法的参数意思，下面附上一个demo，实现了微信运行排行榜的滑动效果，希望可以加深理解。 项目地址 有兴趣的可以自己添加demo进去。 参考文档Android NestedScrolling全面解析 - 带你实现一个支持嵌套滑动的下拉刷新（上篇） NestedScrollWebView.java]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值器与估值器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2F%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%E4%BC%B0%E5%80%BC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[想来了解以下动画的定义： 动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 Android中的动画也遵循这个原理，只不过它的每一帧都是通过插值器与估值器动态计算出一个矩阵，然后应用到控件上得到的。在计算的过程中，插值器负责计算动画执行的百分比，估值器负责根据百分比来计算属性值。 举个例子： 12ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);valueAnimator.setDuration(1000); 这里，我们以 ValueAnimator 举例，做一个值动画，让 1 在 1000ms 内匀速变到 100。 假设这个动画有11帧，那么在第一帧的时候，是保持原来的位置不动，随着时间的流逝，在过了100ms之后，来到了第2帧，这个时候插值器就派上用场了。根据匀速运行的计算，在 100ms 的时候，动画应该执行了 10%，所以会出现一个时间 t 与动画值的函数： f(t) = t / duration * 100 记住这个函数，后面的东西都是围绕它来的 让我们看看线性插值器的代码，来对比一下： android.view.animation.LinearInterpolator#getInterpolation 12345 public float getInterpolation(float input) &#123; return input; &#125;// 转换成函数就是 f(x) = x，这个f(x) 相当于上面函数的 t / duration// 也就是说，这里只是计算了动画执行的百分比，还没有计算到动画的具体值 这里的 input 参数，表示的是时间的流逝百分比，它返回的是动画执行的百分比。 这与上面的 f(t) 函数的意义是一样的，只不过 f(t) 的参数是 t， 而 getInterpolation 的参数是 t/duration。 回想一下，刚接触函数的时候，f(x) = x 这个函数，就是一条直线，所以这个插值器叫线性插值器。 我们再来看看加速插值器的代码： android.view.animation.AccelerateInterpolator#getInterpolation 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 这里我们只考虑 mFactor == 1.0f 的情况，所以有这样的一个函数 f(x) = x * x 。 那么这个函数是什么意思呢？首先，输入范围是 【0，1】，经过函数变换之后，还是【0，1】。这个是很重要的，虽然你可以返回大于1或者小于0的值，但是大于1的会被当成最后一帧处理，小于0的作为第一帧处理。具体请看 android.animation.KeyframeSet#getValue 这个方法。 再回想一下 f(x) = x * x 这个函数的图像，在【0，1】的范围，它的斜率是从低到高的，所以表现出来的就是一个加速行为。想不通的可以这样想，在前面的 【0， 0.5】 的范围内，f(x) 的值从0只增加到了0.25，而在后面的【0.5，1】的范围内，f(x) 的值从 0.25 增加到了 1，所以是增加的速度越来越快。 那么，这里我们自定义一个插值器： 123public float getInterpolation(float input) &#123; return 1 - input;&#125; 猜猜，它会是一个什么样的行为？其实就是一个反向的线性插值器，比如，从 1 到 100，这个插值器会从 100 变到 1。 再看估值器，一般的我们很少会自定义估值器，除非有特殊的需要，比如计算颜色，颜色的算法不像数值的计算，按照百分比乘一下就完事了，因为颜色涉及到 RGB 3个值，所以需要将 RGB 分开来计算。 我们还是看看自带的几个估值器的代码。 先看简单的 int 估值器，这个我们也能写出来，动画的百分比知道了，需要变化的范围我们也知道，用百分比乘以变化范围再加上起始值就ok了。 android.animation.IntEvaluator#evaluate 12345 public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 嗯，和我们想的一摸一样，下一个。 看看 ARGB 的估值器： android.animation.ArgbEvaluator#evaluate 123456789101112131415161718192021222324252627282930313233343536public Object evaluate(float fraction, Object startValue, Object endValue) &#123; int startInt = (Integer) startValue; float startA = ((startInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float startG = ((startInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float startB = ( startInt &amp; 0xff) / 255.0f; int endInt = (Integer) endValue; float endA = ((endInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float endG = ((endInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float endB = ( endInt &amp; 0xff) / 255.0f; // convert from sRGB to linear startR = (float) Math.pow(startR, 2.2); startG = (float) Math.pow(startG, 2.2); startB = (float) Math.pow(startB, 2.2); endR = (float) Math.pow(endR, 2.2); endG = (float) Math.pow(endG, 2.2); endB = (float) Math.pow(endB, 2.2); // compute the interpolated color in linear space float a = startA + fraction * (endA - startA); float r = startR + fraction * (endR - startR); float g = startG + fraction * (endG - startG); float b = startB + fraction * (endB - startB); // convert back to sRGB in the [0..255] range a = a * 255.0f; r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f; g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f; b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f; return Math.round(a) &lt;&lt; 24 | Math.round(r) &lt;&lt; 16 | Math.round(g) &lt;&lt; 8 | Math.round(b);&#125; 嗯，看上去代码很多，但是我们这里取 R 来分析，G、B 是一样的。 123456789101112131415// 拿到起始颜色值的16-24位float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f;// 拿到终止颜色值的16-24位float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f;// 将起始颜色与终止颜色转化为线性的，便于用百分比计算startR = (float) Math.pow(startR, 2.2);endR = (float) Math.pow(endR, 2.2);// 这里我们就很熟悉了，与 int 是一样的float r = startR + fraction * (endR - startR);// 再将线性的转回 RGBr = (float) Math.pow(r, 1.0 / 2.2) * 255.0f; 这样一看，是不是条理很清晰。 总结一下： 插值器负责计算动画执行的百分比 估值器起始就是根据动画的百分比、动画变化量（插值器计算得到的）来计算动画值，如果不能直接计算的，需要转换一下再计算。嗯，就这么多。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent 数据传输限制]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FIntent%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[当我们启动一个Activity的时候，这个过程是需要与AMS进行进程之间通信的。启动 Activity 的时候，需要使用Intent，所以我们在intent中携带的数据也要从APP进程传输到AMS进程，再由AMS进程传输到目标Activity所在进程。通过阅读 Activity 的启动过程，我们知道app与AMS 的进程通信是使用Binder来完成的，看一张图： 普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 (1x1024x1024) - (4096 x2) ，但是由于Intent中还有其他的信息，所以能够放入的数据肯定比这个值还要小。 这个限制定义在frameworks/native/libs/binder/processState.cpp类中： 1#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) 如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的。 PS：注意上面的图：Binder进行数据传递的时候，只需要一次数据拷贝。 这是因为Binder借助内存映射，在内核空间和接收方的用户空间的数据缓存区做了一层内存映射。也就是说，在发送方将数据拷贝到内存空间的时候，内核空间的这部分地址同时也会被映射到接收方的内存缓存中，这样子，就少了一次从内和空间拷贝到用户空间。 代替方案 写入临时文件或者数据库，通过FileProvider将该文件或者ContentProvider通过Uri发送至目标。一般适用于不同进程，比如分离进程的UI和后台服务，或不同的App之间。之所以采用FileProvider是因为7.0以后，对分享本App文件存在着严格的权限检查。 因为 ContentProvider 是使用匿名共享内存来交换数据的，所以没有限制。 同一个进程中，通过单利来传递数据。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk 打包流程及扩展]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FApk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们开发一个应用，大概会有这些东西： 源代码 三方库 图片，so等一些资源 那我们从源文件说起，一个项目的源文件一般都是java文件，有需要还可能会有AIDL 文件。 Java文件会毫无疑问的被 javac 编译成 class 文件。 而 AIDL 文件经过 aidl 工具编译之后也会生成相应的 Java 代码，被编译成 class 文件。 还有一个不要忘记了，资源文件经过编译之后会生成 R.java 文件，它也会被编译成 class 文件。 这里扩展一下，我们知道 app 的 R.java 文件里面的变量都是 final 的，如下： 1public static final int main=0x7f030004; 而 lib 工程的 R.java 文件的变量却不是 final 的（从 ADT14 开始），如下： 1public static int main=0x7f030004; 那么这个又是什么原因呢？ 其实很简单，如果lib中 R.java 文件里面的变量是 final 的，那么会有两个问题： 编译速度：每次编译都需要将所有的资源与代码都编译一次，以免变量值产生碰撞 lib无法复用：如果生成的值是 final 的，那么这个lib给别人用的时候，值很可能与其他 lib 一样，导致问题 所以，为了避免上面的问题，就将变量改为非 final 的，从而 lib 中使用 id 的时候，就只能使用 if-else，而不是使用 switch。 好的，源代码我们处理完了，接下来就需要处理 class 文件了，class 文件除了上面生成的之外，还有我们引入的三方库，他们也是 class 文件。 dx工具会将这些 class 文件打包成 dex 文件。 主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。 我们回头在说说资源文件的处理。 Android中的资源文件有那些呢? res 文件夹下的资源，以及 assets 目录下的资源。 res 资源经过 aapt 的编译之后，会编译为二进制文件。 会为每个文件赋予一个resource id。对于该类资源的访问，应用层代码则是通过resource id进行访问的。 生成一个resource.arsc文件，resource.arsc文件相当于一个文件索引表，记录了很多跟资源相关的信息。 而 assets 的资源保持不动，所以我们只能通过名字来获取它。 资源处理完了，class文件也达成dex包了，接下来就要使用 apkBuilder 将编译后的资源、dex文件、so文件等等打成 apk 包了。 打好apk包了之后，需要签名，因为一旦APK文件生成，它必须被签名才能被安装在设备上。 签好名之后，还需要对apk文件进行对齐处理。那么对齐的作用是什么呢？让我们细细道来。 在开发人员的眼中，CPU是这样访问内存的： CPU 读取内存中的数据是一个一个读取的。 然而，实际上CPU是这样读取内存数据的： 它是一块一块的读取的，CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的，可以当成是内存读取粒度。 那么这样会导致啥问题呢？假设我们需要读取一个 int 值到寄存器，分两种情况讨论： 数据从地址0开始 数据从地址1开始 当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。 当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。 最后贴一张Google官方为我们提供的详细的构建过程图： PS： AnnotationProcessor 发生在 java -&gt; class 之前，因为它需要生成 java 文件。 Transform 发生在 class -&gt; dex 之前，它需要修改class。 Proguard 发生在 Transform 之后，因为混淆后就找不到方法名了。 流程是这样的： annotationProcessor -&gt;javac-&gt; proguard -&gt; Transform]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WorkManager 与 LowMemoryKiller 理解]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FWorkManager%E4%B8%8ELowMemoryKiller%2F</url>
    <content type="text"><![CDATA[今天在查看bugly的时候，发现了如下错误：12android.app.RemoteServiceExceptionContext.startForegroundService() did not then call Service.startForeground()发现是由于WorkManager引起的，原因是由于我们刚刚引入了WorkManager，不想对原来的代码改动太大，所以只是将AlarmManager替换成了WorkManager。 但是我突然想到，既然已经使用了WorkManager，它能保证任务的执行，那为啥还要启动Service呢？不是多次一举吗！ 现在我们来从头理一下，为啥我们需要在Service里面启动线程？ Android是基于linux内核的系统，但是它与其他基于linux内核的系统有一个不同之处，就是它没有“交换空间”。 交换空间的作用：当 RAM 满了之后，而系统还需要额外的内存空间，系统会将内存中的相对不经常使用的内存页放入到硬盘上，腾出位置给正在运行的应用程序。 取而代之的，它使用 OOM Killer 来管理内存。 OOM Killer 的目标是通过基于其“可见性状态”和消耗的内存量来杀死进程来释放内存。 ActivityManager 会给每个进程一个 oom_adj 值，这个值越大，表示该进程的优先级越低。比如，前台进程的优先级就是0。 12345678910# Define the oom_adj values for the classes of processes that can be# killed by the kernel. These are used in ActivityManagerService. setprop ro.FOREGROUND_APP_ADJ 0 setprop ro.VISIBLE_APP_ADJ 1 setprop ro.SECONDARY_SERVER_ADJ 2 setprop ro.BACKUP_APP_ADJ 2 setprop ro.HOME_APP_ADJ 4 setprop ro.HIDDEN_APP_MIN_ADJ 7 setprop ro.CONTENT_PROVIDER_ADJ 14 setprop ro.EMPTY_APP_ADJ 15 Android 中，存在着一张内存阈值表，这张阈值表是可以在 init.rc 中进行配置的，合理配置这张表，对于小内存设备有非常重要的作用。我们来看 lowmemorykiller.c 中这张默认的阈值表： 1234567891011121314static int lowmem_adj[6] = &#123; 0, 1, 6, 12,&#125;;static int lowmem_adj_size = 4;static int lowmem_minfree[6] = &#123; 3 * 512,/* 6MB */ 2 * 1024,/* 8MB */ 4 * 1024,/* 16MB */ 16 * 1024,/* 64MB */&#125;;static int lowmem_minfree_size = 4; 这个表的意思是： 当系统的可用内存小于6MB时，警戒级数为0；当系统可用内存小于8M而大于6M时，警戒级数为1；当可用内存小于64M大于16MB时，警戒级数为12。 比如，当 LMK 被触发的时候，发现系统的内存只剩下了 7M，那么查找上面的表会发现，警戒级数为 1。那么 LMK 会开始遍历系统所有进程，过程如下： 123456789101112131415161718192021for (遍历所有进程) &#123; if (p is 内核进程) &#123; continue; &#125; if (p.oom_score_adj &lt; 警戒值) &#123; continue; &#125; if (有被选中的进程) &#123; if (当前进程的 oom_score_adj 比选中进程的小) &#123; continue; &#125; if (当前进程的 oom_score_adj 等于选中进程的小 &amp;&amp; 当前进程占用的内存小) &#123; continue; &#125; &#125; 选中当前进程&#125; 可以看出如下结论： 内核线程不参加这个杀进程的游戏进程的 oom_score_adj 越大越危险进程的 oom_score_adj 相同的情况下，占用内存越大越危险 Low memory killer的规则就是根据当前系统的可用内存多少来获取当前的警戒级数，如果进程的oom_adj大于警戒级数并且最大，进程将会被杀死（具有相同omm_adj的进程，则杀死占用内存较多的）。omm_adj越小，代表进程越重要。一些前台的进程，oom_adj会比较小，而后台的服务，omm_adj会比较大，所以当内存不足的时候，Low memory killer必然先杀掉的是后台服务而不是前台的进程。 所以，我们要使用 Service 的原因： 我们需要执行一个长时间运行的操作，所以需要一个比较低的 oom_adj 值 （服务进程比后台进程值小） 可以单独开启一个进程 但是随着Android版本的升级，使用 Service 会带来一些其他的问题： 电量消耗 开发人员可以在后台做任何他们想做的事情，没有任何限制。 所以Google搞了一个Doze模式： 简而言之 - 在用户关闭设备屏幕后，Doze 模式启动并禁用网络，同步，GPS，警报和wifi扫描。直到用户打开屏幕或连接到充电器。这是为了 - 减少执行不重要工作的应用程序的数量，并且这样做 - 节省了用户的电量 使用限制 从 API 26 开始，如果应用的 targetSdkVersion 在 26 以上，在后台进程里面调用 startService 方法会抛出 IllegalStateException。 说了这么多，得出一个结论：苍天已死，黄天当立。 既然Service已经不再能够实现它的主要目的（在后台长时间的运行任务），所以最好就不要在使用它了。 WorkManager ： Just because work should be easy to do. WorkManager可以简化开发人员的工作，它提供了一流的api。 它适用于即使应用程序不再位于前台也应运行的后台作业。 在可能的情况下，它使用JobScheduler或Firebase JobDispatcher来完成工作。 如果你的应用程序在前台，它甚至会尝试直接在你的进程中完成工作。 WorkManger 的使用可以查看最后面的官方文档，讲的非常详细，这里并不介绍。 WorkManger 的体系结构如下： 可以看到，WorkManger 在 enqueue work 的时候，将 work 保存到了数据库中（使用 room），用于满足条件之后再执行。所以，如果遇到报数据库相关的错误，而你的项目又没有相关代码，记得检查这里。 # 参考文档Services. The life with/without. And WorkManager. Android low memory killer 机制 Schedule tasks with WorkManager Location all the time with WorkManager!!]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding 原理分析]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FDataBinding%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[DataBinding 是一个支持库，它可以将布局中的界面组件绑定到数据源上，做到UI与数据的单项或者双向监听。说白一点就是数据发生变化可以直接反映到界面上，不用再次手动操作了。当然它的作用远远不止于此，本文从这个点入手，来略微深入一下它的实现过程。首先，DataBinding可以将数据的变化反应到UI上，实际上就是帮助我们更新UI，那么它肯定需要持有（直接或者间接）UI的引用，不然的话，是没法操作UI的。用过DataBinding 的小伙伴应该都知道，DataBinding 会根据布局生成一个类，这个类里会有许多成员变量，每个变量对应着布局里面各个控件。 PS：因为每个项目生成的代码不一致，而且我使用了多个项目生成的代码，所以看的时候不要太纠结，尽量理解为主。 举个例子吧，我们的布局如下： app\src\main\res\layout\content_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.test.user" /&gt; &lt;import type="android.view.View" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;viewModel.name&#125;" /&gt; &lt;TextView android:id="@+id/tv_sex" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="@&#123;viewModel.sex&#125;" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" /&gt; &lt;TextView android:id="@+id/tv_class" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="@&#123;viewModel.age&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 这里面看起来有很多高级的用法，实际上它经过编译之后，是下面这个样子的（因为没有在工程里面找到生成的文件，可能是新版本又换了位置，所以只能看apk里面的资源文件了）： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="1" android:tag="layout/content_main_0" android:layout_width="-1" android:layout_height="-1"&gt; &lt;TextView android:id="@ref/0x7f0800c8" android:tag="binding_1" android:layout_width="-2" android:layout_height="-2" /&gt; &lt;TextView android:id="@ref/0x7f0800c9" android:tag="binding_2" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:id="@ref/0x7f0800c7" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:tag="binding_3" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt;&lt;/LinearLayout&gt; 不要在意哪些 dimension/ref 之类的东西，关键点在于它给使用了 @{} 的控件都生成了一个 tag 属性。可以看出，tag 是有规律的： 如果是根布局，为xml的名字，跟一个数字0，本例为 content_main_0。 如果不是根布局，为binding_x，x是数值，从1开始（根布局把0用了）。 我们手动添加的layout，data，以及 @{viewModel.name} 这些看似高级的东西，其实在编译后都去掉了。那么它为什么要添加一个 tag 呢？？？其实是因为它在内部是使用了这个tag来获取view的引用。 我们知道，要使用 DataBinding，除了布局需要特殊写法，加载布局的时候，也需要特殊处理。拿 Activity 举例，我们要使用 DataBinding 加载布局，就不能像以前一样直接调用 setContentView，而是要使用 DataBindingUtil.setContentView 这个方法，那么我们就来分析一下这个方法。 androidx.databinding.DataBindingUtil#setContentView(android.app.Activity, int) 这个方法里面调用了其他方法，我们一直追踪下去，发现了它的核心方法是这个： androidx.databinding.DataBindingUtil#bind(androidx.databinding.DataBindingComponent, android.view.View, int) 12345678 private static DataBinderMapper sMapper = new DataBinderMapperImpl(); ... static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root, int layoutId) &#123; return (T) sMapper.getDataBinder(bindingComponent, root, layoutId); &#125; DataBinderMapperImpl 是编译器生成了一个类，它的 getDataBinder 内容大致如下： com.aprz.snackbardemo.DataBinderMapperImpl#getDataBinder(androidx.databinding.DataBindingComponent, android.view.View, int) 12345678910111213141516171819@Overridepublic ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) &#123; int localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId); if(localizedLayoutId &gt; 0) &#123; final Object tag = view.getTag(); if(tag == null) &#123; throw new RuntimeException("view must have a tag"); &#125; switch(localizedLayoutId) &#123; case LAYOUT_CONTENTMAIN: &#123; if ("layout/content_main_0".equals(tag)) &#123; return new ContentMainBindingImpl(component, view); &#125; throw new IllegalArgumentException("The tag for content_main is invalid. Received: " + tag); &#125; &#125; &#125; return null;&#125; 这个方法的 layoutId 就是 R.layout.content_main （我们使用DataBindingUtil#setContentView传入的值 ）。由于编译器自己生成了一个 Map，这个Map储存了所有需要 DataBinding 处理的 layoutId，layoutId 是key，value 是一个整数值。这里是我没有想通的地方，为啥要对应一个整数值，而不是直接使用 layoutId 呢？？？比如像下面这样写： 12345678switch(layoutId) &#123; case R.layout.content_main: &#123; if ("layout/content_main_0".equals(tag)) &#123; return new ContentMainBindingImpl(component, view); &#125; throw new IllegalArgumentException("The tag for content_main is invalid. Received: " + tag); &#125;&#125; 这个不影响，我们继续往下看，它最后返回了一个对象，叫做 ContentMainBindingImpl。使用过 DataBinding 的都应该会有点眼熟，因为我们使用的对象是 ContentMainBinding，而 ContentMainBindingImpl 看起来是 ContentMainBinding 的一个实现类。看一下他们的关系： 123public abstract class ContentMainBinding extends ViewDataBindingpublic class ContentMainBindingImpl extends ContentMainBinding 也就是说，虽然我们使用的是 ContentMainBinding，但是它实际上是一个 ContentMainBindingImpl 对象。 我们继续，看 ContentMainBindingImpl 的构造方法： com.aprz.databindingdemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(android.databinding.DataBindingComponent, android.view.View) 123public ContentMainBindingImpl(@Nullable android.databinding.DataBindingComponent bindingComponent, @NonNull View root) &#123; this(bindingComponent, root, mapBindings(bindingComponent, root, 5, sIncludes, sViewsWithIds));&#125; 这里调用了一个叫做 mapBindings 的方法，就是它解析了View的 tag ，然后将view存储到了一个数组中，在将这个数组赋值给成员变量，这样我们就不用 findViewById 了，因为它的方法比较长，所以我不贴代码了，就简单的说一下它的工作过程。 androidx.databinding.ViewDataBinding#mapBindings(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[], androidx.databinding.ViewDataBinding.IncludedLayouts, android.util.SparseIntArray, boolean) 1234567891011121314if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith("layout")) &#123; final int underscoreIndex = tag.lastIndexOf('_'); if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) &#123; // 这里的 index 就是 content_main_0 的 0 final int index = parseTagInt(tag, underscoreIndex + 1); if (bindings[index] == null) &#123; bindings[index] = view; &#125; indexInIncludes = includes == null ? -1 : index; isBound = true; &#125; else &#123; indexInIncludes = -1; &#125;&#125; 首先是获取到 tag 以 layout 开头的 View，将这个view 放入到 bindings[0] 中。 123456789&#125; else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123; // 这里的 index 是 binding_1 的 1，当然不只是 1，还有 2，3.... int tagIndex = parseTagInt(tag, BINDING_NUMBER_START); if (bindings[tagIndex] == null) &#123; bindings[tagIndex] = view; &#125; isBound = true; indexInIncludes = includes == null ? -1 : tagIndex;&#125; 然后获取以 tag 为 binding_ 开头的 View，放入到 bindings[1…n] 中。 12345678910if (!isBound) &#123; final int id = view.getId(); if (id &gt; 0) &#123; int index; if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp; bindings[index] == null) &#123; bindings[index] = view; &#125; &#125;&#125; 最后，如果控件没有id，但是使用了 @{} 的用法，也会存入 bindings 数组中，这个index也是接着上面 binding_ 的数字，比如，上面最后一个是 binding_5，这里的 index 就是从 6 开始了，这些数值都是编译器生成好了的。我猜想是在处理 xml 的时候，就需要生成对应的类，然后将index对应好。 有了这个数组，显然只需要将它赋值给对应的变量就好了。我们可以生成控件的成员变量，然后以驼峰式命名，将数组的值赋值给对应的变量。 com.aprz.snackbardemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[]) 1234567891011121314151617181920212223242526 private ContentMainBindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123; super(bindingComponent, root, 0 , (android.widget.TextView) bindings[4] , (android.widget.TextView) bindings[1] , (android.widget.TextView) bindings[2] ); this.mboundView0 = (android.widget.LinearLayout) bindings[0]; this.mboundView0.setTag(null); this.mboundView3 = (android.widget.TextView) bindings[3]; this.mboundView3.setTag(null); this.tvName.setTag(null); this.tvSex.setTag(null); setRootTag(root); // listeners invalidateAll(); &#125;---------------------------------------- protected ContentMainBinding(Object _bindingComponent, View _root, int _localFieldCount, TextView tvClassName, TextView tvName, TextView tvSex) &#123; super(_bindingComponent, _root, _localFieldCount); this.tvClassName = tvClassName; this.tvName = tvName; this.tvSex = tvSex; &#125; 从代码里面可以看出，它确实是将bindings赋值给了成员变量。没有id的无法外部使用 ，所以是 ContentMainBindingImpl 的成员变量，内部名字叫做 mboundViewXXX。 说了这么多，只是讲了一下它的如何不用 findViewById 的。但是 DataBinding 还有更重要的作用，就是数据绑定，我们接下来分析分析，它是如何将数据绑定到 UI 的，而且数据更新之后，是如何改变 UI 的！！！ 实现数据绑定，我们需要调用binding.setVariable或者binding.setViewModel，两者效果一样，因为setVariable会间接调用setViewModel方法。 com.aprz.databinding.ContentMainBindingImpl 12345678910111213141516171819202122 // variableId 是生成的BR文件中的一个变量，对应于你在 xml 中设置的变量@Override public boolean setVariable(int variableId, @Nullable Object variable) &#123; boolean variableSet = true; if (BR.viewModel == variableId) &#123; setViewModel((com.aprz.snackbardemo.User) variable); &#125; else &#123; variableSet = false; &#125; return variableSet; &#125; public void setViewModel(@Nullable com.aprz.snackbardemo.User ViewModel) &#123; // 这个方法有个坑，后面会说到 this.mViewModel = ViewModel; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; notifyPropertyChanged(BR.viewModel); super.requestRebind(); &#125; 可以看到实际上主要是调用了一下 notifyPropertyChanged 方法。notifyPropertyChanged 内部就是做了一个回调监听的操作，和我们的观察者模式没有区别，但是这里比较搞笑的就是，此时监听是为 null 的，也就是说没有注册观察者。 它在代码中表现的行为是这样的：我们创建一个对象A，将A通过 binding.setVariable 方法绑定到数据上，是可以正常显示出数据的，但是如果我们改变了对象A的某个属性，这个时候，属性的变化是无法反映到UI上的，我们还需要手动更新UI。 那么当我们改变了对象A的某个属性时，怎么才能自动更新UI 呢？参考官方文档的一个方法是使用 @Bindable 注解，比如我们的对象长这样： com.aprz.aboutme.MyName 12345678910data class MyName(var name: String) : BaseObservable() &#123; @get:Bindable var nickname: String = "aprz" set(value) &#123; field = value notifyPropertyChanged(com.aprz.aboutme.BR.nickname) &#125;&#125; 可以看到，每当 set 方法调用的时候，我们需要手机调用一下 notifyPropertyChanged 方法，这个时候，我们再看生成的文件，查看 setViewModel 方法： com.aprz.databinding.ContentMainBindingImpl#setViewModel 12345678910public void setViewModel(@Nullable com.aprz.snackbardemo.User ViewModel) &#123; // hhh updateRegistration(0, ViewModel); this.mViewModel = ViewModel; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; notifyPropertyChanged(BR.viewModel); super.requestRebind();&#125; 可以看到，第一行多了一行代码：updateRegistration，应该可以猜到，这个方法里面应该就是注册了观察者。为了验证我们的想法，查看一下这个方法： androidx.databinding.ViewDataBinding#updateRegistration(int, androidx.databinding.Observable) 123protected boolean updateRegistration(int localFieldId, Observable observable) &#123; return updateRegistration(localFieldId, observable, CREATE_PROPERTY_LISTENER);&#125; 这里的调用链比较深，我们只关心重要的方法，最后发现调用到了如下方法 androidx.databinding.ViewDataBinding.WeakListener#setTarget 1234567public void setTarget(T object) &#123; unregister(); mTarget = object; if (mTarget != null) &#123; mObservable.addListener(mTarget); &#125;&#125; 这里的 mTarget 是上面的 viewModel 变量，mObservable 是一个叫做 WeakPropertyListener 的类，因为我们省略了中间的调用过程，所以会有点突兀，但是我们把它当作一个 WeakListener 的一个包装类就好了，它持有 WeakListener 的引用而已。 再往下最终，会发现调用到了这里： androidx.databinding.BaseObservable#addOnPropertyChangedCallback 123456789@Overridepublic void addOnPropertyChangedCallback(@NonNull OnPropertyChangedCallback callback) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; mCallbacks = new PropertyChangeRegistry(); &#125; &#125; mCallbacks.add(callback);&#125; 这里就比较熟悉了吧，就是 notifyPropertyChanged 会触发监听回调，而这个监听就是在这里添加（注册）的。 经过上面的一连串调用，viewModel，WeakPropertyListener ，WeakListener ，就建立这样的一个关系： 因为 ViewModel 继承至 BaseObservable，所以它有一个成员变量：mCallbacks，而 updateRegistration 方法主要是添加了一个观察者。实际上DataBinding的自动更新UI原理还是观察者，但是它的高明之处是编译器自动生成逻辑代码。 好的，说完了观察者的注册，还有一步需要完成，就是通知观察者数据发生了变化。应该还记得，我们的 ViewModel 里面，set 方法都调用了一个方法notifyPropertyChanged： 123456@get:Bindablevar nickname: String = "aprz" set(value) &#123; field = value notifyPropertyChanged(com.aprz.aboutme.BR.nickname) &#125; 这个很显然就是通知观察者，我们的数据发生了变化，我们看看源码吧（其实不看都知道，最终触发了 mCallbacks 的回调）。同样的经过多层调用，到了下面的方法： androidx.databinding.ViewDataBinding#handleFieldChange 123456789101112private void handleFieldChange(int mLocalFieldId, Object object, int fieldId) &#123; if (mInLiveDataRegisterObserver) &#123; // We're in LiveData registration, which always results in a field change // that we can ignore. The value will be read immediately after anyway, so // there is no need to be dirty. return; &#125; boolean result = onFieldChange(mLocalFieldId, object, fieldId); if (result) &#123; requestRebind(); &#125;&#125; 主要是两个方法，先看第一个，看名字就应该是字段发生了变化的处理，该方法会调用到下面的方法： com.aprz.aboutme.databinding.ActivityMainBindingImpl#onChangeMyName 1234567891011121314151617181920212223private boolean onChangeViewModel(com.foxlee.testdatabinding.NewsViewModel ViewModel, int fieldId) &#123; switch (fieldId) &#123; case BR.name: &#123; synchronized(this) &#123; mDirtyFlags |= 0x2L; &#125; return true; &#125; case BR.value1: &#123; synchronized(this) &#123; mDirtyFlags |= 0x4L; &#125; return true; &#125; case BR._all: &#123; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; return true; &#125; &#125; return false;&#125; 这里其实啥都没做，就只给 mDirtyFlags 设置了一个标记位，这里就很灵性了，它不是与我们通常的想法一样，给每个字段分别处理，而是只是设置一个标记。 再看 requestRebind，从名字也可以看出来，应该是重新绑定，因为 onChangeMyName 给字段发生了变化的位设置了标记，所以在这个方法里面，应该就是根据标志位来刷新UI了，好，我们看看： androidx.databinding.ViewDataBinding#requestRebind 123456789101112protected void requestRebind() &#123; if (mContainingBinding != null) &#123; mContainingBinding.requestRebind(); &#125; else &#123; ... if (USE_CHOREOGRAPHER) &#123; mChoreographer.postFrameCallback(mFrameCallback); &#125; else &#123; mUIThreadHandler.post(mRebindRunnable); &#125; &#125;&#125; 如果对View的绘制源码有一点了解的，这里应该很好理解，这里就是刷新UI 了。然后继续往下追踪，它会调用到这个方法： com.aprz.aboutme.databinding.ActivityMainBindingImpl#executeBindings 123456789101112131415161718192021222324252627282930if ((dirtyFlags &amp; 0xfL) != 0) &#123; if ((dirtyFlags &amp; 0xbL) != 0) &#123; if (viewModel != null) &#123; // read viewModel.name viewModelName = viewModel.name; &#125; &#125; if ((dirtyFlags &amp; 0xdL) != 0) &#123; if (viewModel != null) &#123; // read viewModel.value1 viewModelValue1 = viewModel.value1; &#125; &#125;&#125;// batch finishedif ((dirtyFlags &amp; 0xdL) != 0) &#123; // api target 1 com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.mboundView3, viewModelValue1); com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.tvValue, viewModelValue1);&#125;if ((dirtyFlags &amp; 0xbL) != 0) &#123; // api target 1 com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.tvName, viewModelName);&#125; 可以看到，这个方法里面就是根据 dirtyFlags 的标志位来更新UI的。这个标志位的算法需要说一下，我们拿 name 的更新举例子： 在 onChangeViewModel 方法中，name字段更新的时候，给 mDirtyFlags 设置的标志位是 mDirtyFlags |= 0x2L;，而在 executeBindings 方法中，判断 name 字段的更新是使用的 dirtyFlags &amp; 0xbL 来判断的，这是为啥呢？ 这里不去深入研究它的计算规则了，只是简单的说一下： 0x1，0x2，0x4，0xb，0xd，0xf，他们转换成二进制是这样的： 123450 00010 00100 01000 10001 0000 看出规律了没有，这些数只有其中一位为1，其余的都为1，按照这个思路，如果某个数的该位为1，那么应该就是需要更新该位对应的属性。有了这个猜想，我们看看下面的数(023， 0x25， 0x29,，0x31)： 123410 001110 0101 10 100111 0001 这些数也是有规律的，他们第一位为1，最后一位为1，中间的数有一位为1。第一位为1，是用来保证更新所有字段的。中间的某位为1是与上面的位对应的，表示某个属性需要更新。第一位我还没搞清楚是用来做什么的（好像是与双向绑定有关系）。 自动刷新UI我们分析完了，还有一个问题，就是UI变化的时候，是如何改变ViewModel的值的呢？ 其实看上面的图，就可以看出一个大概，因为只有 ActitivyMainBindingImpl 有 ViewModel 的引用，所以肯定是它搞得事情。我们打开这个类就会发现这样的一些监听： 1234567891011121314151617181920private android.databinding.InverseBindingListener tvField1androidTextAttrChanged = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of user.field1 // is user.setField1((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(tvField1); // localize variables for thread safety // user != null boolean userJavaLangObjectNull = false; // user com.aprz.databindingdemo.User user = mUser; // user.field1 java.lang.String userField1 = null; userJavaLangObjectNull = (user) != (null); if (userJavaLangObjectNull) &#123; user.setField1(((java.lang.String) (callbackArg_0))); &#125; &#125;&#125;; 嗯，这里的逻辑很简单，首先拿到 TextView 的值，然后设置到 user 变量里面。不用想都知道 InverseBindingListener 是用来监听 TextView 的文字变化的。这里是因为在自动生成的代码里面给 TextView 都添加了一个 TextWatcher。所以当它发生变化的时候，就会回调这个方法。 需要注意的是，双向绑定容易引起死循环，因为UI导致 ViewModel 发生变化，ViewModel 变化了，又要去刷新 UI，就会不断的重复这个过程，需要自己处理一下，就是在更新UI的时候，判断一下值是否与当前相同，相同的时候再去更新（通知监听变化了）。 PS： 坑：不支持merge标签。布局根节点必须是 . 同时layout只能包含一个View标签. 不能直接包含&lt;merge&gt;。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation Processor]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FAnnotation%20Processor%2F</url>
    <content type="text"><![CDATA[注解处理在 Java 1.5 的时候就已经发布了，虽然它很老了，但是却是最强大的 API 之一。下面我们会先讨论注解处理，代码自动生成以及使用到这些技术的开源库。什么是注解实际上，我们应该都知道什么是注解。我们经常使用到的：@Override，@Singleton，@StringRes 等等，这些就是注解。 注解是一种可以添加到Java源代码的语法元数据。 我们可以注释类，接口，方法，变量，参数等。 可以从源文件中读取Java注解。 Java注解也可以嵌入和读取编译器生成的类文件。 Java VM可以在运行时保留注解，并通过反射进行读取。 比如： 12345@Retention(RetentionPolicy.SOURCE)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; 创建一个注解需要两部分信息： Retention 和 Target 。 RetentionPolicy 指定了注解应该保留到程序生命周期的什么时候。举个例子：注解可以保留到程序的编译时期或者运行时期。 ElementTypes 指定了注解应该作用于程序的哪一个部分。有3个取值： SOURCE —— 编译时期，不会储存 CLASS —— 储存在 class 文件中，但是不会保留到运行时期 RUNTIME —— 储存在 class 文件中，运行时期可以访问（通过反射） 拿 BindView 注解来说，RetentionPolicy.SOURCE 表示注解只需要在编译时期保存，之后就不需要了。ElementType.FIELD 表示该注解只能修饰字段。 注解处理器介绍编译时期Annotation Processor 实际上是 javac 编译器的一部分，所以注解处理时发生在编译时期，这有许多好处，其中之一就是“在编译其实发生错误比运行时期发生错误要好的多”。 无反射Java 的反射 API 会在运行时抛出许多错误，这实在是有点蛋疼。但是 Annotation Processor 就不一样了，它会直接给我们一个程序的语义结构，我们使用这个语义结构就可以分析注解所处的上下文场景，然后做处理。 生成样板代码Annotation Processor 最大的用处就是用来生成样板代码了，比如著名的 ButterKnife 等开源库。 注意：注解处理器只能生成新的文件，无法更改已经存在的文件。 注解处理器是如何工作的注解处理会执行很多轮。编译器首先会读取java源文件，然后查看文件中是否有使用注解，如果有使用，则调用其对应的注释处理器，这个注解处理器（可能会）生成新的带有注解的java源文件。这些新注解将再次调用其相应的注释处理器，然后再次生成更多的java源文件。就这样一直循环，直到没有新的文件生成。 注册注解处理器java 编译器需要知道所有的注解处理器，所以如果我们想要自定义一个处理器，我们必须要让 java 编译器知道我们创建了一个。 有两种方法来注册一个处理器： 老方法： 创建一个目录： 1&lt;your-annotation-processor-module&gt;/src/main/resources/META-INF/services 然后在services文件夹里面，创建一个名字叫做javax.annotation.processing.Processor的文件。在这个文件中声明你的处理器的权限定名： 1&lt;your-package&gt;.YourProcessor 新方法： 使用谷歌的 AutoService 库。 123456package foo.bar;import javax.annotation.processing.Processor;@AutoService(Processor.class)final class MyProcessor implements Processor &#123; // …&#125; 注意在 gradle 文件中引入依赖。 创建一个注解处理器首先，我们需要继承一个父类： 1234567891011121314151617181920public class Processor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); // initialize helper/utility classes... &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; // do processing... return true; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; // &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; // &#125;&#125; init() 提供帮助和工具类，如：Filer（生成文件），Messager（用于记录错误，警告等），Elements（用于操作程序元素的工具方法），类型（用于操作类型的工具方法）等。 我们可以使用processingEnvironment 这个变量来获取这些类。 process() 这个方法就是所有处理器处理注解的地方。这里你可以获取到被注解修饰的元素的所有信息。然后你就可以生成新的文件了。 getSupportedAnnotationTypes() 这里返回自定义的注解就好了。它的返回值是 process() 方法的第一个参数。 getSupportedSourceVersion() 返回最新的 java 版本就好了。 新建两个module一个用于创建注解，一个用于创建注解处理器。 为啥需要新建两个module呢？ 因为 processor 需要 annatation 的引用，所以 annotation 需要提出来作为一个 module。 那么可不可以将所有代码都放到 app 里面呢？是可以的，但是由于我们不需要 processor 的代码，只需要它在编译的时候处理我们的代码然后生成新的文件就好了，更不就不需要将 processor 的代码打包到 apk 里面，所以新建 module 是最好的选择。 piri-pricessor 的 build.gradle 需要配置一下： 1implementation project(':piri-annatation') app 的 build.gradle 需要配置一下： 12implementation project(':piri-annatation')annotationProcessor project(':piri-processor') 创建注解1234@Retention(RetentionPolicy.SOURCE)@Target(ElementType.TYPE)public @interface NewIntent &#123;&#125; ElementType.TYPE 表示这个注解可以修饰 类，接口，枚举 等等。 创建注解处理器自定义的注解处理器需要继承至一个指定的父类（AbstractProcessor）： 1234567891011121314public class NewIntentProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123;&#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv) &#123;&#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;&#125; @Override public SourceVersion getSupportedSourceVersion() &#123;&#125;&#125; 开始处理注解首先找到所有的被指定注解修饰元素123456789101112for (Element element : roundEnvironment.getElementsAnnotatedWith(NewIntent.class)) &#123; if (element.getKind() != ElementKind.CLASS) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Can be applied to class."); return true; &#125; TypeElement typeElement = (TypeElement) element; activitiesWithPackage.put( typeElement.getSimpleName().toString(), elements.getPackageOf(typeElement).getQualifiedName().toString());&#125; 我们利用 roundEnvironment.getElementsAnnotatedWith() 这个方法就可以找出所以被指定注解修饰的元素，这个方法返回了一个集合，集合类型是 Element，Element 是所有元素的一个父接口。 然后我们判断一下，注解是否被正确使用了，因为我们在创建注解的时候就指定了该注解只能修饰类，接口，枚举… 如果注解被错误使用了，我们可以使用 message 打印错误信息，反之，被正确使用了，那么我们就可以将它强制转换为 TypeElement。关于这个 TypeElement ，它是 Element 的一个子接口。它通常可以用于类和方法参数。还有一些其他类型的元素： 12345678910111213package com.example; // PackageElementpublic class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () &#123;&#125; // ExecuteableElement public void setA ( // ExecuteableElement int newA // TypeElement ) &#123;&#125;&#125; 之所以要强制转换成 TypeElement，是因为转换之后，我们可以获取到更多的信息。 生成代码1234567891011121314151617TypeSpec.Builder navigatorClass = TypeSpec .classBuilder("Navigator") .addModifiers(Modifier.PUBLIC, Modifier.FINAL);for (Map.Entry&lt;String, String&gt; element : activitiesWithPackage.entrySet()) &#123; String activityName = element.getKey(); String packageName = element.getValue(); ClassName activityClass = ClassName.get(packageName, activityName); MethodSpec intentMethod = MethodSpec .methodBuilder(METHOD_PREFIX + activityName) .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(classIntent) .addParameter(classContext, "context") .addStatement("return new $T($L, $L)", classIntent, "context", activityClass + ".class") .build(); navigatorClass.addMethod(intentMethod);&#125; 这个是 JavaPoet 的使用方法，就不多说了，可以查看 文档 。 最后，将代码写入文件123JavaFile.builder("com.annotationsample", navigatorClass.build()) .build() .writeTo(filer); 生成的文件大概内容如下： 12345public final class Navigator &#123; public static Intent startMainActivity(Context context) &#123; return new Intent(context, com.annotationsample.MainActivity.class); &#125;&#125; 然后，我们就可以在代码中使用生成的代码了： 1234567891011121314@NewIntentpublic class MainActivity extends AppCompatActivity &#123;&#125;----------------------------------------------------------------------------------------public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); Navigator.startMainActivity(this); //generated class, method &#125;&#125; 实例工程AnnotationProcessorDemo 遇到的坑： 新建module的时候要选择 java module，否则找不到 AbstractProcessor 类 我的 AS 一直保持着最新的 gradle 版本，在我写示例项目的时候，是引用的 gradle 版本是 https\://services.gradle.org/distributions/gradle-5.1.1-all.zip，于是我就踩了一个深坑，那就是发现 processor 工程打包除了问题，导致 app 项目引用了无法生成文件。找了一个下午的问题最后发现是 gradle 版本的问题，改成 https\://services.gradle.org/distributions/gradle-4.6-all.zip 就好了。我特么想骂人。 上面的版本问题，已经找到答案，添加一行代码即可： 1annotationProcessor &apos;com.google.auto.service:auto-service:1.0-rc5&apos; 我当时看别人的博客的时候，就很奇怪，为啥不用加 annotationProcessor。 倒推一下 ButterKnife 是怎么做的首先我们先来回忆一下我们是怎么使用 ButterKnife 的。 给控件加上注解： 12@BindView(R.id.title) TextView title; 在 Activity 的 setContentView 后，添加代码： 1ButterKnife.bind(this); 经过这两步，title 就会被自动赋值，然后我们就可以使用了。 这里我们可以猜想一下，ButterKnife 的注解处理器做了什么。 第一步，肯定也是先要获取到被注解修饰的元素。然后接下来该做什么呢？我们转换一下思维，如果我们没有使用 ButterKnife 的话，我们会做什么——我们会在 setContentView 方法后面写一个 initView 方法，然后给变量赋值。这个时候你就应该反应过来了，ButterKnife.bind(this); 这句代码就做了类似的功能。那么它是如何实现的呢？ 我们从这行代码中可以看出，ButterKnife 会持有当前 Activity 的引用，那么我们可不可以利用这个引用，拿到 title 呢？答案是可以的，因为 title 不是私有的，所以我们只需要生成一个类，将这个类放入当前 Activity 所在的 package 中即可。 由于注解的参数就是这个控件的 id，所以我们也可以找到这个控件，调用 findViewById，将这个值赋值给 title。大概是这样： 自动生成的代码 xxx 12activity.title = Utils.findViewById(root, id);这样就完成了赋值。当然实际不可能这么简单，还有很多细节需要处理，这里只是一个倒推，具体的细节还请执行查阅源代码。 后记 文章中已经说过，Annotaion Processor 只能生成新的文件，无法对已有的文件进行修改。如果我们有这方便的需求，那么应该怎么做呢？比如，我们想给某些类（比如Activity 或者 Fragement ）添加 log，手动添加的话，就很蛋疼了，这个时候，如果可以批量处理的话就会轻松很多。那么有什么可以办到呢，就是 Transform API 了，下一篇就写这个东西。 added注解处理器有这么一个蛋疼的地方：它会为每个使用注解的工程生成一个文件，那么问题就来了，有多个module以依赖的形式被app引用，那么就会生成多个相同的类，打包的时候肯定会报错，怎么解决呢？Arouter是生成不同的文件（以模块命名）。 想做一个收集被指定注解修饰的类的功能，但是遇到了很多问题： 首先生成的多个文件只能在module中访问，无法整合成一个类。 就算想别的方法再搞一个类整合这些生成的类，也需要知道这些生成的类的类名，还要能够访问的到这些类（除非你使用反射）。注解处理器的工作方式是每个module分开处理，没法知道别的module生成类的名字（除非像deeplink一样，手动添加）。 后记注解处理器可能会有多次处理过程。一个简单的例子：第一轮处理调用了注解处理器的process()方法，我们生成了对应的文件。由于生成了新文件，它可能会有注解，所以会走下一轮注解处理，然后重复生成文件。就会报错：Attempt to recreate a file for type xxxx解决办法是需要在 process 中将保存的集合清空，在集合为空时，不生成文件。]]></content>
      <categories>
        <category>AnnotationProcessor</category>
      </categories>
      <tags>
        <tag>Java-AnnotationProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005-使用定时器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0005-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[组件的业务逻辑里难免有涉及到定数触发的逻辑，比如倒计时、定时滚动。Tangram 内置了定时器模块，可以全局复用，防止重复开发。以在组件里使用定时器为例： 在 bindView 或者 postBindView 方法里注册定时器。在自定义的 View 中：12345678910@Overridepublic void postBindView(BaseCell cell) &#123; if (cell.serviceManager != null) &#123; TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class); if (timerSupport != null &amp;&amp; !timerSupport.isRegistered(this)) &#123; //第一个参数4是单位秒，第二个参数是接口回调，第三个参数是立即执行 timerSupport.register(4, this, true); &#125; &#125;&#125; 可以看到 TimerSupport 的获取方式有点类似 Android 的 getSystemService。我们看看是怎么做的。 com.tmall.wireless.tangram.BaseTangramEngine 12345678910111213141516private ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt; mServices = new ConcurrentHashMap&lt;&gt;();@Overridepublic &lt;S&gt; void register(@NonNull Class&lt;S&gt; type, @NonNull S service) &#123; Preconditions.checkArgument(type != null, "type is null"); mServices.put(type, type.cast(service));&#125;@Overridepublic &lt;S&gt; S getService(@NonNull Class&lt;S&gt; type) &#123; Object service = mServices.get(type); if (service == null) &#123; return null; &#125; return type.cast(service);&#125; BaseTangramEngine 这个类里面有一个 map，里面储存了各种 service 的实例。我们只需要调用 register 方法将一个实例注册进去，以后就可以通过 getService 方法获取了。而 BaseCell 的 serviceManager 字段又是指向同一个对象，所以这就像是一个单利用来储存与获取数据。 获取到 TimerSupport 之后，就是使用观察者模式来注册监听与解绑监听。 com.tmall.wireless.tangram.support.TimerSupport#register(int, com.tmall.wireless.tangram.support.TimerSupport.OnTickListener, boolean) 123public void register(int interval, @NonNull OnTickListener onTickListener, boolean intermediate) &#123; mDefaultTimer.register(interval, onTickListener, intermediate);&#125; 监听器的实现是 com.tmall.wireless.tangram.support.HandlerTimer类，这个类很简单，一般只要做过倒计时功能的都看的懂，里面是使用 Handler 做了一个循环实现的，所以我就不分析这个类了。 在注册完监听之后，还需要考虑的是，什么时候启动这个循环，什么时候终止这个循环，因为 TimerSupport 是统一管理所有的定时器。比如：当一个观察者解除监听的时候，不能直接停止整个定时器，因为可能还有别的观察者需要使用整个定时器。我们来看看，Tangram 是如何处理的： com.tmall.wireless.tangram.support.HandlerTimer#register 12345@Overridepublic void register(int interval, OnTickListener onTickListener, boolean intermediate) &#123; mListeners.put(onTickListener, new IntervalTickListener(interval, onTickListener, intermediate)); start(false);&#125; 在注册监听的时候，就会启动这个全局定时器。 com.tmall.wireless.tangram.support.HandlerTimer#runTask 1234567891011public void runTask() &#123; mCopyListeners.clear(); mCopyListeners.addAll(mListeners.values()); for (int i = 0, size = mCopyListeners.size(); i &lt; size; i++) &#123; IntervalTickListener listener = mCopyListeners.get(i); listener.onTick(); &#125; if (mListeners.isEmpty()) &#123; stop(); &#125;&#125; 在通知所有观察者的时候会判断，如果没有了观察者，会停止这个全局定时器。 关于定时器的处理，TimerSupport 就是用来统一管理一个全局的定时器的，免得每个 Cell 都开启一个自己的。TimerSupport 里面还有其他的一些方法，可以去看看。 在自定义 View 中实现接口： com.tmall.wireless.tangram.support.TimerSupport.OnTickListener 1234@Overridepublic void onTick() &#123; //处理业务逻辑 &#125; 在 unbindView 或者 postUnbindView 的方法里要记得注销定时器： 123456if (cell.serviceManager != null) &#123; TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class); if (timerSupport != null) &#123; timerSupport.unregister(this); &#125;&#125;]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-使用布局辅助模块]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0007-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[CardSupport，布局辅助模块，主要处里布局背景加载的回调，让业务方有能力去控制相关逻辑，业务方需要继承它并注册到 Tangram 里。由于这里面的逻辑涉及到 vLayout，而 vLayout 系列准备另起一个系列，所以这里就不说咯。这个类还是挺简单的，里面就几个空方法，Java 8 可以改成接口，用默认实现。 方法的意义也很明了，就是用来处理布局背景的，其他的没有。 还有一个方法是用来设置固定的 view 的出现与消失动画的。 123456789101112public abstract class CardSupport &#123; public FixAreaLayoutHelper.FixViewAnimatorHelper onGetFixViewAppearAnimator(Card card) &#123; return null; &#125; public void onUnbindBackgroundView(View layoutView, Card card) &#123; &#125; public abstract void onBindBackgroundView(View layoutView, Card card);&#125;]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-使用组件辅助模块]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0006-%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[每个组件里可能会有一些重复逻辑，特别是采用通用 model 开发组件的时候，组件的 View 之间一般没有继承体系，为了解决这种问题，建议业务也像SimpleClickSupport或者ExposureSupport一样将逻辑模块化，通过 serviceManager 注册到框里提供给组件使用。此外框架里还提供了一个CellSupport，暴露了一些基本接口，业务方需要继承它并注册到 Tangram 里。 假设我们的页面上有一些 Cell 需要做一些比较特殊且复杂的 log 操作，我们将 log 操作封装了起来以方便调用。 现在就有两种方式来使用封装好了的工具，第一种是在自定义 View 的时候，创建这个工具类出来，这显然不太好，或许我们可以将这个工具方法改为静态的，没法改的话，将工具类改为单利。 第二种方法就对该工具类没啥要求，只需要我们写好这个类之后，然后注册到 ServiceManager 里面，然后每个 cell 都可以获取到这个工具类了，如下： 123public class ComplexLogUtil &#123; public void log(View v)&#123;...&#125;&#125; 1engine.register(ComplexLogUtil.class, new ComplexLogUtil()); 123456789@Overridepublic void cellInited(BaseCell cell) &#123; if (cell.serviceManager != null) &#123; ComplexLogUtil complexLogUtil = cell.serviceManager.getService(ComplexLogUtil.class); if (timerSupport != null ) &#123; complexLogUtil.log(this); &#125; &#125;&#125; ServiceManager 就是一个纽带，让每个 Cell 都可以共享同一个东西。 再说 CellSupport，源码里面是这样使用这个类的： com.tmall.wireless.tangram.MVHelper#mountView 123456if (cell.serviceManager != null) &#123; CellSupport cellSupport = cell.serviceManager.getService(CellSupport.class); if (cellSupport != null) &#123; cellSupport.postBindView(cell, view); &#125;&#125; 这就说明了，当我们注册的时候，我们只能使用 CellSupport.class 来注册。比如我们有一个类 MyCellSupport 实现了这个接口，我们注册的时候如下： 1engine.register(CellSupport.class, new MyCellSupport()); 这个玩意就比较像一个切面了，比如我们想对每一个 cell 在 bindView 或者 unBindView 做一些通用的操作，就可以实现这个接口。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-异步加载数据]]></title>
    <url>%2F2019%2F09%2F09%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0004-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Tangram 的页面的数据无法一次性返回，有些区块布局内的数据需要异步加载、甚至分页加载。Tangram 里内置了封装了异步加载的逻辑，需要各个层面配合完成。数据设置想要实现异步加载，服务器返回的数据需要做如下配置：123456&#123; "id": "Shop", "load": "queryShop", "loadType": "-1", "type": "container-oneColumn"&#125; load 是接口名称，表示这个布局需要执行异步加载的接口。 loadType 是异步加载的方式，-1表示需要异步加载，1表示需要异步加载且有分页。 hasMore 与 loadType 配合，当 loadType = 1 的时候表示分页是否结束。 loadParams 是异步加载接口的常规参数字典，需要在调用接口时透传。 既然规定了 load 是接口名称，我们直接搜一下哪里用到了 “load”这个字符串，果然 Card 里面有一个字段： com.tmall.wireless.tangram.dataparser.concrete.Card#KEY_API_LOAD 1public static final String KEY_API_LOAD = "load"; 继续看用这个字符串搞了啥： com.tmall.wireless.tangram.dataparser.concrete.Card#parseWith(org.json.JSONObject, com.tmall.wireless.tangram.MVHelper, boolean) 12345public void parseWith(@NonNull JSONObject data, @NonNull final MVHelper resolver, boolean isParseCell) &#123; ... load = data.optString(KEY_API_LOAD, null); ...&#125; 从 json 数据里面解析出来接口名字，这个在意料之中。 解析出来之后，框架里面并没有去发起请求，而是使用了接口的方式让外部去做请求，这里只是将接口的一些信息解析出来保存起来。 CardLoadSupport与AsyncLoader，AsyncPageLoader上面说了，请求的处理还是暴露给了外部去处理，那么应该怎么做呢？只需要做一件事，提供一个自定义的 CardLoadSupport 就好了。 这个 CardLoadSupport 需要传入两个参数进去，AsyncLoader和AsyncPageLoader。所以归根结底，还是要自定义两个对象，AsyncLoader 和 AsyncPageLoader。 自定义这两个对象不难，我们看一个例子就明白了： 123456789new AsyncLoader() &#123; @Override public void loadData(Card card, @NonNull final LoadedCallback callback) &#123; Log.w("Load Card", card.load); ... // callback.fail(false); callback.finish(engine.parseComponent(cells)); &#125;&#125; card 参数里面有接口的所有信息了，所以可以发起请求，请求之后可以根据结果来设置相应的回调。 1234567891011121314151617181920212223242526new AsyncPageLoader() &#123; @Override public void loadData(final int page, @NonNull final Card card, @NonNull final LoadedCallback callback) &#123; // cells 是请求回来的数据 List&lt;BaseCell&gt; cs = engine.parseComponent(cells); if (card.page == 1) &#123; GroupBasicAdapter&lt;Card, ?&gt; adapter = engine.getGroupBasicAdapter(); card.setCells(cs); adapter.refreshWithoutNotify(); Range&lt;Integer&gt; range = adapter.getCardRange(card); adapter.notifyItemRemoved(range.getLower()); adapter.notifyItemRangeInserted(range.getLower(), cs.size()); &#125; else &#123; card.addCells(cs); &#125; //mock load 6 pages callback.finish(card.page != 6); card.notifyDataChange(); &#125;&#125;)); 这里是分页请求的处理，与我们平时分页的逻辑并无多大区别。 下面我们来看看源码里面，这两个 loader 做了什么，我们以 AsyncPageLoader 为例。 com.tmall.wireless.tangram.TangramEngine#onScrolled 在 RecyclerView 滚动的时候，就会调用这个方法，当然这方法需要我们主动的调用： 1234567recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); engine.onScrolled(); &#125;&#125;); 下面，我们分析 onScrolled 方法里面的核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// position 是当前屏幕上最后一个 cell 的位置// lastCardIndex 是表示的第几种 type 类型，从 0 开始// 所以 current 是屏幕上最后一个 card// 这里是对屏幕上最后一个卡片进行预加载更多if (pair != null &amp;&amp; position &gt;= pair.first.getUpper() - mPreLoadNumber) &#123; // async load if (!TextUtils.isEmpty(current.load) &amp;&amp; current.loaded) &#123; // page load if (current.loadMore) &#123; loadSupport.loadMore(current); loadSupport.reactiveDoLoadMore(current); &#125; return; &#125;&#125;boolean loadedMore = false;// 这里是处理当前屏幕上的 cardfor (int i = firstCardIndex; i &lt; Math.min(lastCardIndex + mPreLoadNumber, cards.size()); i++) &#123; Card c = cards.get(i); // async load if (!TextUtils.isEmpty(c.load) &amp;&amp; !c.loaded) &#123; // page load if (c.loadMore &amp;&amp; !loadedMore) &#123; // only load one load more card loadSupport.loadMore(c); loadSupport.reactiveDoLoadMore(c); loadedMore = true; &#125; else &#123; loadSupport.doLoad(c); loadSupport.reactiveDoLoad(c); &#125; c.loaded = true; &#125;&#125;// 这里是处理数据源里的最后一个 cardif (mEnableAutoLoadMore &amp;&amp; mGroupBasicAdapter.getItemCount() - position &lt; mPreLoadNumber) &#123; loadMoreCard();&#125; 这里面的主要逻辑分为 3 段，但是很蛋疼的是，这 3 段逻辑又有重复的地方。我们拿数学区间举例：假设第一段区间是 [0, 3]，第二段是 [2, 4]，第三段是 [3, 5]。可以看出区间里面有重复的地方法，就如同上面代码的 3 段逻辑。我们举一个例子来说明逻辑重复导致的影响： Tangram 提供了一个禁止加载更多的方法： com.tmall.wireless.tangram.TangramEngine#enableAutoLoadMore 123public void enableAutoLoadMore(boolean enableAutoLoadMore) &#123; this.mEnableAutoLoadMore = enableAutoLoadMore;&#125; 可以看到，这个字段只用在了第 3 段逻辑里面，按照道理来说，设置了这个之后，我们就不会自动加载更多了，但是实际上上面的两段逻辑也包含加载更多的逻辑，所以即使也将这个字段设置为了 false，你再运行官方demo也没啥区别。 这里我懒得搞清楚它为啥要这样写了，说实话这个框架的是值得一看的，但是代码真的很乱，阅读起来你搞不清楚写的人在想啥。 我们继续我们的分析，从上面的代码中我们可以看到它调用了 CardLoadSupport 的 doLoad 与 loadMore 方法。 CardLoadSupport#doLoad这个方法是用来加载 Card 中的数据的。 com.tmall.wireless.tangram.support.async.CardLoadSupport#doLoad 123456789101112131415161718192021222324252627public void doLoad(final Card card) &#123; if (mAsyncLoader == null) &#123; return; &#125; if (!card.loading &amp;&amp; !card.loaded) &#123; card.loading = true; mAsyncLoader.loadData(card, new AsyncLoader.LoadedCallback() &#123; @Override public void finish() &#123; card.loading = false; card.loaded = true; &#125; @Override public void finish(List&lt;BaseCell&gt; cells) &#123; finish(); card.addCells(cells); card.notifyDataChange(); &#125; public void fail(boolean loaded) &#123; card.loading = false; card.loaded = loaded; &#125; &#125;); &#125;&#125; 在方法中，我们可以看到实际上是使用了 com.tmall.wireless.tangram.support.async.AsyncLoader#loadData 这个方法，而这个方法是我们在创建 AsyncLoader 的时候，需要实现的方法。这样加载 Card 数据的逻辑就串起来了： 监听 RecyclerView 的滚动，在滚动的时候就触发加载加载逻辑。 如果数据没有加载的话，就调用外部实现的 AsyncLoader#loadData 方法来加载数据。 CardLoadSupport#loadMore这个方法是用来处理分页加载的。 com.tmall.wireless.tangram.support.async.CardLoadSupport#loadMore 1234567891011121314151617181920212223242526272829303132333435363738394041public void loadMore(final Card card) &#123; if (mAsyncPageLoader == null) &#123; return; &#125; if (!card.loading &amp;&amp; card.loadMore &amp;&amp; card.hasMore) &#123; card.loading = true; if (!card.loaded) &#123; card.page = sInitialPage; &#125; mAsyncPageLoader.loadData(card.page, card, new AsyncPageLoader.LoadedCallback() &#123; @Override public void finish(boolean hasMore) &#123; card.loaded = true; card.loading = false; card.page++; card.hasMore = hasMore; &#125; @Override public void finish(List&lt;BaseCell&gt; cells, boolean hasMore) &#123; if (card.page == sInitialPage) &#123; card.setCells(cells); &#125; else &#123; card.addCells(cells); &#125; finish(hasMore); card.notifyDataChange(); &#125; @Override public void fail(boolean retry) &#123; card.loaded = true; card.loading = false; card.hasMore = retry; &#125; &#125;); &#125;&#125; 这里的逻辑也很简单，与 doLoad 方法是一样的。我们在实现 AsyncPageLoader.loadData 方法的时候，一定要注意正确的调用 finish 与 fail 方法。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-处理点击与曝光]]></title>
    <url>%2F2019%2F09%2F09%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0003-%E5%A4%84%E7%90%86%E7%82%B9%E5%87%BB%E4%B8%8E%E6%9B%9D%E5%85%89%2F</url>
    <content type="text"><![CDATA[在上一篇，我们在自定义的 View 中的 cellInited 方法里面做了一些初始化的操作，其中就有添加点击事件，代码如下：12345@Overridepublic void cellInited(BaseCell cell) &#123; setOnClickListener(cell); this.cell = cell;&#125; 其中，setOnClickListener 方法的参数是 BaseCell，说明它肯定实现了点击事件的接口： com.tmall.wireless.tangram.structure.BaseCell#onClick 12345678910111213@Overridepublic void onClick(View v) &#123; if (serviceManager != null) &#123; SimpleClickSupport service = serviceManager.getService(SimpleClickSupport.class); if (service != null) &#123; int eventType = this.pos; if (innerClickMap.containsKey(v.hashCode())) &#123; eventType = innerClickMap.get(v.hashCode()).intValue(); &#125; service.onClick(v, this, eventType); &#125; &#125;&#125; 看第 10 行代码，这行代码最终会调用到 com.tmall.wireless.tangram.support.SimpleClickSupport#defaultClick 里面。 SimpleClickSupport 的子类应该要处理这个方法： 123456789101112public class SampleClickSupport extends SimpleClickSupport &#123; public SampleClickSupport() &#123; setOptimizedMode(true); &#125; @Override public void defaultClick(View targetView, BaseCell cell, int eventType) &#123; super.defaultClick(targetView, cell, eventType); Toast.makeText(targetView.getContext(), " 您点击了组件 type:"+cell.type, Toast.LENGTH_SHORT).show(); &#125;&#125; 可以看出来，SimpleClickSupport 是用来统一处理点击事件的。说一下 defaultClick 的 3 个参数： targetView 是 Cell 对应的 View，可能是一个 View，也可能是一个 ViewGroup cell 是View 对应的 cell （感觉有点废话） eventType 是注册点击事件时，传入的 type，如果没有传入该值默认为在 Card 中的位置。 我们可以在自定义 View 中传入 type： 12345@Overridepublic void cellInited(BaseCell cell) &#123; cell.setOnClickListener(this, 4); this.cell = cell;&#125; 这样的话，点击该 cell，eventType 就是 4 了。 使用SimpleClickSupport的时候需要注意： 建议开启优化模式 在路由点击事件的时候，会判断如果开启了优化，会调用到 defaultClick 方法，否则的话会触发反射： 1234567891011public void onClick(View targetView, BaseCell cell, int eventType, Map&lt;String, Object&gt; params) &#123; if (optimizedMode) &#123; defaultClick(targetView, cell, eventType); &#125; else &#123; ... // 使用反射寻找方法 // 方法需要以 onClickXXX 或者 onXXXClick 命名 // 并且参数列表是View targetView, BaseCell cell, int type或者View targetView, BaseCell cell, int type, Map&lt;String, Object&gt; params ... &#125;&#125; 处理曝光Tangram 认为组件曝光的时机就是被 RecyclerView 的 Adapter 绑定数据的那个时候，也就是即将滑动到屏幕范围内。在这个时候业务上可能需要有一些处理，因此提供了接口定义并整合到框架里 —— ExposureSupport。它定义了3个层面的曝光接口，一是曝光布局，二是曝光组件整体区域，三是曝光组件局部区域。业务方实现子类，并针对三个层面的曝光做分别的实现。 文档开头说的还是很清晰的，但是却没有仔细说这 3 个接口是哪 3 个，真的是蛋疼。 布局的整体曝光（这是从文档copy出来的，不知道是布局的曝光还是组件整体的曝光）回调接口是： 1public abstract void onExposure(@NonNull Card card, int offset, int position); 这个方法在com.tmall.wireless.tangram.dataparser.concrete.PojoGroupBasicAdapter#onBindViewHolder中调用。 组件的局部区域曝光接口是： 123public void defaultTrace(@NonNull View targetView, @NonNull BaseCell cell, int type) &#123;&#125; 但是我却没找到哪里调用了这个方法！！！ 还有一个方法： 123public void defaultExposureCell(@NonNull View targetView, @NonNull BaseCell cell, int type) &#123;&#125; 这个方法在 com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder 中调用。 可以看到，onExposure 与 defaultExposureCell 执行的时机差不多在同一时刻，因为 PojoGroupBasicAdapter 是 GroupBasicAdapter 的子类。差别就只有参数了。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-组件开发]]></title>
    <url>%2F2019%2F09%2F07%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0002-%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在 Tangram 的领域里，我们将一个普通的列表页面结构化成树状结构：分别是页面 - 布局 - 组件。123456789101112131415161718192021222324252627282930页面 | - 布局1 | | | - 组件11 | | | - 组件12 | | | - 组件13 | - 布局2 | | | - 组件21 | | | - 组件22 | - 布局3 | | | - 组件31 | | | - 组件32 | - 组件4 ... | | | - 布局n | - 组件n1 组件分为两层：model 和 View。Tangram 里提供了通用 model 类型 BaseCell，因此开发组件有两个选择： 采用通用 model，开发自定义 View。 采用自定义 model 和自定义 View BaseCell 里面储存了组件的数据信息，又需要的都可以在里面获取到，可以看一下结构树来了解一下里面的方法都有什么，这里就不展开说了，方法名很明了。 通用 Model 开发自定义 View文档提供了两种开发方式，一种是需要实现 ITangramViewLifeCycle 接口，一种是使用注解加反射的方式。 我们先来看第一种，实现结构的方式，以官方的demo为例： com.tmall.wireless.tangram.example.data.SingleImageView 1public class SingleImageView extends LinearLayout implements ITangramViewLifeCycle &#123;...&#125; 自定义的 View 需要实现接口，这个没啥说的。 该接口有 3 个方法需要实现： com.tmall.wireless.tangram.structure.view.ITangramViewLifeCycle 123456789public interface ITangramViewLifeCycle &#123; void cellInited(BaseCell cell); void postBindView(BaseCell cell); void postUnBindView(BaseCell cell);&#125; 第一个方法，就是用来做一些初始化工作的，cell 表示是这个组件的一些信息。上面说过，页面由布局与组件组成，对应的就是 Card 与 Cell。 我们追踪一下，看这个方法在哪里被调用： com.tmall.wireless.tangram.MVHelper#initView com.tmall.wireless.tangram.MVHelper#mountView com.tmall.wireless.tangram.core.adapter.BinderViewHolder#bind com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder 可以看到，最后到了 GroupBasicAdapter 的 onBindViewHolder方法里面。Tangram 的布局是基于 RecyclerView 的，我们将 GroupBasicAdapter 当作一个超级强的 Adapter 的实现就好了，所以 Cell 的初始化是在 onBindViewHolder 中执行的。 再看接口中的第二个方法，看名字就应该知道也是在 onBindViewHolder 的时候执行的，不过有一个 post 前缀，我们追踪一下就会发现，其实就是比 cellInited 方法晚一点调用而已。 com.tmall.wireless.tangram.MVHelper#mountView 12345678910&#125; else &#123; loadMethod(cell, view); initView(cell, view); renderView(cell, view); renderStyle(cell, view);&#125;if (mvResolver.isCompatibleType(cell.stringType)) &#123; mvResolver.getCellClass(cell.stringType).cast(cell).bindView(view);&#125;postMountView(cell, view); 第 3 行与第 10 行，第 3 行会触发 cellInited 的调用，第 10 行触发了 postBindView。 再看接口中的第三个方法，我们可以思考一下，应该在什么时候触发 postUnBindView 方法？最显然的应该是在滑出屏幕的时候，但是如果对 RecyclerView 的回收机制有一定了解的应该知道，一个 item 滑出屏幕的时候，还没有进入 pool 里面，而是进入到了 cache 里面，是为了防止用户滑出又滑入的情况。所以我们应该在 item 进入 pool 的时候再触发 postUnBindView，而且只有进入了 pool 中的 item 才会重新走 onBindViewHolder，这刚好与 postBindView 是对称的。 我们追踪一下代码，看看它是什么时候调用的： com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onViewRecycled 123456@Overridepublic void onViewRecycled(BinderViewHolder&lt;C, ? extends View&gt; holder) &#123; ... holder.unbind(); ...&#125; 与我们思考的一样，是当 item 被回收的时候，触发的。 现在，我们知道了这 3 个方法调用的时机，就知道我们可以在这 3 个方法里面做什么了，下面是一个例子： com.tmall.wireless.tangram.example.data.TestView 12345@Overridepublic void cellInited(BaseCell cell) &#123; setOnClickListener(cell); this.cell = cell;&#125; 这里处理了点击事件。 12345678910111213141516171819@Overridepublic void postBindView(BaseCell cell) &#123; int pos = cell.pos; String parent = ""; if (cell.parent != null) &#123; parent = cell.parent.getClass().getSimpleName(); &#125; textView.setText( cell.id + " pos: " + pos + " " + parent + " " + cell .optParam("msg")); if (pos &gt; 57) &#123; textView.setBackgroundColor(0x66cccf00 + (pos - 50) * 128); &#125; else if (pos % 2 == 0) &#123; textView.setBackgroundColor(0xaaaaff55); &#125; else &#123; textView.setBackgroundColor(0xcceeeeee); &#125;&#125; 这个方法里，就是设置组件了。 postBindView 与 cellInited 的区别在于，postBindView 调用的时候，view 与 style 的渲染准备工作都完成了。 123@Overridepublic void postUnBindView(BaseCell cell) &#123;&#125; 一般情况下，这个方法都不用做什么，除非你有什么需要取消的，比如网络请求，定时器。 自定义 View 还支持注解加反射的方式，原理是一样的，不过一个是直接调用，一个是使用反射来调用，我不太喜欢这种方式，就不介绍了。 自定义 Model 开发组件采用通用的 model 开发组件，只需要写 View 就可以了，然而需要在每次绑定数据的时候都要取原始 json 里解析一下字段。有时候一个业务方会有一些通用的业务字段定义，每个组件里重复解析会让代码显得冗余，因此也提供了注册自定义 model 的兼容模式开发组件。这个时候就需要写自定义 model 和自定义 View 两部分了。 自定义 Model 需要继承 BaseCell，可以实现下面的几个方法： 1234567891011121314/** 解析数据业务数据，可以将解析值缓存到成员变量里 */public void parseWith(JSONObject data)/** 解析数据样式数据，可以将解析值缓存到成员变量里 */public void parseStyle(@Nullable JSONObject data)/** 绑定数据到自定义 View */public void bindView(@NonNull V view)/** 绑定数据到 View 之后，可选实现 */public void postBindView(@NonNull V view)/** 校验原始数据，检查组件的合法性 */public boolean isValid() 其中两个 parse 方法可以理解，但是两个 bind 方法感觉没啥作用啊，有啥通用的 bind 与 unbind 逻辑可以写在这里吗？当成一个切面好理解些。 粒度想一下，Tangram 复用的粒度是 Card 还是 Cell？Card的作用是用来排列 Cell 的，所以它只是起了一个布局的作用，是一个虚拟的概念，在实际的绘制中根本不存在 Card 。所以粒度是 Cell。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F07%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[直接看官方文档比较好吧： 了解Tangram 基本概念 基础架构 设计原则 后面的文章，都是照着下面链接的目录来的： http://tangram.pingguohe.net/docs/android/access-tangram 主要是记录在看文档的过程中，对相应部分源码的分析与自己的理解。 Tangram 的接入与核心方法这两部分可讲的东西不多，所以我们直接跳过。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005-绑定数据]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0005-%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前面一篇文章，对于 preview 方法，我们分析完了第一行代码，现在，我们继续分析设置数据的方法，做了什么：1234IContainer iContainer = (IContainer) mContainer;if (jsonData != null) &#123; iContainer.getVirtualView().setVData(jsonData);&#125; 前面的东西都看懂了的话，就知道这里的 mContainer 实际上是一个 Container 的实例，iContainer.getVirtualView()的值就是 VHLayout。这里设置了 json 数据。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setVData(java.lang.Object, boolean) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768final public void setVData(Object data, boolean isAppend) &#123; if (VERSION.SDK_INT &gt;= 18) &#123; Trace.beginSection("ViewBase.setVData"); &#125; mViewCache.setComponentData(data); if (data instanceof JSONObject) &#123; boolean invalidate = false; if (((JSONObject) data).optBoolean(FLAG_INVALIDATE)) &#123; invalidate = true; &#125; List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView(); if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125; &#125; ((JSONObject) data).remove(FLAG_INVALIDATE); &#125; else if (data instanceof com.alibaba.fastjson.JSONObject) &#123; boolean invalidate = false; if (((com.alibaba.fastjson.JSONObject) data).getBooleanValue(FLAG_INVALIDATE)) &#123; invalidate = true; &#125; List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView(); if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125; &#125; ((com.alibaba.fastjson.JSONObject) data).remove(FLAG_INVALIDATE); &#125; if (VERSION.SDK_INT &gt;= 18) &#123; Trace.endSection(); &#125;&#125; 代码稍微有点长，再仔细看一下，里面有两段逻辑，是差不多的，一段是针对 Android 自带的 JSONObject 处理的，一段是针对 com.alibaba.fastjson.JSONObject 处理的，为啥没有 Gson。 我们只分析其中一段： 1234567891011121314151617181920212223List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView();if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125;&#125; 获取缓存中的所有 ViewBase，然后对每一个 ViewBase 的 Item （也就是封装的属性类），都调用它的 bind 方法。 com.tmall.wireless.vaf.virtualview.core.ViewCache.Item#bind 这个方法有点长，截取一段分析 1234567case TYPE_INT: if (value instanceof Number) &#123; Integer integer = Utils.toInteger(value); if (integer != null) &#123; mView.setAttribute(mKey, integer.intValue()); &#125; &#125; value 的值，是 Parser 解析出来的，里面就是从 json 里面取对应的字段值，懒得看了。拿到值之后，设置给 view。 这样，数据绑定就搞定了。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-事件处理]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0006-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[组件默认是不会响应事件的。想要组件响应事件，需要做如下类似设置：1flag="flag_exposure|flag_clickable"flag_exposure 表示组件曝光事件，源码中 com.tmall.wireless.vaf.virtualview.event.EventManager#TYPE_Exposure 表示曝光事件，看了调用的位置，一般都在 setData 的时候，有点奇怪。 flag_clickable 就是点击事件了。 当用户触摸了某个位置的时候，会触发下面的代码： com.tmall.wireless.vaf.virtualview.core.ViewBase#click 123public boolean click(int x, int y, boolean isLong) &#123; return clickRoute(mId, isLong);&#125; 或者下面的 layout 的方法： com.tmall.wireless.vaf.virtualview.core.Layout#click 123456789101112131415161718192021222324@Overridepublic boolean click(int x, int y, boolean isLong) &#123; boolean deal = false; for (int i = mSubViews.size() - 1; i &gt;= 0; i--) &#123; ViewBase v = mSubViews.get(i); int l = v.getAbsoluteDrawLeft(); int t = v.getAbsoluteDrawTop(); int w = v.getComMeasuredWidth(); int h = v.getComMeasuredHeight(); if (x &gt;= l &amp;&amp; x &lt; (l + w) &amp;&amp; y &gt;= t &amp;&amp; y &lt;= t + h) &#123; deal = v.click(x, y, isLong); if (deal) &#123; break; &#125; &#125; &#125; if (!deal) &#123; deal = super.click(x, y, isLong); &#125; return deal;&#125; 可以看出，对于 layout 来说，如果 child 没有处理 click 事件的话，会自己处理。类比一下 View 与 ViewGroup 还是很容易理解的。 下面的分析流程走 ViewBase 的 click 方法。 com.tmall.wireless.vaf.virtualview.core.ViewBase#clickRoute 123456789101112protected boolean clickRoute(int id, boolean isLong) &#123; boolean ret; if (isLong) &#123; ret = onLongClick(id); &#125; else &#123; ret = onClick(id); &#125; //if (!ret &amp;&amp; null != mParent) &#123; // ret = mParent.clickRoute(mParent.mId, isLong); //&#125; return ret;&#125; 以 onClick 为例： com.tmall.wireless.vaf.virtualview.core.ViewBase#onClick 123456789101112131415161718192021222324protected boolean onClick(int id) &#123; boolean ret = false; if (null != mBean) &#123; mBean.click(id, false); &#125; if (null != mClickCode) &#123; ExprEngine engine = mContext.getExprEngine(); if (null != engine) &#123; engine.getEngineContext().getDataManager().replaceData( getViewCache().getComponentData()); &#125; if (null != engine &amp;&amp; engine.execute(this, mClickCode)) &#123; &#125; else &#123; Log.e(TAG, "onClick execute failed"); &#125; &#125; // isClickable 会判断是否设置了 flag_clickable 标志位 if (isClickable() &amp;&amp; isVisible()) &#123; ret = mContext.getEventManager().emitEvent(EventManager.TYPE_Click, EventData.obtainData(mContext, this)); &#125; return ret;&#125; 这里发送了一个消息。 点击事件的注册如下： 123456789101112sVafContext.getEventManager().register(EventManager.TYPE_Click, new IEventProcessor() &#123; @Override public boolean process(EventData data) &#123; Log.d(TAG, "TYPE_Click data view:" + data.mView); Log.d(TAG, "TYPE_Click view name:" + data.mVB.getTag("name")); Log.d(TAG, "TYPE_Click view traceId:" + data.mVB.getTag("activityTraceId")); Toast.makeText(PreviewActivity.this, "TYPE_Click view name:" + data.mVB.getTag("name") + "\n traceId:" + data.mVB.getTag("activityTraceId"), Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); 可以看到，这里处理了消息， 只能统一处理。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-控件]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0007-%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[虚拟控件到底是如何工作的？它是如何直接绘制在 canvas 上的？Tangram 提供的控件分为两类，一类以 Native 开头，表示实际上是基于原生控件实现的。一类以 Virtual 开头，表示这不是一个实际的控件。这里分析两个控件，来加深对虚拟控件的理解。NativeText看它的构造函数，它里面封装了一个原生的控件： com.tmall.wireless.vaf.virtualview.view.text.NativeText 12345678910public class NativeText extends TextBase &#123; protected NativeTextImp mNative; public NativeText(VafContext context, ViewCache viewCache) &#123; super(context, viewCache); mNative = new NativeTextImp(context.forViewConstruction()); &#125;&#125; 这个 NativeTextImp 就是继承至 TextView 的。 Tangram 的控件都是继承至 ViewBase 的，而不是继承至 View。它们没有 view 的 onMeasure，onLayout，onDraw 等方法，而是有自己的一套方法： com.tmall.wireless.vaf.virtualview.core.IView 123void onComMeasure(int widthMeasureSpec, int heightMeasureSpec);void onComLayout(boolean changed, int l, int t, int r, int b); 这两个方法就是自己的一套测量与布局逻辑，对于 Native 开头的控件来说，肯定是直接调用了封装的原生控件的方法： com.tmall.wireless.vaf.virtualview.view.text.NativeText 123456789@Overridepublic void onComMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; mNative.onComMeasure(widthMeasureSpec, heightMeasureSpec);&#125;@Overridepublic void onComLayout(boolean changed, int l, int t, int r, int b) &#123; mNative.onComLayout(changed, l, t, r, b);&#125; 而对于 Virtual 开头的控件来说，它里面没有封装原生控件，所以只能自己实现了，不过我们不用太担心，ViewBase 里有一个内部类 com.tmall.wireless.vaf.virtualview.core.ViewBase.VirtualViewImp，它实现了一些通用的逻辑，一般情况下，我们只需要使用它的方法就好了，看看 VirtualText 是如何做的： com.tmall.wireless.vaf.virtualview.view.text.VirtualText 123456789101112public class VirtualText extends TextBase &#123; protected VirtualViewImp mImp = new VirtualViewImp(); @Override public void onComMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; mImp.onComMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override public void onComLayout(boolean changed, int l, int t, int r, int b) &#123; &#125;&#125; 可以看到，用起来还是很方便的，VirtualText 没有子组件，所以不用实现 onComLayout 方法。 上面说了测量与布局，没有说绘制，是因为绘制有点特殊。还记得在容器添加组件的时候，是怎么做的么？ com.tmall.wireless.vaf.virtualview.container.Container#attachViews(com.tmall.wireless.vaf.virtualview.core.ViewBase, android.view.View) 之前我们没有深入分析这个方法，只是简单的带过了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void attachViews(ViewBase view, View displayViewHolder) &#123; view.setDisplayViewContainer(displayViewHolder); if (view instanceof Layout) &#123; View v = view.getNativeView(); if (null != v) &#123; if (v.getParent() == null) &#123; LayoutParams layoutParams = new LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight); addView(v, layoutParams); &#125; else &#123; LayoutParams layoutParams = v.getLayoutParams(); layoutParams.width = view.getComLayoutParams().mLayoutWidth; layoutParams.height = view.getComLayoutParams().mLayoutHeight; v.setLayoutParams(layoutParams); &#125; if (v instanceof INativeLayoutImpl) &#123; Layout layout = (Layout) view; List&lt;ViewBase&gt; subViews = layout.getSubViews(); if (null != subViews) &#123; for (int i = 0, size = subViews.size(); i &lt; size; i++) &#123; ViewBase com = subViews.get(i); ((INativeLayoutImpl) v).attachViews(com, v); &#125; &#125; &#125; &#125; else &#123; Layout layout = (Layout) view; List&lt;ViewBase&gt; subViews = layout.getSubViews(); if (null != subViews) &#123; for (int i = 0, size = subViews.size(); i &lt; size; i++) &#123; ViewBase com = subViews.get(i); attachViews(com, displayViewHolder); &#125; &#125; &#125; &#125; else &#123; View v = view.getNativeView(); if (null != v) &#123; if (v.getParent() == null) &#123; LayoutParams layoutParams = new LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight); addView(v, layoutParams); &#125; else &#123; LayoutParams layoutParams = v.getLayoutParams(); layoutParams.width = view.getComLayoutParams().mLayoutWidth; layoutParams.height = view.getComLayoutParams().mLayoutHeight; v.setLayoutParams(layoutParams); &#125; &#125; &#125;&#125; 这个方法看起来很长，但是表达的意思非常的简单： 如果这个组件是以 Native 开头，这将这个组件封装的原生控件添加到容器里面 而对于不是以 Native 开头的，没有添加到容器里面，因为它根本就不是一个 view 这里说的 Native 开头不太准确，但是比较好理解，应该说成是里面封装了一个原生控件的组件。 对于以 Native 开头的，既然添加到了容器里面，那么它的绘制，就都交给 ViewRootImpl 去处理了，不用我们关心。那么这里有一个问题，既然它会被添加到容器里面，我们可不可以不用去实现其测量与布局逻辑呢？反正都是由系统处理。这个肯定是不行的，因为虽然添加到容器中后，走的是系统的布局，但是它与容器中其他虚拟控件的相互位置等等，走的是自定义的那一套逻辑，所以还是要实现自定义的测量与布局。 VirtualText而对于非 Native 开头的，它没有被添加到容器里面，那么它是怎么显示出来的呢？其实就是直接画在容器上的 canvas 上的啦。 com.tmall.wireless.vaf.virtualview.container.Container#onDraw 如果有虚拟控件，需要调用 setWillNotDraw(false);，该方法才会执行 123456@Overrideprotected void onDraw(Canvas canvas) &#123; if (null != mView &amp;&amp; mView.shouldDraw()) &#123; mView.comDraw(canvas); &#125;&#125; 这里的 mView 就是模板文件的根 ViewBase 了。它调用了自己 comDraw 方法，参数是自己的 canvas，我们拿 VHLayout 举例： com.tmall.wireless.vaf.virtualview.core.Layout#comDraw VHLayout 继承 Layout 1234567891011121314151617@Overridepublic void comDraw(Canvas canvas) &#123; super.comDraw(canvas); //FIXME let layout clip virtual children //canvas.save(); //VirtualViewUtils.clipCanvas(canvas, mMeasuredWidth, mMeasuredHeight, mBorderWidth, // mBorderTopLeftRadius, mBorderTopRightRadius, mBorderBottomLeftRadius, mBorderBottomRightRadius); // draw children for (int i = 0, size = mSubViews.size(); i &lt; size; i++) &#123; ViewBase v = mSubViews.get(i); if (v.shouldDraw()) &#123; v.comDraw(canvas); &#125; &#125; //canvas.restore();&#125; 可以看到，它调用了每个子组件的 comDraw 方法。这样一层一层绘制下去，我们拿 VirtualText 举例： com.tmall.wireless.vaf.virtualview.view.text.VirtualText#onComDraw 123456789101112131415161718192021 @Override protected void onComDraw(Canvas canvas) &#123; super.onComDraw(canvas); if (null == mContentRect) &#123; makeContentRect(); &#125; if (null != mContentRect) &#123;... canvas.save(); canvas.clipRect(0, 0, mMeasuredWidth, mMeasuredHeight); canvas.drawText(mDrawText, left, top - mDescent, mPaint); canvas.restore(); ... &#125; else &#123; Log.w(TAG, "skip draw text"); &#125; &#125; 这样 Text 就绘制出来了。 不过在绘制的时候，还有一个需要注意的地方： 子组件的画布需要变化一下，需要将绘制的位置，变换到布局的位置。 看看它是如何做的： com.tmall.wireless.vaf.virtualview.core.ViewBase#comLayout 1234567@Overridepublic void comLayout(int l, int t, int r, int b) &#123; mDrawLeft = l; mDrawTop = t; onComLayout(true, l, t, r, b);&#125; 在子组件布局完成之后，保存了左上角的位置。 com.tmall.wireless.vaf.virtualview.core.ViewBase#comDraw 1234567public void comDraw(Canvas canvas) &#123; canvas.save(); canvas.translate(mDrawLeft, mDrawTop); onComDraw(canvas); canvas.restore(); mIsDrawed = true;&#125; 然后，在绘制的时候，将画布平移了，这样一来，就不用子组件来操心了。 总结： 虚拟控件就是将测量，布局，绘制的逻辑封装在了一个普通的类X中，在依托容器显示的时候，容器中组件的测量，布局，绘制的逻辑，都走X类中的测量，布局，绘制的逻辑。 测量，布局逻辑是为了确定子组件在容器中画布的位置。 其实，把它想象成一个自定义控件就很好理解了。 当我们自定义一个比较复杂的控件时，通常会将这个控件分为好几部分。比如我们要绘制一个日历控件： 我们可以将将年分当作容器，它可以用 RecyclerView 或者 ViewPager 来实现 将月份封装成一个类，它只需要确定当前月有多少天，以及每天的信息应该绘制在哪个位置 （这个玩意就相当于一个布局方法了），以及绘制边框 将天封装成一个类，它绘制每一天的信息 对于月份来说，它不是一个 View，却相当于一个 ViewGroup，用于确定每一天的位置，然后平移画布。 对于天来说，它不是一个 View，却相当于一个 View，用于绘制某天的信息。 我们项目中的日历就是这么实现的，扩展性也不错。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0027-栈的应用之四则表达式]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0027-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%9B%9B%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[四则表达式大家应该都知道如何取计算，有个口诀： 先乘除，后加减，从左算到右，先括号内再括号外。 看下面的这个表达式：19 + (3 - 1) * 3 + 10 / 2这个表达式，让我们来算，非常的简单。但是让计算机来计算呢，就比较麻烦了。因为计算机不会口诀，它不知道应该先计算括号里面的。那么如何才能让计算机计算四则表达式呢？在 20 世纪 50 年代，一个波兰逻辑学家（名字太长，就不打了）发明了一种后缀表达式（逆波兰表达式）。这种后缀表达式是一种全新的显示方式，非常巧妙的解决了程序实现四则运算的问题。 对于上面的那个四则表达式，它的后缀表达式如下： 1234四则表达式9 + (3 - 1) * 3 + 10 / 2后缀表达式：9 3 1 - 3 * + 10 2 / + 之所以叫后缀表达式，是因为符号在要运算数字的后面出现。 后缀表达式的计算有了后缀表达式，我们需要理解它是如何工作的，先来说一段规则： 从左到右遍历表达式的每个数字与符号，遇到数字就进栈，遇到符号，就出栈两个数字，然后进行运算，将运算的结果进栈，一直遍历完毕，最后栈内的就是计算结果。 看下面的这个例子： 12后缀表达式：9 3 1 - 3 * + 10 2 / + 创建一个空栈，遍历表达式，前3个都是数字，直接进栈： 接下来遇到了 “-”，从栈里面取两个运算数字，第一个是减数，第二个是被减数，即（3 - 1），然后将结果 2 进栈: 接着是数字 3 进栈 接着是遇到了 “*”，同样从栈里面取出两个数字，计算（2 * 3），将结果 6 放入栈中，然后，又遇到了 “+”，从栈里面取出两个数字，计算（9 + 6），将结果 15 放入栈中： 接着是，10 与 2 进栈，然后是遇到 “/”，计算（10 / 2），将 5 进栈。最后遇到 “+”，计算 （15 + 5），将 20 进栈。20 就是计算结果。 中缀表达式转后缀表达式前面我们说了，后缀表达式对于程序来说，很好描述，但是如果没有一个方法很容易的将中缀表达式转成后缀表达式的话，后缀表达式毫无意义。 所以这里介绍中缀表达式转后缀表达式的规则： 从左到右遍历中缀表达式 遇到数字直接输出 遇到左括号进栈 遇到右括号，需要将栈内元素出栈，直到左括号出栈 遇到符号需要对于栈顶元素 如果栈为空，进栈 如果栈顶为左括号，进栈 将栈顶元素依次出栈，直到遇到比该符号的优先级低的符号。 还是上面的例子【9 + (3 - 1) * 3 + 10 / 2】，用图来描述一遍： 初始化一个空栈，开始遍历，第一个是数字 9 ，直接输出，然后是符号 “+”，进栈 此时表达式为：9 左括号未配对，直接进栈，3直接输出，“-”进栈，1直接输出，遇到右括号需要将栈里面的元素输出，直到左括号出栈 此时表达式为：9 3 1 - 遇到 “*” 号，比栈顶元素的优先级高，进栈，输出 3 此时表达式为：9 3 1 - 3 遇到 “+”号，将 “*”出栈，将“+”出栈，将这个“+”号进栈，输出表达式为 ：，然后是输出 10，将“/”进栈， 此时表达式为：9 3 1 - 3 * + 10 输出 “2”，将 “/”，“+” 出栈 此时表达式为：9 3 1 - 3 * + 10 2 / + 代码实现先定义操作符数据结构，因为涉及到优先级比较： 123456789101112131415161718192021222324252627enum Operator &#123; PLUS("+", 1), MINUS("-", 1), MUl("*", 2), DIV("/", 2), LEFT_BRACKET("(", 3), RIGHT_BRACKET(")", 3); String symbol; int priority; Operator(String s, int priority) &#123; this.symbol = s; this.priority = priority; &#125; public boolean lessOrEqual(Operator operator) &#123; return this.priority &lt;= operator.priority; &#125; public static Operator get(String s) &#123; Operator[] values = Operator.values(); for (Operator operator : values) &#123; if (operator.symbol.equals(s)) &#123; return operator; &#125; &#125; return null; &#125;&#125; 然后开始想法子计算表达式，分为几个步骤。 将字符串表达式分解开 1234567891011121314151617181920212223242526272829303132333435363738private static String[] splitExpr(String expr) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); expr = expr.replaceAll(" ", ""); int length = expr.length(); // 用来储存数字 StringBuilder builder = null; for (int i = 0; i &lt; length; i++) &#123; String c = expr.substring(i, i + 1); // 遇到符号，需要先判断将 builder 里面储存的数字添加到集合，然后将符号添加到集合 if (isSymbol(c)) &#123; if (builder != null) &#123; result.add(builder.toString()); builder = null; &#125; result.add(c); &#125; else if (isNumber(c)) &#123; // 遇到数字就将数字添加到 builder，避免多位数字问题 if (builder == null) &#123; builder = new StringBuilder(); &#125; builder.append(c); &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; if (builder != null) &#123; result.add(builder.toString()); &#125; return result.toArray(new String[0]);&#125; 将表达式分解之后，可以执行中缀转后缀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static String[] midToEnd(String expr) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 先将表达式分解出来 String[] array = splitExpr(expr); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); String pop; for (int i = 0; i &lt; array.length; i++) &#123; String s = array[i]; if (isNumber(s)) &#123; // 数字直接输出 result.add(s); &#125; else if (isOperator(s)) &#123; // 符号将栈顶优先级高于或等于的依次出栈 Operator operator; Operator top; while (!stack.isEmpty() &amp;&amp; isOperator(stack.peek())) &#123; operator = Operator.get(s); top = Operator.get(stack.peek()); if (operator.lessOrEqual(top)) &#123; result.add(stack.pop()); &#125; else &#123; break; &#125; &#125; // 将自己进栈 stack.push(s); &#125; else if (s.equals(Operator.LEFT_BRACKET.symbol)) &#123; // 左括号进栈 stack.push(s); &#125; else if (s.equals(Operator.RIGHT_BRACKET.symbol)) &#123; // 右括号需要匹配左括号 while (!stack.empty()) &#123; pop = stack.pop(); if (pop.equals(Operator.LEFT_BRACKET.symbol)) &#123; break; &#125; result.add(pop); &#125; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; while (!stack.isEmpty()) &#123; result.add(stack.pop()); &#125; return result.toArray(new String[0]);&#125; 然后计算后缀表达式 12345678910111213141516171819202122232425262728293031323334353637private static double cal(String expr) &#123; String[] temp = midToEnd(expr); Stack&lt;Double&gt; number = new Stack&lt;&gt;(); for (String s : temp) &#123; if (isNumber(s)) &#123; // 数字直接进栈 number.push(Double.parseDouble(s)); &#125; else if (isOperator(s)) &#123; // 运算符则弹出两个数字，计算结果，将结果进栈 if (number.size() &gt;= 2) &#123; Double opr = number.pop(); Double opl = number.pop(); number.push(func(opl, opr, s)); &#125; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; return number.pop(); &#125; private static Double func(Double opl, Double opr, String op) &#123; if (Operator.PLUS.symbol.equals(op)) &#123; return opl + opr; &#125; else if (Operator.MINUS.symbol.equals(op)) &#123; return opl - opr; &#125; else if (Operator.MUl.symbol.equals(op)) &#123; return opl * opr; &#125; else if (Operator.DIV.symbol.equals(op)) &#123; return opl / opr; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125;&#125; 这里我为了简单，只处理了运算数为整形的情况，分解表达式字符串用的是正则，如下： 1234567891011121314private static boolean isNumber(String s) &#123; String numberRegex = "\\d+"; return s.matches(numberRegex);&#125; private static boolean isSymbol(String s) &#123; String regex = "[\\+\\-\\*\\/()]"; return s.matches(regex);&#125; private static boolean isOperator(String s) &#123; String regex = "[\\+\\-\\*\\/]"; return s.matches(regex);&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[本来按照顺序是应该先写 VLayout，再写 Tangram，最后才是 Virtualview。这是一个循序渐进的过程。由于我本身对 VLayout 有了一定的了解，所以我就直接看了 Tangram，发现源码阅读起来不算太难，就是写代码的风格看着有点蛋疼（我们装了阿里的 Java 规约插件，然后发现源码里全是警告线，这特么自己开发的内部都不用的吗）。当我根据文档一点一点的阅读完源码之后，本来以为就要结束的时候，才发现里面说的“虚拟控件”才是比较值得咀嚼的。 于是我又花了3天左右来啃这个东西，其中的艰辛…，唉，我太难了。 根据官方文档，对照源码，阅读完里面的核心内容之后，发现虚拟控件并没有那么的神奇，而且它有一些不足。 本系列就是将我在阅读的过程中，理解的，记录的，思考的东西整理出来。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-组件的创建]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0004-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前面我们说了，想要加载一个模板文件，需要调用如下代码：1sViewManager.loadBinBufferSync(TEST.BIN);那么，模板加载进来了之后，该怎么使用呢？用法还算是简单，如下：1234567891011121314151617protected void preview(String templateName, com.alibaba.fastjson.JSONObject jsonData) &#123; mContainer = sVafContext.getContainerService().getContainer(templateName, true); IContainer iContainer = (IContainer) mContainer; if (jsonData != null) &#123; iContainer.getVirtualView().setVData(jsonData); &#125; Layout.Params p = iContainer.getVirtualView().getComLayoutParams(); LinearLayout.LayoutParams marginLayoutParams = new LinearLayout.LayoutParams(p.mLayoutWidth, p.mLayoutHeight); marginLayoutParams.leftMargin = p.mLayoutMarginLeft; marginLayoutParams.topMargin = p.mLayoutMarginTop; marginLayoutParams.rightMargin = p.mLayoutMarginRight; marginLayoutParams.bottomMargin = p.mLayoutMarginBottom; mLinearLayout.removeAllViews(); mLinearLayout.addView(mContainer, marginLayoutParams);&#125; templateName 就是我们模板的名字，不是模板文件的名字，是模板的名字，以我们的例子来说，就是“TEST”。 jsonData 就是模板需要展示的数据，一个例子如下： 123456&#123; "style": &#123; "text-style" : "bold|italic" &#125;, "height": 200&#125; 这里的 style 可以看作是一个对象，它里面有一个 text-style 属性，我们可以这样使用它： 1textStyle="$&#123;style.text-style&#125;" 我们的例子中没有用到 style 这个东西。 ContainerService参数介绍完之后，我们来看看里面的逻辑： 1mContainer = sVafContext.getContainerService().getContainer(templateName, true); 这行代码就是核心内容了，里面就有实例化模板文件中的 view 的所有逻辑。我们点进去看一下： com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, boolean) 1234567public View getContainer(String viewType, boolean createParam) &#123; int type = mComContainerTypeMap.getContainerMap(viewType); if (type &lt;= -1) &#123; type = CONTAINER_TYPE_NORMAL; &#125; return getContainer(viewType, type, createParam);&#125; 因为 Tangram 是支持自定义组件与组件容器的，所以如果你有自定义的组件容器的话，需要注册进去，注册的时候需要传递一个 type 值。由于我们没有自定义的 type 所以这里会返回 -1（也就是说对于自带的容器都是返回 -1），所以我们的 type 值会默认是 CONTAINER_TYPE_NORMAL。 com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, int, boolean) 1234567891011121314151617181920212223242526272829303132333435363738394041public View getContainer(String viewType, int containerType, boolean createParam) &#123; IContainer container = null; // 实例化组件是这行代码做的 ViewBase vb = mVM.getView(viewType); if (null == vb) &#123; vb = mVM.getDefaultImage(); vb.setViewType(viewType); &#125; // 如果模板的根布局是 container，不用做什么额外的操作 // 如果模板的根布局不是 container，需要添加一层 container 在外面，container 为 com.tmall.wireless.vaf.virtualview.container.Container 对象 if (vb.isContainer()) &#123; container = (IContainer) vb.getNativeView(); &#125; else &#123; ContainerMrg cm = mContainerMrg.get(containerType); if (null != cm) &#123; container = cm.getContainer(mAppContext); &#125; else &#123; Log.e(TAG, "getContainer type invalidate:" + containerType); &#125; &#125; // 有了容器之后，设置 layoutParams 就完事了 if (null != container) &#123; container.setVirtualView(vb); if (createParam) &#123; Layout.Params p = vb.getComLayoutParams(); MarginLayoutParams marginLayoutParams = new MarginLayoutParams(p.mLayoutWidth, p.mLayoutHeight); marginLayoutParams.leftMargin = p.mLayoutMarginLeft; marginLayoutParams.topMargin = p.mLayoutMarginTop; marginLayoutParams.rightMargin = p.mLayoutMarginRight; marginLayoutParams.bottomMargin = p.mLayoutMarginBottom; ((View)container).setLayoutParams(marginLayoutParams); &#125; // 这里就是将 layout 里面的控件都拿出来，add到容器里里面 container.attachViews(); &#125; return (View)container;&#125; 文档里面说过，因为虚拟控件只是绘制在 canvas 上，所以它依托一个原生容器控件作为宿主容器，必须要有容器才会显示。 我们例子中用的 VHLayout，看起来像一个容器，但是它不是，它里面有自己的测量，布局，绘制逻辑，但是它不是 ViewGroup，也不是 View。它也需要依托在一个容器里面，因为容器是继承了 ViewGroup 的，所以容器才能显示出来。 比如：VHLayout里面竖向排列了3个 NText，我们只拿布局逻辑来说。竖向排列的逻辑放在了 VHLayout 里面，但是容器会将 3个 NText 都拿出来，add 到自己的布局里面，那么这个时候，容器在布局的时候，就需要调用 VHLayout 里面的布局逻辑，来排列 3 个 NText。 这里先有个大致的了解，后面会单独讲解虚拟控件到底是个什么东西。 ViewManager回到代码逻辑，我们深入下去： com.tmall.wireless.vaf.framework.ViewManager#getView 12345678910111213141516171819public ViewBase getView(String type) &#123; ViewBase v; List&lt;ViewBase&gt; vList = mViewCache.get(type); if (null == vList || 0 == vList.size()) &#123; v = mViewFactory.newView(type, mUuidContainers); if (null != v) &#123; if (v.supportDynamic()) &#123; mAppContext.getNativeObjectManager().addView(v); &#125; v.setViewType(type); &#125; else &#123; Log.e(TAG, "new view failed type:" + type); &#125; &#125; else &#123; v = vList.remove(0); &#125; return v;&#125; 这个方法就很简单了，只有第5行是核心代码，就是调用了 ViewFactory 的方法。其他的逻辑都是与缓存相关，因为最终都是基于RecyclerView的，有兴趣的可以自己研究。 ViewFactory com.tmall.wireless.vaf.virtualview.ViewFactory#newView(java.lang.String, android.util.SparseArray&lt;com.tmall.wireless.vaf.virtualview.core.ViewBase&gt;) 这个方法很长，我们一段一段的分析： 12345678910111213public ViewBase newView(String type, SparseArray&lt;ViewBase&gt; uuidContainers) &#123; ViewBase ret = null; if (null != mLoader) &#123; CodeReader cr = null; synchronized (LOCK) &#123; cr = mUiCodeLoader.getCode(type); if (cr == null) &#123; Log.d(TAG, "load " + type + " start when createView "); mTmplWorker.executeTask(type); cr = mUiCodeLoader.getCode(type); &#125; &#125; mUiCodeLoader 是老朋友了，我们可以根据 type 获取到对应的 CodeReader，CodeReader 里面储存的是模板的二进制数据。 mTmplWorker 是用来做异步加载处理的，因为有可能我们启动了异步加载，在实例化模板的时候，模板文件还没有读取完成，所以这里就需要先去加载模板文件。 1234567if (null != cr) &#123; mComArr.clear(); ViewBase curView = null; int tag = cr.readByte(); int state = STATE_continue; ViewCache viewCache = new ViewCache(); mComArr 是一个栈，是用来帮助读取模板的结构的，因为栈的特性很适合处理嵌套的控件层次。 tag 有两个字，一个是表示开始，一个表示结束，其实就是组件的开始与结束标识符，对应着xml 里面的 “&lt;” 与 “/&gt;”。这个没有实际证据，我猜的。 state 是用来表示是否需要跳出循环的，下面是一个死循环： 123456789101112131415161718192021222324252627282930313233while (true) &#123; switch (tag) &#123; case Common.CODE_START_TAG: short comID = cr.readShort(); // 这里就是实例化 viewBase 了，暂时不深入 ViewBase view = createView(mAppContext, comID, viewCache); if (null != view) &#123; Layout.Params p; if (null != curView) &#123; p = ((Layout) curView).generateParams(); mComArr.push(curView); &#125; else &#123; p = new Layout.Params(); &#125; view.setComLayoutParams(p); curView = view; ... case Common.CODE_END_TAG: if (mComArr.size() &gt; 0) &#123; ViewBase c = mComArr.pop(); if (c instanceof Layout) &#123; ((Layout) c).addView(curView); &#125; else &#123; state = STATE_failed; Log.e(TAG, "com can not contain subcomponent"); &#125; curView = c; &#125; else &#123; // can break; state = STATE_successful; &#125; break; 主要说一下 mComArr 的作用： 第一次遇到起始标志，将该 view 赋值给 curView。 再遇到起始标志的时候，就说明遇到了 view 嵌套的情况，这个时候将 curView 放入栈内。 遇到结束标识的时候，将栈顶元素取出来，add 到 curView 中。 这样就搞定了 view 树的解析，还是比较容易理解的，实在绕不清楚的可以回去看看四则运算的中缀转后缀。 接下来，我们看看上面代码中省略的部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 // int byte attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setValue(key, value); --attrCount; &#125; // int RP attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setRPValue(key, value); --attrCount; &#125; // float attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); float value = Float.intBitsToFloat(cr.readInt()); view.setValue(key, value); --attrCount; &#125; // float RP attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); float value = Float.intBitsToFloat(cr.readInt()); view.setRPValue(key, value); --attrCount; &#125; // string code attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setStrValue(key, value); --attrCount; &#125; // expr code attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setValue(key, mExprCodeLoader.get(value)); --attrCount; &#125; // user var attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int varType = cr.readByte(); int nameId = cr.readInt(); int value = cr.readInt(); view.addUserVar(varType, nameId, value); --attrCount; &#125; int uuid = view.getUuid(); if (uuid &gt; 0 &amp;&amp; null != uuidContainers) &#123; uuidContainers.put(uuid, view); &#125; List&lt;Item&gt; pendingItems = viewCache.getCacheItem(view); if (pendingItems == null || pendingItems.isEmpty()) &#123; view.onParseValueFinished(); &#125;&#125; else &#123; state = STATE_failed; Log.e(TAG, "can not find view id:" + comID);&#125;break; 这里的大部分代码都是在读取二进制文件中储存的属性键值对。 属性的 key 是一个 int 值，在 com.libra.virtualview.common.StringBase 中。 属性的 value 分为好几类： int int RP float flot RP string expr user var int 是整数，int RP 是什么呢？RP 表示的是百分比。不是说我们要写 20%w 这样的东西，而是说，如果UI妹妹给我们的切图是 720 * 1080 的，其中有个 button 的宽度为 100px，那么我们不用换算成dp，可以直接使用 100，然后调用 com.libra.Utils#setUedScreenWidth 设置一下就好了，在创建 view 的时候，会自动帮我们按百分比换算的。 我们拿我们的 xml 来说，有一个属性键值对是 textSize=&quot;12&quot;，那么 key 就是 final public static int STR_ID_textSize = -1003668786;，value 就是 12。这些属性键值对都是在组件区的组件数里面。 ViewBase当我们解析出来了组件的属性键值对之后，就可以设置给实例化出来的 view 了。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setValue(int, int) 1234567891011final public boolean setValue(int key, int value) &#123; // set self value boolean ret = this.setAttribute(key, value); // set layout param value if (!ret &amp;&amp; null != mParams) &#123; ret = mParams.setAttribute(key, value); &#125; return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, int) 12345678protected boolean setAttribute(int key, int value) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_paddingLeft: mPaddingLeft = Utils.dp2px(value); isPaddingLeftSet = true; break; com.tmall.wireless.vaf.virtualview.core.Layout.Params#setAttribute(int, int) 1234567891011public boolean setAttribute(int key, int value) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_layoutWidth: if (value &gt; 0) &#123; mLayoutWidth = Utils.dp2px(value); &#125; else &#123; mLayoutWidth = value; &#125; break; setValue 的思路还是很清楚的，先看 ViewBase 能不能处理这个属性，不能就给 Params 处理。看里面的逻辑都是将属性值给储存起来了，随后在测量，布局，绘制的时候就会用到这些属性值。 上面是对 int 类型的处理，对 String 类型的处理有点不一样。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrValue 123456789final public boolean setStrValue(int key, int value) &#123; boolean ret = this.setStrAttribute(key, value); if (!ret &amp;&amp; null != mParams) &#123; ret = mParams.setStrAttribute(key, value); &#125; return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrAttribute 1234567protected boolean setStrAttribute(int key, int value) &#123; StringLoader sm = mContext.getStringLoader(); // 注意这里 String stringValue = sm.getString(value); boolean ret = setAttribute(key, stringValue); return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, java.lang.String) 1234567protected boolean setAttribute(int key, String stringValue) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_layoutWidth: mViewCache.put(this, StringBase.STR_ID_layoutWidth, stringValue, Item.TYPE_FLOAT); this.mParams.mLayoutWidth = LayoutCommon.WRAP_CONTENT; break; com.tmall.wireless.vaf.virtualview.core.Layout.Params#setStrAttribute 1234public boolean setStrAttribute(int key, int value) &#123; //TODO return false;&#125; ViewBase 的 setStrAttribute 方法，需要注意的是 value 并不是属性值。还记得我们前面讲 StringLoader 的时候，会给字符串生成一个唯一的 id 么？这里的 value 就是生成的id。根据这个 id， 我们可以获取到对应的字符串值。 在设置字符串属性值的时候，需要特殊处理，因为如果是按照 layoutHeight=&quot;${height}&quot;这样的使用方式，我们这个时候是拿不到对应的值的，我们只能将 “${height}”给储存起来，等到设置了 json 数据的时候，在从里面取对应的值，然后再设置属性。 具体的方式就是：将属性键值对封装成一个类。 com.tmall.wireless.vaf.virtualview.core.ViewCache.Item 123456public Item(ViewBase v, int key, String attrEL, int valueType) &#123; mView = v; mKey = key; mAttrEL = attrEL; mValueType = valueType;&#125; v 就是属性所属的 view，key 就是属性的 id，attrEl 就是属性字符串值，valueType 是属性值的类型。attrEl 可能还需要进行解析才能使用，比如将 “${height}”解析为 “height”，具体看 com.tmall.wireless.vaf.virtualview.core.ViewCache.Parser 源码。 然后，等到设置了数据之后，就可以调用 item.bind 方法，给 view 设置属性了，后面细说。 其他的属性解析都是类似的，就不说了。再回到 view 实例化的代码处，具体说一下实例化过程。 1ViewBase view = createView(mAppContext, comID, viewCache); com.tmall.wireless.vaf.virtualview.ViewFactory#createView 1234567private ViewBase createView(VafContext context, int comID, ViewCache viewCache) &#123; ViewBase.IBuilder builder = mBuilders.get(comID); if (null != builder) &#123; return builder.build(context, viewCache); &#125; return null;&#125; 实际上就是调用了 build 方法。mBuilders 集合是在构造方法里com.tmall.wireless.vaf.virtualview.ViewFactory#ViewFactory初始化的： 12345...mBuilders.put(Common.VIEW_ID_FrameLayout, new FrameLayout.Builder());mBuilders.put(Common.VIEW_ID_GridLayout, new GridLayout.Builder());mBuilders.put(Common.VIEW_ID_VHLayout, new VHLayout.Builder());... 可以看出来，每个控件都需要提供一个 Builder 类，用来实例化该控件。可以看一下 VHLayout 的 Builder 类： 123456public static class Builder implements ViewBase.IBuilder &#123; @Override public ViewBase build(VafContext context, ViewCache viewCache) &#123; return new VHLayout(context, viewCache); &#125;&#125; 这样的话，整个模板的实例化逻辑就理清楚了。 总结： 从模板里面解析出 view 树。 解析 view 树的时候，使用 builder 创建 view，然后给 view 设置对应的属性。 如果是 @{height}这样的属性值的话，不能直接给属性赋值，需要储存起来，等到设置数据的时候在设置值。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-模板编译与解析]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0003-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[PS： 为了方便记录，将编译与解析合并 官方文档的这一篇叫做“组件编译”，我看了文档，发现这里的组件的意思应该是“控件”。为了阅读的流畅性，所以这里我就改名为模板编译，其实最终还是编译的一个一个的布局控件。既然要将一个xml文件编译成二进制文件，最后还要能够解析出来，那么我们需要解决一些问题，还是拿之前的 xml 文件来说： TextTest.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 首先，VHLayout 这些控件的名字怎么储存？ 然后属性名怎么储存？ 属性值怎么储存？ 属性值分为多种，一般的颜色、数值子类的简单，可以字节作为整数存起来，但是像 text 属性，一般是一个字符串，该怎么储存呢？ 还有像 layoutWidth 这样的，可以写 200 这样的数值，也可以写 match_parent，这个又该如何处理？ 模板还支持逻辑表达式，这个表达式又该怎么储存？ 我们先来看官方文档的说明，然后一个一个来对照源码进行解析。 颜色：转换成4字节整型颜色值，格式 AARRGGBB； 枚举：按照预定义的整数转换，比如 gravity 的类型，orientation 的类型… 基础组件的类型：按照预定义的整数转换，内置基础组件的类型从 1 开始分配，自定义组件建议从 1000 开始分配，后续可能语义化成字符串类型定义，对用户隐藏这些细节； 字符串：以 hashCode 值作为它的序列化后整数，并在字符串资源区建立以 hashCode 为索引的列表，在解析的时候从中获取原始的字符串值； 逻辑表达式：与字符串的处理类似； 上面说，对于颜色值，是字节储存的，因为颜色值也是 4 个字节组成的，转成二进制都不用改的。在上面的例子种，我们设置的颜色值是 #008899，前面的“#”，我们不需要，只需要后面的“008899”，直接放入二进制文件中。为了验证猜想，我们查看二进制文件，看看有没有 00 88 99 3个直接是挨着的。 肯定是有的。 我们再来看源码，是如何解析这个值的。 加载模板文件一个模板编译好了之后，我们可以直接使用，也可以让服务器下发。这里介绍直接使用的方式。按照官方文档的实例，是在 Application 中加载的模板文件，应该也是可以在别的地方加载的。代码如下： com.aprz.virtualviewdemo.MyApp#onCreate 1sViewManager.loadBinBufferSync(TEST.BIN); 这里传入的参数，就是模板文件的二进制数据数组了。既然加载了数组，肯定需要解析出来使用，我们可以顺着这里路径点击去，最后就到了下面的代码： com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean) 这坨方法，还是非常长的，但是不难，我们一点一点分析啊。 如果你能对着模板文件结构图来看这段代码，简直不要太简单了。 1234567891011public int loadFromBuffer(byte[] buf, boolean override) &#123; int ret = -1; if (null != buf) &#123; mDepPageIds = null; if (buf.length &gt; 27) &#123; // check tag byte[] tagArray = Arrays.copyOfRange(buf, 0, Common.TAG.length()); if (Arrays.equals(Common.TAG.getBytes(), tagArray)) &#123; ... Common.TAG 就是 “ALIVV”，这个固定标识是用来验证是否是模板文件的。总不能随便给一个二进制文件，就开始解析吧。最后的 if 判断就是用来判断前 5 个字节是否为 “ALIVV”表示的字节。 12345678910CodeReader reader = new CodeReader();reader.setCode(buf);reader.seekBy(Common.TAG.length());// check versionint majorVersion = reader.readShort();int minorVersion = reader.readShort();int patchVersion = reader.readShort();reader.setPatchVersion(patchVersion); 这一段，逻辑也很清晰，跳过固定标识，依次读取 主版本号，次版本号，修订版本号。 123456789101112if ((Common.MAJOR_VERSION == majorVersion) &amp;&amp; (Common.MINOR_VERSION == minorVersion)) &#123; int uiStartPos = reader.readInt(); reader.seekBy(4); int strStartPos = reader.readInt(); reader.seekBy(4); int exprCodeStartPos = reader.readInt(); reader.seekBy(4); int extraStartPos = reader.readInt(); reader.seekBy(4); 当主版本号为1，并且次版本号为0的时候，才会走里面的逻辑。这里就可以看出来，主版本号与次版本号不是我们可以更改的，应该是编译的时候生成的固定值。我们只能设置修订版本号。 123456789int pageId = reader.readShort();int depPageCount = reader.readShort();if (depPageCount &gt; 0) &#123; mDepPageIds = new int[depPageCount]; for (int i = 0; i &lt; depPageCount; ++i) &#123; mDepPageIds[i] = reader.readShort(); &#125;&#125; 这里是记录该模板的依赖，没搞懂，而且源码里面标记为过时了，查看源码也没有用到的地方，就当做没有这几行代码吧。 12345678if (reader.seek(uiStartPos)) &#123; // parse ui codes boolean result = false; if (!override) &#123; result = mUiCodeLoader.loadFromBuffer(reader, pageId, patchVersion); &#125; else &#123; result = mUiCodeLoader.forceLoadFromBuffer(reader, pageId, patchVersion); &#125; 定位到组件区的起始位置（不明白的回去查看模板文件二进制格式图）。然后就可以开始读取组件（控件）信息了。UiCodeLoader 里面的逻辑咱们不深入了，留到下面说，这里先把外面的逻辑走完，有个大致的理解。可以猜想一下，UiCodeLoader 肯定是解析控件信息了，将解析控件的代码封装为了一个类。 123456789101112// parse stringif (reader.getPos() == strStartPos) &#123; if (null != mStringLoader) &#123; result = mStringLoader.loadFromBuffer(reader, pageId); &#125; else &#123; Log.e(TAG, "mStringManager is null"); &#125;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "string pos error:" + strStartPos + " read pos:" + reader.getPos()); &#125;&#125; 根据模板文件二进制格式图可以看出来，组件解析完了之后，就是字符串区了，这里就是解析字符串了。 1234567891011121314151617181920// parse exprif (reader.getPos() == exprCodeStartPos) &#123; if (null != mExprCodeLoader) &#123; result = mExprCodeLoader.loadFromBuffer(reader, pageId); &#125; else &#123; Log.e(TAG, "mExprCodeStore is null"); &#125;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "expr pos error:" + exprCodeStartPos + " read pos:" + reader.getPos()); &#125;&#125;// load extra dataif (reader.getPos() == extraStartPos) &#123;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "extra pos error:" + extraStartPos + " read pos:" + reader.getPos()); &#125;&#125; 解析表达式，与解析额外数据，但是这里没有对额外数据做处理，也没有提供可覆盖的方法，有点奇怪。 总结一下，com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean)这个方法就是照着模板二进制文件解析出来了里面的所有详细，为实例化出控件做准备。 UiCodeLoader前面，我们没有深入控件解析的逻辑，这里就仔细说说。上面我们分析到了： com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBuffer 123456789101112131415161718192021public boolean loadFromBuffer(CodeReader reader, int pageId, int patchVersion) &#123; boolean ret = true; int count = reader.readInt(); //count should be 1 short nameSize = reader.readShort(); String name = new String(reader.getCode(), reader.getPos(), nameSize, Charset.forName("UTF-8")); CodeReader oldCodeReader = mTypeToCodeReader.get(name); if (oldCodeReader != null) &#123; int oldPatchVersion = oldCodeReader.getPatchVersion(); if (patchVersion &lt;= oldPatchVersion) &#123; //avoid loading code repeat Log.w(TAG, "load view name " + name + " should not override from " + patchVersion + " to " + patchVersion); ret = false; return ret; &#125; &#125; ret = loadFromBufferInternally(reader, nameSize, name); return ret;&#125; 说一下，只要是 loader 里面的逻辑，基本都是在解析二进制文件，搞各种 readInt ，readShort 之类的，所以一定要对着二进制结构图看。 它先读取了一个 count，但是它没有用到这个值，额，牛逼，只是加了一句注释，count应该为1 。我们看结构图，发现这个count值表示的是组件的个数，也就是说这个组件个数应该为1 。那么应该代表的是根布局，如果我写两个会怎么样呢？比如： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt;&lt;VHLayoutflag="flag_exposure|flag_clickable"layoutHeight="match_parent"layoutWidth="match_parent"orientation="V"&gt; &lt;NText background="#002299" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text-------------------------" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 实际上，还是只显示了第一个 VHLayout，而且编译之后的二进制文件里面 count 依然是 1 。猜想是编译器只处理了第一个根节点。 继续往下分析，读取了模板的 name，就是我们在 templatelist.properties 里面设置的值。以我们的例子来说，这个 name 就是 “TEST”。 再接着就是判断补丁值，根据逻辑可以知道，修订版本值不能降低，否则就会忽略。继续深入代码调用： com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBufferInternally 1234567891011121314private boolean loadFromBufferInternally(CodeReader reader, short nameSize, String name) &#123; boolean ret = true; mTypeToCodeReader.put(name, reader); reader.seekBy(nameSize); short uiCodeSize = reader.readShort(); mTypeToPos.put(name, reader.getPos()); if (!reader.seekBy(uiCodeSize) ) &#123; ret = false; Log.e(TAG, "seekBy error:" + uiCodeSize); &#125; return ret;&#125; 将 name 与 reader 对应着储存起来，以后需要的时候可以直接获取，避免重复创建。将 name 与 pos 对应着储存起来，这个表示 reader 读取到了什么位置。这个 pos 非常的重要，这个 pos 表示的是组件区的组件数据开始的位置，组件数据里面都是储存的组件的属性值。 就没有其他的逻辑了，总结一下，UiCodeLoader 做了这些事情： 读取了每个模板的 name，为每个模板都保存了对应的 CodeReader 实例（根据 name 获取），还记录了 CodeReader 读取到了哪个位置。 StringLoader上面处理完了组件区，接着就该字符串区了。看如下代码： com.tmall.wireless.vaf.virtualview.loader.StringLoader#loadFromBuffer 12345678910111213141516171819202122232425262728293031public boolean loadFromBuffer(CodeReader reader, int pageId) &#123; boolean ret = true; // pageId 是页面编码 mCurPage = pageId; int totalSize = reader.getMaxSize(); // 字符串的个数 int count = reader.readInt(); for (int i = 0; i &lt; count; ++i) &#123; // 字符串索引 int id = reader.readInt(); // 字符串长度 int len = reader.readShort(); int pos = reader.getPos(); if (pos + len &lt;= totalSize) &#123; // 解析出字符串 String str = new String(reader.getCode(), reader.getPos(), len); // 与id对应储存起来，可以根据id拿到string，也可以根据string拿到id mIndex2String.put(id, str); mString2Index.put(str, id); reader.seekBy(len); &#125; else &#123; Log.e(TAG, "read string over"); ret = false; break; &#125; &#125; return ret;&#125; 上面的代码里面，其逻辑注释说的很详细了。 需要注意的是，id 表示字符串的唯一标识，这个唯一标识，很重要，应该是编译的时候自动生成的一个数，先记住这个唯一标识。 上面我们说过，像 title=“Hello”这样的属性值，“Hello”就是作为字符串储存的，所以这里就可以将“Hello”给提取出来，id 就是 3556653。 总结一下： StringLoader 就是将字符串区的字符串读取出来了，然后储存了id与string。 ExprCodeLoader这个 loader，我还没深入的去看，暂时就不说了。 说一个我发现的东西，例子中，我们使用了数据绑定： 1layoutHeight="$&#123;height&#125;" 这个 “${height}” 是储存在字符串区的。 说了这么多 loader，其实最核心的东西还没有涉及到，不是不愿意讲，而是这部分代码的逻辑在实例化控件的位置，我们下篇再讲。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-数据模板]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0002-%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这一段本来应该是介绍 Tangram 才说的，但是为了说明模板的作用，这里还是需要简要的说明一下 Tangram 是做什么的。首先，作为一个商城类应用，其首页的变动是非常频繁的，特别是在一些特殊的节日。按照一般的开发逻辑，在节日之前肯定是要发新版的，而且节日过了之后，又需要将界面改回来。如果一直发新版本的话，就效率太低了，更新频繁的话也很容易找骂。 一种解决方案就是使用 H5，但是性能会有问题。下面的片段来源于文档： 最初我们看重动态性，在HTML框架和发布工具上做了大量的文章。我们可以快速开发出一张HTML页面，并推送到端上，而且通过Hybrid接口还能与Native进行交互。然而在大规模（双11）应用的过程中我们很快发现了问题——性能。当时我们认为WebView的性能是HTML页面的瓶颈，现在还不是大规模推广HTML的时候，我们需要一套替代方案。 H5 暂时不可行，那么还是只能在原生页面上想办法了（下面的内容，还是来源于文档，建议去看官方文档）。 从业务的角度来说，带界面的业务基本分三种： 临时性业务——比如活动，几张页面生命周期可能2周，1周，甚至一两天。数量多，需求频繁，有可沉淀的东西，但变化更多。对极致性能不敏感。 常规业务——比如频道，生命周期长，需要长期维护。数量有限，需求稳定，沉淀性好。对极致性能相当敏感。 基础业务——跟常规业务相比需求稳定性更高，对性能和稳定性有极高的要求。 对于第1型，我们认为未来一定属于HTML，随着WebView性能的提升和Mobile开发框架与开发技能日趋成熟，现阶段HTML体现出的劣势终将荡然无存。 而第2型和第3型是值得我们去思考的，结合我们团队所负责的业务形态，我们结合多年在业务上的经验制定了以粗粒度组件化+灵活布局容器为基本理念的界面解决方案。 以 Tangram View 作为根节点，具备滚动能力；页面的子节点为布局容器，每行一个容器，向下单行排列；布局容器中按照各自的布局规则，在其内对任意组件进行排列。 这里说的比较抽象，我举一个例子： 我们写一个 MainActivity，其布局长这样： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/container" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 可以看出，这里布局里面其实什么都没有，那么这个时候，我想要让界面显示出东西出来，怎么办呢？有两种方法： 动态的创建控件 动态的加载布局 动态的创建控件显然难度太高了，特别是复杂的布局，很是蛋疼。动态的加载布局，是可以的，但是解析 XML 太慢了，可以优化一下不？这里参照了 Google 的思路，Android Studio 在打包 APK 的时候，会将 XML 文件编译为二进制文件，它不仅仅减小了体积，而且在解析文件的时候，会更加快速。 这样思考的话，一个可以动态更改布局的方法就有了雏形：将布局文件编译为二进制文件，上传到服务器，客户端下载，界面启动的时候，动态加载最新版本的布局。 理解了上面的话，我们再来看看 Tangram 的模板是什么东西。 模板是什么模板其实就是上面说说的二进制布局文件，不过这个二进制文件不是 Android Studio 编译 xml 文件之后生成的，而是 alibaba 有自己的一套工具，用来生成二进制文件。 这个二进制文件有自己的格式，具体可以参考官方文档，这里只贴一个图，后面的源码部分会经常用到这个图： 创建模板文件我们刚开始接触 Android 的时候，也需要学习如何编写一个界面，需要熟悉每个控件是做什么的。对于 Tangram 也是如此，它有一套自己的控件（虽然也是使用的原生控件实现的），所以我们也需要先熟悉一下这些控件，控件的介绍在： http://tangram.pingguohe.net/docs/virtualview/atom-elements http://tangram.pingguohe.net/docs/virtualview/container-elements 这里举一个简单的例子： TextTest.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 可以看出来，与 Android XML 布局的差别不大，还很简洁。其中使用到的属性的意思也很明了，有不清楚的可以参考文档： http://tangram.pingguohe.net/docs/virtualview/elements 模板编译工具的使用模板写好了之后，我们就可以编译该模板文件为二进制文件了。 首先需要下载编译工具，工具下载地址在：https://github.com/alibaba/virtualview_tools 使用 git clone 下来之后： 切到 virtualview_tools\compiler-tools\TemplateWorkSpace 目录下 在 template 目录下，创建 TextTest.xml 模板文件 打开 templatelist.properties，增加一行 TextTest=Test,1 说一下格式 123456789格式 xmlFileName=outFileName,Version[,platform]xmlFileName 标识 template 目录下需要编译的 xml 文件名建议不带 .xml 后缀，目前做了兼容outFileName 输出到 build 目录下的 .out 文件名，这个 outFileName 会编译到二进制文件中，需要是唯一的，可以理解为模板的 IDVersion 表示 xml 编译后的版本号，看上面的模板文件结构图，模板文件可以有主版本号，次版本号，修订版本号，经过测试这个版本号表示 的是修订版本号，从源码上来看主版本号与次版本号似乎是固定的platform 同时兼容 iOS 和 android 时不写，可填的值为 android 和iphone 打开 git bash，执行 sh buildTemplate.sh 命令 就会在 build 目录下生成相应的文件了 项目地址里面有中文文档，虽然不是非常的详细，但是也大致看的懂。 编译工具还提供了实时预览的效果，由于我只是想看源码，所以并没有尝试这个效果，有兴趣的可以自己试试实时预览，写复杂的布局肯定需要用到。 查看说明文档，还会发现，编译器支持增加自定义属性，我没试过就不说了，但是我大致知道它是如何工作的，我们后面会说源码，所以如果你都能看懂，这个自定义属性也就自然懂了 。 执行完 buildTemplate 命令之后，我们进入 build 目录，里面有几个目录需要关注： out目录：XML 模板编译成二进制数据的文件，其他内容都是以此为基础生成，上传到 cdn，通过模板管理后台下发的也是这里的文件； java目录：XML 模板编译成二进制数据之后的 Java 字节数组形式，可以直接拷贝到 Android 开发工程里使用，作为打底数据； sign目录：out 格式文件的 md5 码，供模板管理平台下发模板给客户端校验使用； txt目录：XML 模板编译成二进制数据之后的十六进制字符串形式，转换成二进制数据就是 java 目录下的字节数组 我们打开 build\java 目录，找到生成的 TEST.java 文件，打开后如下： 12345public class TEST&#123;public static final byte[] BIN = new byte[] &#123;65, 76, 73, 86, 86, 0, 1, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 122, 0, 0, 0, -87, 0, 0, 0, 32, 0, 0, 0, -51, 0, 0, 0, 0, 0, 0, 0, -47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 4, 84, 101, 115, 116, 0, 110, 0, 0, 2, 4, -86, 50, -11, -48, 0, 0, 0, 0, 0, 47, -1, 108, 0, 0, 0, 48, 92, -43, -16, -15, -1, -1, -1, -1, 119, 112, -84, -68, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, -60, 45, 58, -50, 0, 0, 0, 12, 0, 47, -1, 108, 0, 0, 0, 48, -80, -104, 85, 46, -1, 0, -120, -103, 119, 112, -84, -68, -1, -1, -1, -1, -64, -101, 46, 54, -1, 51, 51, 51, 0, 0, 0, 2, 92, -43, -16, -15, -14, -87, -65, 127, 0, 54, 69, 45, 82, -14, -15, -117, 0, 0, 1, 1, 0, 0, 0, 2, 82, -14, -15, -117, 0, 11, 84, 105, 116, 108, 101, 58, 32, 116, 101, 120, 116, -14, -87, -65, 127, 0, 9, 36, 123, 104, 101, 105, 103, 104, 116, 125, 0, 0, 0, 0, &#125;;&#125; 里面就只有一个 byte 数组，里面个每个数都表示一个字节。 我们再打开 build\out 目录，找到生成的 TEST.out 文件，用十六进制编辑器查看，如下： 看前面5个字节，表示的就是 ALIVV，这个就是模板文件结构表的固定开头。将图中的十六进制换成数字，就是与 TEST.java 文件中的字节数组是一一对应的。 看了这些东西，总结出一句话，那就是这个二进制数组就表示的是一个布局，所以这个文件叫做模板文件。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0021-栈的定义]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0021-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在我们的软件应用中，栈的应用是非常普通的。 拿一个文本编辑器来举例，我们经常使用 Ctrl + Z 的快捷键来回退到上一步，这个动作就用到了栈。 栈是一种只能够在一端进行插入与删除的数据结构，如下图： 栈的插入操作叫做入栈，删除操作叫做出栈。 我们玩的游戏《汉诺塔》，就是一种典型的入栈出栈操作。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0022-进栈出栈变化形式]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0022-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考一个问题：有 [1, 2, 3, 4, … ，n] 一共 n 个整数，他们按顺序入栈，问一共有多少种出栈顺序（提示：1 入栈之后可以立即出栈）？首先，我们设f(n)代表序列个数为n的出栈序列种数。同时，我们假定第一个出栈的序数是k。第一个出栈的序数k将1~ n的序列分成两个序列： 其中一个是1~ k-1，序列个数为k-1； 另外一个是k+1~n，序列个数是n-k。 那么对于一个给定的值 k 来说，f(k) 就表示前 k 个数的出栈顺序，f(n-k) 就表示后 n-k 个数的出栈顺序。 f(n)的问题就等价于序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的出栈组合为f(k-1)×f(n-k)，又因为第一个出栈的数可以是 1 ~ n 中的任意一个数，所以 k 可以取值 1 ~ n。 所以：f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0) 12f(0) = 1;f(1) = 1; 如果，我们知道卡特兰数，那么这个公式可以转换为 $C^n_{2n}-C^{n+1}_{2n}$ 。 可以看出最后转换成了排列组合公式，那么下面我们从排列组合的角度来思考一下这个问题。 我们先不管数的顺序是怎么样的，对于每一个数来说，总是要先入栈一次，然后再出栈一次。这里就假设入栈记为1，出栈记为0，那么就会产生一个 2n 个数的序列。这个序列由 n 个 1 与 n 个 0 组成。 使用排列组合的思想，在 2n 个位置里面选 n 个位置放入 1，其余的位置放入 0，一共有 $C^n_{2n}$ 种可能。 然后再思考一下，按照上面的排列方式，有一些序列是不符合要求的，比如 0001... 这种序列，因为 0 表示出栈，前面都没有入栈，哪里来的出栈呢？ 所以我们需要找出在某个位置上，它前面的0的个数大于1的个数的所有序列。 我们假设在某个位置上（只能是奇数位置，不可能是偶数位置），0的个数刚好比1的个数多一个，设这个位置为 2m+1。 那么，这个位置前就有 m+1 个 0 和 m 个 1。后面有 n-m-1 个 0， n -m 个 1。 这里我们要做一个骚操作： 将 2m+1 位置后面的 0 与 1 互换，则该位置后面就变成了 n-m-1 个 1， n -m 个 0。所以整个序列变成了由 n+1 个 0， n-1 个 1 组成的序列。 我们将所有不符合要求的集合记作 B。 将由 n+1 个 0， n-1 个 1 组成的序列集合记作 A，A 的个数为 $C^{n+1}_{2n}%$。 B 集合中的每一个元素都对应着 A 中的一个元素。 则 A 集合包含 B 集合。 再反过来思考，任何一个由 n+1 个 0 和 n-1 个 1 组成的 2n 个数的序列，由于 0 的个数比 1 的个数多 2 个，2n为偶数，故必在某一个奇数位上 0 的个数刚好比 1 的个数多一个。同样在后面部分0和1互换，就成为了由 n 个 0 和 n 个 1 组成的 2n 个数的序列，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。 同样的，转换为集合来思考，即集合 B 包含集合 A。 最终，我们得到，集合A = 集合B。 所以，不符合要求的集合数为 $C^{n+1}_{2n}$。 最后得到 $C^n_{2n}-C^{n+1}_{2n}$ 。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0023-栈的顺序储存结构及实现]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0023-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本篇我们使用数组来实现栈。在之前我们需要思考一个简单的问题，因为栈只能从一端进行删除，那么我们使用数组的哪一端来进行插入与删除呢？根据出栈与入栈的特性，我们知道栈底一般是不变的，显然用数组的下标为 0 的一段作为栈底比较好。接下来我们还要使用一个变量来记录栈顶元素的位置，如下图：当入栈与出栈的时候，只需要改变top的值就好了。当 top = 0 的时候，表示栈内只有一个值，所以我们规定 top = -1 的时候，栈为空。 数据结构123456789public class MyStack&lt;T&gt; &#123; private static final int SIZE = 100; private Object[] table = new Object[SIZE]; private int top = -1; &#125; 入栈将一个元素压入栈中，分为两步： 将 top 的值加一 将元素赋值给 top 指向的位置 代码如下： 123456789public int push(T value) &#123; if (isFull()) &#123; return -1; &#125; table[++top] = value; return 0;&#125; 嗯，非常的简单，没啥说的，返回值 -1 表示失败， 0 表示成功。如下图： 出栈将一个元素删除，分为三步： 返回 top 指向的元素 将 top 减一 代码如下： 12345678910@SuppressWarnings("unchecked")public T pop() &#123; if (top == -1) &#123; return null; &#125; T result = (T) table[top]; top--; return result;&#125; 这里 pop 返回了出栈的值，这里的返回值还是经常会用到的。图的话，将入栈的图反过来看就好了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0024-两个栈共享空间]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0024-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[首先需要说的是，两个栈共享空间的意思是一个数组里面有两个栈。那么什么情况下会设计出这么奇怪的数据结构呢？有时候我们需要两个栈，而且这两个栈的变化是相反的，当一个栈的元素增加的时候，另一个栈的元素就应该减少，这个时候就可以使用两个栈共享空间了。之所以要让两个栈共享空间而不是直接写两个栈，主要是在顺序储存的情况下，太浪费空间了，因为我们只能预估一个大概的最大值作为栈的储存空间。当两个栈共享空间的话，就可以节约一部分内存了。 看下面的这个设计图： 我们让两个栈的栈底分别在数组的两端，两个栈的栈顶是对着的（就像两个饮料瓶的瓶口相互对着一样，假设瓶口是栈顶）。当我们像栈内放入元素的时候，两个栈顶就会相互靠拢，直到两个栈顶挨着了，这个时候就说明，两个栈都满了。 数据结构12345678910public class MyStack2&lt;T&gt; &#123; private static final int SIZE = 100; private Object[] table = new Object[SIZE]; private int top = -1; private int top2 = SIZE; &#125; top 表示栈1 的栈顶，栈1 没有元素的时候 top = -1，top2 表示栈2 的栈顶，栈2 没有元素的时候 top = SIZE。 插入元素插入元素的时候需要指定插入哪一个栈，就没啥其他的了。 1234567891011121314public int push(T value, int which) &#123; // 栈满了 if (top + 1 == top2) &#123; return -1; &#125; if (which == 1) &#123; table[++top] = value; &#125; else &#123; table[--top2] = value; &#125; return 0;&#125; 删除元素123456789101112131415161718@SuppressWarnings("unchecked")public T pop(int which) &#123; T result; if (which == 1) &#123; if (top == -1) &#123; return null; &#125; result = (T) table[top--]; &#125; else &#123; if (top2 == SIZE) &#123; return null; &#125; result = (T) table[top2++]; &#125; return result;&#125; 插入与删除就是分为两个栈来处理，与单个栈的插入与删除是一样的。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0026-栈的应用之递归]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0026-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归是个啥就不说了，是非常基础的东西了。将两面镜子对着，你就明白啥是递归了。下面我们讲一个数列：斐波那契数列。用这个数列来讲解递归。斐波那契数列 如果兔子在出生的第二个月，就有了繁殖能力，一对兔子每个月可以生一对兔子。问一年后有多少对兔子？ 这里我们假设第 x 个月，兔子有 f(x) 对，则 第 x-1 个月，有 f(x-1) 对，第 x-2 个月，有 f(x-2) 对。这看起来像是废话，但是仔细想一想，因为兔子在出生的第2个月才有繁殖能力。所以在 x-1 个月的时候，只有 f(x-2) 对兔子才有繁殖能力，有因为每一对兔子可以生一对兔子，所以 : f(x) = f(x-1) + f(x-2) 其中，f(x-1) 表示第 x-1 个月的兔子数，f(x-2) 表示所有兔子中可以繁殖的兔子数。 所以这个数列为：1，1，2，3，5，8，13，21，34，55，89，144。即一年后有 144 对兔子。 循环实现12345678910111213141516public static int f(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; int p = 1; int c = 1; int q = 0; for (int i = 2; i &lt; n; i++) &#123; q = p + c; p = c; c = q; &#125; return q;&#125; 递归实现123456int f(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; return f(n-1) + f(n-2);&#125; 明显可以看出，递归的逻辑更加清晰。但是需要注意的是，函数的每次调用都将其变量，返回值，参数值都放入了调用栈之中，如果递归的层次太深，会报栈溢出的错误，因为栈的容量是有大小限制的，不会无穷大。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0025-栈的链式储存结构及实现]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0025-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[使用数组来实现线性表总是有很大的局限性，因为大小无法决定，如果增加扩容功能的话，赋值元素也很浪费性能，所以下面我们用链式储存来实现栈。使用链式储存结构，必然要增加一个指向下一个元素的指针，所以这里相比顺序储存增加了使用空间。思考一下，使用链式存储的时候，头指针应该指向哪里，是指向栈底还是栈顶比较好？因为我们经常需要对栈顶进行操作，所以头指针指向栈顶比较合适，不然每次操作都要从栈底遍历一下。如下图： 数据结构123456789public class Node &#123; T value; Node next;&#125;public class Stack &#123; Node head; int count;&#125; 入栈操作12345678910111213public int push(T value) &#123; if (count == SIZE) &#123; return - 1; &#125; Node node = new Node(); node.value = value; node.next = head; head = node; count++; return 0;&#125; 如下图： 出栈操作123456789101112public T pop() &#123; if (count == 0) &#123; return null; &#125; T result = head.value; Node p = head; head = head.next; free(p); count--; return result;&#125; 如下图： 如果前面的链表都理解的话，这些入栈出栈的代码还是很简单的。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0020-双向链表]]></title>
    <url>%2F2019%2F08%2F28%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0020-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表很好理解，就是既可以往后遍历也可以往前遍历。就好比你做地铁，工作人员告诉你只能从 A 到 B，无法从 B 到 A，那你肯定觉得这个人有病。单向链表与循环链表虽然都很有用，但是有各自的局限性，有局限就会有可以完善的地方，双向链表就是来补充他们的不足的。前面的例子中，我们的节点类都是这样设计的：123456public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next;&#125; 双向链表的话，就还需要加一个东西，加一个指向前面节点的指针： 1234567public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next; Node&lt;T&gt; pre;&#125; next 指针就是用来向后遍历的，pre 指针是用来向前遍历的。 头节点就应该是这样（不要搞错了头指针与头节点）： 一开始让他们都指向自己就好了。 一个有数据的双向链表长这样： 插入元素这里就不写完成的代码了，只说一下核心逻辑，其他的与单项链表差不多。 先理清思路： 找到要插入的位置，拿到该位置的前后两个节点（P, N） 用两个变量保存起来 再执行单链表的插入操作（执行两次） 1234567Node p, e;Node insert;p.next = insert;insert.next = e;e.pre = insert;insert.pre = p; 这样写就不用记顺序，如果只使用两个变量，也可以做出来，但是有点蛋疼。 如下图： 1234s.pre = p;s.next = p.next;p.next.pre = sp.next = s; 删除元素这个还是比较简单的：就是将单链表的删除操作，执行两次。 12p.pre.next = p.next;p.next.pre = p.pre; 这两个语句顺序没啥关系，因为将链表反过来，再删除的话，也是一样的。 双向链表相对于单链表来说，更加复杂一点，但是在操作某个节点的前后节点的时候会更加方便。这就是一个典型的使用空间换时间的操作。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0019-循环链表]]></title>
    <url>%2F2019%2F08%2F27%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0019-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前面我们说的链表都是单链表，因为链表中的节点只储存了指向后一个节点的指针，所以我们无法向前遍历，只能向后遍历。如果我们想要遍历前面的节点，那么该怎么做呢？原来的单链表结构是无法做到了，所以需要改进一下。第一中改进方案就是这一章需要讲的，循环链表。顾名思义，就是将链表的头和尾连起来，串成一个圆环，就是循环链表了。 同样是只能向后遍历，因为头和尾连起来了，所以最后总能遍历到前面的节点。有点不撞南墙不回头的意思。 虽然只是将头与尾连起来了，但是在使用这个数据结构的时候，还是有几个需要注意的地方。 循环链表的初始化为了与单链表保持一致，循环链表也有一个头节点，但是在初始化这个头节点的时候，需要注意一下，因为刚开始的链表是没有数据的，所以这个时候头节点需要指向自己，如下图： 当有数据的时候，循环链表如下图： 可以看出，其实这种循环链表与单链表的差别不大，只不过循环链表的遍历条件变成了：node.next != headNode。 我们想访问一个节点的时候，时间复杂度仍然为 O(n). 有些时候，我们需要访问到链表的最后一个元素，按照上面的循环链表的结构，我们需要 O(n) 的时间，那么有没有快捷一点的方法呢？ 显然是有点，比如说我们加一个尾指针，指向最后一个节点，这样就可以以 O(1) 的时间访问尾节点了。再仔细想一下，有了尾指针，头指针还需要吗？ 因为是循环链表，所以尾指针指向的就是头节点，所以可以不需要头指针了。如下图： 举一个尾指针的用处，合并两个链表，如下图： 要想将它们合并，还是很简单的，先理清思路： 将 A 链表的头尾节点引用断开（由于断开后就找不到了，所以需要保存一下头节点的引用） 将 A 链表的尾指针指向 B 链表的第一个节点 将 B 链表的尾指针指向 A 链表的第一个节点 代码如下： 1234567Node temp = rearA.next;rearA.next = rearB.next.next;// 因为 java 会自动释放节点，所以就没写// 可以加上// Node headB = rearB.next;// free(headB);rearB.next = temp; 有了尾节点之后，代码会简单很多，因为合并链表涉及到头与尾两个节点，所以使用尾节点比较方便。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0025-非阻塞算法]]></title>
    <url>%2F2019%2F08%2F26%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0025-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇文章，真的是很有意思，讲的都是概念性的东西，但是越读越有味道，最好多读几遍。 在并发上下文中，非阻塞算法是一种不阻塞访问共享状态（或以其他方式协作或通信）的线程的算法。更一般地说，如果一个线程的挂起不会导致算法中涉及的其他线程的挂起，则这个算法是非阻塞的。为了更好的理解阻塞算法和非阻塞算法之间的区别，我会先讲解阻塞算法然后再讲解非阻塞算法。 阻塞算法很多算法和并发数据结构都是阻塞的。例如，java.util.concurrent.BlockingQueue的不同实现都是阻塞数据结构。如果一个线程要往一个阻塞队列中插入一个元素，队列中没有足够的空间，执行插入操作的线程就会阻塞直到队列中有了可以存放插入元素的空间。 下图演示了一个阻塞算法是如何保证一个共享数据结构的行为的： 线程 A 执行请求的操作 线程 B 会一直阻塞直到可以安全地执行操作（线程A的操作执行完） 非阻塞算法Java也包含几个非阻塞数据结构。AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference都是非阻塞数据结构的例子。 下图演示了一个非阻塞算法保证一个共享数据结构的行为： 线程 B 执行请求的操作 线程 A 访问的时候，发现无法访问会直接返回，可以去做一些别的操作。 非阻塞算法 vs 阻塞算法阻塞算法和非阻塞算法的主要不同在于当请求操作不能够执行时阻塞算法和非阻塞算法会怎么做。 阻塞算法会阻塞线程直到请求操作可以被执行。非阻塞算法会通知请求线程操作不能够被执行，并返回。 阻塞算法的问题：如果一个线程 T1 往一个已经满了的阻塞队列里插入一个元素，这个线程就会阻塞，直到其他线程从这个阻塞队列中取走了一些元素。如果由于某些原因，从阻塞队列中取元素的线程 T2 被阻塞在了程序的某处，那么，T1 要么一直阻塞下去，要么直到 T2 从阻塞队列中取走了一个元素。 并发数据结构在一个多线程系统中，线程间通常通过一些数据结构“交流”。可以是任何的数据结构，从变量到更加高级的数据结构（队列，栈等）。为了便于多线程对数据结构的正确并发访问，必须通过某些并发算法来保护数据结构。这些并发算法让这些数据结构成为并发数据结构。 如果某个算法确保一个并发数据结构是阻塞的，它就被称为是一个阻塞算法。这个数据结构也被称为是一个阻塞，并发数据结构。 如果某个算法确保一个并发数据结构是非阻塞的，它就被称为是一个非阻塞算法。这个数据结构也被称为是一个非阻塞，并发数据结构。 单个写线程的情景在一些场景下，你仅有唯一的一个线程在向一个共享变量写，多个线程在读这个变量。当仅有一个线程在更新一个变量，不管有多少个线程在读这个变量，都不会发生竞态条件。因此，无论时候当仅有一个线程在写一个共享变量时，你可以把这个变量声明为volatile。 当多个线程在一个共享变量上执行一个 read-update-write 的顺序操作时才会发生竞态条件。如果你只有一个线程在执行一个 raed-update-write 的顺序操作，其他线程都在执行读操作，将不会发生竞态条件。 下面是一个单个写线程的例子，它没有采取同步手段但任然是多线程安全的： 123456789101112131415161718192021public class SingleWriterCounter &#123; private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions. */ public void inc() &#123; this.count++; &#125; /** * Many reading threads may call this method * @return */ public long count() &#123; return this.count; &#125;&#125; 上面的例子中，多个线程时可以访问 SingleWriterCounter 的同一个实例的，只要只有一个线程调用 inc() 方法（不是指某一时刻一个线程，而是只有一个线程）。count()方法可以被多个线程调用。这样的场景将不会发生任何竞态条件。 下图，说明了线程是如何访问count这个volatile变量的。 基于volatile变量的更高级的数据结构使用多个volatile变量去创建数据结构是可以的，构建出的数据结构中每一个volatile变量仅被一个单个的线程写，被多个线程读。每个volatile变量可能被一个不同的线程写（但仅有一个）。使用像这样的数据结构多个线程可以使用这些volatile变量以一个非阻塞的方法彼此发送信息。 下面是一个简单的例子： 123456789101112131415161718192021222324252627282930public class DoubleWriterCounter &#123; private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions. */ public void incA() &#123; this.countA++; &#125; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions. */ public void incB() &#123; this.countB++; &#125; /** * Many reading threads may call this method */ public long countA() &#123; return this.countA; &#125; /** * Many reading threads may call this method */ public long countB() &#123; return this.countB; &#125;&#125; 只有一个线程调用 incA()，也只有一个线程调用 incB()，countA()和countB()可以被多个线程调用。这个例子实际上是两个 SingleWriterCounter 合在一起了。 下图，展示了两个线程通过类似于上面的一个数据结构进行通信的： CAS 与乐观锁如果你确实需要多个线程写同一个共享变量，使用volatile变量是不合适的。你需要独占对这个变量的访问权限（排他）。下面代码演示了Java中的同步块是如何进行排他访问的： 123456789101112131415public class SynchronizedCounter &#123; long count = 0; public void inc() &#123; synchronized(this) &#123; count++; &#125; &#125; public long count() &#123; synchronized(this) &#123; return this.count; &#125; &#125;&#125; inc() 与 count() 都有一个同步块，而同步块与 wait() - notify() 却是我们想避免的。 我们可以使用原子变量来代替这两个同步块。在这个例子中是AtomicLong。下面是SynchronizedCounter类的AtomicLong实现版本。 1234567891011121314151617import java.util.concurrent.atomic.AtomicLong;public class AtomicCounter &#123; private AtomicLong count = new AtomicLong(0); public void inc() &#123; boolean updated = false; while(!updated)&#123; long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); &#125; &#125; public long count() &#123; return this.count.get(); &#125;&#125; 这个版本是上一个版本的线程安全版本。在这一版中，我们感兴趣的是inc()方法的实现。inc()方法中不再含有一个同步块。而是被下面这些代码替代： 12345boolean updated = false;while(!updated)&#123; long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1);&#125; 上面这些代码并不是一个原子操作。也就是说，可能会有两个不同的线程调用 inc() 方法。但是这里却没有包含竟态条件。 秘密就在于while循环里的第二行代码。compareAndSet()方法调用是一个原子操作。它用一个期望值和AtomicLong 内部的值去比较，如果这两个值相等，就把AtomicLong内部值替换为一个新值。compareAndSet()通常被CPU中的compare-and-swap指令直接支持。因此，不需要去同步，也不需要去挂起线程。 假设，这个AtomicLong的内部值是20。然后，两个线程去读这个值，都尝试调用compareAndSet(20, 20 + 1)。尽管compareAndSet()是一个原子操作，这个方法也会被这两个线程相继执行（某一个时刻只有一个）。 第一个线程会使用期望值20（这个计数器的上一个值）与AtomicLong的内部值进行比较。由于两个值是相等的，AtomicLong会更新它的内部值至21（20 + 1 ）。变量updated被修改为true，while循环结束。 现在，第二个线程调用compareAndSet(20, 20 + 1)。由于AtomicLong的内部值不再是20，这个调用将不会成功。AtomicLong的值不会再被修改为21。变量，updated被修改为false，线程将会再次在while循环外自旋。这段时间，它会读到值21并企图把值更新为22。如果在此期间没有其它线程调用inc()。第二次迭代将会成功更新AtomicLong的内部值到22。 上一部分展现的代码被称为乐观锁（optimistic locking）。乐观锁区别于传统的锁（有时也被称为悲观锁）。传统的锁会使用同步块或其他类型的锁阻塞对临界区域的访问。一个同步块或锁可能会导致线程挂起。 乐观锁允许所有的线程在不发生阻塞的情况下创建一份共享内存的拷贝。这些线程接下来可能会对它们的拷贝进行修改，并企图把它们修改后的版本写回到共享内存中。如果没有其它线程对共享内存做任何修改， CAS操作就允许线程将它的变化写回到共享内存中去。如果，另一个线程已经修改了共享内存，这个线程将不得不再次获得一个新的拷贝，在新的拷贝上做出修改，并尝试再次把它们写回到共享内存中去。 称之为“乐观锁”的原因就是：线程会乐观的认为，其他线程在此期间（线程获得了他们想要更改的数据的副本并应用他们的更改）不会对共享内存进行更改。当这个乐观假设成立时，这个线程仅仅在无锁的情况下完成共享内存的更新。当这个假设不成立时，线程所做的工作就会被丢弃，但仍然不使用锁。 乐观锁适用于共享内存竞用不是非常高的情况。如果共享内存上的内容非常多，仅仅因为更新共享内存失败，就用浪费大量的CPU周期用在拷贝和修改上。 不可替换的数据结构一般的，在数据结构不是很复杂的情况下，我们可以使用 CAS 来更新一个数据结构：将数据拷贝一份，做出修改，然后将旧的替换为新的引用。 然而，一个大的数据结构可能会需要大量的内存和CPU周期来复制。这会使你的程序占用大量的内存和浪费大量的时间在拷贝操作上，导致你的程序的性能降低，特别是在这个数据结构的竞争非常高情况下。 一个线程花费在拷贝和修改这个数据结构上的时间越长，其它线程在此期间修改这个数据结构的可能性就越大。如果一个线程修改了这个数据结构，其它所有的线程都不等不再次执行 拷贝-修改 操作。这将会增大性能影响和内存浪费。 接下来的部分将会讲解一种实现非阻塞数据结构的方法，这种数据结构可以被并发修改，而不仅仅是拷贝和修改。 共同修改我们可以不用每次复制原来的数据结构，而是让多个线程同时修改这个数据结构。这里的多线程同时修改并不是真正意义上的同时修改，而是说某一个线程提交自己的修改时，别的线程依然无法访问，但是如果该线程在提交自己的修改之后阻塞了，别的线程可以继续完成该线程提交的修改操作。 大致的过程如下： 检查另一个线程是否已经对这个数据结构提交了修改 如果没有其他线程提交了修改，创建一个修改对象，然后向这个数据结构提交这次修改 执行对共享数据结构的修改 移除对这个修改的引用，向其它线程发送信号，告诉它们这个修改已经被执行 第二步可以阻塞其他线程提交一个修改。因此，第二步实际的工作是作为这个数据结构的一个锁。如果一个线程已经成功提交了一个修改，其他线程就不可以再提交一个修改直到第一个修改执行完毕。 如果一个线程提交了一个修改，然后做一些其它的工作时发生阻塞，这时候，这个共享数据结构实际上是被锁住的。其它线程检测到它们不能够提交修改，这个时候我们就休要做一些特殊的操作（为了避免一个已经提交的修改锁住共享数据结构，这个修改对象必须包含足够的信息让其他线程来完成这次修改），我们让别的线程来帮助完成这次修改。 下面是一个蓝图： 可以看到，上面的图中有两次检查。 第一次检查，是某个线程 T1 想要对数据结构提交一个修改，发现已经有别的线程 T0 提交过修改了，但是 T0 却没有完成自己提交的修改，所以 T1 需要先帮 T0 完成它提交的修改，然后再复制数据结构，创建自己的修改。 等到 T1 创建完自己的修改之后，由于不可抗力，T1 也阻塞了，这个时候 T2 又来了，所以 T2 也需要再次完成未完成的修改。这里就是第二次检查的作用了。 一个非阻塞算法的模板在非阻塞算法方面，我（博客原作者 Jakob Jenkov ）并不是一位专家，所以，下面的模板可能错误。不要基于我提供的模板实现自己的非阻塞算法。这个模板意在告诉你一个关于非阻塞算法大致是什么样子的。如果，你想实现自己的非阻塞算法，首先学习一些实际的工业水平的非阻塞算法，然后在实践中学习更多关于非阻塞算法实现的知识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicStampedReference;public class NonblockingTemplate &#123; public static class IntendedModification &#123; public AtomicBoolean completed = new AtomicBoolean(false); &#125; private AtomicStampedReference&lt;IntendedModification&gt; ongoingMod = new AtomicStampedReference&lt;IntendedModification&gt;(null, 0); //declare the state of the data structure here. public void modify() &#123; while(!attemptModifyASR()); &#125; public boolean attemptModifyASR()&#123; boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null)&#123; //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted)&#123; //complete modification via a series of compare-and-swap operations. //note: other threads may assist in completing the compare-and-swap // operations, so some CAS may fail modified = true; &#125; &#125; else &#123; //attempt to complete ongoing modification, so the data structure is freed up //to allow access from this thread. modified = false; &#125; return modified; &#125;&#125; 说实话，这里有个地方我有点疑问（上面代码中的 45-50行）： 123456&#125; else &#123; //attempt to complete ongoing modification, so the data structure is freed up //to allow access from this thread. modified = false;&#125; 这里别的线程帮助完成提交的修改的时，应该怎么做才能不导致阻塞？ 如果使用 CAS，那岂不是还是要走 copy 数据结构的套路？那就还是回到了原来的问题啊，copy 复杂的数据结构可能会导致更激烈的竞争。 或者将两个修改合并？？但是虽然这样不会 copy 数据，但是合并的操作怎么保证不阻塞？合并的时候完全使用 CAS 操作，这样就只 copy 了提交对象。 非阻塞算法是不容易实现的正确的设计和实现非阻塞算法是不容易的。在尝试设计你的非阻塞算法之前，看一看是否已经有人设计了一种非阻塞算法正满足你的需求。 Java已经提供了一些非阻塞实现（比如 ConcurrentLinkedQueue），相信在Java未来的版本中会带来更多的非阻塞算法的实现。 除了Java内置非阻塞数据结构还有很多开源的非阻塞数据结构可以使用。 选择非阻塞算法的第一个好处是，给了线程一个选择，当它们请求的动作不能够被执行时做些什么。不再是被阻塞在那。在这种情况下，它可以选择阻塞或自我等待，像这样把CPU的使用权让给其它的任务。 没有死锁非阻塞算法的第二个好处是，一个线程的挂起不会导致其它线程挂起。这也意味着不会发生死锁。非阻塞算法任然可能产生活锁（live lock），两个线程一直请求一些动作，但一直被告知不能够被执行（由于相互影响）。 没有线程挂起挂起和恢复一个线程的代价是昂贵的。 无论什么时候，一个线程阻塞，就会被挂起。由于使用非阻塞算法线程不会被挂起，这种过载就不会发生。这就意味着CPU有可能花更多时间在执行实际的业务逻辑上而不是上下文切换。 降低线程延迟在这里我们提到的延迟指的是一个请求产生到线程实际的执行它之间的时间。因为在非阻塞算法中线程不会被挂起，它们就没有线程切换成本。这就意味着当一个请求执行时可以得到更快的响应，减少它们的响应延迟。 非阻塞算法通常忙等待直到请求动作可以被执行来降低延迟。当然，在一个非阻塞数据数据结构有着很高的线程争用的系统中，CPU可能在它们忙等待期间消耗大量的CPU周期。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0021-阻塞队列]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0021-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[阻塞队列与普通队列的区别在于：当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来（如从队列中移除一个或者多个元素，或者完全清空队列）。 下图展示了如何通过阻塞队列来合作： 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素 从5.0开始，JDK在java.util.concurrent包里提供了阻塞队列的官方实现。尽管JDK中已经包含了阻塞队列的官方实现，但是熟悉其背后的原理还是很有帮助的。 阻塞队列的简单实现阻塞队列的实现类似于带上限的Semaphore的实现。下面是阻塞队列的一个简单实现： 12345678910111213141516171819202122232425262728293031323334public class BlockingQueue &#123; private List queue = new LinkedList(); private int limit = 10; public BlockingQueue(int limit)&#123; this.limit = limit; &#125; public synchronized void enqueue(Object item) throws InterruptedException &#123; while(this.queue.size() == this.limit) &#123; wait(); &#125; if(this.queue.size() == 0) &#123; notifyAll(); &#125; this.queue.add(item); &#125; public synchronized Object dequeue() throws InterruptedException&#123; while(this.queue.size() == 0)&#123; wait(); &#125; if(this.queue.size() == this.limit)&#123; notifyAll(); &#125; return this.queue.remove(0); &#125;&#125; 可以看到这个例子与上一篇的带上界的信号量很像，不过就是多了一步操作（往 list 里面添加或删除元素）。 每当 list 满的时候，enqueue 线程就会进入 wait 方法，然后阻塞。当 list 从满变为非满的时候，阻塞的线程就会被唤醒。 当 list 为空的时候，dequeue 线程会进入 wait 方法，然后阻塞。当 list 从空变为非空的时候，阻塞的线程就会被唤醒。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0024-剖析同步器]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0024-%E5%89%96%E6%9E%90%E5%90%8C%E6%AD%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前面，我们设计了简易版的信号量、锁等，它们虽然功能不一样，但是内部的差距却差不多。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能： 状态 访问条件 状态变化 通知策略 Test-and-Set 方法 Set 方法 并不是所有同步器都包含上述部分，也有些并不完全遵照上面的内容。但通常你会看到一或多个类似的功能。 状态同步器中的状态是用来确定某个线程是否有访问权限。 下面是Lock和BoundedSemaphore中的两个代码片段。 123456789101112public class Lock&#123;+ //state is kept here+ private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; ...&#125; 123456789101112131415public class BoundedSemaphore &#123;+ //state is kept here+ private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait(); this.signal++; this.notify(); &#125; ...&#125; 访问条件访问条件决定调用test-and-set方法（下文会说到）的线程是否可以对状态进行设置。访问条件一般是基于同步器状态的。通常是放在一个while循环里，以避免虚假唤醒问题。访问条件的计算结果要么是true要么是false。 这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。 123456789101112public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123;+ //access condition+ while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; ...&#125; 状态变化一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果。 这里有两个状态变化的代码片段： 12345678910111213141516171819public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125;+ //state change+ isLocked = true; &#125; public synchronized void unlock()&#123;+ //state change+ isLocked = false; notify(); &#125;&#125; 12345678910111213141516171819202122public class BoundedSemaphore &#123; private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait();+ //state change+ this.signals++; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait();+ //state change+ this.signals--; this.notify(); &#125;&#125; 通知策略一旦某个线程改变了同步器的状态，可能需要通知其它等待的线程状态已经变了。因为也许这个状态的变化会让其它线程的访问条件变为true。 通知策略通常分为三种： 通知所有等待的线程 通知所有等待的线程非常简单。所有等待的线程都调用的同一个对象上的wait()方法，某个线程想要通知它们只需在这个对象上调用notifyAll()方法。 通知N个等待线程中的任意一个 通知等待线程中的任意一个也很简单，只需将notifyAll()调用换成notify()即可。调用notify方法没办法确定唤醒的是哪一个线程，也就是“等待线程中的任意一个”。 通知N个等待线程中的某个指定的线程 有时候可能需要通知指定的线程而非任意一个等待的线程。例如，如果你想保证线程被通知的顺序与它们进入同步块的顺序一致，或按某种优先级的顺序来通知。想要实现这种需求，每个等待的线程必须在其自有的对象上调用wait()。当通知线程想要通知某个特定的等待线程时，调用该线程自有对象的notify()方法即可。 下面是通知策略的一个例子（通知任意一个等待线程）： 123456789101112131415161718public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; //wait strategy - related to notification strategy wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false;+ notify(); //notification strategy &#125;&#125; Test-and-Set方法test-and-set其实就是包括了访问条件与状态变化。 同步器中最常见的有两种类型的方法，test-and-set是第一种（set是另一种）。Test-and-set的意思是，调用这个方法的线程检查访问条件，如若满足，该线程设置同步器的内部状态来表示它已经获得了访问权限。 状态的改变通常使其它试图获取访问权限的线程计算条件状态时得到false的结果，但并不一定总是如此。例如，在读写锁中，获取读锁的线程会更新读写锁的状态来表示它获取到了读锁，但是，只要没有线程请求写锁，其它请求读锁的线程也能成功。 test-and-set很有必要是原子的，也就是说在某个线程检查和设置状态期间，不允许有其它线程在test-and-set方法中执行。 test-and-set方法的程序流通常遵照下面的顺序： 如有必要，在检查前先设置状态 检查访问条件 如果访问条件不满足，则等待 如果访问条件满足，设置状态，如有必要还要通知等待线程 下面的ReadWriteLock类的lockWrite()方法展示了test-and-set方法。调用lockWrite()的线程在检查之前先设置状态(writeRequests++)。然后检查canGrantWriteAccess()中的访问条件，如果检查通过，在退出方法之前再次设置内部状态。这个方法中没有去通知等待线程。 1234567891011121314151617181920212223public class ReadWriteLock&#123; private Map&lt;Thread, Integer&gt; readingThreads = new HashMap&lt;Thread, Integer&gt;(); private int writeAccesses = 0; private int writeRequests = 0; private Thread writingThread = null; ... public synchronized void lockWrite() throws InterruptedException&#123; writeRequests++; Thread callingThread = Thread.currentThread(); while(! canGrantWriteAccess(callingThread))&#123; wait(); &#125; writeRequests--; writeAccesses++; writingThread = callingThread; &#125; ...&#125; set方法set方法是同步器中常见的第二种方法。set方法仅是设置同步器的内部状态，而不先做检查。set方法的一个典型例子是Lock类中的unlock()方法。持有锁的某个线程总是能够成功解锁，而不需要检查该锁是否处于解锁状态。 set方法的程序流通常如下： 设置内部状态 通知等待的线程 这里是unlock()方法的一个例子： 12345678public class Lock&#123; private boolean isLocked = false; public synchronized void unlock()&#123; isLocked = false; notify(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0023-CAS]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0023-CAS%2F</url>
    <content type="text"><![CDATA[在说 CAS 之前先说一下乐观锁的定义： 乐观锁总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，所以在每次操作数据的时候都不会给数据加锁，即在线程对数据进行操作的时候，别的线程不会阻塞仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。 CAS是乐观锁的一种实现，说起来很抽象，其实还是很简单的，因为实际上它都不算是锁，更像是一种策略。 CAS（Compare and swap），是设计并发算法时用到的一种技术。简单来说，CAS 是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术。 在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。下面是一个简单的示例： 123456789101112class MyLock &#123; private boolean locked = false; public boolean lock() &#123; if(!locked) &#123; locked = true; return true; &#125; return false; &#125;&#125; 上面这段代码，如果用在多线程的程序会出现很多错误。 为了在一个多线程程序中良好的工作，“check then act” 操作必须是原子的。原子就是说“check”操作和“act”被当做一个原子代码块执行。不存在多个线程同时执行原子块。 下面是一个代码示例，把之前的lock()方法用synchronized关键字重构成一个原子块。 123456789101112class MyLock &#123; private boolean locked = false; public synchronized boolean lock() &#123; if(!locked) &#123; locked = true; return true; &#125; return false; &#125;&#125; 现在lock()方法是同步的，所以，在某一时刻只能有一个线程在同一个 MyLock 实例上执行它。 原子的lock方法实际上是一个“compare and swap”的例子。 现在的 CPU 自身就支持 CAS 操作。Java 5 中，我们可以使用 java.util.concurrent.atomic 包中的原子类来使用CPU中的这些功能。 下面是一个使用AtomicBoolean类实现lock()方法的例子： 12345678public static class MyLock &#123; private AtomicBoolean locked = new AtomicBoolean(false); public boolean lock() &#123; return locked.compareAndSet(false, true); &#125;&#125; locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。如果值被替换了，compareAndSet()返回true，否则，返回false。 使用 Java5+ 提供的CAS特性而不是使用自己实现的的好处是 Java5+ 中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性。这会使代码运行更快。 在使用 CAS 的时候，还需要注意 ABA 问题。 ABA 问题就是：如果某个线程将变量的值改变了，然后又改回原来的值，所以 CAS 仍然会认为值没有别的线程改变过。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0022-线程池]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0022-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池（Thread Pool）对于限制应用程序中同一时刻运行的线程数很有用。因为每启动一个新线程都会有相应的性能开销，每个线程都需要给栈分配一些内存等等。我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。只要池里有空闲的线程，任务就会分配给一个线程执行。在线程池的内部，任务被插入一个阻塞队列，线程池里的线程会去取这个队列里的任务。当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它。 Java 5 在 java.util.concurrent 包中自带了内置的线程池，所以你不用非得实现自己的线程池。不过无论如何，知道一点关于线程池实现的知识总是有用的。 下面我们来实现一个简易版的线程池。 一个线程池需要存放两部分的东西：线程、任务。 1234567891011121314151617181920212223242526272829303132public class ThreadPool &#123; private BlockingQueue taskQueue = null; private List&lt;PoolThread&gt; threads = new ArrayList&lt;PoolThread&gt;(); private boolean isStopped = false; public ThreadPool(int noOfThreads, int maxNoOfTasks) &#123; taskQueue = new BlockingQueue(maxNoOfTasks); for (int i=0; i&lt;noOfThreads; i++) &#123; threads.add(new PoolThread(taskQueue)); &#125; for (PoolThread thread : threads) &#123; thread.start(); &#125; &#125; public void synchronized execute(Runnable task) &#123; if(this.isStopped) throw new IllegalStateException("ThreadPool is stopped"); this.taskQueue.enqueue(task); &#125; public synchronized boolean stop() &#123; this.isStopped = true; for (PoolThread thread : threads) &#123; thread.toStop(); &#125; &#125;&#125; 我们在构造函数中，一开始就创建出多个线程，并启动它们，以供后面的任务使用，当然这里是为了简化，完全可以做到任务到来了之后再去创建线程。 execute 方法就很简单了，我们啥都不用做，将任务放入队列即可（就像银行排队一样，就算前面没有人，你也要先取号）。 stop 方法就是用来停止线程池里面所有线程的。 我们再来看 PoolThread 的实现： 123456789101112131415161718192021222324252627282930public class PoolThread extends Thread &#123; private BlockingQueue&lt;Runnable&gt; taskQueue = null; private boolean isStopped = false; public PoolThread(BlockingQueue&lt;Runnable&gt; queue) &#123; taskQueue = queue; &#125; public void run() &#123; while (!isStopped()) &#123; try &#123; Runnable runnable =taskQueue.take(); runnable.run(); &#125; catch(Exception e) &#123; // 写日志或者报告异常, // 但保持线程池运行. &#125; &#125; &#125; public synchronized void toStop() &#123; isStopped = true; this.interrupt(); // 打断池中线程的 dequeue() 调用. &#125; public synchronized boolean isStopped() &#123; return isStopped; &#125;&#125; 这个类就是一个增强版，线程执行 run 方法的时候，只能去队列里面取。队列没有东西，就阻塞着。处理异常一定要捕获。如果线程有中断标识按需退出，例子中没有处理，官方包中线程池也是不会中断，一定会执行完当前任务。 然后一个隐藏的点：子线程会在完成当前执行的任务后阻塞。注意 PoolThread.stop() 方法中调用了 this.interrupt()。它确保阻塞在 taskQueue.dequeue() 里的 wait() 调用的线程能够跳出 wait() 调用（因为执行了中断interrupt，它能够打断这个调用），并且抛出一个 InterruptedException 异常离开 dequeue() 方法。这个异常在 PoolThread.run() 方法中被截获、报告，然后再检查 isStopped 变量。由于 isStopped 的值是 true, 因此 PoolThread.run() 方法退出，子线程终止。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0018-失效的数据]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0018-%E5%A4%B1%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[原文叫做 “Slipped Conditions”，这个不太好翻译，所以我就借用一下《Java并发编程实战》的一节的标题了，讲的东西差不多。直接看一个例子：123456789101112131415161718192021222324public class Lock &#123; private boolean isLocked = true; public void lock()&#123; synchronized(this)&#123; while(isLocked)&#123; try&#123; this.wait(); &#125; catch(InterruptedException e)&#123; //do nothing, keep waiting &#125; &#125; &#125; synchronized(this)&#123; isLocked = true; &#125; &#125; public synchronized void unlock()&#123; isLocked = false; this.notify(); &#125;&#125; 看 lock 方法，里面有两个同步代码块，第一个同步代码块里面使用 isLocked 作为条件判断，却在第二个同步代码块里面更新了 isLocked 这个值。 这样的写就会很容易产生问题： 当一个线程 T1 执行完第一个同步代码块之后，可能就失去了CPU时间片执行的机会，然后另外一个线程 T2 就可以若无其事的也进入到 lock 方法里面，并且由于第一个线程 T1 没有更新 isLocke 的值，所以 T2 进入第一个同步代码块之后不会进入 wait 方法，这样就相当于有两个线程同时获取了 lock 锁。 这个场景就是“slipped conditions”的例子。 当 T1 进入第一个同步代码块后，从它使用 isLocked 这个值开始，一直到它更新 isLocke 值后，这个期间应该是不允许别的线程访问的，其他线程访问了就是使用了失效的数据。 所以我们应该让使用条件与更新条件这两个地方为原子的。也就是说，在第一个线程检查和设置条件期间，不会有其它线程使用这个条件。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0017-嵌套监视器锁死]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0017-%E5%B5%8C%E5%A5%97%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前面我们说到过死锁产生的4个条件，其中前3个是可以说是由于锁的特性导致的，一般我们不可改变，只有第4个原因是人为导致的，即获取锁的顺序不一致导致的。但是在某些情况下，即使获取锁的顺序一致，也有可能会导致类似死锁的情况，相互等待。举个例子：12345678910111213141516171819202122232425//lock implementation with nested monitor lockout problempublic class Lock&#123; protected MonitorObject monitorObject = new MonitorObject(); protected boolean isLocked = false; public void lock() throws InterruptedException&#123; synchronized(this)&#123; while(isLocked)&#123; synchronized(this.monitorObject)&#123; this.monitorObject.wait(); &#125; &#125; isLocked = true; &#125; &#125; public void unlock()&#123; synchronized(this)&#123; this.isLocked = false; synchronized(this.monitorObject)&#123; this.monitorObject.notify(); &#125; &#125; &#125;&#125; 看上面的代码，lock 与 unlock 方法都顺序获取两个锁，一个是 lock 对象本身，一个是 monitorObject 对象。 看上去没什么问题，但是注意一下，monitorObject 同步块下面的代码是一个相互唤醒的代码，这会导致下面的情况发生： 某一时刻，isLocked 为 true，这个时候，T1 获取到了 lock 对象的锁，然后接下来获取到了 monitorObjet 的锁，但是由于该 lock 锁已经被别人使用了，所以会进入 wait 方法，释放 monitorObject 锁。所以 T1 只持有 lock 对象的锁，然后等待别的线程唤醒。 然后切换到另一个线程 T2，这个线程是获取了 lock 锁（将 isLocked 置为 true）的线程，它执行完自己的代码之后，需要调用 unLock 方法了，然后发现 lock 对象被 T1 持有了，它无法进入 synchronized 里面，唤醒 T1 线程。 这样，T1 等待 T2 唤醒，但是 T2 又无法唤醒 T1（T1 持有 T2 需要的锁），这就与死锁比较类似，不过死锁都是阻塞在获取锁这里，而嵌套监视器锁定是一个线程阻塞在获取锁这里，另一个线程一直在 wait。 最后，由于 lock 锁被 T1 持有了，而后所有调用 lock 与 unlock 方法的线程都会被阻塞。另外，从这里也可以看出来，wait 只会释放对象上的锁。 看完上面的解释后，你可能会想，确实会有这样的情况，但是本公子天纵奇才，怎么可能会写这么搓的代码。那我们接下来看个不那么简化的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Fair Lock implementation with nested monitor lockout problempublic class FairLock &#123; private boolean isLocked = false; private Thread lockingThread = null; private List waitingThreads = new ArrayList(); public void lock() throws InterruptedException&#123; QueueObject queueObject = new QueueObject(); synchronized(this)&#123; waitingThreads.add(queueObject); while(isLocked || waitingThreads.get(0) != queueObject)&#123; synchronized(queueObject)&#123; try&#123; queueObject.wait(); &#125;catch(InterruptedException e)&#123; waitingThreads.remove(queueObject); throw e; &#125; &#125; &#125; waitingThreads.remove(queueObject); isLocked = true; lockingThread = Thread.currentThread(); &#125; &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; if(waitingThreads.size() &gt; 0)&#123; QueueObject queueObject = waitingThread.get(0); synchronized(queueObject)&#123; queueObject.notify(); &#125; &#125; &#125;&#125; 这个例子基本上是与前面“饥饿与公平”的最后一个例子一样。但是不同的地方在于，“饥饿与公平”的例子中，lock 方法的 synchronized 里面没有嵌套 synchronized(queueObject)，而在这个例子中，显然是一个监视器嵌套的情况。 与之前的例子仅仅又一步之差，但是却引发出一个重大的bug。 嵌套监视器锁死 VS 死锁嵌套监视器锁死与死锁很像：都是线程最后被一直阻塞着互相等待。 但是两者又不完全相同。在死锁中我们已经对死锁有了个大概的解释，死锁通常是因为两个线程获取锁的顺序不一致造成的，线程1锁住A，等待获取B，线程2已经获取了B，再等待获取A。如死锁避免中所说的，死锁可以通过总是以相同的顺序获取锁来避免。 发生嵌套管程锁死时锁获取的顺序是一致的。线程1获得A和B，然后释放B，等待线程2的信号。线程2需要同时获得A和B，才能向线程1发送信号。所以，一个线程在等待唤醒，另一个线程在等待想要的锁被释放。 不同点归纳如下： 123死锁中，二个线程都在等待对方释放锁。嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0019-锁的可重入性]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0019-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[synchronized 就是可重入的，看下面的实例代码：12345678910111213public class Counter &#123; private int count = 0; public synchronized int inc() &#123; return ++count; &#125; public synchronized int dec() &#123; inc(); return --count; &#125;&#125; 这个例子没什么意义，我们可以不用在意。 但是注意一下它的 dec 方法，在这个方法里面它又调用了 inc 方法，而 inc 与 dec 方法都有 synchronized 修饰。如果 synchronized 不可重入的话，线程在执行 dec 方法的时候，会阻塞在对 inc 方法的调用上。但是实际情况是没有的，所以 synchronized 肯定是可重入的。 再回想一下我们前面写的例子，Lock 与 FairLock 这两个锁是可重入的吗？ 先看 Lock 例子： 123456789101112131415161718192021222324252627public class Lock&#123; private boolean isLocked = false; private Thread lockingThread = null; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; lockingThread = Thread.currentThread(); &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; notify(); &#125; &#125; 当一个线程 T 进入 lock 方法之后，会将 isLocked 置为 true，如果这个时候，再次调用 lock 方法的话，会发生什么呢？ 1234// 连续调用调用 lock 方法myLock.lock();// do somethingmyLock.lock(); 在第二次调用 lock 方法的时候，由于 isLocked 已经变为 true 了，所以会进入 wait 方法，导致该线程休眠了，这就不是一个可重入的锁，正常情况下它不应该休眠。 那么应该如何解决这个问题呢？ 我们想想，发现如果是同一个线程多次获取锁的话，就不应该进入 wait 方法。所以我们需要特殊处理一下，而且，获取锁多少次还应该释放锁多少次。 看看改进之后的代码： 1234567891011121314151617181920212223242526272829public class Lock&#123; boolean isLocked = false; Thread lockedBy = null; int lockedCount = 0; public synchronized void lock() throws InterruptedException&#123; Thread callingThread = Thread.currentThread(); while(isLocked &amp;&amp; lockedBy != callingThread)&#123; wait(); &#125; isLocked = true; lockedCount++; lockedBy = callingThread; &#125; public synchronized void unlock()&#123; if(Thread.curentThread() == this.lockedBy)&#123; lockedCount--; if(lockedCount == 0)&#123; isLocked = false; notify(); &#125; &#125; &#125;&#125; 先看 lock 方法： 在进入 wait 之前，先判断了当前线程是不是获取了锁的线程，如果是则不需要 wait。然后记录了获取锁的次数。 在看 unlock 方法： 首先就判断了当前线程是不是获取了锁的线程，不是的话，就不用走下面的逻辑了，是的话就notify，减少获取锁的次数。 这样，我们就实现了一个可重入锁了，其实还是蛮简单的，就是记录了一下锁的获取次数以及判断一下当前线程是不是获取了锁的线程。 有一个需要注意的地方：在finally语句中调用unlock() 如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例： 1234567lock.lock();try&#123; //do critical section code, //which may throw exception&#125; finally &#123; lock.unlock();&#125; 这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。 FairLock 与 Lock 的核心代码其实是差不多的，所以就不讲了。 synchronized 不用这样是因为，java文件在被编译为 class 文件的时候就已经做了这些操作。比如，我们查看一个 class 文件的字节码： 1234563: monitorenter //进入同步方法//..........省略其他 15: monitorexit //退出同步方法16: goto 24//省略其他.......21: monitorexit //退出同步方法 发现，有两个 monitorexit，第二个 monitorexit 就是用来处理发生异常的情况的。再看第一个 monitorexit 后面有一个 goto，说明如果不出现异常是不会走第二个 monitorexit 的。]]></content>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0020-信号量]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0020-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失，或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理。 之前就在实现公平锁的时候就实现了一个类似信号量的东西。 123456789101112131415public class Semaphore &#123; private boolean signal = false; public synchronized void take() &#123; this.signal = true; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(!this.signal) wait(); this.signal = false; &#125;&#125; 这里的逻辑前面已经解释过多次了，所以这里就不再赘述了。 唯一需要注意的是，这里的 take 与 release 的意思与我们理解的意思是相反的。take 表示产生了一个信号，release 表示消耗了一个信号。在这里例子中显得很反常，但是在本文的最后一个例子中就会发现很合理。 上面的例子是一个简单的信号量，那么它可以做什么呢？ 可以在两个线程之间通信 如下例子： 1234567891011121314151617181920212223242526272829303132333435Semaphore semaphore = new Semaphore();SendingThread sender = new SendingThread(semaphore)；ReceivingThread receiver = new ReceivingThread(semaphore);receiver.start();sender.start();public class SendingThread &#123; Semaphore semaphore = null; public SendingThread(Semaphore semaphore)&#123; this.semaphore = semaphore; &#125; public void run()&#123; //do something, then signal this.semaphore.take(); &#125;&#125;public class RecevingThread &#123; Semaphore semaphore = null; public ReceivingThread(Semaphore semaphore)&#123; this.semaphore = semaphore; &#125; public void run()&#123; this.semaphore.release(); //receive signal, then do something... &#125;&#125; SendingThread 线程执行到 this.semaphore.take(); 的时候会阻塞，然后等待 RecevingThread 执行到 this.semaphore.release(); 才会醒过来，继续执行自己的代码。 信号量可以用在线程需要配合的地方。 下面我们对信号量进行增强。 可计数的信号量123456789101112131415public class CountingSemaphore &#123; private int signals = 0; public synchronized void take() &#123; this.signals++; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait(); this.signals--; &#125;&#125; 这个可计数的也没啥意义，我们再增加一下功能。 带上界的信号量12345678910111213141516171819202122232425public class BoundedSemaphore &#123; private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait(); this.signals++; // 这里调用 notify，是用来唤醒 release 导致的阻塞的线程 this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait(); this.signals--; this.notify(); &#125;&#125; 当已经产生的信号数量达到了上限，take方法将阻塞新的信号产生请求，直到某个线程调用release方法后，被阻塞于take方法的线程才能传递自己的信号。 BoundedSemaphore 其实可以当作锁来使用： 12345678BoundedSemaphore semaphore = new BoundedSemaphore(1);...semaphore.take();try&#123; //critical section&#125; finally &#123; semaphore.release();&#125; 在前面的例子中，Semaphore被用来在多个线程之间传递信号，这种情况下，take和release分别被不同的线程调用。 但是在锁这个例子中，take和release方法将被同一线程调用，因为只允许一个线程来获取信号（允许进入关键区域的信号），其它调用take方法获取信号的线程将被阻塞，直到第一个调用take方法的线程调用release方法来释放信号。对release方法的调用永远不会被阻塞，这是因为任何一个线程都是先调用take方法，然后再调用release。 通过有上限的Semaphore可以限制进入某代码块的线程数量。设想一下，在上面的例子中，如果BoundedSemaphore 上限设为5将会发生什么？意味着允许5个线程同时访问关键区域，但是你必须保证，这个5个线程不会互相冲突。否则你的应用程序将不能正常运行。 必须注意，release方法应当在finally块中被执行。这样可以保在关键区域的代码抛出异常的情况下，信号也一定会被释放。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0016-饥饿与公平]]></title>
    <url>%2F2019%2F08%2F21%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0016-%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3%2F</url>
    <content type="text"><![CDATA[在多线程程序中，有可能出现这样的情况：某个线程由于得不到CPU的时间片，导致这个线程永远无法执行。这种情况就叫做“饥饿”。解决“饥饿”的方案叫“公平性”，即让每个线程都有机会获得CPU得运行机会。“饥饿”的原因先来说一下导致“饥饿”得几个原因： 高优先级线程吞噬低优先级线程的CPU时间 你可以为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。 线程被一直因为获取不到锁而阻塞，因为 synchronized 是非公平锁，所以有可能线程永远得不到锁。 Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。 线程一直处于 wait 状态，因为 notify 总是随机唤醒一个，所以有可能线程永远不会被唤醒。 如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。 实现“公平性”文章原文说了这样的一句话： While it is not possible to implement 100% fairness in Java we can still implement our synchronization constructs to increase fairness between threads. 我也不知道为啥不能100%实现。暂且放过。 下面，我们来自己实现一个锁，不要方，很简单的。 12345678public class Synchronizer&#123; Lock lock = new Lock(); public void doSynchronized() throws InterruptedException&#123; this.lock.lock(); //critical section, do a lot of work which takes a long time this.lock.unlock(); &#125;&#125; 这个例子里面所使用的 Lock 就是我们需要实现的锁了。实现代码如下： 12345678910111213141516171819202122232425262728293031public class Lock&#123; private boolean isLocked = false; private Thread lockingThread = null; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; lockingThread = Thread.currentThread(); &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; notify(); &#125;&#125; lock 方法：多个线程访问该方法的时候，只有第一个获得 synchronized 锁的线程才能进入 lock 方法，然后将 isLocked 置为true，其余的线程获得 synchronized 锁之后，只能进入 wait 方法。 unlock 方法：该方法重新将 isLocked 置为 false，这样其他线程才能跳出 wait 所在的循环。调用 notify 之后，由于多个线程使用的是同一个锁，所以将随机唤醒一个线程。 我们仔细想一下，lock 方法也是一个同步代码块，但是线程基本不会在同步代码块上阻塞（同步代码块很短），而是都阻塞到了 wait 方法上。 虽然，notify 唤醒的时候，是随机唤醒一个阻塞在同一个对象上的线程。但是这里就是我们可以优化的点了！！！因为如果我们让每个线程都阻塞在不同对象的 wait 方法上，这样我们只需要公平的调用这些对象的 notify 方法就可以实现公平性了。 为了实现公平性，我们还需要一个队列，用来存储线程到来的顺序，按照到来的顺序来唤醒线程，实现公平性。 看下面的代码，一个简易的公平锁： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FairLock &#123; private boolean isLocked = false; private Thread lockingThread = null; private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;(); public void lock() throws InterruptedException &#123; QueueObject queueObject = new QueueObject(); boolean isLockForThisThread = true; synchronized (this) &#123; waitingThreads.add(queueObject); &#125; while (isLockForThisThread) &#123; synchronized (this) &#123; isLockForThisThread = !isLocked &amp;&amp; waitingThreads.get(0) == queueObject; if (isLockForThisThread) &#123; isLocked = true; waitingThreads.remove(queueObject); lockingThread = Thread.currentThread(); return; &#125; &#125; try &#123; queueObject.doWait(); &#125; catch (InterruptedException e) &#123; synchronized (this) &#123; waitingThreads.remove(queueObject); &#125; throw e; &#125; &#125; &#125; public synchronized void unlock() &#123; if (this.lockingThread != Thread.currentThread()) &#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; if (waitingThreads.size() &gt; 0) &#123; waitingThreads.get(0).doNotify(); &#125; &#125;&#125; 12345678910111213141516171819202122public class QueueObject &#123; private boolean isNotified = false; public synchronized void doWait() throws InterruptedException &#123; while(!isNotified)&#123; this.wait(); &#125; this.isNotified = false; &#125; public synchronized void doNotify() &#123; this.isNotified = true; this.notify(); &#125; public boolean equals(Object o) &#123; return this == o; &#125;&#125; 我们先说 QueueObject 类，它其实就是一个信号量。doWait 方法里面使用了循环，避免假唤醒。同时也储存了唤醒信号，避免信号丢失。这个类还是很好理解的，就是将 Object 的 wait 与 notify 增强了一下。 再来看 FairLock 类。别看代码有点复杂，但是逻辑基本没变。比如 lock 方法： 首先为每个线程都创建一个锁对象，然后放入队列里面。 接下来仍然是一个 while 循环，只不过这个循环的变量需要注意一下，原先只要判断是否已经有线程把锁拿走了，现在还需要在这个基础上判断，是否当前线程是队列里面的第一个线程（只有第一个有资格运行，这样才公平）。然后仍然是调用 wait 方法。 再来仔细的对比一下，FairLock 与 Lock 的区别： lock()方法不再声明为synchronized，取而代之的是只对必需同步的代码进行同步。 调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程（头部的）获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。 queueObject.doWait()调用放置在synchronized(this)块之外，以避免监视器嵌套锁死的情况（下一篇会讲）。 最后，注意到queueObject.doWait()的try – catch块，在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。 性能考虑如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。 这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。 究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0013-ThreadLocal]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0013-ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal类创建的变量会给每个线程都分配一份，虽然每个线程都持有的是执行同一个ThreadLocal对象的引用，但是获取的（调用 get 方法）确实不同的对象。创建 ThreadLocal 对象1private ThreadLocal myThreadLocal = new ThreadLocal(); 这个好理解，与普通Java类一样使用即可。 储存值当创建好了 ThreadLocal 之后，我们就可以往里面储存值了，就像 ThreadLocal 是一个容器一样。 123456// ThreadLocal 支持泛型private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;();// 储存一个 string 对象myThreadLocal1.set("Hello ThreadLocal");String threadLocalValues = myThreadLocal.get(); 嗯，获取用 String 来当作例子有点不恰当，没法看出它是不是同一个对象，我们稍微改变一下： 1234567// ThreadLocal 支持泛型private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;Object&gt;();// 储存一个 string 对象myThreadLocal1.set(new Object());Object o = myThreadLocal.get();System.out.println(o.hashcode()) 在不同的线程里面执行，打印 hashCode 会发现是不同的值，即不同的线程 set 与 get 获取的都是属于自己的那一份，无法获取别的线程的，别的线程也获取不到自己的。 初始值ThreadLocal 还可以指定一个初始值，即当没有执行 set 方法的时候，get 方法也能取出初始值来。 1private ThreadLocal&lt;Object&gt; threadLocal = ThreadLocal.withInitial(Object::new); 这个初始值也是每个线程都有一份，每个线程获取的也是不同的对象，而不是同一个对象。 示例12345678910111213141516171819202122232425262728293031323334public class ThreadLocalExample &#123; public static class MyRunnable implements Runnable &#123; private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); @Override public void run() &#123; threadLocal.set( (int) (Math.random() * 100D) ); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(threadLocal.get()); &#125; &#125; public static void main(String[] args) &#123; MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); //wait for thread 1 to terminate thread2.join(); //wait for thread 2 to terminate &#125;&#125; 上面创建了两个线程共享一个MyRunnable实例。 每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。 如果不使用ThreadLocal对象，那么第二个线程将会覆盖第一个线程所设置的值。 然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。 InheritableThreadLocalInheritableThreadLocal类是ThreadLocal的子类。 为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。 需要注意的地方ThreadLocal 实际上是将要存放的对象放入到了 Thread 的 localValues 变量中。 java.lang.Thread 1234/** * Normal thread local values. */ThreadLocal.Values localValues; 使用 set 方法的时候，是将 ThreadLocal 本身的弱引用做为 key，将要储存的对象做为 value。 java.lang.ThreadLocal#set 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 看起来传递的是 this，其实真正put的时候，使用的是弱引用。如下： java.lang.ThreadLocal.ThreadLocalMap.Entry 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 可以看到，Entry 是继承至 WeakReference 的，而 Entry 就是要 put 进去的 key 与 value 的封装。 所以，网上多说，会有内存泄露的可能。是因为如果 ThreadLocal 本身如果没有再使用了，而当前线程迟迟不结束的话，会导致 Thread 的 localValues 变量里存的 key 被回收，values 却无法被回收（引用找不到了，但是却存在于 threa 的成员变量里面）。 这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value造成内存泄漏，当然线程结束就好了。 所以，使用 ThreadLocal 推荐写成 private static 的。用完也应该 remove。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0015-死锁]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0015-%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。死锁的产生死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。举个例子：123如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 上面的例子可能的代码如下： 1234567891011121314151617181920212223242526public class TreeNode &#123; TreeNode parent = null; List children = new ArrayList(); public synchronized void addChild(TreeNode child)&#123; if(!this.children.contains(child)) &#123; this.children.add(child); child.setParentOnly(this); &#125; &#125; public synchronized void addChildOnly(TreeNode child)&#123; if(!this.children.contains(child)&#123; this.children.add(child); &#125; &#125; public synchronized void setParent(TreeNode parent)&#123; this.parent = parent; parent.addChildOnly(this); &#125; public synchronized void setParentOnly(TreeNode parent)&#123; this.parent = parent; &#125;&#125; 如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程： 12345Thread 1: parent.addChild(child); //locks parent --&gt; child.setParentOnly(parent);Thread 2: child.setParent(parent); //locks child --&gt; parent.addChildOnly() 首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。 然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。 现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。 上面的例子说的是比较简单的死锁，还有更加复杂的死锁（死锁可能不止包含2个线程）。下面是4个线程发生死锁的例子： 1234Thread 1 locks A, waits for BThread 2 locks B, waits for CThread 3 locks C, waits for DThread 4 locks D, waits for A 还有数据库也可能发生死锁（这个与线程的死锁是一样的道理）。 当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁。 死锁预防先来说一下死锁产生的必要条件，知道了条件之后，就可以采取对应的措施。 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 通过前面死锁的产生篇章，我们知道了循环等待的条件的形成是由于线程请求锁的顺序不一致导致的。那么如果我们让线程请求锁的顺序有序的话，那就不会形成循环等待条件，这样形成死锁的条件就打破了。看下面这个例子： 123456789101112Thread 1: lock A lock BThread 2: wait for A lock C (when A locked)Thread 3: wait for A wait for B wait for C 如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。 线程2和线程3只有在获取了锁A之后才能尝试获取锁C。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。 还有一种方式，就是加上超时机制。一个线程在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。看下面的例子： 12345678910111213Thread 1 locks AThread 2 locks BThread 1 attempts to lock B but is blockedThread 2 attempts to lock A but is blockedThread 1's lock attempt on B times outThread 1 backs up and releases A as wellThread 1 waits randomly (e.g. 257 millis) before retrying.Thread 2's lock attempt on A times outThread 2 backs up and releases B as wellThread 2 waits randomly (e.g. 43 millis) before retrying. 在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁。 需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁，也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。 此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相同的重试时间的概率就高的多。 还有一种避免死锁的算法（银行家算法），不过需要预先知道所有的线程，资源。 死锁检测死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。 每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。 当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。 当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。先判断B是否有A所要的锁，没有则查看线程B等待的线程C，看C是否持有A说要的锁，就这样递进的检查下去。 下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。 那么当检测出死锁时，这些线程该做些什么呢？ 一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0014-volatile关键字]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0014-volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java 的 volatile 关键字表示修饰的这个变量的 值储存在主存 中，这里不要理解错了，并不是说 volatile 修饰的变量就直接在主内存中操作（这是不可能的），而是说： 修改volatile变量时会强制将修改后的值刷新的主内存中。 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，需要重新读取主内存中的值。 说的通俗一点，就是每次读取 volatile 变量都会从主存中读取，每次写入 volatile 变量都是写入到主存中。 前面我们说过可见性问题，而 volatile 关键字就是用来保证线程之间变量的可见性。可能还是有点抽象，那就再说一遍。 volatile 对可见性的保证现在的 CPU 为了性能，会将内存中的数据拷贝到 CPU 的高速缓存中。如果有多个 CPU 的话，每个线程会运行在不同的 CPU 上，即每个线程都会拷贝一个数据到高速缓存中。如下图： 对于非 volatile 的变量，在多线程的程序中，就会出现可见性问题，当一个线程更新了值之后，而另一个线程却看不到，就会导致程序错误： 12345public class SharedObject &#123; public int counter = 0;&#125; 假设，线程 1 会更新计数器的值， 线程 2 会时时的读取这个计数器的值。由于 counter 不是 volatile 的，所以在线程 1 更新其值之后，不一定会将值刷新到主存中，当线程 2 读取的时候，读取的还是未更新的值： 使用 volatile 之后，就不一样了。volatile 就是用来解决这个问题的，我们给 counter 加上关键字： 12345public class SharedObject &#123; public volatile int counter = 0;&#125; 当线程1更新 counter 的值后， 线程2就能读到最新值了。 但是如果 线程1 与 线程2 都更新 counter 的值的话，仅仅加上 volatile 关键字还是不够的，后面会说。 volatile 对重排序的影响volatile 可见性不仅会影响到它优化的变量，还会对重排序有一定影响。看下面这个例子： 12345678//x、y为非volatile变量//flag为volatile变量x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且 volatile 关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 volatile 与 Happens-Before再来看一个例子： 123456789101112131415161718192021public class MyClass &#123; private int years; private int months private volatile int days; public int totalDays() &#123; int total = this.days; total += months * 30; total += years * 365; return total; &#125; public void update(int years, int months, int days)&#123; // 1 this.years = years; // 2 this.months = months; // 3 this.days = days; &#125;&#125; update 方法写了3个变量，只有 days 是 volatile 的。但是实际上在将 days 的值刷入主内存的时候，会将 years 与 months 的值也刷入主内存。 totalDays 方法读取了3个变量的值，当从主内存读取 days 的值的时候，也会从主内存读取 months 与 years 的值。 起初，我是无法理解的，于是去 stackOverFlow 上问了一下，很快就有了答案： 这个是由于 “Happens-Before” 原则引发的： 由于 days 被 volatile 修饰，所以代码 1 2 处 Happens-Before 代码 3，即代码 1 2 的结果对代码 3 是可见的。 同样，volatile 变量的写 Happens-Before volatile 变量的读。 在根据 Happens-Before 的传递性，所以某一个线程想要读取 days 的值的时候，months 与 years 的值也是最新的。 volatile 使用注意前面，我们说的多个线程更新 counter 的值，尽管 counter 是 volatile 的，但是还是会出问题，现在就来解释一下。 1counter++; 就拿这个举例，假设某个时刻，counter 的值为 4。 123456789线程1从主内存中读取值为4，准备执行加一的指令，然后线程1被阻塞，切换到线程2线程2从主内存中读取值为4，准备执行加一的指令，然后线程2被阻塞，切换到线程1线程1执行加一的指令，最后将自增后的值赋值给counter，counter的值成了5，写入回了主内存。线程1阻塞，切换到线程2.线程2执行加一的指令（将4加一的过程中不需要对counter进行读写，所以自增之后的值还是5），然后将 5 赋值给 counter，并写入回了主内存。最后，counter 的结果还是 5. 看一张图： 在读取一个变量与给这个变量赋值之间是有一段间隔的，这段间隔表示它们不是一个原子操作，不是原子操作就会产生竟态条件。两个线程同时读取值之后，一个线程即使更新了值，也不管用了，因为读取操作已经完成了，后面的写操作不需要再次读取该值，也就看不到最新的值。 所以，volatile 应该用在不需要依赖变量的当前值的地方。反过来说： 运算结果并不依赖变量的当前值（即结果对产生中间结果不依赖），或者能够确保只有单一的线程修改变量的值 比如，用来更新标识变量，直接给标识赋值，flag = true 或者 flag = false，不需要依赖当前的值，像 flag = !flag 就不行。 最后，由于 volatile 每次写操作将最新值刷入主存，每次读操作要从主存重新读取，所以效率不高，而且它还禁止了指令优化，所以一定要在确实需要的时候才使用。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-synchronized同步代码块]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0011-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[同步代码块就像一个锁一样，将代码给锁起来，线程需要执行同步块中的代码时需要先获取锁才能执行。一次只能有一个线程获得锁。Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在同一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。 有四种不同的同步块： 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块 实例同步方法123public synchronized void add(int value)&#123; this.count += value;&#125; 这个方法是同步在这个方法所属的对象上的。如果有多个线程执行该对象的 add 方法，就会出现阻塞，只有获取了锁的线程才能执行。但是如果是执行的不同对象上的 add 方法，因为获取的是不同的锁，所以不会阻塞。 静态同步方法123public static synchronized void add(int value)&#123; this.count += value;&#125; 与实例同步方法一样。不过它同步的不是实例对象，而是类对象（XXX.class）。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。 实例方法中的同步块有时你不需要同步整个方法，而是同步方法中的一部分。 1234567public void add(int value)&#123; synchronized(this)&#123; this.count += value; &#125; &#125; 注意到，这里我们传递了this，说明同步代码块是作用在 this 这个对象上的，它的作用与实例同步方法一样。（在同步构造器中用括号括起来的对象叫做监视器对象） 我们出了传递 this，还可以传递别的对象，只要是你想让代码块作用在这个对象上就行。 静态方法中的同步块12345678910111213public class MyClass &#123; public static synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public static void log2(String msg1, String msg2)&#123; synchronized(MyClass.class)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; log2 与 log1 是等价的，当然静态方法中的同步块我们也可以传递别的类的 class。 示例在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。 1234567891011121314151617181920212223242526272829303132public class Counter&#123; long count = 0; public synchronized void add(long value)&#123; this.count += value; &#125;&#125;public class CounterThread extends Thread&#123; protected Counter counter = null; public CounterThread(Counter counter)&#123; this.counter = counter; &#125; public void run() &#123; for(int i=0; i&lt;10; i++)&#123; counter.add(i); &#125; &#125;&#125;public class Example &#123; public static void main(String[] args)&#123; Counter counter = new Counter(); Thread threadA = new CounterThread(counter); Thread threadB = new CounterThread(counter); threadA.start(); threadB.start(); &#125;&#125; 这里创建了两个线程。他们的构造器引用同一个Counter实例。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。 如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示： 123456789101112public class Example &#123; public static void main(String[] args)&#123; Counter counterA = new Counter(); Counter counterB = new Counter(); Thread threadA = new CounterThread(counterA); Thread threadB = new CounterThread(counterB); threadA.start(); threadB.start(); &#125;&#125; 注意这两个线程，threadA和threadB不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0018-静态链表]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0018-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[在一些早期的语言中，是没有指针这个东西的，那么就没办法实现链表了。但是我们的前辈们想出了一个办法：用数组来实现链表，是真的牛逼。我们来看看是如何实现的吧。首先，同样是定义一个Node类，然后创建一个Node数组，为了方便插入数据，会把这个数组定义的大一些，以免溢出（这里就不考虑扩容了）。注意这里我们储存的是下一个节点的位置，而不是下一个节点的引用，因为早期的语言没有引用。 1234class Node &#123; Object value; int nextPos;&#125; 然后我们再来思考，用数组怎么链式储存数据。 首先头指针怎么存？ 新插入一个节点的时候，怎么插入？肯定不能一个个往后移动 删除节点的时候，怎么标记这个位置是空的？ 直接给出答案吧，看下图： 这样储存的就解决了上面的3个问题。 头节点放在最后一个位置。 第一个位置用来放备用链表，啥叫备用链表呢，就是把数组里面所有为空的位置串起来的链表。有了备用链表，想要插入的话，从备用链表里面拿第一个节点就好了。想要删除的话，将删除的节点放入备用链表就好了。 静态链表的初始化其实静态链表的初始化就是要做3件事： 头节点 备用链表头节点 备用链表 12345678910public void initList() &#123; for(int i=0; i&lt;SIZE; i++) &#123; // 这里初始化了备用链表的头节点与备用链表 // 原本我想的是将静态链表的头节点放在第一个位置，后来想了一下 // 放在最后一个位置会更简单一些，虽然放在第一个位置也能实现，但是就显得麻烦了 nodes[i].nextPos = i+1; &#125; // 这里初始化了静态链表的头节点 nodes[SIZE - 1].nextPos = 0;&#125; 其实就是将整个数组串起来，最后将头尾连起来，形成一个闭环。 这个闭环里面其实是有两条链表，一个备用链表，一个存放数据的链表。 上面的代码中，将数据链表一开始指向了 0 位置，其实一开始指不指向 0 无所谓，只要它后来指向第一个存放数据的位置就好了。 插入一个元素第一个插入的元素，肯定是存放在1位置的（因为备用链表初始化的时候，第一个节点是1位置），接下来插入的数据依次往后摆。 假设静态链表已经存放进去了一些数据，如下图所示： 要想插入一个数据，需要分为这几步： 拿出备用链表的头节点 H 更新备用链表的头节点 将 H 节点插入到数据链表中 我们先从备用链表里面拿到其头节点，代码如下： 123456789101112private int getStandByHeadNode() &#123; // 获取备用链表头节点的位置 int pos = table[0].nextPos; // 我们指定，备用链表的头节点为0，表示链表已经满了 if (pos != 0) &#123; // 更新备用链表的头节点 table[0].nextPos = table[pos].nextPos; &#125; return pos;&#125; 然后再插入数据，这里的插入数据与之前的不一样，因为我们储存了下一个节点的位置，所以我们只需要更新一下下一个节点的位置就好了： 1234567891011121314151617181920public void insertNode(int index, Object value) &#123; // 保证 index 在 0 与 数据链表的长度之间 checkIndex(index); int pos = getStandByHeadNode(); if (pos == 0) &#123; return; &#125; table[pos].value = value; // 寻找插入位置 int dataNextPos = SIZE - 1; for (int i = 0; i &lt; index; i++) &#123; dataNextPos = table[dataNextPos].nextPos; &#125; // 在第i个节点后面添加一个节点 table[pos].nextPos = table[dataNextPos].nextPos; table[dataNextPos].nextPos = pos;&#125; 插入后数据如下图： 删除一个元素同样的，先来理思路： 找到需要删除的元素 D 的前一个元素H（因为需要更改 H 元素的cur值） 将 H 的cur 值改为 D 的 cur 值 将 D 元素放入备用链表 代码如下： 1234567891011121314151617181920212223242526public void deleteNode(int index) &#123; // 保证链表长度大于1 checkLength(); // 保证 index 在 0 与 数据链表的长度之间 checkIndex(index); // 找到需要删除的节点的前一个节点 int dataNextPos = SIZE - 1; for (int i = 0; i &lt; index; i++) &#123; dataNextPos = table[dataNextPos].nextPos; &#125; // 前一个节点 Node p = table[dataNextPos]; // 需要删除的节点 Node d = table[p.nextPos]; // 删除节点 p.nextPos = d.nextPos; // 将 d 放入备用链表 d.nextPos = table[0].nextPos; table[0].nextPos = p.nextPos; // 释放节点空间 d.nextPos = 0; d.value = null;&#125; 静态链表的优缺点优点： 增删时只需要修改游标，不需要移动元素 缺点： 没有解决长度问题（长度无法确定，只能取一个估计值），失去了随机存储的特性]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-线程安全及不可变性]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0009-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%2F</url>
    <content type="text"><![CDATA[当一个以上的线程对同一个资源进行写操作的时候，就会产生竟态条件。多个线程同时读不会产生竟态条件。不可变对象如果我们让共享资源不可变的话，不提供修改方法，那就没有线程安全问题了。如下：1234567891011public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125;&#125; 这里我们只在构造函数里面传递值进去来实例化一个对象，该对象实例化完成之后，就无法更改里面的值了。所以这个对象是线程安全的，是不可变的。即不可变的对象是线程安全的。 需要区分“不可变”与“只读”。 一个变量只读，不代表这个变量不可变。 举一个例子：一个人的年龄是只读的，因为无法随便更改一个人的年龄，但是随着时间的变化，这个人的年龄是可以增加的，所以年龄这个变量是只读的，但是是可变的。一个人的出生年月是不可变的。 上面的不可变例子由于没有提供任何的修改方法，所以它是不可变的，但是需要用到这种不可变对象的需求毕竟非常少，如果有需要修改这个对象，那么有没有什么方法能保证线程安全呢？看看下面的例子： 123456789101112131415public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public ImmutableValue add(int valueToAdd)&#123; return new ImmutableValue(this.value + valueToAdd); &#125;&#125; 我们给这个不可变对象提供了一个 add 方法，但是注意，我们返回了一个新的对象。这就是一种比较常用的方法，为了保证线程的安全性，我们通常不会改变原来的对象，而是创建一个新的对象并返回。 使用不可变对象不代表线程安全看下面这个例子： 123456789101112131415public void Calculator&#123; private ImmutableValue currentValue = null; public ImmutableValue getValue()&#123; return currentValue; &#125; public void setValue(ImmutableValue newValue)&#123; this.currentValue = newValue; &#125; public void add(int newValue)&#123; this.currentValue = this.currentValue.add(newValue); &#125;&#125; Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。 换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010-内存模型]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0010-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在说内存模型之前，我们先来说下一CPU，对CPU有一定了解之后，再来说为何要有内存模型。CPU缓存一致性我们知道CPU是用来执行计算机指令的，而指令中包含的数据是从主存（内存）当中读取的，它将读取的数据放入自己的寄存器中，然后执行操作，这个是因为CPU在寄存器上执行操作的速度远大于在主存上执行的速度。 虽然CPU访问寄存器的速度很快，但是每次执行新的指令的时候，又要重新从主存中读取数据。那么这就会产生一个问题：随着CPU技术的发展，CPU的运行速度越来越快，而内存的技术没有啥太大的改变，这就导致了CPU与内存的运行速度差距越来越大。换成人类时间举个例子，一个主频2.6G的CPU执行一个指令只需要1s，它从内存读取数据大概需要4分钟（这还假设它没有触发缺页异常）。 可以看到如果CPU只能从内存中读取数据的话，那么CPU技术发展的再快也没有用。那么有没有什么办法解决呢？显然是有的，不然我们的个人计算机也不会发展的那么迅速了。 就是给CPU加一个高速缓存，这样由于局部性原理，CPU只需要将部分数据保存在高速缓存中，就可以极大的缓解数据读取慢的问题（从高速缓存中读取数据与执行指令的速度在同一个数量级）。于是CPU工作方式如下： 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 现在的CPU有的还会有多级缓存：L1，L2，L3。工作方式与普通的缓存一样，L1中找不到找L2，L2中找不到找L3。但是每一级缓存的速度相差比较大，L1与L2的速度就不在同一个数量级。我们只需要知道CPU有一个高速缓存就好了。 高速缓存解决了数据访问慢的问题，但是引入了新的问题：每个CPU有自己的缓存，每个缓存中的数据都是主存中的一份拷贝。如果多个CPU都同时从主存中读取了一样的数据，都更改了这个数据，那么当CPU将缓存中的数据写回主存会发生什么呢？具体会发生啥我也不知道，反正肯定会乱成一锅粥就对了。这种问题叫做缓存一致性问题。 这里说一个小知识：我们经常说的 4核8线程是什么意思？ 4核显然是4个CPU核心，但是8线程是什么呢？难道一个CPU可以同时运行两个线程？ 8线程指的是通过超线程技术，用一个物理核模拟两个虚拟核，在CPU核心没有满负荷运载时，其剩余用量可以模拟成虚拟的核心。 除了缓存一致性问题，还有别的导致多CPU运算出错（不符合我们的预期）的问题。比如：CPU指令优化导致的问题。比如，一个32位的系统读取 double 与 long 值的时候会分两次读，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值。 内存模型为了保证共享内存的正确性，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。主要是抽象出了3个概念：可见性、有序性、原子性。 这3个概念就是前人们总结出来的3个前置条件，我们要想在编写出一个符合期望的多线程程序，那么内存模型就需要提供一套解决方案来实现这3个条件。 Java内存模型Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。 Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问。 线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。 工作内存中存储着主内存中的变量副本拷贝。 下面举几个例子来说明哪些变量储存在主内存，哪些变量储存在工作内存。注意不要把主内存，工作内存与堆栈搞混了。 原始类型的本地变量是储存在栈（在工作内存中）。 对象类型的本地变量储存在堆中（在主内存中），但是该类型的引用储存在栈中（在工作内存中）。 对象的成员变量（不管这个变量是基本类型还是对象类型）是放在堆中（在主内存中）。 static变量以及类本身相关信息将会存储在方法区（在主内存中）。 JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。 在上面的图中，Object3对象肯定不是在 methodOne() 中创建的，所以它们指向同一个对象。 Object1 与 Object5 才是在 methodTwo() 中创建的，所以每个线程都创建了自己的对象。 Java内存模型与实际内存的关系对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分。 JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中或者CPU缓存或者寄存器中。 Java内存模型保证了原子性、可见性、有序性JMM主要是靠happens-before 原则，sychronized等同步锁， volatile 等关键字来保证原子性、可见性以及有序性。 下面是happens-before原则规则： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作； volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始； 这些东西读起来像是很理所当然的东西，但是却是并发编程的基石。就像高等数学学起来很费劲，1+1却是理所当然一样。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0012-线程间通信]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0012-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程之间的通信通常是为了协调这些线程的工作。线程之间的通信会涉及到下面几个内容的东西： 通过共享对象通信 忙等待 wait、notify、notifyAll 丢失的信号 假唤醒 不要对常量以及全局对象调用 wait 通过共享对象通信这个是最容易想到的方法：创建一个对象，在这个对象里面存放一个标识，提供更新标识的方法。然后每个线程持有这个对象的引用，即可进行通信。 12345678910111213public class MySignal&#123; protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess()&#123; return this.hasDataToProcess; &#125; public synchronized void setHasDataToProcess(boolean hasData)&#123; this.hasDataToProcess = hasData; &#125;&#125; 线程A和B获得指向同一个MySignal实例的引用，就可以进行通信。 忙等待由于线程运行的先后顺序不固定，所以我们需要保证B线程在 hasDataToProcess 的值变为 true 之前，一直等待，否则就会出错。 1234567protected MySignal sharedSignal = ......while(!sharedSignal.hasDataToProcess())&#123; //do nothing... busy waiting&#125; 于是，我们可以这样写，这种等待的方式就叫做忙等待。 ##wait、notify、notifyAll 忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。 Java 里面内置了3个方法允许线程在等待信号的时候变为非运行状态。 java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。 一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify： 123456789101112131415161718192021public class MonitorObject&#123;&#125;public class MyWaitNotify&#123; MonitorObject myMonitorObject = new MonitorObject(); public void doWait()&#123; synchronized(myMonitorObject)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; myMonitorObject.notify(); &#125; &#125;&#125; 当一个线程调用 notify 方法之后，将会从所有等待的线程中随机唤醒一个。 一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()，否则，会抛出IllegalMonitorStateException异常。 不知道你看到上面的话之后，有没有什么想法，如果你是刚接触这方面的内容的话，这里是有个说不通的地方的。 上面说，wait 必须要在同步代码块里面调用，那么它调用完之后，锁还是自己持有，别的线程也没法干啥啊 所以，为了不出现这种bug，wait方法会释放锁。 但是 notify 就不一样的，notify 不会释放锁，需要等待同步代码块执行完才会释放锁。一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。说白了，就是线程被唤醒之后，还需要等待一段时间（等notify的同步代码块执行完）才能退出 wait 方法。 如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。 ##丢失的信号 假如一个线程还没有进入 wait 方法，另一个线程就调用了 nofity 方法，那么就会导致这个线程错失了唤醒的机会。有些时候这没啥，但是在某些情况下，只会唤醒一次，这样这个线程就永远不会醒了。 为了避免这种情况，我们可以将信号保存起来： 123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 这样就不会错失信号了，即使信号在 wait 前发出来。 假唤醒由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，这个是属于底层的问题。 如果上面的例子中出现了假唤醒，那么程序就会出问题，所以我们不能使用 if 判断，而是需要使用 while 来防止假唤醒： 123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 将 wait 写在 while 循环体里面，这样即使发生了假唤醒，由于 wasSignalled 没有更新，所以它仍然会继续进入 wait 状态。 ##不要对常量以及全局对象调用 wait 看下面的例子： 123456789101112131415161718192021222324public class MyWaitNotify&#123; String myMonitorObject = ""; boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 这个例子的问题在于：JVM/编译器内部会把常量字符串转换成同一个对象。 这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。 那么，这会发生什么问题呢？ 首先，即使创建了多个MyWaitNotify实例，它们的锁都是同一把，导致不同实例上的所有的线程竞争同一个锁，这个问题我们就不说了。我们说另外一个问题。 假设，线程B调用了 notify 方法，本来应该是线程A被唤醒，但是由于多个实例使用了同一个锁，所有可能是线程C被唤醒，由于线程C检查了信号的状态，发现它没有被更新，所以对线程C来说，这相当于一次假唤醒。但是对于线程A来说，是信号丢失了。 有的同学说，可以使用 notifyAll 来解决这个问题，但是这对性能不好。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。 所以：在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让 CPU 告诉你硬盘和网络到底有多慢]]></title>
    <url>%2F2019%2F08%2F18%2Fblog_bak%2FBlog%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E8%AE%A9%20CPU%20%E5%91%8A%E8%AF%89%E4%BD%A0%E7%A1%AC%E7%9B%98%E5%92%8C%E7%BD%91%E7%BB%9C%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2%2F</url>
    <content type="text"><![CDATA[经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。 希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。 注：所有的数据都是来自这个地址。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，这个网址给出了不同年份一些指标的数值。 数据 先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 2.6*10^9个指令，每个指令只需要 0.38ns（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 1s，因为 1s 大概是人类能感知的最小时间单位。 一级缓存读取时间为 0.5ns，换算成人类时间大约是 1.3s，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。 分支预测错误需要耗时 5ns，换算成人类时间大约是 13s，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如这个得分非常高的 stackoverflow 问题。 二级缓存时间就比较久了，大约在 7ns，换算成人类时间大约是 18.2s，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。 小知识：为什么需要多层的 CPU 缓存呢？这篇文章通过一个通俗易懂的例子给出了讲解。 我们继续，互斥锁的加锁和解锁时间需要 25ns，换算成人类时间大约是 65s，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。 然后就到了内存，每次内存寻址需要 100ns，换算成人类时间是 260s，也就是4分多钟，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。到了内存之后，时间就变得一个量级，CPU 和内存之间的速度瓶颈被称为冯诺依曼瓶颈。 一次 CPU 上下文切换（系统调用）需要大约 1500ns，也就是 1.5us（这个数字参考了这篇文章，采用的是单核 CPU 线程平均时间），换算成人类时间大约是65分钟，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，这段时间里 CPU 没有做任何有用的计算，只是切换了两个不同进程的寄存器和内存状态；而且这个过程还破坏了缓存，让后续的计算更加耗时。 在 1Gbps 的网络上传输 2K 的数据需要 20us，换算成人类时间是 14.4小时，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。 SSD 随机读取耗时为 150us，换算成人类时间大约是 4.5天。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。I/O 设备 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 memcached 和 redis 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。 从内存中读取 1MB 的连续数据，耗时大约为 250us，换算成人类时间是 7.5天，这次假期升级到国庆七天国外游了。 同一个数据中心网络上跑一个来回需要 0.5ms，换算成人类时间大约是 15天，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。 从 SSD 读取 1MB 的顺序数据，大约需要 1ms，换算成人类时间是 1个月。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，SSD 已经很快啦，不信你看下面机械磁盘的表现。 磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 RPM(Revolutions Per Minute/每分钟转速) 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。 从磁盘读取 1MB 连续数据需要 20ms，换算成人类时间是 20个月。IO 设备是计算机系统的瓶颈，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。 而从世界上不同城市网络上走一个来回，平均需要 150ms（参考世界各地 ping 报文的时间），换算成人类时间是 12.5年。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，CDN 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。 虚拟机重启一次大约要 4s 时间，换算成人类的时间是 3百多年。对于此，我想到了乔布斯要死命优化 Mac 系统开机启动时间的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。 物理服务器重启一次需要 5min，换算成人类时间是 2万5千年，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[0008-线程安全与共享资源]]></title>
    <url>%2F2019%2F08%2F18%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0008-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[我们知道竟态条件指的是多个线程访问共享资源需要依赖线程的执行顺序，说白了就是计算的结果依赖线程的执行顺序，线程顺序OK才能到正确的结果。一份代码到底是否线程安全，需要看它是否有共享资源。那么线程会共享哪些资源呢？通常，我们的资源一般都是 文件，数据库，图片等，或许还有其他的，但是不管他们都是什么，在Java里面都是用一个变量表示。即我们只需要分析代码里面有哪些共享变量就好了。 变量分为局部变量与成员变量。 局部变量局部变量存储在线程自己的栈中。 局部变量也有两种：基本类型与类类型。 基本类型基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子： 123456public void someMethod()&#123; long threadSafeInt = 0; threadSafeInt++;&#125; 类类型对象的局部引用与基本类型不一样。它虽然本身没有被共享，但引用所指的对象并没有存储在线程的栈内，而是在共享堆中。 其实，只要别的线程获取不到这个类类型，它也是线程安全的。 下面是一个线程安全的局部引用样例： 12345678910public void someMethod()&#123; LocalObject localObject = new LocalObject(); localObject.callMethod(); method2(localObject);&#125;public void method2(LocalObject localObject)&#123; localObject.setValue("value");&#125; 样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。 每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。 因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。 即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。 当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了，但是它在 someMethod 这个方法中还是线程安全的。 成员变量对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例： 1234567public class NotThreadSafe&#123; StringBuilder builder = new StringBuilder(); public add(String text)&#123; this.builder.append(text); &#125; &#125; 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如： 12345678910111213141516NotThreadSafe sharedInstance = new NotThreadSafe();new Thread(new MyRunnable(sharedInstance)).start();new Thread(new MyRunnable(sharedInstance)).start();public class MyRunnable implements Runnable&#123; NotThreadSafe instance = null; public MyRunnable(NotThreadSafe instance)&#123; this.instance = instance; &#125; public void run()&#123; this.instance.add("some text"); &#125;&#125; 注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。 当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子： 12new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start(); 现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。 线程控制逃逸规则根据我们上面所说的，如果我们把一个变量控制在线程之内，让别的线程无法访问，那么就不会有多线程问题了。 那么我们如何判断这个变量是否是被控制在线程之内的？下面就说一下判断规则。 12如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。 即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。 比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的（这里其实就是违反了上面的规则–没有在线程内创建资源，我们只是持有了这个资源的引用）。比如，2个线程执行如下代码： 1检查记录X是否存在，如果不存在，插入X 如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录： 1234线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X 同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
</search>
