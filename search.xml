<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Annotation Processor 的应用]]></title>
    <url>%2F2019%2F09%2F29%2Fblog_bak%2FBlog%2FJava%2FAnnotation-Processor-%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[作为一个程序员，每天的生活都是平淡而且枯燥。先开需求会，再来画界面。画着画着，突然感觉有点不对劲，以前画个界面不应该这么麻烦的，不知道是不是错觉，感觉使用了 ConstraintLayout 之后，画个界面越来越慢了。说到这里不得不吐槽一下，ConstraintLayout 虽然减少 了层级，但是阅读单独上升了不少，特比是对于刚接触的人来说，一个那么复杂的布局，就一层，里面十几个控件，位置乱放，毫无顺序，你要是不点一下右边的预览视图来看看它们之间的关系，根本看不懂。真希望谷歌出一个容器，将子控件可以包一下，但是却不参加编译。 画完了界面，就要开始写逻辑，有网络请求的页面，比如详情页面，应该还是要保存一下请求详情接口的 id 才行。 DetailActivity于是就有了下面的代码： 12345678910111213141516 // handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。@Override protected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); if (savedInstanceState != null) &#123; mId = savedInstanceState.getLong(KEY_ID); &#125; else if (intent != null) &#123; mId = intent.getLongExtra(KEY_ID, -1L); &#125; &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putLong(KEY_ID, mId); &#125; 这都不知道是我多少次写这样的代码了，写完之后，终于受不了了，先将需求（不多）抛在一遍，想办法将这些重复的东西搞一搞。 BaseActivity首先，将 if - else if 封装一下再说，于是 Base 里面就多了一些下面的方法： 123456789101112protected int getSavedInt(Intent intent, Bundle savedInstanceState, String key) &#123; return getSavedInt(intent, savedInstanceState, key, 0);&#125;protected int getSavedInt(Intent intent, Bundle savedInstanceState, String key, int defaultValue) &#123; if (savedInstanceState != null) &#123; return savedInstanceState.getInt(key, defaultValue); &#125; else if (intent != null) &#123; return intent.getIntExtra(key, defaultValue); &#125; return defaultValue;&#125; 这里只列出了针对 int 的，当然还有其他类型的，按需添加。 SavedFieldHandler但是再一想，这个玩意虽然只在 Activity 里面用到，但是抽成一个工具类会不会更好一点，于是就有了一个工具类： SavedFieldHandler 将 Base 里面添加的方法，改为 public static 的，放入工具类： 123456789101112public static int getSavedInt(Intent intent, Bundle savedInstanceState, String key) &#123; return getSavedInt(intent, savedInstanceState, key, 0);&#125;public static int getSavedInt(Intent intent, Bundle savedInstanceState, String key, int defaultValue) &#123; if (savedInstanceState != null) &#123; return savedInstanceState.getInt(key, defaultValue); &#125; else if (intent != null) &#123; return intent.getIntExtra(key, defaultValue); &#125; return defaultValue;&#125; DetailActivity于是，我们的 Activity 里面的代码，就变成了这样： 123456789101112 // handleIntent 是在 Base 里面稍微封装了一下的，可以忽略，当作是在 onCreate 里面就好了。@Override protected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); SavedFieldHandler.getSavedLong(intent, savedInstanceState, KEY_ID, 0L); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putLong(KEY_ID, mId); &#125; 看起来舒服了一点，但是每次复写这两个方法也很烦。再仔细观察一下这两个方法，其实就是 key 不一样，然后由于储存的类型不一样，所以调用的 get put 方法名也不一样。 那么，如果将这两个方法往上浮到 BaseActivity 里面，需要做一些什么呢？ 我们需要知道 字段的值，与字段对应的 KEY。那么怎么才能获取这两个东西呢？想一下，似乎直接获取有点难度，那么加点辅助信息呢，比如说注解，我们定义一个这样的注解： SaveField 12345public @interface SaveField &#123; String key() default ""; String defaultValue() default "";&#125; key() 方法表示 字段对应的 KEY。defaultValue() 方法表示 字段的值。然后我们使用反射可以获取被该注解修饰的字段的值，嗯，完美。 当我准备开始写代码的时候，突然感觉哪里不对劲，值有问题，如果我是一个 long 型的变量的话，那岂不是还需要调用 Long.parseLong 方法转一下，而且，我们写 long 型值的时候，都习惯添加一个 L 在后面的，比如：long x = 3L; ，为了兼容这样的情况，我特么不是要做的判断更多了。 想到长痛不如短痛，多做几个判断就多做几个吧。我灵光一现，既然一个注解搞不定，那多搞几个注解不就好了，于是下面的注解就出现了： FloatSavedField 1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface FloatSavedField &#123; String key() default ""; float defaultValue() default 0f;&#125; Retention 一定要是 RetentionPolicy.RUNTIME，因为要在反射的时候获取。 类似的还有 IntSavedField 等等，都是一样的代码，就不说了。 定义好了注解之后，我们就可以开始写 BaseActivity 的逻辑了。 BaseActivity BaseActivity 123456789101112@Overrideprotected void handleIntent(Intent intent, Bundle savedInstanceState) &#123; super.handleIntent(intent, savedInstanceState); // 收集注解标识的字段 Field[] declaredFields = this.getClass().getDeclaredFields(); for (Field declaredField : declaredFields) &#123; declaredField.setAccessible(true); Annotation[] annotations = declaredField.getAnnotations(); injectField(annotations, declaredField, intent, savedInstanceState); &#125;&#125; 这里就是遍历所有的字段。 12345678910111213141516171819private void injectField(Annotation[] annotations, Field field, Intent intent, Bundle savedInstanceState) &#123; try &#123; for (Annotation annotation : annotations) &#123; Class&lt;?&gt; type = field.getType(); if (annotation instanceof IntSavedField) &#123; if (type != int.class &amp;&amp; type != Integer.class) &#123; throw new IllegalArgumentException("字段类型与注解类型不匹配"); &#125; IntSavedField savedField = (IntSavedField) annotation; int defaultValue = savedField.defaultValue(); String key = savedField.key(); field.set(this, SavedFieldHandler.getSavedInt(intent, savedInstanceState, key, defaultValue)); mSavedFieldMap.put(field, savedField); &#125; else if (...) &#123;...&#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 看看字段上是否有我们定义的注解，如果有的话，将注解里面定义的 KEY 取出来，然后使用 SavedFieldHandler 去获取传递过来的值，最后设置到该字段里面。 mSavedFieldMap 是将有指定注解修饰的字段保存一下，以免在 onSaveInstanceState 又要重新遍历一下所有字段。 在 onSaveInstanceState 里面： 12345678910111213141516@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); try &#123; Set&lt;Map.Entry&lt;Field, Annotation&gt;&gt; entrySet = mSavedFieldMap.entrySet(); for (Map.Entry&lt;Field, Annotation&gt; entry : entrySet) &#123; Field key = entry.getKey(); Annotation value = entry.getValue(); if (value instanceof IntSavedField) &#123; outState.putInt(((IntSavedField) value).key(), (Integer) key.get(this)); &#125; else if(...) &#123;...&#125; &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125;&#125; 这里的逻辑，也很简单，从字段里面取出值，然后储存到 outState 里面就好了。 运行一下demo，可以正常运行。但是这个 BaseActivity 里面的代码就不太好看了，是因为这两个方法里面有太长的 if - else if 了，那怎么解决呢？回想一下《重构》这本书，抽一个接口就好了： SavedFieldHandler 1234567public interface SavedFieldHandler&lt;T extends Annotation&gt; &#123; void injectField(T annotation, Object target, Field field, Intent intent, Bundle savedInstanceState); void saveField(Bundle outState, Object target, Field key, T annotation);&#125; 然后分别为各种类型写一个实现： DoubleHandler 123456789101112131415161718192021public class DoubleHandler implements SavedFieldHandler&lt;DoubleSavedField&gt; &#123; @Override public void injectField(DoubleSavedField annotation, Object target, Field field, Intent intent, Bundle savedInstanceState) &#123; double defaultValue = annotation.defaultValue(); String key = annotation.key(); try &#123; field.set(target, SavedFieldHandler.getSavedDouble(intent, savedInstanceState, key, defaultValue)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void saveField(Bundle outState, Object target, Field key, DoubleSavedField annotation) &#123; try &#123; outState.putDouble(annotation.key(), (Double) key.get(target)); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再次重构 BaseActivity 的代码： 123456789101112131415161718192021222324252627282930313233private fun handleIntent(intent: Intent, savedInstanceState: Bundle?) &#123; val s = System.nanoTime() val declaredFields = this.javaClass.declaredFields for (declaredField in declaredFields) &#123; declaredField.isAccessible = true val annotations = declaredField.annotations for (annotation in annotations) &#123; val handler = HandlerFactory.get(annotation) if (handler != null) &#123; handler.injectField(annotation, this, declaredField, intent, savedInstanceState) mSavedFieldMap[declaredField] = annotation &#125; &#125; &#125; Log.e(TAG, "获取耗时" + ((System.nanoTime() - s) / 1000000.0).toString() + "毫秒")&#125;override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) val s = System.nanoTime() val entrySet = mSavedFieldMap.entries for (entry in entrySet) &#123; val key = entry.key val value = entry.value HandlerFactory.get(value)?.saveField(outState, this, key, value) &#125; Log.e(TAG, "保存耗时" + ((System.nanoTime() - s) / 1000000.0).toString() + "毫秒")&#125; 嗯，这次看起来就舒服多了。运行一下，看看耗时情况，结果如下： 12获取耗时第一次为 2-3 毫秒，再次运行在 0.5 毫秒左右保存耗时 为 0.2 ~ 0.3 毫秒左右 结果还是可以接收的。 在写完之后，又想了想，如果我不使用反射，那么耗时情况是怎么样的呢？既然不能使用反射，那么还要能给变量赋值与获取值，这咋办呢？给变量赋值…，ButterKnife 不就是给变量赋值，ButterKnife 的工作原理这里还是简单描述一下哈： 12345678我们有一个目标类：SbActivity，它在 com.sb 包下。我们使用注解处理器生成一个类 SbActivity_ViewBinding，也让它生成到 com.sb 包下面给 SbActivity_ViewBinding 类搞一个构造函数，构造函数有两个参数：第一个参数是 SbActivity，第二个参数是 SbActivity 的根 view这样，我们可以在 SbActivity_ViewBinding类中拿到 SbActivity 的所有非私有变量，就可以给这个变量设置值，获取它的值 了解了它的工作原理，这完全和我们的需求一摸一样啊，所以，我们直接按照 ButterKnife 来设计我们的结构。 SaveHelper首先，我们需要一个工具类，它的作用与 ButterKnife 类一样，提供一个 bind 方法，返回一个 UnBinder 对象，这里我们另起一个方法名： SaveHelper 1234@UiThreadfun get(target: Activity, intent: Intent?, savedInstanceState: Bundle?): SaveUnbinder &#123; return createBinding(target, intent, savedInstanceState)&#125; 这个方法的逻辑，都不用我们自己想，直接从 ButterKnife 里面 copy 出来用就好了。 123456789101112131415161718192021222324fun createBinding(target: Activity, intent: Intent?, savedInstanceState: Bundle?): SaveUnbinder &#123; val targetClass = target.javaClass Log.d(TAG, "Looking up binding for " + targetClass.name) val constructor = findBindingConstructorForClass(targetClass) ?: return EMPTY_UNBINDER //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. try &#123; return constructor.newInstance(target, intent, savedInstanceState) &#125; catch (e: IllegalAccessException) &#123; throw RuntimeException("Unable to invoke $constructor", e) &#125; catch (e: InstantiationException) &#123; throw RuntimeException("Unable to invoke $constructor", e) &#125; catch (e: InvocationTargetException) &#123; val cause = e.cause if (cause is RuntimeException) &#123; throw cause &#125; if (cause is Error) &#123; throw cause &#125; throw RuntimeException("Unable to create binding instance.", cause) &#125;&#125; 这个方法，就是根据我们的 Activity，创建 Activity_ViewBinding 的一个对象，因为我们使用注解处理器创建的类的构造函数是有两个参数的，这里使用反射创建 Activity_ViewBinding 类的实例。 1234567891011121314151617181920212223242526272829303132333435363738394041@Nullable@CheckResult@UiThreadfun findBindingConstructorForClass(cls: Class&lt;*&gt;): Constructor&lt;out SaveUnbinder&gt;? &#123; var bindingCtor: Constructor&lt;out SaveUnbinder&gt;? = BINDINGS[cls] if (bindingCtor != null) &#123; Log.d(TAG, "HIT: Cached in binding map.") return bindingCtor &#125; val clsName = cls.name if (clsName.startsWith("android.") || clsName.startsWith("java.")) &#123; Log.d(TAG, "MISS: Reached framework class. Abandoning search.") return null &#125; try &#123; val bindingClass = cls.classLoader?.loadClass(clsName + "_FieldSaving") bindingCtor = bindingClass?.getConstructor( cls, Intent::class.java, Bundle::class.java ) as Constructor&lt;out SaveUnbinder&gt; Log.d(TAG, "HIT: Loaded binding class and constructor.") &#125; catch (e: ClassNotFoundException) &#123; Log.d(TAG, "Not found. Trying superclass " + cls.superclass?.name) cls.superclass?.apply &#123; bindingCtor = findBindingConstructorForClass(this) &#125; &#125; catch (e: NoSuchMethodException) &#123; throw RuntimeException("Unable to find binding constructor for $clsName", e) &#125; bindingCtor?.apply &#123; BINDINGS[cls] = this &#125; return bindingCtor&#125; 这里是寻找 Activity_ViewBinding 这个类，然后加载这个类，获取它的 Constructor 并返回。 bindingCtor 缓存了对应的 Constructor 。 这里为了加以区分，我们注解处理器生成的类，后缀叫 _FieldSaving。 SaveUnbinderSaveUnbinder 对象的生成解决了，那么这个接口应该有哪些方法呢？ 123456789interface SaveUnbinder &#123; @UiThread fun save(outState: Bundle) @UiThread fun unbind()&#125; 这个接口的定义还是很简单的。 BaseActivity那么我们的 BaseActivity 就可以这样写了： 1234567891011121314151617181920212223242526272829abstract class BaseActivity2 : AppCompatActivity() &#123; companion object &#123; const val TAG = "BaseActivity2" &#125; private lateinit var saveUnbinder: SaveUnbinder override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val s = System.nanoTime() saveUnbinder = get(this, intent, savedInstanceState) Log.e(TAG, "获取花费了 $&#123;(System.nanoTime() - s) / 1000000.0&#125; 毫秒") &#125; override fun onSaveInstanceState(outState: Bundle) &#123; super.onSaveInstanceState(outState) val s = System.nanoTime() saveUnbinder.save(outState) Log.e(TAG, "保存花费了 $&#123;(System.nanoTime() - s) / 1000000.0&#125; 毫秒") &#125; override fun onDestroy() &#123; super.onDestroy() saveUnbinder.unbind() &#125;&#125; 这个看起来就更舒服了。 接下来，就只需要搞定注解生成对应的类就好了，注解处理器，就不说了，主要是 JavaPoet 的使用，它生成的类应该如下： 1234567891011121314151617181920212223242526public final class MainActivity_FieldSaving implements SaveUnbinder &#123; MainActivity target; public MainActivity_FieldSaving(MainActivity activity, Intent intent, Bundle bundle) &#123; this.target = activity; this.target.testL = IntentHandlerKt.getSavedLong(intent, bundle, "testL", 71L); this.target.testS = IntentHandlerKt.getSavedString(intent, bundle, "testS", "74"); this.target.testD = IntentHandlerKt.getSavedDouble(intent, bundle, "testD", 7.3D); this.target.testI = IntentHandlerKt.getSavedInt(intent, bundle, "testI", 70); this.target.testF = IntentHandlerKt.getSavedFloat(intent, bundle, "testF", 7.2F); &#125; @Override public void save(Bundle outState) &#123; outState.putLong("testL", this.target.testL); outState.putString("testS", this.target.testS); outState.putDouble("testD", this.target.testD); outState.putInt("testI", this.target.testI); outState.putFloat("testF", this.target.testF); &#125; @Override public void unbind() &#123; this.target = null; &#125;&#125; 嗯，这样就搞定了。 最后将这些类分开，我们新建 3 个不同作用的 Module： 123save-api 用于存放给外部使用的类save-annotation 用于存放需要处理的注解save-processor 用于处理注解 运行 demo，却报了一个错，报的是字段不能是私有的，这个是我在注解处理器里面输出的错误，可是这就奇怪了啊，我的字段不是私有的啊，经旁边同事的提醒，查看一下它的 byteCode，果然是私有的，原来是 Kotlin 搞的鬼，它为字段生成了公有的 get set 方法，所以变量是私有的了。那这可咋办呢？我去翻了一下 ButterKnife 的注解处理器，它也没有处理这种情况。看来 Java 的注解处理器来兼容 Kotlin，是用前朝的剑来斩本朝的官啊。不过听说又有一个 KotlinPoet，但是还是得分开处理，很麻烦。 本来想着，参考一下 Gson 的代码，看它是怎么处理有 get set 方法的。但是想了想还是算了，感觉这样兼容很脆弱，而且我对 Kotlin 还不太熟，不知道它没有什么注解处理器来兼容 Java。 最后，使用 Java 来写 Activity，测试性能结果： 12获取耗时第一次为 1.7-2.3 毫秒，再次运行在 0.2 毫秒左右保存耗时 为 0.06 毫秒左右 最后额外说一下，由于使用了注解处理器，注解的 Retention 可以改为了 SOURCE。 一个比较令人满意的依赖库就做好了。 项目代码并没有经过严格测试，只是写的有意思，所以分享一下，项目源代码地址如下： https://github.com/aprz512/SaveHelper]]></content>
      <categories>
        <category>AnnotationProcessor</category>
      </categories>
      <tags>
        <tag>Java-AnnotationProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FLeakCanary%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[所有的三方框架里面，LeakCanary 简直是最老的伙伴了，经历的开发项目都用过这个，像网络图片的等加载框架每个项目的选择可能不一样， LeakCanary 一直都在。 可惜的是一直没有去看里面的源码，只是大致的了解了一下，现在想了起来，于是就开了这个系列。 不看不知道，看了是真的舒服。之前一段时间受过 Tangram 代码的摧残，现在看 LeakCanary 的代码就是一种享受。]]></content>
      <categories>
        <category>LeakCanary</category>
      </categories>
      <tags>
        <tag>Android源码解析-LeakCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-监控页面的销毁]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FLeakCanary%2F0002-%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%E7%9A%84%E9%94%80%E6%AF%81%2F</url>
    <content type="text"><![CDATA[使用首先，还是要说一下使用，非常的简单：1234debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3'releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3'// Optional, if you use support library fragments:debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3' 我这里依赖的版本是 1.6.3，所以源码分析也是基于这个版本的。最新的 2.0 版变化也是很大的，但是核心原理差不多，分析原理还是老一点的版本比较好，思路更清晰，逻辑分支更少。 releaseImplementation 表示打 release 版本的时候会依赖这个包。leakcanary-android-no-op 这个依赖包的名字意思也很明显，这个依赖包里面只有两个类，而且类的方法都是空方法，里面啥都不做，因为如果在 release 版也依赖 LeakCanary 的话，用户就会很奇怪了，而且会影响性能。当然你也可以选择在打 release 包的时候将依赖包与相关代码移除，这样就是比较麻烦。 leakcanary-support-fragment 这个依赖包是表示如果你的 Fragment 使用了 support 包里面的 Fragment，那么就应该使用这个依赖包，具体为啥，源码里面分析，这个依赖包里面也就一个类。 监控页面的方法我们想要监控页面（Activity 与 Fragment），需要做如下配置： 12// this 是 Application 对象LeakCanary.install(this); 因为，LeakCanary 会单独开一个进程用来做 .hprof 文件分析，所以需要排除分析进程。 1234567protected void initCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return; &#125; LeakCanary.install(this); BlockCanary.install(this, new AppBlockCanaryHelper()).start();&#125; 里面判断进程的逻辑可以自行去了解一下。 想要监控其他对象，需要做如下配置： 123456789public abstract class BaseService extends Service &#123; @Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = MyApp.getRefWatcher(); // 可以传入任何对象 refWatcher.watch(this); &#125;&#125; 这里使用了 RefWatcher 来监控 Service。同样的，你也可以监控其他对象，比如 Bitmap，数组 等。 如何做到对页面的监控的监控 Activity 比较简单，我们都能想的到，使用 ActivityLifecycleCallbacks 即可。源码里面也是这样实现的。但是 Fragment 是如何监控的呢？？？ 下面，我们开始分析源码。 com.squareup.leakcanary.LeakCanary#install 12345public static @NonNull RefWatcher install(@NonNull Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125; 一个链式调用。 refWatcher 是创建一个 Builder 对象。 listenerServiceClass 是起一个 Service，当然这里还没有真正的启动，只是做了准备工作，因为是 builder 模式，所以至少需要调用 build 后才会启动。 excludedRefs 是排除一些引用，这是啥意思呢，是因为 Android SDK 本身也会导致一些内存泄露问题，所以需要将这些问题排除，显然，这个类会一直更新，我们也可以贡献一下，比如我们会在华为的手机上遇到“键盘导致的泄露的问题”，但是实际上是没有泄露的，别的手机都没有出现过这个问题，而且代码最终到了 SDK 里面。有兴趣的可以去看看这个类 com.squareup.leakcanary.AndroidExcludedRefs。 buildAndInstall 才是核心代码，我们往下看。 com.squareup.leakcanary.AndroidRefWatcherBuilder#buildAndInstall 12345678910111213141516171819public @NonNull RefWatcher buildAndInstall() &#123; if (LeakCanaryInternals.installedRefWatcher != null) &#123; throw new UnsupportedOperationException("buildAndInstall() should only be called once."); &#125; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; if (enableDisplayLeakActivity) &#123; LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); &#125; if (watchActivities) &#123; ActivityRefWatcher.install(context, refWatcher); &#125; if (watchFragments) &#123; FragmentRefWatcher.Helper.install(context, refWatcher); &#125; &#125; LeakCanaryInternals.installedRefWatcher = refWatcher; return refWatcher;&#125; buildAndInstall 这个方法只让调用一次。下面的 3 个if 才是核心。 com.squareup.leakcanary.internal.LeakCanaryInternals#setEnabledAsync先看第一个： 1LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true); 这行代码的作用与桌面启动图标有关系。我们先看依赖库的 AndroidManifest.xml 文件： 1234567891011121314&lt;activity android:name="com.squareup.leakcanary.internal.DisplayLeakActivity" android:enabled="false" android:icon="@mipmap/leak_canary_icon" android:label="@string/leak_canary_display_activity_label" android:process=":leakcanary" android:taskAffinity="com.squareup.leakcanary.$&#123;applicationId&#125;" android:theme="@style/leak_canary_LeakCanary.Base" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 可以看到，这个依赖库里面也设置了一个 LAUNCHER 页，加上我们的 App 也有一个，那么就有两个了启动页了。但是注意这里 activity 的 enable 属性配置的是 false，所以这个启动页图标一开始不会显示，只有调用了 install 方法，执行了 setEnabledAsync 方法才会显示。里面的逻辑较简单就部分析了，注意一下这个方法是异步的，开了一个线程。 com.squareup.leakcanary.ActivityRefWatcher#install第二个 if，这里就是使用 ActivityLifecycleCallbacks。 com.squareup.leakcanary.ActivityRefWatcher#install 123456public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) &#123; Application application = (Application) context.getApplicationContext(); ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher); application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);&#125; 其实就是调用了 Application 的 registerActivityLifecycleCallbacks 方法。核心内容在 ActivityRefWatcher 这个类中。 com.squareup.leakcanary.ActivityRefWatcher 123456private final Application.ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123; @Override public void onActivityDestroyed(Activity activity) &#123; refWatcher.watch(activity); &#125; &#125;; 它有一个成员变量，叫 lifecycleCallbacks，也是上一个方法用到的。ActivityLifecycleCallbacksAdapter 是 ActivityLifecycleCallbacks 的一个空实现，里面啥都没做，只是为了减少无关方法的复写。 所以 ActivityRefWatcher 的作用就是：创建了一个 ActivityLifecycleCallbacks 监听，在 onActivityDestroyed 回调里面，调用了 refWatcher.watch(activity); 这行代码。 最终，还是到了 com.squareup.leakcanary.RefWatcher#watch(java.lang.Object) 这个方法，如果你对前面的代码还有影响，可以发现，我们监控 Service 等对象，也是调用的这个方法。 所以，看了这么多，本质上还是调用了 com.squareup.leakcanary.RefWatcher#watch(java.lang.Object)。只不过一个是在统一的地方调用，一个是手动的一处一处的调用。 com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install这个方法就是实现了 Fragment 的监控。看看它是如何实现的。 com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#install 1234567891011121314151617181920212223242526public static void install(Context context, RefWatcher refWatcher) &#123; List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;(); if (SDK_INT &gt;= O) &#123; fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher)); &#125; try &#123; Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME); Constructor&lt;?&gt; constructor = fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class); FragmentRefWatcher supportFragmentRefWatcher = (FragmentRefWatcher) constructor.newInstance(refWatcher); fragmentRefWatchers.add(supportFragmentRefWatcher); &#125; catch (Exception ignored) &#123; &#125; if (fragmentRefWatchers.size() == 0) &#123; return; &#125; Helper helper = new Helper(fragmentRefWatchers); Application application = (Application) context.getApplicationContext(); application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);&#125; 这个方法里面先是创建了两个 FragmentRefWatcher 对象，一个是 AndroidOFragmentRefWatcher，一个是 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME。 最后，又注册了一个 ActivityLifecycleCallbacks，注意这里的 ActivityLifecycleCallbacks 是 Helper 自己的，看看它做了什么： com.squareup.leakcanary.internal.FragmentRefWatcher.Helper#activityLifecycleCallbacks 12345678private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks = new ActivityLifecycleCallbacksAdapter() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; for (FragmentRefWatcher watcher : fragmentRefWatchers) &#123; watcher.watchFragments(activity); &#125; &#125; &#125;; 其实就是在 Activity 创建完成之后，调用了 FragmentRefWatcher 的方法。上面我们分析过，FragmentRefWatcher 有两个实例对象。 AndroidOFragmentRefWatcher我们先分析 AndroidOFragmentRefWatcher 做了什么。 com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#watchFragments 1234@Override public void watchFragments(Activity activity) &#123; FragmentManager fragmentManager = activity.getFragmentManager(); fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true);&#125; 这里出现了一个我没见过的方法，没想到 Fragment 也能像 Activity 一样注册监听，学到了。同理，我们应该也能猜到，这个监听里面做了什么。 com.squareup.leakcanary.internal.AndroidOFragmentRefWatcher#fragmentLifecycleCallbacks 123456789101112131415private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks = new FragmentManager.FragmentLifecycleCallbacks() &#123; @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) &#123; View view = fragment.getView(); if (view != null) &#123; refWatcher.watch(view); &#125; &#125; @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) &#123; refWatcher.watch(fragment); &#125; &#125;; 这里监控了两个对象，一个是 Fragment 本身，一个是 Fragment 的 rootView。 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME还有一个 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME。 上面的逻辑分析中，如果你看的仔细的话，会发现我们获取 FragmentManager 实例的时候，使用的是 getFragmentManager 方法，而不是 getSupportFragmentManager 方法。就是说，AndroidOFragmentRefWatcher 是针对原生的 Fragment 的，而 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 就应该是针对 support 包里面的 Fragment 的。 还有一个要理解的地方就是，在创建 SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME 实例的时候，使用了反射，这是因为这个 Fragment 需要添加额外的依赖leakcanary-support-fragment，所以才使用的反射。 我们还是看看代码吧： com.squareup.leakcanary.internal.SupportFragmentRefWatcher 123456789101112131415161718192021222324252627282930class SupportFragmentRefWatcher implements FragmentRefWatcher &#123; private final RefWatcher refWatcher; SupportFragmentRefWatcher(RefWatcher refWatcher) &#123; this.refWatcher = refWatcher; &#125; private final FragmentManager.FragmentLifecycleCallbacks fragmentLifecycleCallbacks = new FragmentManager.FragmentLifecycleCallbacks() &#123; @Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) &#123; View view = fragment.getView(); if (view != null) &#123; refWatcher.watch(view); &#125; &#125; @Override public void onFragmentDestroyed(FragmentManager fm, Fragment fragment) &#123; refWatcher.watch(fragment); &#125; &#125;; @Override public void watchFragments(Activity activity) &#123; if (activity instanceof FragmentActivity) &#123; FragmentManager supportFragmentManager = ((FragmentActivity) activity).getSupportFragmentManager(); supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true); &#125; &#125;&#125; 与 AndroidOFragmentRefWatcher 的代码几乎是一样的。]]></content>
      <categories>
        <category>LeakCanary</category>
      </categories>
      <tags>
        <tag>Android源码解析-LeakCanary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler]]></title>
    <url>%2F2019%2F09%2F25%2Fblog_bak%2FBlog%2FAndroid-%E7%9F%A5%E8%AF%86%E7%82%B9%2FHandler%2F</url>
    <content type="text"><![CDATA[ThreadLocal 的工作原理文字版理解 每个线程都有一个 ThreadLocalMap 类型的 threadLocals 属性。 ThreadLocalMap 类相当于一个Map，key 是 ThreadLocal 本身，value 就是我们的值。 当我们通过 threadLocal.set(new Integer(123)); ，我们就会在这个线程中的 threadLocals 属性中放入一个键值对，key 是 这个 threadlocal 自己，value 就是 new Integer(123)。 当我们通过 threadlocal.get() 方法的时候，首先会根据这个线程得到这个线程的 threadLocals 属性，然后由于这个属性放的是键值对，我们就可以根据键 threadlocal 拿到值。 注意，这时候这个键 threadlocal 和 我们 set 方法的时候的那个键 threadlocal 是一样的，所以我们能够拿到相同的值。 源码分析这个类比较简单，我们直接从 java.lang.ThreadLocal#set 这个方法看起： java.lang.ThreadLocal#set 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 在 set 方法的第二行，由一个 getMap 方法获取了 ThreadLocalMap 的一个实例。 java.lang.ThreadLocal#getMap 12345678910/** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 看到了没，这里直接使用的是 Thread 类的变量。 java.lang.Thread 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 所以，我们储存的数据实际上时放入到了 Thread 类的成员变量中。继续深入 ThreadLocalMap 这个类，上面的 set 方法调用它的 set 方法，所以我们直接看它的 set 方法。 java.lang.ThreadLocal.ThreadLocalMap 1234567891011121314151617181920212223242526272829303132private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 看这个代码，思路还是满清晰的。要说一些这个 Entry 类，它是继承了 WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，注意这里是一个弱引用。有一个比较有趣的问题就是：网上有讨论说 ThreadLocal 有可能出现内存泄漏问题，就与它有关系。我们来看一下引用链： ThreadLocal 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; WeakReference -&gt; ThreadLocal value 的引用链：Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value 可以看到，value 是被强引用的，所以如果没有其他对象引用 ThreadLocal 对象的话，ThreadLocal 可能会被回收，但是 value 不会被回收。而且这个时候，我们也没法访问到 value 了。这样就造成了内存泄露。一般的使用方式都是使用 static 的或者手动调用 set null。看看官方的使用方式： android.os.Looper 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 回到正题，分析 set 方法的流程：首先，利用 key 的 hashCode 获取索引值，然后查看索引值执行的位置有没有数据，没有数据就创建一个新的放进去，有的话，就比较 key ，key一样就直接替换 value 的值，key不一样就看下一个位置的值，再比较。 set 方法说完了，我们在看看 get 方法。 java.lang.ThreadLocal#get 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 了解了 set 方法，get 方法其实就是反过来的，与 set 的思路一样，由于 key 始终是自己（ThreadLocal&lt;?&gt;），所以总能取到正确的值。这里还有一个 setInitialValue 方法，它默认返回null，就是没有设置初始值的时候，就会触发这个方法，我们可以复写这个方法，返回一个默认值。 ThreadLocal 的大致原理就说完了，再说一下它的一般用法：第一个比较普通，就是通过它来储存线程中的数据，只有当前线程可以获取到，其他线程获取的是另一份自己的数据。第二个使用场景是复杂逻辑下的对象传递，比如监听器的传递，有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程，这个时候可以怎么做呢？其实这个时候就可以采用 ThreadLocal，让监听器作为线程内的全局对象，在线程内部只要通过get方法就可以获取到监听器。如果不采用这种方式，那么一般会使用参数的传递或者使用静态变量。使用参数传递的话，如果方法调用栈不深还可以接收，如果调用栈很深，代码看起来就很糟糕了。使用静态变量的话，多个线程就难以维护了。 消息队列这里不会走源码了，最多给个图。我只是梳理一下以前没有注意到的东西。 在讨论这个主题之前，我们先来认识一下GUI的单线程模型，嗯，想来了解一下问什么。现代的 GUI 框架使用的模型：创建一个专门的线程，事件派发线程（event dispatch thread，RDT）来处理 GUI 事件。 有很多人都试图写出多线程的GUI框架，最终都由于竞争条件和死锁导致的稳定性问题，又回到了单线程化的事件队列模型的老路上来。多线程的GUI框架会尤其易受死锁的影响，部分原因在于： 用户发起的动作总会冒泡似的从操作系统传递给应用程序。先是由os检测到一次鼠标点击，然后工具集把它转化为“鼠标点击”事件，最终它会作为一个高层事件（比如“buttonpressed”事件）转发给应用程序的监听器。 另一方面，应用程序发起的动作又会以冒泡的形式传回操作系统。应用程序发起一个动作要改变某个组件的背景颜色，这会被转发给一个特定的组件类，最终转发给os进行渲染。两种动作以完全相反的顺序访问相同的GUI对象，需要保证让每一个对象都是线程安全的，这会导致一系列的锁顺序的不一致，这会直接引发死锁。 虽然，单线程模式比较简单，但是单线程消息队列机制存在一个问题： 消息响应函数中不能有耗时长的、计算密集型的操作，因为主线程在努力地处理这样的操作的时候就无法去处理其它的积压在消息队列中的绘制消息、事件消息了（一个消息处理完了主线程才会去队列中取下一个消息），这时候就会出现按键无响应、点击无反应的情况。 但这个问题有完美的解决方案，我们可以在消息响应函数中启动另一个工作线程（Worker Thread）来执行耗时操作，这样在线程启动起来后这个消息就算处理完了，主线程可以取下一个消息了，这时候主线程和还未执行完计算任务的工作线程就在操作系统的调度下并驾齐驱地狂奔了（调度算法会保证两个线程并发或并行地执行，不会专宠某个线程）。 Android 中也是采用的单线程消息队列，它是使用 Hanlder 来处理线程之间的消息传递的。一般我们在耗时任务执行完后还要更新界面展示计算的结果，正确的处理办法是将耗时任务改为异步通知机制，即工作线程向消息队列中添加消息以通知主线程耗时任务完成了，这样主线程在启动工作线程后就不需要主动地去调查任务的进展了。 了解了为什么，现在我们从几个问题来入手消息队列的运作过程。 消息是如何延迟发送的？不同的延时长度的消息是如何排序的？ 没有消息时，MessageQueue 在干什么，Looper在做什么？从没有消息到有消息，MessageQueue 是如何被唤醒的？ Message 分发的3种渠道？ Looper是死循环，为什么 UI 线程不会ANR? IdleHandler 是什么? 异步消息与同步屏障了解不？ 延时消息放入Message时会根据msg.when这个时间戳进行顺序的排序,如果非延迟消息则msg.when为系统当前时间，延迟消息则为系统当前时间+延迟时间(如延迟发送3秒则为：SystemClock.uptimeMillis() + 3000)。 Message放入MessageQueue时会以msg.when对msg进行排序确认当前msg处于单链表中的位置,分为几种情况: 头结点为null(代表MessageQueue没有消息),Message直接放入头结点。 头结点不为null时开启死循环遍历所有节点 遍历出的节点的when大于放入message的when(说明当前message是一个比放入message延迟更久的消息，将放入的Message放入当前遍历的Message节点之前)。 遍历出的节点的next节点为null(说明当前链表已经遍历到了末尾，将放入的Message放入next节点)。 android.os.MessageQueue#enqueueMessage 12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; // 退出循环 if (mQuitting) &#123; ... msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 没有其他消息，把它作为头结点 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; // 根据时间来寻找节点的位置 if (p == null || when &lt; p.when) &#123; break; &#125; // 异步消息与屏障的处理，后面会说到 if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; ... &#125; return true;&#125; 消息队列的阻塞与唤醒对于消息队列而言，从里面取出消息需要考虑多个方面： 如果队列为空了，或者队列里面的消息没有可以取出的消息（时间都没到），那么应该阻塞消息队列。阻塞肯定不能用一般的方式，如果像流一样，直接阻塞了线程，浪费CPU，导致 ANR，那肯定是不行的，所以应该怎么办呢？ 阻塞需要阻塞多长时间呢？怎么保存这个时间？ 这个比较简单，message 有个 when 字段保存了时间，由于 message 是排序了的，所以只需要去头部的 message 的 when 用来计算就好了。 阻塞后如何唤醒？ 我们根据代码来分析： android.os.MessageQueue#next 123...nativePollOnce(ptr, nextPollTimeoutMillis);... nativePollOnce 这个方法是一个 native 方法，它就是用来阻塞消息队列的，nextPollTimeoutMillis 就是阻塞的时间。在说明这个方法做了什么之前，我们需要先了解一下 epoll 是什么！ epoll首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？ 阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。 非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？” 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉，这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”。 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。 于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）： 123456while true &#123; for i in stream[]; &#123; if i has data read until unavailable &#125;&#125; 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流。代码长这样： 1234567while true &#123; select(streams[]) for i in streams[] &#123; if i has data read until unavailable &#125;&#125; 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了。 epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。 一个epoll模式的代码大概的样子是： 123456while true &#123; active_stream[] = epoll_wait(epollfd) for i in active_stream[] &#123; read or write till &#125;&#125; 前文我们已经说过，next()中调用的nativePollOnce()起到了阻塞作用，保证消息循环不会在无消息处理时一直在那里“傻转”。那么，nativePollOnce()函数究竟是如何实现阻塞功能的呢？ 其实是在 C++ 层的 Looper 的构造函数中，其内部除了创建了一个管道以外，还创建了一个epoll来监听管道的“读取端”。也就是说，是利用epoll机制来完成阻塞动作的。每当我们向消息队列发送事件时，最终会间接向管道的“写入端”写入数据，于是epoll通过管道的“读取端”立即就感知到了风吹草动，epoll_wait()在等到事件后，随即进行相应的事件处理。这就是消息循环阻塞并处理的大体流程。当然，因为向管道写数据只是为了通知风吹草动，所以写入的数据是非常简单的“W”字符串。 分发优先级当遍历出Message后Message会获取其中的Handler并调用Handler的dispatchMessage进行分发,这时也会有三个优先级。 android.os.Handler#dispatchMessage 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Message的回调方法：message.callback.run()，优先级最高； 对应handler.post(new Runnable)的方式发送消息。 Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于上面； 对应新建Handler时传进CallBack接口 1Handler handler=new Handler(new Handler.Callback()); 通常我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息，场景如：Hook ActivityThread.mH，在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。 Handler的默认方法：Handler.handleMessage(msg)，优先级最低。对应新建Handler并复写handleMessage方法。 Looper 的死循环我们知道Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper的控制之下，如果它停止了，应用也就停止了。 真正的阻塞是因为轮询出message后在处理message消息的时候由于执行了耗时操作导致了ANR，而不是死循环导致的阻塞，没有消息处理的时候消息队列是阻塞在nativePollOnce方法中的，这个方法使用的是epoll管道机制，Linux底层执行后会释放CPU避免不断死循环造成的CPU浪费。 IdleHandler 是什么简而言之，IdleHandler 是一个接口，就是在looper里面的message暂时处理完了，这个时候会回调这个接口，返回false，那么就会移除它，返回true就会在下次message处理完了的时候继续回调。 IdleHandler 可以用来提升提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情（譬如UI线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。 当从消息链中取消息的时候，如果取到的消息还未到执行的时间或者没有取到消息，那么就会触发 IdleHandler （当然前提是你设置了），需要注意的是，这个回调只会执行一次，嗯，意思是如果在 5s 内，都没有消息需要处理，在这 5s 内，只会调用一次，而不会不断的调用。 android.os.MessageQueue#next 12// Reset the idle handler count to 0 so we do not run them again.pendingIdleHandlerCount = 0; 可以看到，调用一次之后，就将 count 设置为 0，下次就不会调用了，直到再次触发 next 方法。 可以看一下这篇文章的使用。 同步分割栏所谓“同步分割栏”，可以被理解为一个特殊Message，它的target域为null。它不能通过sendMessageAtTime()等函数打入到消息队列里，而只能通过调用Looper的postSyncBarrier()来打入。 “同步分割栏”是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中摘取消息并进行处理时，一旦遇到这种“同步分割栏”，那么即使在分割栏之后还有若干已经到时的普通Message，也不会摘取这些消息了。请注意，此时只是不会摘取“普通Message”了，如果队列中还设置有“异步Message”，那么还是会摘取已到时的“异步Message”的。 在Android的消息机制里，“普通Message”和“异步Message”也就是这点儿区别啦，也就是说，如果消息列表中根本没有设置“同步分割栏”的话，那么“普通Message”和“异步Message”的处理就没什么大的不同了。 将普通消息变成异步消息，只需要调用一个方法就可以啦： android.os.Message#setAsynchronous 1234567public void setAsynchronous(boolean async) &#123; if (async) &#123; flags |= FLAG_ASYNCHRONOUS; &#125; else &#123; flags &amp;= ~FLAG_ASYNCHRONOUS; &#125;&#125; 参考文档带你真正攻克Handler 聊一聊Android的消息机制 我读过的最好的epoll讲解–转自”知乎“]]></content>
      <tags>
        <tag>Android-知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0030-队列的链式储存结构以及实现]]></title>
    <url>%2F2019%2F09%2F22%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0030-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[上一篇说了循环队列，但是由于是基于数组的，所以它还是会有溢出问题，为了改善这个问题，所以了解一下它的链式储存还是有必要的。 虽然我们常用的 ArrayList 一看就知道是使用的数组，但是它实现了扩容，所以解决了溢出问题。而且我们一般只使用 add 方法，很少使用 remove 方法，所以元素的移动也很少。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0029-循环队列]]></title>
    <url>%2F2019%2F09%2F20%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0029-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[顺序结构的储存方式的最大不足就是：对头的元素移除的时候，需要将队列中的每一个元素向前移动一格。为了避免每次移动，所以想出了循环队列的结构。我们按照下面的方式来定义循环队列：上面的这个图表示空的循环队列，front 指向队头，rear指向队尾。front 与 rear 相等表示队列为空。那么我们需要思考一个问题。当队列满了的时候，front 与 rear 的关系是什么样的？看下面的这个图： 可以看到在这种情况下，a1 与 a3 被从队头移除，又添加了 a6 与 a7，front 与 rear 也是相等的，那么就分不清了队列到底是满还是空的了。我们可以额外加一个辅助条件来帮助我们判断队列是满还是空，但是这里我们介绍另外一种方式：我们最多只存放 SIZE-1 个元素，如下图： front 与 rear 之间始终隔了一个，这样我们认为队列满了，虽然这样浪费了一个格子，但是使用起来却非常的方便，因为 front 与 rear 始终满足这样的一个关系： 1(rear + 1) % SIZE = front 下面，我们来使用代码来实现它。 队列大小123public int size() &#123; return (rear - front + SIZE) % SIZE;&#125; 因为 rear 可能比 front 小，所以需要先加上 SIZE，然后再取余。 插入元素1234567public void inQueue(T e) &#123; if(isFull()) &#123; return; &#125; table[rear] = e; rear = (rear + 1) % SIZE&#125; 删除元素12345678public T deQueue() &#123; if(!inRange(i)) &#123; return; &#125; T result = table[front]; front = (front + 1) % SIZE; return result;&#125; 删除与插入都很简单，因为是数组所以需要考虑的东西不多。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0028-队列]]></title>
    <url>%2F2019%2F09%2F19%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0028-%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列在生活中很常见了，几乎做什么都要排列，食堂打饭，取票厅取票，地铁进站等等。想象一下我们排队的时候是如何行动的，在队伍的尾部开始排队，然后慢慢向前移动，最后到了队伍的头部，搞完事情之后就可以走了。每次排特别长的队伍总是很烦躁的，因为很浪费时间，而且限制了自由，这相当于是一种顺序储存方式。那么既然有顺序储存方式也就有链式储存，再想一下，当我们在银行或者医院排队的时候，是不是需要先取号，然后就不用排队了，只需要找个位置坐下来，然后等着叫号就行了，这其实就是一种链式储存方式，每个排队的人可以随意的坐在任何位置，当队伍最前面的事情被处理完之后，排队的人也不需要移动。 下面，我们分别来说明顺序储存与链式储存，由于顺序储存与链表的顺序储存基本是一样的，所以这里就不再介绍了。我们说一个比较特殊的队列——循环队列。下篇见。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-View的层次]]></title>
    <url>%2F2019%2F09%2F18%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0003-View%E7%9A%84%E5%B1%82%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[前面我们说到，RecyclerView 的 view 不是在一个层次的。比如 FixView 就显示在最顶层。需要理解的是，这里的 layer 与 canvas 的 layer 比较类似，虽然分了层次，但是实际上是一个先绘制一个后绘制导致的，后绘制的 view 会盖在先绘制的 view 的上面。比如，我们写一个 FrameLayout，它又两个 child： 1234567891011121314151617181920212223242526&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/border_bg"&gt; &lt;TextView android:id="@+id/title" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/item_background" android:gravity="center" android:textColor="#999999" android:textSize="22sp" android:textStyle="bold"/&gt; &lt;TextView android:id="@+id/title2" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/item_background" android:gravity="center" android:textColor="#999999" android:textSize="22sp" android:textStyle="bold"/&gt;&lt;/FrameLayout&gt; 在显示这个布局的时候，显然下面的 TextView 会覆盖在上面的 TextView 上，这个是因为 ViewGroup 使用数组保存了所有的 child。 android.view.ViewGroup 12// Child views of this ViewGroupprivate View[] mChildren; 在绘制 child 的时候，是遍历的各个 child： android.view.ViewGroup#dispatchDraw 123for (int i = 0; i &lt; childrenCount; i++) &#123; drawChild(canvas, child, drawingTime);&#125; 由于都是在同一个画布上作画，先绘制的自然看起来是在下面，所以就有了一个层次效果。 同时，有一个需要特别注意的地方，就是要想 child 在最上面，显然在 addView 的时候，需要传递 index 为 -1，这样就会添加到最后面（当然不传递也是默认为 -1）。 好的，了解了这个我们再来看 com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView 这个方法做了什么： com.alibaba.android.vlayout.VirtualLayoutManager#addFixedView 123456@Overridepublic void addFixedView(View view) &#123; showView(view); addView(view, -1); hideView(view);&#125; 上面的不是原来的代码，但是与原来的代码是等价的，看起来会更容易理解一点。 showView 方法，我们已经说过了，是使用 ChildHelper 设置了一个标识。 addView 方法，这里可以理解为向 RecyclerView 中添加了一个 view。 hideView 方法，使用 ChildHelper 设置了一个标识，标识这个 view 无法被找到。 hideView 这个方法的作用并不是说对我们隐藏了这个 view，而是对 LayoutManager 来说，隐藏了这个 view。这是什么意思呢？具体可以看这两篇文章（是一个在 Android Framework 组工作的大佬写的）： http://www.birbit.com/recyclerview-animations-part-1-how-animations-work http://www.birbit.com/recyclerview-animations-part-2-behind-the-scenes 我说一下我自己的理解，可能理解的不准确。 我们的列表上有 A B D E 四个元素，这个时候在 B D 之间准备添加一个 C，当我们添加了数据，调用 notifyxxx 之后，Adapter 中的数据就立刻是最新的了，但是这个时候 LayoutManager 中的数据仍然是没有发生变化的，为什么呢？这个是因为 RecyclerView 的动画导致的。因为 RecyclerView 要显示一个添加动画，而这个动画需要两个布局才能完成，一个添加之前的布局（pre-layout），一个添加之后的布局(post-layout)，将这个两个布局进行对比，才有可能执行正确的动画。 当 pre-layout 完成之后，Adapter 中数据的变化才会反应到 LayoutManager 中，然后 post-layout，接着再执行动画。 实际上，LayoutManager 工作的方式是这样的： LayoutManger 保存了可见与不可见的 child，可以认为它与 Adatper 的变化是同步的。 但是它有两套 API，一套用于获取可见的 view，一套用于获取所有的 view。即 pre-layout 获取的是所有的view，post-layout 获取的是可见的 view。 这里所说的可见与不可见都是针对 LayoutManager 的，showView 与 hideView 也是。 如果我们将 hideView 注释掉，就会发现当我们滚动的时候，所有的 child 都会显示出来，界面会变得很卡，这是因为 LayoutManager 知晓了所有的 child，并且每次滚动都会触发 addFixView 方法，所以 LayoutManager 管理的 child 越来越多（都是重复的），自然就会很卡。 如果我们将 showView 注释掉，当我们滚动的时候，会发现 FixView 跑到背景后面去了（VLayoutActivity），至于为什么下面说。 最后再说，addView，这个方法并没有重复添加 view，看下面的逻辑： android.support.v7.widget.RecyclerView.LayoutManager#addViewInt 12345678910111213// ensure in correct positionint currentIndex = mChildHelper.indexOfChild(child);if (index == -1) &#123; index = mChildHelper.getChildCount();&#125;if (currentIndex == -1) &#123; throw new IllegalStateException("Added View has RecyclerView as parent but" + " view is not a real child. Unfiltered index:" + mRecyclerView.indexOfChild(child));&#125;if (currentIndex != index) &#123; mRecyclerView.mLayout.moveView(currentIndex, index);&#125; 可以看到其实只是将 view 重新移动了最后的位置。但是如果我们没有调用 showView 的话，LayoutManager 是不知道有这个 view 的，会导致 currentIndex 为 -1，则抛出异常，从而导致 view 的位置没有移动，则被后面添加的 view 给覆盖了。 啊，终于比较能够说服自己了，解决了心头之恨，当初看了一天，看的几乎快要怀疑自己了。 嗯，再额外说一个东西，就是它的每个 Card 的背景是如何实现的。 先看如何设置背景： 12LinearLayoutHelper layoutHelper1 = new LinearLayoutHelper();layoutHelper1.setBgColor(Color.YELLOW); 这样设置之后，LinearLayoutHelper 对应的 Adapter 管理的所有 View 就都会在同一个背景上，如下图： 这个背景其实是一个 View 实现的，具体看代码吧。 com.alibaba.android.vlayout.layout.BaseLayoutHelper#requireLayoutView 1234@Overridepublic boolean requireLayoutView() &#123; return mBgColor != 0 || mLayoutViewBindListener != null;&#125; 像追踪这样的效果的源码，最好的方法就是直接看哪里用到了相关的变量，这里我们从 bgColor 入手。 com.alibaba.android.vlayout.layout.BaseLayoutHelper#afterLayout 1234if (mLayoutView == null) &#123; mLayoutView = helper.generateLayoutView(); helper.addOffFlowView(mLayoutView, true);&#125; 在 afterLayout 中，这里创建了一个 LayoutView，然后将这个 view 添加到最前头（head 的值为 true）。 这样 LayoutView 就是一个背景了。需要注意的是 LayoutView 的 LayoutParams 必须是对应 LayoutMangager 的 LayoutParams，否则会被替换掉。 com.alibaba.android.vlayout.VirtualLayoutManager#generateLayoutView 1234567891011@Overridepublic final View generateLayoutView() &#123; if (mRecyclerView == null) return null; View layoutView = mLayoutViewFatory.generateLayoutView(mRecyclerView.getContext()); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); attachViewHolder(params, new LayoutViewHolder(layoutView)); layoutView.setLayoutParams(params); return layoutView;&#125; 这里设置的 LayoutParams 是 VirtualLayoutManager.LayoutParams，然后还将 layoutParams 的 mViewHolder 变量赋值了，这个也很重要，否则会报空指针异常，因为这个 view 也添加到了 RecyclerView 中，由 LayoutManager 来管理，需要满足一定的条件。 这里需要理解的是，这个 view 是我们自行添加的，而不是通过 adapter 的流程添加的。 我们再看，如果不使用这个 LayoutParams 会怎样： android.support.v7.widget.RecyclerView.Recycler#bindViewToPosition 1234567891011final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();final LayoutParams rvLayoutParams;if (lp == null) &#123; rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams);&#125; else if (!checkLayoutParams(lp)) &#123; rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams);&#125; else &#123; rvLayoutParams = (LayoutParams) lp;&#125; 可以看到，它会检测 LayoutParams 是否会满足要求，不满足就自己生成了一个，而生成的 LayoutParams 的 mViewHolder 是 null，所以会报空指针异常。 这个问题，我在研究 view 的 generateLayoutParams 的时候就遇到过，知识点串联起来的感觉还是挺爽的。 我自己的测试代码，我想在 FixView 上额外添加一个 Button，见如下代码： 12345678910111213141516171819202122@Overridepublic void addFixedView(View view) &#123; //removeChildView(view); //mFixedContainer.addView(view); addOffFlowView(view, false); if (!t.contains(view)) &#123; Button button = new Button(view.getContext()); VirtualLayoutManager.LayoutParams layoutParams = new VirtualLayoutManager.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); attachViewHolder(layoutParams, new LayoutViewHolder(button)); button.setLayoutParams(layoutParams); button.measure(View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY)); button.layout(view.getLeft(), view.getTop(), view.getLeft() + 100, view.getTop() + 100); button.setText("Test"); showView(button); addView(button, -1); hideView(button); t.add(view); &#125;&#125; 这样一个 button 就显示出来了。 刚开始，我使用了 RecyclerView.LayoutParams，报了空指针异常，提示 mViewHolder 为null，立刻就想到是 LayoutParams 被替换了，然后改了一下就好了。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-自定义LayoutHelper]]></title>
    <url>%2F2019%2F09%2F17%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0002-%E8%87%AA%E5%AE%9A%E4%B9%89LayoutHelper%2F</url>
    <content type="text"><![CDATA[在实现自己的 LayoutHelper 之前，我们先看看官方是如何实现的。如果你之前了解过自定义 LayoutManager，那么这个就是小意思了。我们先来看一个比较简单的 com.alibaba.android.vlayout.layout.FixLayoutHelper。 com.alibaba.android.vlayout.layout.FixLayoutHelper 12345678@Overridepublic void setItemCount(int itemCount) &#123; if (itemCount &gt; 0) &#123; super.setItemCount(1); &#125; else &#123; super.setItemCount(0); &#125;&#125; 可以看到，固定的 item 只管理单个 view，就算我们设置了多个，也只取第一个。比如： 123456789101112131415FixLayoutHelper layoutHelper = new FixLayoutHelper(10, 10);// itemCount 设置为 0，不显示，LayoutHelper 认为没有 view 需要排列adapters.add(new SubAdapter(this, layoutHelper, 0));layoutHelper = new FixLayoutHelper(FixLayoutHelper.TOP_RIGHT, 20, 20);// 这里即使将 itemCount 设置为 10，效果也是一样的adapters.add(new SubAdapter(this, layoutHelper, 1) &#123; @Override public void onBindViewHolder(MainViewHolder holder, int position) &#123; super.onBindViewHolder(holder, position); LayoutParams layoutParams = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 200); holder.itemView.setLayoutParams(layoutParams); &#125;&#125;); 看看别的方法，有三个比较重要，我们先看第一个： com.alibaba.android.vlayout.layout.FixLayoutHelper#layoutViews 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overridepublic void layoutViews(RecyclerView.Recycler recycler, RecyclerView.State state, VirtualLayoutManager.LayoutStateWrapper layoutState, LayoutChunkResult result, final LayoutManagerHelper helper) &#123; // reach the end of this layout if (isOutOfRange(layoutState.getCurrentPosition())) &#123; return; &#125; if (!mShouldDrawn) &#123; layoutState.skipCurrentPosition(); return; &#125; // find view in currentPosition View view = mFixView; if (view == null) &#123; view = layoutState.next(recycler); &#125; else &#123; layoutState.skipCurrentPosition(); &#125; if (view == null) &#123; result.mFinished = true; return; &#125; mDoNormalHandle = state.isPreLayout(); if (mDoNormalHandle) &#123; // in PreLayout do normal layout helper.addChildView(layoutState, view); &#125; mFixView = view; doMeasureAndLayout(view, helper); result.mConsumed = 0; result.mIgnoreConsumed = true; handleStateOnResult(result, view);&#125; 我们看第 16-21 行的代码，这是很重要的一个部分，这里就是获取是否有可以复用的 view。往下看，到 37 行，这里就是处理了 view 的测量与布局。里面的逻辑还是很简单的，这里截取两段看一看： 12345final int widthSpec = helper.getChildMeasureSpec(xxx);heightSpec = helper.getChildMeasureSpec(xxx);// do measurementhelper.measureChildWithMargins(view, widthSpec, heightSpec); 测量都是一样的，先创建 MeasureSpec，然后调用 measureChildWithMargins 方法，view 的大小就测量好了。 1234top = helper.getPaddingTop() + mY + mAdjuster.top;right = helper.getContentWidth() - helper.getPaddingRight() - mX - mAdjuster.right;left = right - params.leftMargin - params.rightMargin - view.getMeasuredWidth();bottom = top + params.topMargin + params.bottomMargin + view.getMeasuredHeight(); 布局就更简单了，因为是固定位置，所以只需要算一下绝对位置就好了，没啥好说的。 我们再看另外两个方法： com.alibaba.android.vlayout.layout.FixLayoutHelper#beforeLayout 123456789101112131415@Overridepublic void beforeLayout(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutManagerHelper helper) &#123; super.beforeLayout(recycler, state, helper); if (mFixView != null &amp;&amp; helper.isViewHolderUpdated(mFixView)) &#123; // recycle view for later usage helper.removeChildView(mFixView); recycler.recycleView(mFixView); mFixView = null; isAddFixViewImmediately = true; &#125; mDoNormalHandle = false;&#125; 这个方法的作用，是在 layout 之前做一些事情，这里做的事情是如果检测到 viewHolder 变化了，就将 view 放入复用池中，便于接下来layout时复用。 com.alibaba.android.vlayout.layout.FixLayoutHelper#afterLayout 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic void afterLayout(final RecyclerView.Recycler recycler, RecyclerView.State state, int startPosition, int endPosition, int scrolled, final LayoutManagerHelper helper) &#123; super.afterLayout(recycler, state, startPosition, endPosition, scrolled, helper); // disabled if mPos is negative number if (mPos &lt; 0) &#123; return; &#125; if (mDoNormalHandle &amp;&amp; state.isPreLayout()) &#123; if (mFixView != null) &#123; // Log.d(TAG, "after layout doNormal removeView"); helper.removeChildView(mFixView); recycler.recycleView(mFixView); isAddFixViewImmediately = false; &#125; mFixView = null; return; &#125; // Not in normal flow if (shouldBeDraw(helper, startPosition, endPosition, scrolled)) &#123; mShouldDrawn = true; if (mFixView != null) &#123; // already capture in layoutViews phase // if it's not shown on screen if (mFixView.getParent() == null) &#123; addFixViewWithAnimator(helper, mFixView); &#125; else &#123; // helper.removeChildView(mFixView); helper.addFixedView(mFixView); isRemoveFixViewImmediately = false; &#125; &#125; else &#123; Runnable action = new Runnable() &#123; @Override public void run() &#123; mFixView = recycler.getViewForPosition(mPos); doMeasureAndLayout(mFixView, helper); if (isAddFixViewImmediately) &#123; helper.addFixedView(mFixView); isRemoveFixViewImmediately = false; &#125; else &#123; addFixViewWithAnimator(helper, mFixView); &#125; &#125; &#125;; if (mFixViewDisappearAnimatorListener.isAnimating()) &#123; mFixViewDisappearAnimatorListener.withEndAction(action); &#125; else &#123; action.run(); &#125; &#125; &#125; else &#123; mShouldDrawn = false; if (mFixView != null) &#123; removeFixViewWithAnimator(recycler, helper, mFixView); mFixView = null; &#125; &#125;&#125; 这个方法的作用，是在 layout 之后做一些事情。不知道你看到这里时有没有产生疑问：我们 RecyclerView 时从上往下，或者从下往上布局的，那么如果我们的屏幕上只能显示 10 个 item，而在第 100 个位置有一个 FixView，那么问题就来了，为什么我们一打开这个界面 FixView 就能立即显示出来，而不是滑动到了第 100 个位置才显示出来？ 我们先看该方法时在什么时候被调用的？ com.alibaba.android.vlayout.VirtualLayoutManager#runPostLayout 12345678910111213141516171819202122232425private void runPostLayout(RecyclerView.Recycler recycler, RecyclerView.State state, int scrolled) &#123; mNested--; if (mNested &lt;= 0) &#123; mNested = 0; final int startPosition = findFirstVisibleItemPosition(); final int endPosition = findLastVisibleItemPosition(); List&lt;LayoutHelper&gt; layoutHelpers = mHelperFinder.getLayoutHelpers(); Iterator&lt;LayoutHelper&gt; iterator = layoutHelpers.iterator(); LayoutHelper layoutHelper = null; while (iterator.hasNext()) &#123; layoutHelper = iterator.next(); try &#123; layoutHelper.afterLayout(recycler, state, startPosition, endPosition, scrolled, this); &#125; catch (Exception e) &#123; if (VirtualLayoutManager.sDebuggable) &#123; throw e; &#125; &#125; &#125; if (null != mViewLifeCycleHelper) &#123; mViewLifeCycleHelper.checkViewStatusInScreen(); &#125; &#125;&#125; 这个方法在 com.alibaba.android.vlayout.VirtualLayoutManager#onLayoutChildren 里面被调用，而 onLayoutChildren 几乎是不断的在被调用，RecyclerView 刚显示时，滚动时都需要调用该方法，所以 runPostLayout 也是不断的会被调用。 看 runPostLayout 的内部逻辑，可以发现它调用了所有的 LayoutHelper 的 afterLayout 方法。即，与 layoutViews 不一样，layoutViews 只会在滚动到相应位置才会调用，afterLayout 与 beforeLayout 都会不断的被调用。 所以，FixView 一开始就可以显示，显然是在 afterLayout 中做了什么。 说实话，这段逻辑我没看懂，写这个代码的人太喜欢用bool变量来控制逻辑了，所以只好使出断点调试大法。界面（VLayoutActivity）刚展示的时候，只会走 afterLayout 与 beforeLayout，beforeLayout 没什么影响，afterLayout 走到了第 47 行： com.alibaba.android.vlayout.layout.FixLayoutHelper#addFixViewWithAnimator 1234567891011121314151617private void addFixViewWithAnimator(LayoutManagerHelper layoutManagerHelper, View fixView) &#123; if (mFixViewAnimatorHelper != null) &#123; ViewPropertyAnimator animator = mFixViewAnimatorHelper .onGetFixViewAppearAnimator(fixView); if (animator != null) &#123; fixView.setVisibility(View.INVISIBLE); layoutManagerHelper.addFixedView(fixView); mFixViewAppearAnimatorListener.bindAction(layoutManagerHelper, fixView); animator.setListener(mFixViewAppearAnimatorListener).start(); &#125; else &#123; layoutManagerHelper.addFixedView(fixView); &#125; &#125; else &#123; layoutManagerHelper.addFixedView(fixView); &#125; isRemoveFixViewImmediately = false;&#125; 然后调用了第 14 行，所以，是 addFixedView 方法起了作用。该方法是将 FixView add 到了 LayoutManager 里面。这里需要 add 是因为本来 fixView 不应该在 LayoutManager 管理的集合里面，但是它又需要显示出来，所以需要 add。 addFixedView 这个方法里面的逻辑也很简单： 12345678910111213141516@Overridepublic void addFixedView(View view) &#123; addOffFlowView(view, false);&#125;@Overridepublic void addOffFlowView(View view, boolean head) &#123; showView(view); addHiddenView(view, head);&#125;protected void addHiddenView(View view, boolean head) &#123; int index = head ? 0 : -1; addView(view, index); mChildHelperWrapper.hide(view);&#125; showView 是调用了 mChildHelperWrapper 的 show 方法，最终会调用到 android.support.v7.widget.ChildHelper.Bucket#clear 里面。这个类具体可以看看这篇文章：https://blog.csdn.net/fyfcauc/article/details/54175072 ，它的内部逻辑就是将该 view 标记为可见。 我刚开始以为这个 showView 方法没啥作用，因为后面不是又重新隐藏了么，直到我将这行代码注掉之后，发现刚开始是正常的吗，但是上下滑动之后， FixView 的层次变化了，但是没找到原因。 查看 LayoutManagerHelper 的注释与 layer 有点关系，下篇再讲。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-设计思想]]></title>
    <url>%2F2019%2F09%2F16%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FvLayout%2F0001-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一般的情况下，我们使用 RecyclerView 都是用来实现同一种类型的列表。实现多种类型的列表的话，也有解决方案，就是通过 android.support.v7.widget.RecyclerView.Adapter#getItemViewType 来区分不同的 item 类型，来加载不同的布局。但是这种解决方法有局限性，想要做出一个类似淘宝首页的界面，基本上是不可能的。 我们先来看一下淘宝的首页长什么样，然后再思考该如何去做。 这是一个比较复杂的界面，对于一个复杂的问题，我们需要将问题简化，或者将这个问题分解为多个相对简单的小问题，所以我们将这个界面分隔为多个部分： 我们将首页分为了几个部分，每个部分的结构都比较简单，那么这个时候就遇到了第一个需要解决的问题： 我们知道 RecyclerView 之所以能够流畅滑动，是因为它的复用机制，那么我们将首页分为了好几个部分之后，它的复用粒度应该是什么样的呢？是每个黑框框起来的作为一个复用粒度，还是说将黑框里面的每一个布局作为一个复用粒度呢？显然复用粒度越小滑动起来就越流畅，但是我们需要实现如何才能复用更小的粒度。 我们知道，RecyclerView 的五虎上将中，LayoutManager 是用来排列item的布局的，我们现有的 LayoutManager 都无法满足要求，那么应该怎么办呢？只能自定义 LayoutManager 了。通过自定义 LayoutManager 我们可以解决 item 的排列问题，但是这里我们又遇到了第二个问题： 首页的 item 排列并不是固定的，就算我们实现了一个 LayoutManager 将 item 排列成图上的模样，但是如果 UI 改了 item 的位置，那岂不是又要重新写一个 LayoutManager？这也太惨了。这个问题要怎么解决呢？这个就不是纯技术的问题了。如果 UI 随心所欲的改 item 样式，如果我们怎么写都是徒劳的，这个时候就需要与 UI 达成一致，给 UI 一定的创作空间，但是需要在某个范围内。这个创作空间就在 com.alibaba.android.vlayout.layout 下，什么意思呢？这个包下面的各种 Helper 其实本质上都是一个 LayoutManager。当然如果你实在杠不过UI，你也可以自定义 LayoutHelper 来实现特殊效果。 就算我们定义了各种 LayoutManager，那又能怎么样呢？ 我们回想一下 RecyclerView 的工作原理，首先，RecyclerView 从 Adapter 获取 View，然后 LayoutManager 将 View 按实现排列，这样我们的列表就出来了。 上面，我们将首页分为了多段，那么我们可不可以使用多个 Aadapter 与 LayoutManager 呢？每一段分别对应不同的 Adapter 与 LayoutManager，如下图： 那么，对于屏幕上的每一个位置，我们可以这样做： 当然，我们需要先将 LayoutHelper 给设置进去，也就是说，我们需要先知道每个位置的 item 是什么类型的（或者知道每个类型有多少个 item）。LayoutHelper 搞定了，同理，Adapter 也是一样的，具体的实现在 com.alibaba.android.vlayout.DelegateAdapter 里面。]]></content>
      <categories>
        <category>vLayout</category>
      </categories>
      <tags>
        <tag>Android源码分析-vLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-梳理（一）]]></title>
    <url>%2F2019%2F09%2F12%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0011-%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[再回顾一下，Tangram 是如何将一个 Json 文件变成一个个的 View，显示到页面上的？首先，我们发起网络请求，从服务器请求下来 json 数据，使用解析器将 json 数据解析成 Card 对象，这一步是由 com.tmall.wireless.tangram.dataparser.concrete.PojoDataParser 类完成的。 获取到了 Card 之后，Card 里面还有 Cell 数据需要解析，这一步是由 com.tmall.wireless.tangram.dataparser.concrete.Card 类完成的。 这样我们就将 Json 数据转成了 Tangram 可以理解的东西。 然后，我们需要对 RecyclerView 与 Adapter 有比较深入的了解。 我们一般是这样写 Adapter 的： 12345678910111213141516171819202122232425262728293031323334class StackAdapter(private var count: Int) : RecyclerView.Adapter&lt;StackViewHolder&gt;() &#123; fun addItem() &#123; notifyItemInserted(++count) &#125; override fun getItemCount() = count override fun onBindViewHolder(holder: StackViewHolder, position: Int) &#123; Log.e("tetg", "onBindViewHolder + $position") holder.bind(position) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123; Log.e("tetg", "onCreateViewHolder") val root = LayoutInflater.from(parent.context) .inflate(R.layout.item_stack, parent, false) return StackViewHolder(root) &#125;&#125;class StackViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; private val text: TextView = itemView.findViewById(R.id.text) private val root: View = itemView.findViewById(R.id.root) fun bind(position: Int) &#123; text.text = "$position" val rnd = Random() val color = Color.argb(255, rnd.nextInt(256), rnd.nextInt(256), rnd.nextInt(256)) root.setBackgroundColor(color) &#125;&#125; 我们仔细看一下，想要做出不同样式的item，主要将 onBindViewHolder 与 onCreateViewHolder 的逻辑分别封装到 Cell 里面，这样就简单很多。如下： 1234public class MyCell &#123; fun onBindViewHolder(holder: StackViewHolder, position: Int) &#123;&#125; fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123;&#125;&#125; 然后，我们在将 Adapter 的数据源改成这样： 1private List&lt;MyCell&gt; datas; Adapter 的逻辑就可以这样写了： 12345678910111213141516171819class Adapter(private var count: Int) : RecyclerView.Adapter&lt;ViewHolder&gt;() &#123; fun addItem() &#123; notifyItemInserted(++count) &#125; override fun getItemCount() = count override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123; datas.get(position).onBindViewHolder(holder, position) &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StackViewHolder &#123; // 这里需要根据 viewType 来创建不同的 ViewHolder // 一种很直接的解决方法就是用一个map，将 viewType 与 viewHolder 对应起来 return map.get(viewType).createViewHolder() &#125;&#125; 我们只需要处理好，viewHolder 就行了。当然 Tangram 里面的逻辑不可能这么简单，但是只要你理解了这个，再看 Tangram 应该会好理解很多。 有了数据，又有了所有的 viewHolder，就只差自定义的 layoutManager 了。 vlayout 做了自定义 layoutManager 的部分，一个类型的 Card 都对应一个 layoutManager，根据不同的 Card 获取不同的 layoutManager，然后将 Card 里面的 Cell 排列好，这样页面就显示出来了。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0008-事件总线]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0008-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[事件总线(TangramBus)用于组件和组件、组件和卡片、组件和页面之间的通信。它也是默认被注册到 Tangram 的 serviceManager 里，在组件和 TangramEngine 里都可以获取到。BusSupport 与 TimerSupport 一样，都是内置在 TangramEngine 里面了的，不需要我们手动注册： com.tmall.wireless.tangram.TangramBuilder.InnerBuilder#build 12tangramEngine.register(TimerSupport.class, new TimerSupport());tangramEngine.register(BusSupport.class, new BusSupport()); 我们在其他地方就可以获取注册进去的这个对象了。 1BusSupport busSupport = serviceManager.getService(BusSupport.class); 获取到 BusSupport 之后，我们就可以使用这个对象来发送一个事件对象了，就像 EventBus 一样。 com.tmall.wireless.tangram.eventbus.BusSupport#post(com.tmall.wireless.tangram.eventbus.Event) 123public boolean post(@NonNull Event event) &#123; return mDispatcher.enqueue(event);&#125; 在深入分析之前，我们来先看看 Event 相关的东西。 Event 这个类相当简单，可以当作一个 bean 来看待。我们可以直接创建这个对象，但是比较好的做法是复用该对象，为此 Tangram 提供了一个 EventPool 来帮助我们复用 Event 对象，如下： com.tmall.wireless.tangram.eventbus.BusSupport#obtainEvent(java.lang.String, java.lang.String, android.support.v4.util.ArrayMap&lt;java.lang.String,java.lang.String&gt;, com.tmall.wireless.tangram.eventbus.EventContext) 123456789public static Event obtainEvent(String type, String sourceId, ArrayMap&lt;String, String&gt; args, EventContext eventContext) &#123; Event event = EventPool.sharedInstance().acquire(); event.type = type; event.sourceId = sourceId; event.args = args; event.eventContext = eventContext; return event;&#125; 这里，我们使用了 BusSupport 封装的方法来获取到一个 Event 对象，并对其字段赋值。 事件对象创建好了之后，使用 post 方法发送出去，那么如果去接收这个对象呢？上面我们分析到，post 方法内部是调用了 Dispatcher.enqueue 方法： com.tmall.wireless.tangram.eventbus.Dispatcher#enqueue(com.tmall.wireless.tangram.eventbus.Event) 123456@Overridepublic boolean enqueue(@NonNull Event event) &#123; Message msg = obtainMessage(); msg.obj = event; return sendMessage(msg);&#125; 由于 Dispatcher 是继承了 Handler 的，所以这里是将 Event 封装成了一个 Message，然后发送出去了。那么哪里可以接收到这个消息呢，看 Dispatcher 的构造方法： com.tmall.wireless.tangram.eventbus.Dispatcher#Dispatcher 1234public Dispatcher(IDispatcherDelegate dispatcherDelegate) &#123; super(Looper.getMainLooper()); this.mDispatcherDelegate = dispatcherDelegate;&#125; 我们看到 Looper 是主线程的 Looper 对象，所以发送出去的消息在主线程可以接收到。又因为 Hander 在发送 Message 的时候，会将接收者（target）设置为自己，所以 Dispatcher 想要处理接收到的消息的话，肯定需要重写 handleMessage 方法。 com.tmall.wireless.tangram.eventbus.Dispatcher#handleMessage 12345678@Overridepublic void handleMessage(Message msg) &#123; super.handleMessage(msg); if (mDispatcherDelegate != null) &#123; mDispatcherDelegate.dispatch((Event) msg.obj); &#125; EventPool.sharedInstance().release((Event) msg.obj);&#125; 这里做了两件事： 将接收到的消息分发出去 将事件对象回收 我们继续跟踪下去，发现 BusSupport 实现了 IDispatcherDelegate 接口： com.tmall.wireless.tangram.eventbus.BusSupport#dispatch 12345678910111213141516@Overridepublic synchronized void dispatch(@NonNull Event event) &#123; String type = event.type; List&lt;EventHandlerWrapper&gt; eventHandlers = subscribers.get(type); if (eventHandlers != null) &#123; EventHandlerWrapper handler = null; for (int i = 0, size = eventHandlers.size(); i &lt; size; i++) &#123; handler = eventHandlers.get(i); if (!TextUtils.isEmpty(handler.producer) &amp;&amp; handler.producer.equals(event.sourceId)) &#123; handler.handleEvent(event); &#125; else if (TextUtils.isEmpty(handler.producer)) &#123; handler.handleEvent(event); &#125; &#125; &#125;&#125; 这里出现了一个新类：EventHandlerWrapper，看类名就知道它是来处理事件的。 有个地方需要注意，如果我们在创建 EventHandlerWrapper 对象的时候指定了 producer，那么需要在创建 Event 的时候，也指定相应的值，否则匹配不上哦。 首先，我们获取到事件的类型，然后根据这个类型，获取到该类型对应的所有观察者，然后一个一个的将事件回调过去，很是很简单的。 了解了 BusSupport 的工作流程，我们就知道如果我们想要接收一个事件，需要定义一个事件类型，然后向 BusSupport 注册该类型的观察者： 12345678910111213141516171819202122232425262728293031private EventHandlerWrapper mSetMeta = BusSupport.wrapEventHandler("setMeta", null, this, "parseMeta");@Overrideprotected void onAdded() &#123; super.onAdded(); BusSupport busSupport = serviceManager.getService(BusSupport.class); if (busSupport != null) &#123; busSupport.register(mSetMeta); &#125;&#125;@Overrideprotected void onRemoved() &#123; super.onRemoved(); BusSupport busSupport = serviceManager.getService(BusSupport.class); if (busSupport != null) &#123; busSupport.unregister(mSetMeta); &#125;&#125;@Keeppublic void parseMeta(Event event) &#123; try &#123; if (mTotalPageCount != Integer.MAX_VALUE) &#123; storeCache(); &#125; mIndex = Integer.parseInt(event.args.get(KEY_INDEX)); mTotalPageCount = Integer.parseInt(event.args.get(KEY_PAGE_COUNT)); &#125; catch (Exception e) &#123; &#125;&#125; 由于 EventHandlerWrapper 内部是使用了反射来获取回调的方法，所以这里需要写一个 parseMeta 方法，而且为了防止代码压缩的时候被删除，需要 keep 一下。 好长时间不画图了，画个图吧，感觉这个图没有说清楚，觉得没有帮助的话当作没看见吧：]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010-与 RxJava 配合使用]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0010-%E4%B8%8E-RxJava-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[想要使用 RxJava，需要先开启：1engine.setSupportRx(true);然后还要提供依赖包，具体可以参考官方文档.响应式流中数据结构的定义在响应式流中，传递的都是数据单个对象，而传统的命令式接口里，一个操作往往有多个类型的参数，JAVA 里没有像元组那样的结构用来组合一系列对象，用 Object[] 类型的对象也难以理解维护，因此，针对这种情况，Tangram 将相关接口的参数封装成一系列 TangramOp1、TangramOp2、TangramOp3 对象，分别包含一个、两个、三个参数，用来在响应式流中传递信息，也方便原有接口的对接。具体的定义在包 com.tmall.wireless.tangram.op 下，包含了插入、更新、异步加载等接口的操作定义。下文中碰到的接口里包含的 ClickExposureCellOp、LoadGroupOp 等都是在这个背景下定义的结构。 这一段还是应该好好阅读几遍的，在我刚开始接触 Rx 的时候，就不太明白为啥会设计出这样的接口： io.reactivex.functions 在 functions 包下，还有 Function3，Function4 这样的东西。有了上面这段话，初学者应该就会比较好理解一些。 关于 Rx 的配合使用，官方文档也说的差不多了，再深入就是 Rx 相关的东西，这里就不说了。这里只说一下 demo 的 RxTangramActivity 显示的效果会是一个一个卡片加载出来的。想要做出依次加载的效果，有哪些思路呢？ 每次add一个，控制好add时机 使用动画 使用动画的话，会有一个问题，就是上下滑出滑入的时候都会执行动画，不好搞。看看 Tangram 是如何做的吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243Disposable dsp8 = Observable.create(new ObservableOnSubscribe&lt;JSONArray&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;JSONArray&gt; emitter) throws Exception &#123; String json = new String(getAssertsFile(getApplicationContext(), "data.json")); JSONArray data = null; try &#123; data = new JSONArray(json); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; emitter.onNext(data); emitter.onComplete(); &#125;&#125;).flatMap(new Function&lt;JSONArray, ObservableSource&lt;JSONObject&gt;&gt;() &#123; @Override public ObservableSource&lt;JSONObject&gt; apply(JSONArray jsonArray) throws Exception &#123; return JSONArrayObservable.fromJsonArray(jsonArray); &#125;&#125;).map(new Function&lt;JSONObject, ParseSingleGroupOp&gt;() &#123; @Override public ParseSingleGroupOp apply(JSONObject jsonObject) throws Exception &#123; return new ParseSingleGroupOp(jsonObject, engine); &#125;&#125;).compose(engine.getSingleGroupTransformer()).filter(new Predicate&lt;Card&gt;() &#123; @Override public boolean test(Card card) throws Exception &#123; return card.isValid(); &#125;&#125;).map(new Function&lt;Card, AppendGroupOp&gt;() &#123; @Override public AppendGroupOp apply(Card card) throws Exception &#123; Thread.sleep(300); return new AppendGroupOp(card); &#125;&#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(engine.asAppendGroupConsumer(), new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; throwable.printStackTrace(); &#125;&#125;); 里面的逻辑还是挺清晰的： 先从 json 模拟数据文件里面读取出数据，将数据转成 JSONArray 将 JsonArray 转成 Observerable&lt;JSONObject&gt;，具体做法就是将 JSONArray 拆成一个一个的 JSONObject 数组，然后发送出去 com.alibaba.android.rx.JSONArrayObservable.FromJsonArrayDisposable#run 12345678910111213141516void run() &#123; JSONArray a = array; int n = a.length(); for (int i = 0; i &lt; n &amp;&amp; !isDisposed(); i++) &#123; T value = (T) a.opt(i); if (value == null) &#123; actual.onError(new NullPointerException("The " + i + "th element is null")); return; &#125; actual.onNext(value); &#125; if (!isDisposed()) &#123; actual.onComplete(); &#125;&#125; 下游接收到 JSONObject 后解析成 Card 校验 Card 是否有效 将 Card 封装成一个 AppendGroupOp 对象 线程切换 下游拿到 AppendGroupOp 对象，执行添加 Card 操作 这样就完成了，那么现在，我们应该就知道了，将 json 数据解析成了 Card 需要耗时一定的时间，所以就有了一个间隔效果，而且调用 notifyItemRangeInserted 还会有有一个自带的动画效果。要是不相信的话，可以自己去写个 demo 跑一下。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-使用布局]]></title>
    <url>%2F2019%2F09%2F11%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0009-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[对于布局来说，内置布局一般满足大部分场景，如果有特殊需求，可自定义实现。需要实现Card和LayoutHelper。Card是自定义布局的 model，LayoutHelper是自定义布局的实现，基于vlayout框架。 这部分的东西也在 vlayout 里面，所以不分析了，可以先看看官方文档介绍。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让 CPU 告诉你硬盘和网络到底有多慢]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%2F%E8%AE%A9%20CPU%20%E5%91%8A%E8%AF%89%E4%BD%A0%E7%A1%AC%E7%9B%98%E5%92%8C%E7%BD%91%E7%BB%9C%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2%2F</url>
    <content type="text"><![CDATA[经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。 希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。 注：所有的数据都是来自这个地址。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，这个网址给出了不同年份一些指标的数值。 数据 先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 2.6*10^9个指令，每个指令只需要 0.38ns（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 1s，因为 1s 大概是人类能感知的最小时间单位。 一级缓存读取时间为 0.5ns，换算成人类时间大约是 1.3s，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。 分支预测错误需要耗时 5ns，换算成人类时间大约是 13s，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如这个得分非常高的 stackoverflow 问题。 二级缓存时间就比较久了，大约在 7ns，换算成人类时间大约是 18.2s，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。 小知识：为什么需要多层的 CPU 缓存呢？这篇文章通过一个通俗易懂的例子给出了讲解。 我们继续，互斥锁的加锁和解锁时间需要 25ns，换算成人类时间大约是 65s，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。 然后就到了内存，每次内存寻址需要 100ns，换算成人类时间是 260s，也就是4分多钟，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。到了内存之后，时间就变得一个量级，CPU 和内存之间的速度瓶颈被称为冯诺依曼瓶颈。 一次 CPU 上下文切换（系统调用）需要大约 1500ns，也就是 1.5us（这个数字参考了这篇文章，采用的是单核 CPU 线程平均时间），换算成人类时间大约是65分钟，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，这段时间里 CPU 没有做任何有用的计算，只是切换了两个不同进程的寄存器和内存状态；而且这个过程还破坏了缓存，让后续的计算更加耗时。 在 1Gbps 的网络上传输 2K 的数据需要 20us，换算成人类时间是 14.4小时，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。 SSD 随机读取耗时为 150us，换算成人类时间大约是 4.5天。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。I/O 设备 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 memcached 和 redis 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。 从内存中读取 1MB 的连续数据，耗时大约为 250us，换算成人类时间是 7.5天，这次假期升级到国庆七天国外游了。 同一个数据中心网络上跑一个来回需要 0.5ms，换算成人类时间大约是 15天，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。 从 SSD 读取 1MB 的顺序数据，大约需要 1ms，换算成人类时间是 1个月。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，SSD 已经很快啦，不信你看下面机械磁盘的表现。 磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 RPM(Revolutions Per Minute/每分钟转速) 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。 从磁盘读取 1MB 连续数据需要 20ms，换算成人类时间是 20个月。IO 设备是计算机系统的瓶颈，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。 而从世界上不同城市网络上走一个来回，平均需要 150ms（参考世界各地 ping 报文的时间），换算成人类时间是 12.5年。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，CDN 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。 虚拟机重启一次大约要 4s 时间，换算成人类的时间是 3百多年。对于此，我想到了乔布斯要死命优化 Mac 系统开机启动时间的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。 物理服务器重启一次需要 5min，换算成人类时间是 2万5千年，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-逻辑结构与物理结构]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0002-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构就是说，一堆数据放在一起，它们之间会有某种关系在里面。下面，我们就来聊聊储存这些关系的结构，按照角度的不同，我们分为两大类：逻辑结构、物理结构。逻辑结构是描述数据之间的关系的，是我们今后要关注的，这是从我们的理解角度出发的。物理结构是数据之间的关系在计算机中的储存形式，是从计算机的角度出发的。 逻辑结构分为四种： 集合结构：可以理解为数学中的集合概念，就是一堆同性质（一般是）的数据放在一起，没啥别的要求。 线性结构：数据项之间是一对一的关系。比如，幼儿园放学的时候，小孩儿都拍成一排。 树形结构：数据项之间是一对多的关系。比如：公司上下级的关系。 图形结构：数据项之间是多对多的关系。比如：一个班级中的同学之间的朋友关系。 物理结构分为两种虽然计算机有多种储存介质，但是对于数据结构来说，都是针对内存说的。我们可以将内存理解为一个一个的格子。 顺序储存关系 顺序就是强迫症一样的摆东西，一个格子挨着一个格子，整整齐齐的。 链式储存关系 链式储存就是瞎几把乱放，有空位置就塞一个，但是需要额外的信息来储存下一个储存位置在哪，不然就找不到了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构、</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-抽象数据类型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0003-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[因为我们是用的 Java，所以这个就不介绍了哈，面向对象牛逼！！！]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-算法的特性]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0006-%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[算法的定义我就不写了，写了也记不住，就理解为解决某个问题的具体步骤，可以翻译为计算机语言。 拿破仑说过，不想当厨子的司机不是好裁缝。那么一个算法应该具备什么样的特性，才算是一个合格的算法呢？ 输入输出：可以不需要输入（生成随机数之类的），但是一定要有输出，不然写这个算法搞毛。 有穷性：可以在一个合理的时间内运算完成。写一个需要耗时几十年的算法，那就没什么意思了。 确定性：同样的输入会得出同样的输出。 可行性：这个有点不好理解，有些算法是无法转换为程序的，由于现在科技与人类认知的局限性。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-算法设计的要求]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0007-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[这个不要跟算法的特性搞混了，这里说的是一个好的算法有哪些要求。上一篇说的是算法的基本特性，即基本要求，如果连这个都不满足，那就更不用说好坏了。 正确性：能够得出正确答案。 可读性：可以方便阅读，供人交流，写的只有自己能看懂，那就只能与计算机交流了。 健壮性：对于一些不合法的输入，可以做合适的处理，而不是直接抛出异常。 时间效率高与储存量低：耗时肯定是越少越好，同时对空间的要求也越低越好。就是传说中的，用最少的钱把事办了，而且还要办的漂漂亮亮的，越快越好。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0008-度量一个算法的效率]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0008-%E5%BA%A6%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[如何去测量一个算法的效率，还是值得思考一下的。比如，我们用算法实现了一个功能，那么想要测量这个算法的运行速度，通常都会直接运行一下，看看它消耗的时间，然后得出一个主观的判断，但是这个测量的结果有用吗？显然没有，因为有很多外在的因素影响了我们测量的结果： 每个计算机运行的速度不一样 测试数据的大小对算法也有影响，有些算法在小型测试数据集合表现很好，但是数据集合大了之后就会变得效率很低 另外，还有一个问题，那就是就算我们找了某些方法，可以避免这些因素，那么还有一个问题就是，我们需要写出我们的程序，才能进行测量，这其实也是一个很严重的问题，因为如果每个算法都需要实现了才能测量，那无疑要消耗很多精力。 那么有没有不需要写出算法的程序，就能测量出算法的效率的方法呢？肯定是有的，就是我们所说的大O阶方法。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-大O阶方法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0009-%E5%A4%A7O%E9%98%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在说这个测量方法之前，我们还介绍一些大家最喜欢的数学知识。函数的渐近增长比如，我们有两个函数：$$f(n) = 4*n + 8$$$$g(n) = n*n$$当 n&lt;=5 的时候，f(n) 是比 g(n) 大的，当 n &gt; 5 后，f(n) 就比 g(n) 小了。对于这两个函数，我们称 g(n) 的渐近增长要快于 f(n) 的渐近增长。 其实，可以画一个图，显然当 n 越大的时候，g(n) - f(n) 的值也是越来越大。 好的，了解了这个，我们就开始介绍大O阶方法。 常数阶看下面这个算法： 123int sum=0, n=100; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */System.out.println(sum); /* 执行一次 */ 我们用一个函数$T(N) = O(f(n))$ 来表示这个算法的时间复杂度（即算法语句的执行次数与问题规模大小之间的关系）。 可以得出$T(N) = O(3)$，简记为 $O(3)$，但是通常我们不会这么表示，而是写作 $O(1)$ ，这是为什么呢？ 假设，我们的算法是这样的： 1234int sum=0, n=100; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */sum = (1+n)*n/2; /* 执行一次 */System.out.println(sum); /* 执行一次 */ 那么，时间复杂度为 $O(4)$ ，但是实际上，这个算法与上面的算法都有一个特点，就是他们的执行次数都是固定的，与问题规模大小没有关系，是一个执行时间恒定的算法。 对于这样的算法，不管常熟是多大，我们都记为 $O(1)$。 所以我们总结出第一条攻略： 用常数1取代运行时间中所有加法常数 线性阶看下面这个算法： 123for(int i=0; i&lt;n; i++) &#123; /* 时间复杂度为 O(1)的程序步骤序列 */&#125; 显然，时间复杂度为 $O(n)$ 。 平方阶看下面这个算法： 1234567int i, j /* 执行一次 */for (i=1; i&lt;=n; i++) &#123; /* 执行N次 */ for (j=1; j&lt;=n; j++) &#123; /* 执行N次 */ /* 时间复杂度为 O(1)的程序步骤序列 */ &#125;&#125;System.out.println(sum); /* 执行一次 */ 可以看到，循环部分占了 $N^2$ 次，时间复杂度为 $O(n^2+2)$，但是我们不会记为 $O(n^2+2)$，而是写作 $O(n^2)$。 这是因为，我们最需要关心的是循环里面的部分，其他的可以忽略，而且，随着 N 的增大，$n^2+2$ 与 $n^2$ 的差别可以忽略不记。 所以我们总结出第二条攻略： 只保留函数中的最高阶项 比如：$O(n^2 +n)$，我们也写作 $O(n^2)$，显然 n 越大，他们的区别越小。 还有一个比较特殊的情况，如下： 123456int i, j /* 执行一次 */for (i=0; i&lt;n; i++) &#123; /* 执行N次 */ for (j=i; j&lt;n; j++) &#123; /* 执行N-i次 */ /* 时间复杂度为 O(1)的程序步骤序列 */ &#125;&#125; 那么，它的时间复杂度为多少呢？看上去这个不好下手，但是却可以这样算： 当 i = 0，内层循环 n 次 当 i = 1，内层循环 n - 1 次 ….. 所以内层循环一共循环了 n + (n-1) + … + 1 次，为 $\frac{n(n+1)}2$ 次。 记为 $O(\frac{n^2}2)$，与省略低阶项同样的道理，我们也可以省略这个相乘的常数，记为 $O(n^2)$。 对数阶下面的代码： 12345int count = 1;while (count &lt; n) &#123; count *= 2; /* 时间复杂度为 O(1)的程序步骤序列 */&#125; 假设循环执行了 x 次，则 $2^x = n$，所以算法时间复杂度为 $O(log_2n)$，通常，我们省略底数2，记为 $O(logn)$。 最后，总结一下： 用常数1取代运行时间中的所有加法常数 在修改后的运行次数中，只保留最高阶项 如果最高阶存在且不是1，则去除与这个项相乘的常数 其实，大O阶考察的还是我们的数学功底。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0015-线性表的链式储存结构]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0015-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[之前，我们说过，用顺序储存在插入与删除的情况下是效率比较低的。我们分析一下原因：每个元素是相邻的，当需要插入的时候，就必须要移动一些元素。想要提高插入与删除的效率，那么就不能让元素相邻。所以另外一种储存方案就被设计出来了——链式储存。所谓链式储存，就是不仅储存数据，还需要储存下一个元素储存的位置，就像一条链子一样，我们叫这种数据结构为单链表。如图： 要注意的是：链表中的第一个节点的储存位置叫头指针。 有两个概念比较容易混淆：头节点与头指针。 头指针是指向第一个节点的指针，如果链表有头节点，则头指针指向头节点，如果链表没有头节点，则头指针指向第一个元素的节点。 头节点是为了操作统一而创建的，一般只会储存第一个元素节点的位置信息。 看下面两个图： 没有头节点 有头节点 现在，我们来定义一下链表储存结构的节点的数据类型。 首先，它要储存下一个元素的位置 然后，它还有能储存数据 那么类就应该是这样的： 123456public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next; &#125; 链表就可以这样写： 12345678910public class MyList&lt;T&gt; &#123; private Node&lt;T&gt; head; public MyList() &#123; this.head = new Node&lt;&gt;(); &#125; &#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-数据结构与算法的关系]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0004-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[如果一部电影光有特效没有剧情，看完了之后，让你说一下这部电影，你会发现不知道怎么说起，感觉自己都知道，但是却没什么好说的。 学数据结构就是这样，如果只讲数据结构，那么学完了就会发现没啥感觉，你不知道这个东西可以做什么，没有内涵。 PS：现在供人消遣的短视频，娱乐节目什么的越来越多，我们花在看视频的时间上越来越多，这会对我们自身有个非常不好的影响，就是会变的越来越不想自己思考，而是借着视频放空脑子，不去思考什么。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-空间复杂度]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0011-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[如果我们想要判某年是不是闰年，可以有两种做法： 写一个算法，输入一个年份，就可以得出结果 建一个数组，数组的大小比现实年份多一点，把所有的年份按照下标的数字对应，如果是闰年就将值赋值为1，不是就赋值为0 这两种做法，一个空间复杂度基本是 O(1)，另一个空间复杂度基本是 o(2022)，假设给数组的大小为 2022。 空间复杂度指的是：一个程序在机器上执行时，除了储存程序本身的指令，变量等，还需要一个额外的内存来帮助实现这个算法，这些消耗的额外内存就是空间复杂度。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0016-单链表的读取、插入、删除]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0016-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[在开始一系列的插入删除方法之前，需要讲解一个东西，对代码的阅读非常有好处：12node1.next = node.next;node.next = node1;我们先不讨论这两行代码有什么意思。光从代码上看，发现 node.next 既可以在 = 的左边，也可以在 = 的右边。在左边与在右边有着不同的意义。 在 = 左边表示 node.next 是当作一个容器，在 = 右边表示需要使用 node.next 容器里面的值。 在链式存储结构中，读取效率为比较低，不像在顺序储存结构中，可以直接拿出来。原因就是因为我们需要知道前一个元素，才能获取到后一个元素的位置。所以我们想要获取一个元素，需要从头指针开始寻找。 读取看看读取的代码： 123456789101112131415161718192021public T getNode(int index) &#123; // 从第一个节点开始遍历 Node&lt;T&gt; temp = head.next; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; // temp 不能为 null，为 null 表示 index 超过了链表的大小 // 理论上来说，p 是不会大于 index 的 if (p &gt; index || temp == null) &#123; return null; &#125; else &#123; return temp.t; &#125;&#125; 思路解说： 拿到第一个节点，因为我们不能直接改头节点，所以需要声明一个临时变量 将 next 节点赋值给自己，这样不断的寻找下一个节点 直到到达指定的位置 时间复杂度为 $O(n)$。所以链表在获取元素的时候，效率很低。虽然它在获取元素时效率很低，但是对于插入与删除元素，效率很高哦。 插入我们先来看两张图： 可以看出，插入节点的时候，不用管其他节点，只需要插入位置的前后两个节点即可。核心代码就是： 12newNode.next = p.next; // 让新节点指向 p 后面的节点p.next = newNode; // 让 p 节点指向新节点 还是非常简单的，但是千万不要搞反了，如果我们先执行了 p.next = newNode，那么 p 后面的那个节点，我们就找不到了，相当于链条断了。插入的过程，相当于将一个链条分成了两段，我们需要这两段的头指针（p 与 p.next），执行 p.next = newNode 就相当于丢弃了后面链条的头指针。 看看完整代码： 123456789101112131415161718192021public void insertNode(T t, int index) &#123; // 从头节点开始遍历 Node&lt;T&gt; temp = head; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; if (p &gt; index || temp == null) &#123; return; &#125; Node&lt;T&gt; newNode = new Node&lt;&gt;(); newNode.t = t; newNode.next = temp.next; temp.next = newNode;&#125; 可以看到，我们还是需要先找到插入的位置的节点，才能开始进行插入。那么问题就来了，它的效率怎么就高了，不也是 $O(n)$ 么？ 其实是这样的，如果我们不知道插入位置的节点指针，那么效率是没有什么优势的。但是如果我们知道了指针的值，则效率就会高很多，比如在第 i 个位置，插入 10 个、100个元素，这样的情况下，我们就不用每次都重新找节点的指针了，而是第一次找到之后，后面只需要更新一下指针的值就好了。 删除删除过程也很简单，先看图： 思路如下： 寻找要删除的节点 创建一个临时变量Q，指向要删除节点P的下一个节点 然后将要删除节点的前一个节点R的next赋值为Q 将 P 的数据清空 代码如下： 12345678910111213141516171819202122public void deleteNode(int index) &#123; // 从头节点开始遍历 Node&lt;T&gt; temp = head; int p = 0; while (temp != null &amp;&amp; p &lt; index) &#123; p++; temp = temp.next; &#125; // 这里还需要额外判断一下 temp.next // 因为 temp.next 是要删除的节点 // 与插入不一样，插入时，temp.next为null不影响 // 删除、插入有多种写法，思路是一样的，只是细节不一样 if (p &gt; index || temp == null || temp.next == null) &#123; return; &#125; Node&lt;T&gt; delete = temp.next; temp.next = delete.next;&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005为啥需要算法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0005-%E4%B8%BA%E5%95%A5%E9%9C%80%E8%A6%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写一个从1加到100的程序。 我们是这样写的： 123for(int i=1; i&lt;=100; i++) &#123; sum += i&#125; 大佬高斯是这样写的： 12int sum = 0, n= 100sum = (1 + n) * n / 2 哪个算的快，不用我多说了吧！！！]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0012-线性表]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0012-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[什么是线性表呢？可以理解为用一根线可以将所有数据串起来的数据集合。 比如：星座列表。 巨蟹座 -&gt; 白羊座 -&gt; 双子座 -&gt; 宝瓶座 -&gt; 室女座 -&gt; 狮子座 -&gt; 金牛座 -&gt; 双鱼座 -&gt; 摩羯座 -&gt; 天蝎座 -&gt; 天秤座 -&gt; 人马座]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0013-线性表的抽象数据类型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0013-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[这个了解了面向对象，还是非常简单的。1234567891011121314151617181920212223class Node&lt;T&gt; &#123; // 判断表是否为空 public boolean isEmpty()&#123;&#125; // 清空线性表 public void clear()&#123;&#125; // 获取指定位置的元素 public T getNode(int index)&#123;&#125; // 查找元素 public void findNode(T t)&#123;&#125; // 在指定位置添加一个元素 public void add(T t, int index)&#123;&#125; // 删除指定位置的元素，并返回它的值 public T delete(int index)&#123;&#125; // 大小 public int size()&#123;&#125;&#125; 对于不同的需求，不同的线性表会有不同的方法，上面所写的，基本是最通用的一些方法。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0014-线性表的顺序储存]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0014-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%2F</url>
    <content type="text"><![CDATA[我们说过，顺序储存，就是一个一个的挨着摆好，在 Java 里面就是对应的数组。如下图：下面，我们就用数组来实现一个线性表。首先，我们定义一个数组：123456public class MyArray&lt;T&gt; &#123; // 因为无法创建泛型数组，所以我们使用 Object 来接受 private Object[] array = new Object[5]; &#125; 然后我们来实现，他的插入方法： 123456789101112131415// 在指定位置添加一个元素public void add(T t, int index) &#123; checkIndex(index); if (isFull()) &#123; return; &#125; for (int i = size() - 1; i &gt;= index; i--) &#123; array[i + 1] = array[i]; &#125; array[index] = t;&#125; 这里面有两个新方法，一个 checkIndex，是用来判断 index 是否是有效的。一个是 size 是用来储存当前数组已被占用的大小，可以用一个 int 来储存，只要随时更新它的大小就好了。 看其他的逻辑，还是蛮简单的，当在一个指定的位置插入数据的时候，其他位置的数据都要向后移动一格。可以想象一下我们排队，有一个人插队的时候，后面的人就不得不往后退一步。如图： 再看一下删除方法： 12345678910111213141516171819// 删除指定位置的元素，并返回它的值@SuppressWarnings("unchecked")public T delete(int index) &#123; checkIndex(index); if (isEmpty()) &#123; return null; &#125; T temp = (T) array[index]; for (int i = index + 1; i &lt; size(); i++) &#123; array[i - 1] = array[i]; &#125; array[size() - 1] = null; return temp;&#125; 其实与插入的逻辑一样，只不过插入是往后移动一格，删除是往前移动一格。如下图： 实现了插入与删除之后，我们再来思考一下，这两个方法的时间复杂度。 根据前面学过的知识，我们知道，他的平均复杂时间度为 $O(\frac{n}2)$，最坏时间复杂度为 $O(n)$。 也就是说，我们每次的插入与删除操作，都可能需要面临移动所有元素的风险。这是顺序储存结构的不足。但是他也有优点，就是获取元素，非常快，只要知道元素的位置，可以立马找到，时间复杂度为 $O(1)$。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010最坏情况与平均情况]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0010-%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[最坏情况，指的是运行时间最长的情况。 举个例子，我们要在抽屉里面找一个东西，最好的情况是将抽屉打开，一眼就看到了，最坏的情况是我们要将抽屉里的东西一个一个翻一遍才能找到。 平均情况，是比较有意义的情况，就是取一个平均值。 一般情况下，我们说的时间复杂度指的是最坏时间复杂度。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0017-单链表的整表创建与整表删除]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0017-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[整表创建其实可以理解为一下子插入n个节点就好了。头插法思路： 创建一个新节点 将新节点插入到头节点后面 不断的循环这个过程n次 看看代码吧：123456789public void createList(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Node&lt;T&gt; newNode = createNewNode(); newNode.next = head.next; head.next = newNode; &#125; &#125; 非常 easy 啊。这种创建 List 的方法叫做头插法，如下图： 尾插法既然有头插法，肯定就有尾插法，嘿嘿嘿。了解了头插法，尾插法也差不多，我们理理思路： 创建一个新节点 将新节点插入到头节点后面 不断的循环这个过程n次 看起来很美好，但是有个问题，我们需要一个指针指向尾部，不然每次都要从头找起，就太沙雕了。 看看代码： 12345678910public void createList2(int n) &#123; Node&lt;T&gt; tail = head; for (int i = 0; i &lt; n; i++) &#123; Node&lt;T&gt; newNode = createNewNode(); newNode.next = tail.next; tail.next = newNode; tail = newNode; &#125;&#125; 这个就是尾插法了，还是非常简单的，就多了一个变量而已。如下图： 删除删除一个 list，思路与创建一个表反过来就好了。 因为我们持有了头节点，只要不断的删除头节点后面的那个节点就好了。 我们看看代码吧： 123456789101112public void clearAll() &#123; Node&lt;T&gt; delete = head.next; Node&lt;T&gt; next; while (delete != null) &#123; next = delete.next; // 这个假设节点需要释放内存 free(delete); delete = next; &#125;&#125; 如果没有其他的需要，可以直接 head.next = null 就好了。嗯，应该可以的，反正是可以自动回收内存（没有别的地方引用Node）。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中点圆算法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E4%B8%AD%E7%82%B9%E5%9C%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当我们在手机屏幕上绘制一个圆的时候，有没有想过这个圆是怎么绘制出来的呢？由于屏幕的像素是一粒一粒的，所以不像我们在一张纸上，可以利用 sin/cos 函数计算出来。看一张图：将手机屏幕放大了看，你就会看到上图所示的情景，那么这些像素点的位置是如何计算出来的呢？其实就是使用了中点圆算法。在计算机图形学中，中点圆算法是一种用于确定绘制一个圆所需的像素点的算法。 算法概念该算法的目标是找到一个通过使用像素网格的使得每个像素点尽可能接近 $x^2 + y^2 = R^2$ 的路径。 准备工作由于圆具有对称性，所以我们只要考虑1/8个圆即可，我们选择y轴正方向到延其顺时针旋转45°的这个区间为例。就是上图中的 2nd octant 区域。 我们先假设要画的圆的圆心在坐标原点，最后再平移到其应该存在的位置。 设要画的圆的圆心在原点(0，0)，半径为R，起点在(0，R)处，终点在 $(\frac{R}{\sqrt2}, \frac{R}{\sqrt2})$ 处，顺时针生成八分之一圆，利用对称性画出全部的圆。 为了应用中点画圆法，我们还需要定义一个检测函数：$$F(x, y) = x^2 + y^2 - R^2$$任何点 (x，y) 的相对位置可由圆函数的符号来检测： &lt;0 点(x，y)位于数学圆内 =0 点(x，y)位于数学圆上 &gt;0 点(x，y)位于数学圆外 算法演示如下图所示，图中有两条圆弧A和B，假定当前取点为$P_i(x_i, y_i)$，如果顺时针生成圆，那么下一点只能取正右方的点 $E(x_i, y_i)$ 或者右下方的 $SE(x_i+1, y_i-1)$。 假设M是E和SE的中点，即，则： 对圆A来说，F(M)&lt;0，M在圆A内，这说明点E距离圆更近，应取点E作为下一象素点； 对圆B来说，当F(M)&gt;0，M在圆B外，表明SE点离圆更近，应取SE点为下一象素点； 而当F(M)=0时，在E点与SE点之中随便取一个即可，我们约定取SE点。 算法推导我们将中点M代入检测函数可以得到一个值，用 $d_i$表示，它就是该点的决策变量。 然后我们再用它来推导出下一个中点决策变量 $d_{i+1}$ 。 $$ d_i = F(x_i+1， y_i-\frac{1}{2}) = (x_i+1)^2 + (y_i - \frac{1}{2})^2 - R^2 $$ 下面分两种情况来讨论在迭代计算中决策变量 $d_{i+1}$ 的推导。 看上面的算法演示图： 如果 $d_i &lt; 0$，则选择E点，接着下一个中点就是 $M_E(x_i+2,y_i-\frac{1}{2})$，这时新的决策变量为： $$ d_{i+1} = F(x_i+2， y_i-\frac{1}{2}) = (x_i+2)^2 + (y_i - \frac{1}{2})^2 - R^2 $$ 用 $d_{i+1}$ - $d_i$，可以得到： $$ d_{i+1} = d_i + 2x_i + 3$$ 如果 $d_i &gt; 0$ ，则选择 SE 点，接着下一个中点就是$M_{SE}(x_i+2,y_i-\frac{3}{2})$，这时新的决策变量为： $$d_{i+1} = F(x_i+2, y_i-\frac{3}{2}) = (x_i+2)^2 + (y_i-\frac{3}{2})^2 - R^2$$ 用 $d_{i+1}$ - $d_i$，可以得到： $$d_{i+1} = d_i + 2(x_i-y_i) + 5$$ 我们利用递推迭代计算这八分之一圆弧上的每个点，每次迭代需要两步处理： （1）用前一次迭代算出的决策变量的正负来决定本次选择的点 （2）对本次选择的点，递推计算得出新的决策变量的值 接下来只要计算出初始决策变量$d_0$的值即可，对于初始坐标$(0,R)$，显然顺时针生成的下一个决策点坐标是$(1, R-\frac{1}{2})$，此时决策变量 $d_0$为：$d_0 = (1)^2 + (R-\frac{1}{2})^2 - R^2 = \frac{5}{4} - R$ 。显然，如果半径大于 $\frac{5}{4}$，则我们应该取 E 点，否则取 SE 点。 就这样不断的递推下去，就可以得到八分之一圆弧的所有点。 算法表示输入：圆半径$R$、圆心$(x_0，y_0)$， 确定初值：$x=0$，$y=R$，$d=\frac{5}{4}$， 1234567891011while(x &lt;= y)&#123; if(d &gt;= 0)&#123; x = x + 1; y = y - 1; d = d + 2 * (x - y) + 5; &#125; else &#123; x = x + 1; d = d + 2 * x + 3; &#125; println("(" + x + ", " + y + ")");&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-数据结构的起源]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0001-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%B5%B7%E6%BA%90%2F</url>
    <content type="text"><![CDATA[学习任何一种知识，了解一下起源总是会感觉更加有兴趣一些（心里安慰）。 早期的计算机一般都是用来做数值计算的，但是数值计算只能解决一部分问题，还有一部分问题是无法化解为数值计算问题。有时候某些问题涉及到的数据，是无法用纯数据来表示的。比如我们想要将一份表格数据输入到程序中，表格一般会有很多列，所有列的同一行数据都是属于某一项数据的。这个时候，只输入纯数据值肯定是不行的，这样数据值之间的关系就丢失了。 还有的问题需要对数据做一些特殊处理，比如需要对数据一个个按顺序处理，我们就需要一种结构（表，树，图等等），将这些数据存起来以便取用。 然后，1968年，一位大佬就写了一本书，系统的阐述了数据的逻辑结构和储存结构及其操作，正式开宗立派。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005-并发编程模型]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0005-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[嗯，说实话。这个我没看太懂，原文地址如下： http://tutorials.jenkov.com/java-concurrency/concurrency-models.html 我只说我看懂的部分吧。并发模型与分布式系统中使用的体系结构很相似。并发系统中是线程之间相互通信，分布式系统中是进程之间相互通信（进程有可能在不同的机器中）。线程与进程又有很多相似的特性，也就是为什么很多并发模型通常类似于各种分布式系统架构。 并行工作者 在这个模型中，每个 Worker 线程都负责一个完整的工作。 如果我们拿汽车工厂举例，那么就是每台车都交给一个工人来生产，工人们都从 0 开始，攒一个完整的车出来。 这个模型很容易理解，代码也易于阅读，提高并发度只需要增加线程就好了。 并行工作者模型虽然看起来简单，却隐藏着一些缺点。 如果，Worker 需要访问共享数据的话，这个模型就会变得复杂： Worker 之间需要避免竞态，死锁等问题。而且，在访问共享数据的时候，如果这个时候竞争很激烈的话，会导致出现线程串行化的现象。 流水线模式看下模型图： 这个就类似于工厂里面的那种流水线了，每个 Worker 负责不同的部分，当前面的 Worker 完成了自己的任务之后就会将结果交给下一个 Worker。这样的话，就不会与别的 Worker 共享数据。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-如何创建并运行 java 线程]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0006-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%20java%20%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java 中线程也是一个类（Thread），继承至 Object 类。我们创建一个线程实例，需要继承至 Thread 类。1Tread thread = new Thread();执行这个线程，需要调用 thread 的 start 方法。1thread.start();在上面的例子中，我们并没有为线程编写运行代码，因此调用该方法后线程就终止了。 想要给线程编写执行代码，有两种方案： 创建Thread子类的一个实例并重写run方法 创建 Thread 实例的时候，传入一个 Runnable 对象 创建 Thread 子类1234567Thread thread = new Thread() &#123; @Override public void run() &#123; System.out.println("MyThread running"); &#125;&#125;;thread.start(); 一旦thread线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回，就好像run方法是在另外一个cpu上执行一样。 当run方法执行后，将会打印出字符串MyThread running。 实现 Runnable 接口123456789public class MyRunnable implements Runnable &#123; public void run()&#123; System.out.println("MyRunnable running"); &#125;&#125;// 为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。Thread thread = new Thread(new MyRunnable());thread.start(); 当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。 那么，这两种方案，哪种好呢？ 对于这两种方式哪种好并没有一个确定的答案，它们都能满足要求。我自己倾向于 实现 Runnable 接口 的方式，因为它将任务从线程里面分离出来了。 常见错误创建并运行一个线程所犯的常见错误是调用线程的run()方法而非start()方法，如下所示： 12Thread newThread = new Thread(MyRunnable());newThread.run(); //should be start(); 起初你并不会感觉到有什么不妥，因为run()方法的确如你所愿的被调用了。但是，事实上,run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行run()方法，必须调用新线程的start方法。 线程起名当创建一个线程的时候，可以给线程起一个名字。它有助于我们区分不同的线程。例如：如果有多个线程写入System.out，我们就能够通过线程名容易的找出是哪个线程正在输出。例子如下： 1234MyRunnable runnable = new MyRunnable();Thread thread = new Thread(runnable, "New Thread");thread.start();System.out.println(thread.getName()); 我们可以使用如下方法来获取当前线程的名字： 1String threadName = Thread.currentThread().getName(); 例子这里是一个小小的例子。首先输出执行main()方法线程名字。这个线程是JVM分配的。然后开启10个线程，命名为1~10。每个线程输出自己的名字后就退出。 123456789101112public class ThreadExample &#123; public static void main(String[] args)&#123; System.out.println(Thread.currentThread().getName()); for(int i=0; i&lt;10; i++)&#123; new Thread("" + i)&#123; public void run()&#123; System.out.println("Thread: " + getName() + "running"); &#125; &#125;.start(); &#125; &#125;&#125; 需要注意的是，尽管启动线程的顺序是有序的，但是执行的顺序并非是有序的。也就是说，1号线程并不一定是第一个将自己名字输出到控制台的线程。这是因为线程是并行执行而非顺序的。Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-竟态条件与临界区]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0007-%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[在一个程序中运行多个线程本身不会有问题，有问题的是这些线程同时访问了同样的资源。比如：同一个变量，同一个数据库。当然如果这些线程都只是读取，那不会有问题，但是如果有一个或者多个写线程就会有问题。多线程同时执行下面的代码可能会出错：123456public class Counter &#123; protected long count = 0; public void add(long value)&#123; this.count = this.count + value; &#125;&#125; 想象下线程A和B同时执行同一个Counter对象的add()方法，我们无法知道操作系统何时会在两个线程之间切换。JVM并不是将这段代码视为单条指令来执行的，而是按照下面的顺序： 123从内存获取 this.count 的值放到寄存器将寄存器中的值增加value将寄存器中的值写回内存 假设线程交替执行： 12345678this.count = 0; A: 读取 this.count 到一个寄存器 (0) B: 读取 this.count 到一个寄存器 (0) B: 将寄存器的值加2 B: 回写寄存器值(2)到内存. this.count 现在等于 2 A: 将寄存器的值加3 A: 回写寄存器值(3)到内存. this.count 现在等于 3 两个线程分别加了2和3到count变量上，两个线程执行结束后count变量的值应该等于5。 然而由于两个线程是交叉执行的，两个线程从内存中读出的初始值都是0。 然后各自加了2和3，并分别写回内存。 最终的值并不是期望的5，而是最后写回内存的那个线程的值，上面例子中最后写回内存的是线程A，但实际中也可能是线程B。如果没有采用合适的同步机制，线程间的交叉执行情况就无法预料。 竟态条件与临界区当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。 导致竞态条件发生的代码区称作临界区。 上例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0000-前言]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0000-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[因为会做成一个系列，所以每篇的东西会比较少，嗯，大概吧。 尽量不copy书里面的文字，用自己的话来说一遍。 文章中的例子是我自己写的，只是经过了简单的测试，并不保证一定完全正确。可以作为参考，但是还是需要自己想想再写。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO 阻塞]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FIO%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[昨天在整理自己的博客的时候，想到的一个问题：进程在从磁盘中读取内容的时候，CPU 在干什么？？？之所以会这样问，是因为，CPU的速度比磁盘要快很多，具体有多块，看这篇文章。 磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。 这是从文中截取的一段，可以体会一下。 那么我的问题的本质是，在这段等带的时间中，CPU 是去搞别的是事情了（执行别的线程），还是空等呢？？？IO 阻塞与线程遇到锁产生的阻塞是一样的吗？ 经过查询资料，Linux系统下，CPU与磁盘交互时大致发生了如下事情： 进程调用库函数向内核发起读文件请求（切换到内核态）； 在 Page Cache（它位于内存和文件之间缓冲区，文件IO操作实际上只和page cache交互，不直接和内存交互。） 中查询数据是否存在。 如果页缓存命中，那么直接返回文件内容；如果页缓存缺失，那么产生一个页缺失异常，需要从磁盘读取数据。 CPU向磁盘发送数据读取指令。 然后，发送完指令后，CPU会转去执行其它任务（为了提高效率），磁盘则会将逻辑块号转换成对应的盘片、磁道、扇区组成的三元组，从而定位到了数据所在的扇区。之后磁盘会采用DMA（直接存储器访问技术，其不需要CPU干预）传送数据到CPU指定的主存地址。 最后，磁盘传送完毕后，会直接发送一个中断信号给CPU芯片的一个外部引脚，把CPU“召唤”回来重新执行先前未完成的任务。 上面的过程不一定准确，但是比较符合我的期望了，准备恶补一下计算机的相关原理。 所以，在 IO 阻塞的时间之内，CPU 也没有闲着（反过来想一下，如果CPU无法干别的事情的话，那么只要IO线程大于CPU线程，那么就卡死了）。 线程状态其实这里面也有提到，我之前没有注意。 线程的状态分为： 可运行（就绪）：线程被创建之后，调用Start（）函数就到了这个状态。 运行：Start（）函数之后，CPU切换到了这个线程开始执行里面的Run方法就称为运行状态。 阻塞：阻塞状态是指线程因为某种原因放弃了cpu执行权，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu 执行权 转到运行(running)状态。阻塞的情况分三种。 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 结束 线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 线程的个数一般说来，大家认为线程池的大小经验值应该这样设置：（其中N为CPU的个数） 如果是CPU密集型应用，则线程池大小设置为N+1 如果是IO密集型应用，则线程池大小设置为2N+1 我们简单的思考一下，为什么会这样？？？ 对于CPU密集型任务，尽量使用较小的线程池，因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。 IO密集型任务可以使用稍大的线程池，IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。 但是，其实最让我疑惑的是，为何要 +1？ 然后我看到了这句话： 即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。 额，这里节省的时间能够补回来由于多了一个线程导致的线程切换的开销吗？？？]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Final 关键字]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FJava%20Final%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final 关键字一般会多用于这样的几个地方： 变量当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。 防止被重写比如：java.lang.String 类 内部类访问外部局部变量这个我们经常使用，而且IDE也会提示你。但是你有没有想过Java为什么要设计成这样，这其中的秘密何在？ 比如，我们有这样的代码： 12345678910// 这个方法没有意义 public void fun() &#123; final int i = 10; new Thread(new Runnable() &#123; @Override public void run() &#123; int c = i + 10; &#125; &#125;).start(); &#125; 如果，我们没有给 i 声明 final 修饰符，IDE就会报一个错误（need to be final）。需要声明为 final 是因为，编译器编译的时候其实悄悄对函数做了手脚，偷偷把外部环境方法的局部变量 i，拷贝了一份到匿名内部类里。其实我们的代码经过编译之后变成了这样： 123456789101112public void fun() &#123; final int i = 10; new Thread(new Runnable() &#123; // copy 了一份 int copyI = i; @Override public void run() &#123; int c = i+10; &#125; &#125;).start();&#125; 所以，这样就知道为啥需要声明为 final 了，因为内部拷贝了一份，而内部使用到了这个变量的值，如果在运行时外部的值改变了，那么内部的值却没有更新，就会出现各种问题，所以就干脆不让它改变。 以前在面试的时候，总是有很多面试官喜欢问：final、finally的区别！这特么就很蛋疼，这两货除了长的像，有啥是一样的。其实他们应该问 final 与 volatile 有啥区别？这个问题就比较阴险了，如果你不往并发上想的话，就会觉得这特么是什么脑残问题！！ 说到这里，我们还是应该从 Java 的内存模型说起。 计算机内存模型大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度，因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的，下面以多核CPU为例）。 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK#锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 说完了内存模型，我们还要了解并发中的3个名词。 3个名词 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：即程序执行的顺序按照代码的先后顺序执行。 这3个名词就不细说了，有兴趣的可以自己查查资料。 最后，我们来说，Java 的内存模型。 Java内存模型在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 Volatile了解了这些，我们再来看看 volatile 的作用。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 那么这两句话是什么意思呢？可见性比较好理解，就是一个线程更改了值，另外一个线程需要重新读取这个值。这里又有一个很有趣的问题，看下面的代码： 12345public volatile int inc = 0;public void increase() &#123; inc++;&#125; 当这个方法在多线程中运行的时候，会出现问题。我们来细细说到一下： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 这里可能就有人想不通了，线程 1 从阻塞变为运行状态后，应该还需要再次读取 inc 的值才对啊，为啥它没有读取呢？其实还是那个原因，我们写的是Java代码，而程序运行的是指令，我们将 inc++ 这行代码转成指令看看： 1230: iconst_11: istore_12: iinc 1, 1 那么，这3个指令是啥意思呢？我们再将这3个指令转为 Java 代码看看： 12345public void increase()&#123; int tmp = inc; // 0 tmp = tmp + 1; // 1 inc = tmp; // 2&#125; 嗯，现在明白了吧。再 inc++ 这个过程中，由于对 inc 的读取在阻塞前已经完成了，所以后面就不用再次读取了。 再说一个有趣的例子，我们有这样的代码： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？ 答案是不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 也许你会很奇怪，就算是多线程，这段代码也不会出现问题啊，怎么可能会出现死循环，简直是无稽之谈！ 实际上，从代码上来看，只要线程2后执行，那么就一定会终止线程。但是，我们需要知道我们写出来的代码不一定就是运行的代码（编译器还会做一些手脚的）。在某些情况下，编译器会直接将上面的代码优化成下面这样： 123456789//线程1boolean stop = false;// 这里编译器做了优化while(true)&#123; doSomething();&#125; //线程2stop = true; 可以看到，由于没有 volatile 关键字，编译器不知道它是多线程程序，所以就直接优化成了死循环。 下面，来到了我们想要说的重点，重排序。啥是重排序呢？一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 一般情况下，这个优化没啥问题，它不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 如果，我们给 inited 添加 volatile 关键字，那么就不会发生指令重排序，程序也就不会出错。 说完了 volatile 对重排序的影响，下面我们说说 final，它对重排序也有一点的影响。 对于 final 域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个 final 域的写，与随后把这个构造对象的引用赋值给一个变量，这两个操作之间不能重排序 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序 举个例子（摘自《Java并发编程实践》）： 12345678public class Holder &#123; private int n; public Holder(int n) &#123; this.n = n; &#125; public void assertSanity() &#123; if (n != n) throw new AssertionError("error"); &#125;&#125; 假设这里有一个线程A执行了下面一段代码： 1Holder holder = new Holder(10); 同时有另一个线程B也在执行下面这段代码： 1if (holder != null) holder.assertSanity(); 那么在某些情况下就会抛出上面的异常，原因就是：Holder holder = new Holder(10);其实是由三步组成的 给holder分配内存 调用构造函数 将holder指向刚分配的内存 理想中是这个执行顺序，然而事实上这三步并不一定按照这个顺序执行，是为了优化效率而存在的指令重排在作怪，假如一个执行顺序为1 3 2，那么在刚执行完1和3的时候线程切换到B，这时候holder由于指向了内存所以不为空并调用assertSanity函数，该函数中的if语句并不是一步完成： 取左表达式n的值 取右表达式n的值 进行！=表达式运算 那么假设刚执行完第一步的时候B线程挂起并重新回到A线程，A线程继续执行构造函数并将n赋值为10，然后再次跳回B线程，这时候执行第2步，那么就会造成前后取到的n不一样，从而抛出异常。 那么加了final修饰之后会如何呢，JVM做了如下保证：一旦对象引用对其他线程可见，则其final成员也必须正确的赋值了。就是说一旦你得到了引用，final域的值(即n)都是完成了初始化的，因此不会再抛出上面的异常。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（三）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%882.5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的分析 IoScheduler 类。首先要说明的是，RxJava2 中虽然使用到了 Java 的线程池，但是还有很多其他的东西，比如，接下来你就会看到 IoScheduler 中自己实现一个简单的线程池。从使用说起1234567// RxJavaScheduler.Worker worker = Schedulers.io().createWorker();worker.schedule();// JavaScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);scheduledExecutorService.schedule() 先不谈运行原理，这里我们比较一下它与我们平时使用的线程池的不同之处。 一般我们使用的时候，都是先获取线程池的对象，然后传递一个 runnable 给它，让它取执行。 但是 RxJava 里面，似乎有点不一样。它需要先创建 worker 对象，然后才能将 action 传递给它。与Java方式比较，它多了一个创建 worker 的过程，那么显然本文的核心就是弄清楚，worker 对象是做什么的？为什么设计成需要 worker 对象才能提交任务？ 先说说每个类具体的作用： 类名 作用 Worker 抽象类，提供了执行 action 的几个方法，支持单次执行，定时多次执行。定时多次执行是基于单次执行，默认已经在该类中实现。 NewThreadWorker Worker 的子类，实现了单次执行方法，使用的是 Executors.newScheduledThreadPool 方法。 ThreadWorker NewThreadWorker 的子类，增强了一下，提供了过期时间的判断方法。 SequentialDisposable 一种容器，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。经过不断的替换引用，从而达到可以支持 Worker 多次执行任务仍然能够 dispose 的功能。 ScheduledRunnable 该类是一个集大成的类，它是一个可以取消任务，也可以取消订阅的 runnable。 AbstractDirectTask 这货虽然名字是 task，然是实际上与 ScheduledRunnable 是一路货色，当成 runnable 也可以。 ScheduledDirectTask AbstractDirectTask 的子类 EventLoopWorker Worker 的子类，使用的是 NewThreadWorker 实现了单次执行。 CachedWorkerPool Rxjava自己实现的一个线程池。 从内部类开始IoSchedulerIoScheduler 源码不长，但是它有3个内部类，我们从内部类开始，因为每个内部类的功能都是比较单一的，分析起来很方便，知道了内部类的作用，外部类的分析就更简单了。 IoScheduler.java 123456789public final class IoScheduler extends Scheduler &#123; static final class CachedWorkerPool implements Runnable &#123;...&#125; static final class EventLoopWorker extends Scheduler.Worker &#123;...&#125; static final class ThreadWorker extends NewThreadWorker &#123;...&#125; &#125; IoScheduler.ThreadWorker我们从代码量最少的 ThreadWorker 来开始： ThreadWorker.java 可以看出来，ThreadWorker 是对 NewThreadWorker 的一个增强，增加了过期的功能。 123456789101112131415161718static final class ThreadWorker extends NewThreadWorker &#123; private long expirationTime; ThreadWorker(ThreadFactory threadFactory) &#123; super(threadFactory); this.expirationTime = 0L; &#125; // 获取过期时间 public long getExpirationTime() &#123; return expirationTime; &#125; // 设置过期时间 public void setExpirationTime(long expirationTime) &#123; this.expirationTime = expirationTime; &#125;&#125; ThreadWorker 继承了 NewThreadWorker，那我们就需要看看 NewThreadWorker 是用来做什么的。 NewThreadWorker NewThreadWorker.java 它继承了 Scheduler.Worker。 从注释上来看，它持有一个单线程的ScheduledExecutorService。 123456/** * Base class that manages a single-threaded ScheduledExecutorService as a * worker but doesn't perform task-tracking operations. * */public class NewThreadWorker extends Scheduler.Worker implements Disposable &#123;...&#125; ####Scheduler.Worker 由于 NewThreadWorker 类继承了 Scheduler.Worker，Scheduler.Worker 是一个抽象类，它的核心方法如下： io.reactivex.Scheduler.Worker.java 12345678910111213141516171819202122232425 public abstract static class Worker implements Disposable &#123; @NonNull public Disposable schedule(@NonNull Runnable run) &#123; // 调用了抽象方法 return schedule(run, 0L, TimeUnit.NANOSECONDS); &#125;// 子类需要实现该方法 @NonNull public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);// 有一个默认实现周期性的方法，子类如果有特殊需要，可以覆盖该方法 @NonNull public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; ... return sd; &#125; public long now(@NonNull TimeUnit unit) &#123; return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; &#125; 所以我们只需要分析两个方法： io.reactivex.Scheduler.Worker#schedule(java.lang.Runnable, long, java.util.concurrent.TimeUnit) io.reactivex.Scheduler.Worker#schedulePeriodically 第一个方法是抽象的，所以我们先放着。 我们先看 schedulePeriodically 这个方法是如何实现周期性的。 io.reactivex.Scheduler.Worker.java 1234567public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; final SequentialDisposable first = new SequentialDisposable(); ... return sd;&#125; 第一行就出现了一个新的类，SequentialDisposable，这个类比较简单，我们看看： SequentialDisposable SequentialDisposable.java 该类是一种容器，用来放入 Disposable 的引用，允许以原子方式更新/替换引用值。 1234567891011121314151617181920212223242526272829303132333435363738public final class SequentialDisposableextends AtomicReference&lt;Disposable&gt;implements Disposable &#123; private static final long serialVersionUID = -754898800686245608L; public SequentialDisposable() &#123; // nothing to do &#125; public SequentialDisposable(Disposable initial) &#123; lazySet(initial); &#125; /** * 原子的：将引用值换成next，会对之前的引用对象调用 dispose */ public boolean update(Disposable next) &#123; return DisposableHelper.set(this, next); &#125; /** * 原子的：将引用值换成next，不会对之前的引用对象调用 dispose */ public boolean replace(Disposable next) &#123; return DisposableHelper.replace(this, next); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125;&#125; 这个类很是很简单的，没有什么复杂的代码，我们把它当作一个容器就好了。 再回到 schedulePeriodically 方法中： 123456789101112131415161718192021222324252627282930313233 public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; // 创建一个容器，引用值为null final SequentialDisposable first = new SequentialDisposable();// 创建一个容易，引用值为 first final SequentialDisposable sd = new SequentialDisposable(first); // 这个暂时没啥作用，当作 decoratedRun = run 理解就好 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 计算时间，我就不细说了，有兴趣自己算一算 final long periodInNanoseconds = unit.toNanos(period); final long firstNowNanoseconds = now(TimeUnit.NANOSECONDS); final long firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay); // 这里调用了 schedule ，它是一个抽象方法 // 暂时不会去分析 schedule，我们这里可以把它理解为 pool 的 execute 方法 // 反正它会去执行我们传递的 runnable // PeriodicTask 就是一个 runnable // 后面的参数，是指定延时长度与单位 Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd, periodInNanoseconds), initialDelay, unit); if (d == EmptyDisposable.INSTANCE) &#123; return d; &#125; // 将 first 的引用值改为 d // 这里之所以要赋值，是因为第一次执行时，如果使用者调用了 dispose，那么我们必须取消订阅 // 由于返回了 sd，所以 sd 会调用 first 的 dispose，first 会调用 d 的 dispose // 这样就取消订阅了 first.replace(d); return sd; &#125; 上面注释写的比较详细了，下面我们看 PeriodicTask 是如何周期执行的，这里我们可以想一下我们使用 Hander 写一个定时器的做法，其实是一样的。 Scheduler.Worker.PeriodicTask io.reactivex.Scheduler.Worker.PeriodicTask PeriodicTask 是 Worker 的一个内部类，Worker 是 Scheduler 的内部类。 该类就是用来实现周期任务的。 1final class PeriodicTask implements Runnable &#123;...&#125; 既然是实现了 Runnable，那我们只看 run 方法。 io.reactivex.Scheduler.Worker.PeriodicTask#run 123456789101112131415161718192021222324252627282930313233@Overridepublic void run() &#123; // 这里就是 run 执行的位置，我们需要执行的 runnable 就是在这里执行的 decoratedRun.run(); // 没有取消订阅 if (!sd.isDisposed()) &#123; // 下面的一段是计算下一次运行的时间，嗯，自己看看吧 long nextTick; long nowNanoseconds = now(TimeUnit.NANOSECONDS); // If the clock moved in a direction quite a bit, rebase the repetition period if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS &lt; lastNowNanoseconds || nowNanoseconds &gt;= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) &#123; nextTick = nowNanoseconds + periodInNanoseconds; /* * Shift the start point back by the drift as if the whole thing * started count periods ago. */ startInNanoseconds = nextTick - (periodInNanoseconds * (++count)); &#125; else &#123; nextTick = startInNanoseconds + (++count * periodInNanoseconds); &#125; lastNowNanoseconds = nowNanoseconds; long delay = nextTick - nowNanoseconds; // 这里将 sd 的引用替换为新的 disposable // 因为旧的任务在第一行代码已经执行完了，所以替换掉 // schedule 方法有安排了下一次的任务，这样就成了一个循环，达到了周期性的目的 sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS)); &#125;&#125; 嗯，到了这里，io.reactivex.Scheduler.Worker类就分析完了，下面回到我们的 NewThreadWorker 类中。 ####NewThreadWorker 看构造方法： NewThreadWorker.java 123public NewThreadWorker(ThreadFactory threadFactory) &#123; executor = SchedulerPoolFactory.create(threadFactory);&#125; 构造函数中调用 SchedulerPoolFactory 的 create 方法，创建了一个 executor 对象。 SchedulerPoolFactory看看 SchedulerPoolFactory 的 create 方法： SchedulerPoolFactory .java 123456789public static ScheduledExecutorService create(ThreadFactory factory) &#123; final ScheduledExecutorService exec = Executors.newScheduledThreadPool(1, factory); // PURGE_ENABLED 的值与系统有关，暂且不提 if (PURGE_ENABLED &amp;&amp; exec instanceof ScheduledThreadPoolExecutor) &#123; ScheduledThreadPoolExecutor e = (ScheduledThreadPoolExecutor) exec; POOLS.put(e, exec); &#125; return exec;&#125; 这里我们只关注第一行代码，与注释说的一样，它创建了一个单线程的 ScheduledExecutorService 对象。 ####NewThreadWorker 构造方法与父类，我们都分析完了，现在看看它是怎么实现那个抽象方法的。 NewThreadWorker 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@NonNull@Overridepublic Disposable schedule(@NonNull final Runnable run) &#123; // 这里它覆盖了原来的默认实现，传递了一个null // 没看懂，方法参数不接受 null 啊 return schedule(run, 0, null);&#125;@NonNull@Overridepublic Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; // disposed 就没啥说的 if (disposed) &#123; return EmptyDisposable.INSTANCE; &#125; // 调用了 scheduleActual 方法 return scheduleActual(action, delayTime, unit, null);&#125;/** * 将runnnable 包装成 ScheduledRunnable，交给 ScheduledExecutorService 去执行 * 如果调度被驳回， ScheduledRunnable.wasScheduled 的值为 false。 */@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) &#123; // 直接理解成 decoratedRun = run Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 将 decoratedRun 包装一下 ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); // 传递的参数为 null，这一段跳过 if (parent != null) &#123; if (!parent.add(sr)) &#123; return sr; &#125; &#125; Future&lt;?&gt; f; try &#123; if (delayTime &lt;= 0) &#123; // 不延迟就直接执行 f = executor.submit((Callable&lt;Object&gt;)sr); &#125; else &#123; // 延迟执行 f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit); &#125; // 设置 future，便于获取执行结果 sr.setFuture(f); &#125; catch (RejectedExecutionException ex) &#123; if (parent != null) &#123; parent.remove(sr); &#125; RxJavaPlugins.onError(ex); &#125; return sr;&#125; 嗯，现在，我们需要看看 ScheduledRunnable 到底是个什么，起什么作用。 ScheduledRunnable ScheduledRunnable 12public final class ScheduledRunnable extends AtomicReferenceArray&lt;Object&gt;implements Runnable, Callable&lt;Object&gt;, Disposable &#123;...&#125; 这个类的源码比较奇特，我就不展开了，我们把它当作一个 Callable 使用就可以了，但是它也支持 Disposable。源码里面都是一些原子性的赋值更新处理。 回到 NewThreadWorker 类，它的 schedule 方法就是将我们传递的 runnable 包装一下，然后将这个包装好的 ScheduledRunnable 交给 ScheduledExecutorService 去处理。 因为 ScheduledRunnable 实现了 Disposable，所以直接返回它，可以用于取消订阅。ScheduledRunnable 还实现了 Callable 是因为我们取消订阅的时候，可以用于线程池取消任务（f.cancel(true)）。 NewThreadWorker到了这里 NewThreadWorker 的一系列 schedule 方法就分析完了，然而，我们发现，它除了 schedule 方法之外，还提供了一些别的public的方法，顺便看了算求。 io.reactivex.internal.schedulers.NewThreadWorker#scheduleDirect 这个方法也是提交一个 runnable 给线程池执行，然是不是使用了 ScheduledRunnable 来包装， 而是使用的 ScheduledDirectTask 123456789101112131415161718public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; // 这里出了一个新类 ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; // 下面的代码与之前分析的一样，就跳过 Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 那我们就来分析分析 ScheduledDirectTask 类。 ScheduledDirectTask ScheduledDirectTask 继承了 AbstractDirectTask 类 主要是实现了 call 方法，给 runner 赋值，调用 runnable 的 run 方法 12345678910111213141516171819202122public final class ScheduledDirectTask extends AbstractDirectTask implements Callable&lt;Void&gt; &#123; private static final long serialVersionUID = 1811839108042568751L; public ScheduledDirectTask(Runnable runnable) &#123; super(runnable); &#125; @Override public Void call() throws Exception &#123; runner = Thread.currentThread(); try &#123; runnable.run(); &#125; finally &#123; // 设置为完成状态 // 还是没有搞太明白，set 与 lazySet 的区别，什么内存屏障啊 lazySet(FINISHED); runner = null; &#125; return null; &#125;&#125; AbstractDirectTask AbstractDirectTask 源码不长，我就全部贴出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class AbstractDirectTaskextends AtomicReference&lt;Future&lt;?&gt;&gt;implements Disposable &#123; private static final long serialVersionUID = 1811839108042568751L; protected final Runnable runnable; protected Thread runner; // 哦，我还不知道有个 Functions.EMPTY_RUNNABLE 可以用 protected static final FutureTask&lt;Void&gt; FINISHED = new FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, null); protected static final FutureTask&lt;Void&gt; DISPOSED = new FutureTask&lt;Void&gt;(Functions.EMPTY_RUNNABLE, null); AbstractDirectTask(Runnable runnable) &#123; this.runnable = runnable; &#125; @Override public final void dispose() &#123; Future&lt;?&gt; f = get(); if (f != FINISHED &amp;&amp; f != DISPOSED) &#123; // 将状态设置为取消 if (compareAndSet(f, DISPOSED)) &#123; // 取消线程池里的任务 if (f != null) &#123; f.cancel(runner != Thread.currentThread()); &#125; &#125; &#125; &#125; @Override public final boolean isDisposed() &#123; Future&lt;?&gt; f = get(); return f == FINISHED || f == DISPOSED; &#125; public final void setFuture(Future&lt;?&gt; future) &#123; for (;;) &#123; Future&lt;?&gt; f = get(); if (f == FINISHED) &#123; break; &#125; if (f == DISPOSED) &#123; // 取消线程池里的任务 future.cancel(runner != Thread.currentThread()); break; &#125; // 设置引用值为 f if (compareAndSet(f, future)) &#123; break; &#125; &#125; &#125;&#125; 感觉，ScheduledDirectTask 这个类的功能与 ScheduledRunnable 的功能差不多啊，ScheduledRunnable 更强力一点。至少在我们分析的这个流程里面，感觉不到区别，嗯，不过想到 scheduleActual 方法比 scheduleDirect多了一个参数，想来，玄机应该在这里，有兴趣的自己再去找找。 如果实在心里想不通的，把 ScheduledDirectTask 与 ScheduledRunnable 都当成具有解除订阅与取消任务的增强型 Runnable 就好了。 NewThreadWorker再次回到 NewThreadWorker，还有一个方法没有说到： io.reactivex.internal.schedulers.NewThreadWorker#schedulePeriodicallyDirect 该方法用于周期性的执行任务 123456789101112131415161718192021222324252627282930313233public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, long period, TimeUnit unit) &#123; final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 这里如果周期性设置为0，也就是说没有间隔的重复执行任务 if (period &lt;= 0L) &#123; // 没有间隔的话，使用 InstantPeriodicTask InstantPeriodicTask periodicWrapper = new InstantPeriodicTask(decoratedRun, executor); try &#123; Future&lt;?&gt; f; if (initialDelay &lt;= 0L) &#123; f = executor.submit(periodicWrapper); &#125; else &#123; f = executor.schedule(periodicWrapper, initialDelay, unit); &#125; periodicWrapper.setFirst(f); &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125; return periodicWrapper; &#125; // 有间隔的话，使用 ScheduledDirectPeriodicTask ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun); try &#123; Future&lt;?&gt; f = executor.scheduleAtFixedRate(task, initialDelay, period, unit); task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 里面，线程池的使用，Task 的分析就不展开了，因为之前已经分析过一个 Task，想一想都能知道里面的代码大概长什么样，有兴趣的自己去看看吧。 好了，到这里，NewThreadWorker 类，我们就分析完了，没想到这么短的一个内部类，里面有这么多东西。不过，总结一下，里面的东西其实并不多。 schedule 等方法，用于提交任务，内部使用的是 ScheduledExecutorService 线程池 schedule 等方法返回一个 Disposable，用于解除订阅，解除订阅时，也会取消该任务。 周期性的实现，有两种方式，一种是自己调用自己实现的，一种是使用 ScheduledExecutorService 的 scheduleAtFixedRate 方法实现的。 IoScheduler.EventLoopWorker接下来，我们趁热打铁，看另外一个继承至 Scheduler.Worker 的内部类。 io.reactivex.internal.schedulers.IoScheduler.EventLoopWorker EventLoopWorker 继承至 Scheduler.Worker Worker 上面分析过，是用来执行任务的。 123456789101112131415161718192021222324252627282930313233343536373839404142 static final class EventLoopWorker extends Scheduler.Worker &#123; private final CompositeDisposable tasks; // 这里有一个新东西 private final CachedWorkerPool pool; private final ThreadWorker threadWorker; final AtomicBoolean once = new AtomicBoolean(); EventLoopWorker(CachedWorkerPool pool) &#123; this.pool = pool; this.tasks = new CompositeDisposable(); this.threadWorker = pool.get(); &#125; @Override public void dispose() &#123; if (once.compareAndSet(false, true)) &#123; tasks.dispose(); // releasing the pool should be the last action // 将线程返回线程池里面去 pool.release(threadWorker); &#125; &#125; @Override public boolean isDisposed() &#123; return once.get(); &#125; @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125;// 让 ThreadWorker 去执行一个 aciton 任务，这里最后一个参数注意一下 // threadWorker 里面只有一个线程，所以，任务是顺序执行的 return threadWorker.scheduleActual(action, delayTime, unit, tasks); &#125; &#125; 看里面的代码还是非常简单的，它的构造方法接收一个 CachedWorkerPool，这个是 EventLoopWorker 类里面，唯一一个陌生类，看看这个类： IoScheduler.CachedWorkerPool欸，太好了，这个也是 IoScheduler 的内部类，这样的话，把这个类分析完了之后， IoScheduler 的内部类就分析完成了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static final class CachedWorkerPool implements Runnable &#123; private final long keepAliveTime; // 队列 private final ConcurrentLinkedQueue&lt;ThreadWorker&gt; expiringWorkerQueue; final CompositeDisposable allWorkers; // java 的线程池 private final ScheduledExecutorService evictorService; private final Future&lt;?&gt; evictorTask; // 线程工程，一般就 new 一个 Thread，然后给个名字就完事了 private final ThreadFactory threadFactory; CachedWorkerPool(long keepAliveTime, TimeUnit unit, ThreadFactory threadFactory) &#123; this.keepAliveTime = unit != null ? unit.toNanos(keepAliveTime) : 0L; this.expiringWorkerQueue = new ConcurrentLinkedQueue&lt;ThreadWorker&gt;(); this.allWorkers = new CompositeDisposable(); this.threadFactory = threadFactory; ScheduledExecutorService evictor = null; Future&lt;?&gt; task = null; if (unit != null) &#123; // 这里也创建了一个单个线程的线程池 evictor = Executors.newScheduledThreadPool(1, EVICTOR_THREAD_FACTORY); // 创建定时任务，runnable 是 this，就是 run 里面的代码 task = evictor.scheduleWithFixedDelay(this, this.keepAliveTime, this.keepAliveTime, TimeUnit.NANOSECONDS); &#125; evictorService = evictor; evictorTask = task; &#125; @Override public void run() &#123; evictExpiredWorkers(); &#125; ThreadWorker get() &#123; // 如果线程池关闭了，则返回一个关闭的线程池 if (allWorkers.isDisposed()) &#123; return SHUTDOWN_THREAD_WORKER; &#125; // 队列不为空，从队列中取一个 worker 出来 while (!expiringWorkerQueue.isEmpty()) &#123; ThreadWorker threadWorker = expiringWorkerQueue.poll(); if (threadWorker != null) &#123; return threadWorker; &#125; &#125; // 队列没有 worker，new 一个出来 // No cached worker found, so create a new one. ThreadWorker w = new ThreadWorker(threadFactory); // ThreadWorker 继承 NewThreadWorker // NewThreadWorker 实现了 Disposable // 调用 dispose 会关闭里面的线程池 allWorkers.add(w); return w; &#125; /** * 将 worker 重新放入到线程池（队列）中，将过期时间重置 */ void release(ThreadWorker threadWorker) &#123; // Refresh expire time before putting worker back in pool threadWorker.setExpirationTime(now() + keepAliveTime); expiringWorkerQueue.offer(threadWorker); &#125; /** * 移除过期 worker */ void evictExpiredWorkers() &#123; if (!expiringWorkerQueue.isEmpty()) &#123; long currentTimestamp = now(); // 遍历队列 for (ThreadWorker threadWorker : expiringWorkerQueue) &#123; // 看看 threadWorker 过期了没有 if (threadWorker.getExpirationTime() &lt;= currentTimestamp) &#123; // 过期了就移除 if (expiringWorkerQueue.remove(threadWorker)) &#123; // 从队列移除成功后，将 Disposable 也移除掉 allWorkers.remove(threadWorker); &#125; &#125; else &#123; // 因为队列是按照时间排列的，所以找到第一个没有过期的就可以退出循环了 // Queue is ordered with the worker that will expire first in the beginning, so when we // find a non-expired worker we can stop evicting. break; &#125; &#125; &#125; &#125; long now() &#123; return System.nanoTime(); &#125; /** * 关闭线程池 */ void shutdown() &#123; allWorkers.dispose(); if (evictorTask != null) &#123; evictorTask.cancel(true); &#125; if (evictorService != null) &#123; evictorService.shutdownNow(); &#125; &#125;&#125; 注释很清晰，如果你阅读过Java的线程池源码，会更容易理解，这里就是教我们如果实现一个自己的 CacheThreadPool 线程池啊。只不过这个线程池（ConcurrentLinkedQueue）的每一个 worker 都是一个线程池（NewThreadWorker）。 嗯，到这里，IoScheduler 的内部类就讲完了，我们看看它的其他方法吧。 首先，IoScheduler 是继承至 Scheduler 的，所以我们先从它对抽象方法的实现看起。 IoScheduler IoScheduler 123public Worker createWorker() &#123; return new EventLoopWorker(pool.get());&#125; 它是直接创建一个 EventLoopWorker 对象并返回。 根据我们上面的分析，EventLoopWorker 将任务给了 ThreadWorker 去执行，ThreadWorker 又将任务给了一个单个线程的线程池去执行。 而且，ThreadWorker 是线程池中的线程池，因为它就一个线程，所以可以把它当作单个线程而不是线程池，那么就是说，IoScheduler 的线程池就是一个功能与Java中的Executors.newCachedThreadPool()方法创建出来的线程池功能是差不多的。 好吧，虽然差不多，但是毕竟这里里面的线程池与线程提供了对 Disposable 接口的支持。 感觉，EventLoopWorker 的作用，只是一个代理啊，最后还是将任务转给了 CachedWorkerPool。可能为了支持 dispose 操作花费了很多心思。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术（基础知识）笔记]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%88%E5%8D%B7%E4%B8%80%EF%BC%89%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 Java程序设计概述面向对象设计用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。即时编译解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。 字节码可以（在运行时刻）动态的翻译成对应运行这个应用的特定CPU机器码。 即时编译器还可以消除函数调用（即“内联”）。 第三章 Java的基本程序设计结构####一个简单的Java应用程序 根据Java语言规范，Java虚拟机将从指定类中的main方法开始执行。 不过，当main方法不是public时，有些版本的Java解释器也可以执行Java应用。这是因为Java虚拟机规范并没有要求main方法一定是public。这个问题已经得到了修复，在Java SE 1.4及以后的版本中强制main方法时public的。 ####整形 从Java 7开始，加上前缀0B或者0b就可以写二进制数。例如：0b1001就是9。同样，从Java 7开始，还可以为数字字面量加下划线，如用1_000_000表示一百万。 ####浮点类型 所有”非数值“的值都认为是不同的。 1if (x == Double.NaN) // is never true 可以使用 Double.isNaN() 来判断（长得帅的肯定会戳进去看一下源码，很有意思哦）。 浮点数不适用于无法接受舍入误差的金融计算中。例如， 1double result = 2.0 - 1.9; // result = 0.10000000000000009 这是因为二进制无法精确的表示 1/10。 可移植性是Java的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位储存一个数值，而有些处理器使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如： 1ddoble w = x * y / z; 使用严格浮点计算，截断中间数，可以了解一下 strictfp 关键字。 ####char类型 转义字符\u可以出现在加引号的字符常量或字符串之外（其他的转义字符不行）。例如： 1public static void main(String\u005B\u005D args) \u005B\u005D其实就是[]，所以上面的代码就是程序的入口main函数。（可以编译成class文件并运行，但是不被IDE识别） Unicode转义字符会在解析代码之前得到处理，举个吓死人的例子： 1// file in c:\user 当你在代码里面加上这行注释的时候，点击运行按钮就会发现，编译过不了！！！我的理解是先会将文件里面的转义字符全部处理一下，当处理到这行注释的时候，发现了 \u 会当成转义字符来处理，但是 \u 后面的字符不合法，所以就报错了。 Unicode的基本平面，辅助平面，码点的概念，可以看维基百科。 一个字符可能有多个码点，一个char只能表示一个码点。 ####运算符 整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或者NaN结果。 ####数值类型之间的转换 两个操作数有一个是 double ，则两个数按照 double 处理， 否则，有一个是 float，则两个数按照 float 处理， 否则，有一个是 long，则两个数按照 long 处理， 否则，两个数按照 int 处理。 123byte a = 1;byte b = 2;byte c = a + b; // error 12byte a = 1;a += 1; // ok，因为 += 会自动进行强制转换 ####位运算符 处理整形类型时，可以直接对组成整形数值的各个位完成操作，浮点数不行。 1234int a = 1;a &lt;&lt; 1; // okdouble b = 3;b &lt;&lt; 1; // error 位移运算符的右操作数要完成模32的运算（如果左操作是long型，则需要模64）。 11 &lt;&lt; 35 相当于 1 &lt;&lt; 3 ####字符串 编译器可以让字符串共享，只有字符串常量是共享的，+或者substring等操作产生的结果并不是共享的。 ####格式化输出： 使用参数索引来对一个参数进行多次格式化： 1System.out.print("%1$s %2$tB %2$te %2$tY", "Due date:", new Date()); 可以看到第二个索引对new Date()参数格式化了多次。使用&lt;标志也可以达到同样的效果。 1System.out.print("%s %tB %&lt;te %&lt;tY", "Due date:", new Date()); ####数组 Java中，允许数组长度为0，数组长度为0和null不同。 ####数组排序 1Arrays.sort(a); // 这个方法使用了优化的快速排序算法 利用数组写一个抽彩游戏（这个算法还是很有想法的）： 123456789101112131415int[] numbers = new int[n];for(int i=0; i&lt;n; i++) &#123; numbers[i] = i + 1;&#125;int[] result = new int[k];for (int i=0; i&lt;k; i++) &#123; int r = (int)(Math.random() * n); result[i] = numbers[r]; // 最关键的代码，将上面随机出来的数用最后一个数覆盖 numbers[r] = numbers[n - 1]; // 将 n 减一，相当于去掉最后一个数 n--;&#125; 第四章 类与对象####面向对象程序设计概述 OOP将数据放在第一位，然后再考虑操作数据的算法。 ####对象 对象状态的改变必须通过调用方法实现，如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。 ####类之间的关系 最常见的关系有： 依赖（“use-a”） 聚合（“has-a”） 继承（“is-a”） ####Java类库中的LocalDate类 将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。 ####用户自定义类 在一个源文件中，只能有一个公有类，但可以有任意数目的非共有类。 第一眼看到这句话我是懵逼的，后来仔细看了代码，发现应该说的是非内部类。 12345678// Main.javapublic class Main&#123; public class Inner&#123;&#125;&#125;class Main2 &#123; &#125; 上面的源文件是Ok的。但是把Main2改成public的就不行。 ####封装的优点 可以改变内部实现，除了该类的方法之外，不会影响其他代码。 更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。 ####静态常量 我们常使用的System类 1234public class System &#123; ... public static final PrintStream out = ...;&#125; 我们知道 final 修饰的变量是不允许将别的值赋给它的，但是System类有这样的一个方法： 1public static void setOut(PrintStream out) &#123;...&#125; 它可以将System.out设置为不同的流，原因是setOut是一个本地方法，它可以绕过Java语言的存取控制机制。 ####方法参数 Java程序设计语言总是采用按值调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的，下面给出例子： 12345public static void swap(Car a, Car b) &#123; Car temp = a; a = b; b = temp;&#125; 如果Java对对象采用的是按照引用传递，那么这个方法应该够实现交换数据的效果，但是，并没有。参数被初始化为对象引用的拷贝。 ####初始化块 调用构造器的具体处理步骤： 所有数据域被初始化为默认值（0，false或null）。 按照在类声明中出现的顺序，依次执行所有域初始化语句和初始化块。 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 执行这个构造器的主题。 123456789101112public class Main &#123; &#123; a = 2; &#125; private int a = 3; public int getA() &#123; return a; &#125;&#125;// Main m = new Main(); 问，m.getA() 的值？ 对象析构与 finalize 方法在实际应用中，不要依赖使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。 我一直觉得，final，finally，finalize有啥区别，这个问题很傻×，因为他们毛关系没有，区别从何谈起。问问 final 与 volitile的区别吧！！！ ####将类放入包中 假定有一个源文件开头有下列语句： 1package com.aprz; 编译器在编译源文件的时候不检查目录结构，即使这个源文件没有在子目录 com/aprz 下，也可以进行编译。但是，最终的程序将无法运行。如果包与目录不匹配，虚拟机就找不到类。 ####包作用域 如果，把一个类文件放置在类路径的某处的 java/awt 子目录下，那么我们就可以访问 java.awt 包的内部了。非常危险！ 从 1.2 版开始，JDK 的实现者修改了类加载器，明确禁止加载用户自定义的、包名以“java”开始的类！ ####类路径 javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。 下面看一个类路径示例： 1/home/user/classdir:.:/home/user/archives/archive.jar 假定虚拟机要搜寻 com.horstmann.corejava.Employee类文件。它首先要查看储存在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找一下文件： 123/home/user/classdir/com/horstmann/corejava/Employee.classcom/horstmann/corejava/Employee.class从当前目录开始com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar 编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类。例如，假定源文件包含指令: 12import java.util.*;import com.horstmann.corejava.*; 并且源代码引用了Employe类。编译器将试图查找jva.lang.Employee (因为java lang包被默认入）、java.util.Employee、com.hostmann.corejava.Employee和当前包中的Employee。对这个类路径的所有位置中所列出的每个类进行逐查看。 如果找到了一个以上的类，就会产生编译错误(因为类必须是唯一的， 而import语句的次序却无关紧要)。 编译器的任务不止这些，它还要查看源文件( Source files) 是否比类文件新。如果是这样的话，那么源文件就会自动地重新编译。 在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以从当前包中导入非公有类。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类。 这一段很长，我只能说QQ的图片文字识别真的牛逼。 第五章 继承类、超类和子类前缀“超”与“子”来源于计算机科学和数学理论中的集合语言的术语。 覆盖方法尽管子类对象有父类的私有域，但是却无法在子类中访问这个域。（这句话是我总结的，可能并不严谨） 有些人（包括我）认为super与this应用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个只是编译器调用超类方法的特殊关键字。 动态绑定虚拟机知道一个引用的对象类型，所以能够正确的调用相应的方法。 多态在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如： 12345public class A &#123;&#125;public class B extends A &#123;&#125;B[] bs = new B[8];A[] as = bs; 但是这样会有一个问题，如下： 1as[0] = new A(); 编译器是会接纳这个赋值操作的。由于bs与as指向同一个数组，当调用B中特有的方法时，就会出现错误。而且在运行时还会报出 ArrayStoreException 错误。 理解方法调用 编译器查看对象的声明类型和方法名。假设调用 x.f(param)，且隐私参数x声明为C类的对象。编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法。 接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析。 允许子类将覆盖方法的返回类型定义为原返回类型的子类型。 123456// A.javapublic Father find() &#123;...&#125;--------------------------------// B.java@Overridepublic Son find() &#123;...&#125; 如果是 private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式就是静态绑定。 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用的时候，虚拟机仅查找这个表就行了。 阻止继承：final类和方法在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程为称为内联。例如，内联调用 e.getName()将被替换为访问e.name域。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略。然面，如果getName在另外个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢?优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。 Object：所有类的超类所有的数组类型，不管时对象数组还是基本类型的数组都扩展了Object类。 equals方法在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。 相等测试与继承如果隐私和显式的参数不属于同一个类，equals方法将如何处理呢？这是一个很有争议的话题！ 许多程序员喜欢使用 instanceof 进行检测： 123if(!(otherObject instanceof Person)) &#123; return false;&#125; 这样做不但没有解决 otherObject 是子类的情况，并且还有可能会招来一些额外的麻烦。 Java语言规范要求 equals 方法具有下面的特性： 自反性 对称性 传递性 一致性 对于任意非空引用x，x.equals(null)，应该返回false。 就对称性来说，当参数不属于同一个类的时候需要仔细思考一下。 1e.quals(m); e 是父类，m是子类。如果这两个对象的实例域都一样，当使用 instanceof 操作符的时候，会返回 true，那么意味着，m.equals(e)，也会返回true。但是实际上，反过来调用是无法通过 instanceof 操作符的。 建议的规则： 如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass进行检测 如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。 一个完美equals方法的编写模板： 显示参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。 检测 this 与 otherObject 是否引用同一个对象。 123if (this == otherObject) &#123; return true;&#125; 检测otheObject是否为null，如果为null，返回false。 123if(otherObject == null) &#123; return false;&#125; 比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测。如果所有的子类拥有统一的语义，就使用instanceof检测。 将otherObject转换为相应类型的变量 ClassName other = (ClassName) otherObject; 开始对所有需要比较的域进行比较，如果在子类中重新定义equals，就要在其中包含调用 super.equals(other)。 一种常见的错误是将equals方法的参数类型改为具体需要比较的类型： 1public boolean equals(Person p) &#123;...&#125; 注意上面的方法不是覆盖，因为参数类型不一样，Object类中equal方法的参数是Object。 hashCode12StringBuilder sb = new StringBuilder("ok");StringBuffer tb = new StringBuffer("ok"); 注意，sb与tb的hashCode不一样，这是因为StringBuffer没有定义自己的hashCode方法。 equals方法相等则hashCode必须一致。 泛型数组列表一旦确定数组列表的大小不再发生变化，就可以调用 trimToSize 方法。这个方法将储存区域的大小调整为当权元素数量所需要的储存空间数目。垃圾回收器将回收多余的储存空间。 对象包装器与自动装箱对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类。 自动装箱规范要求 boolean、byte、char &lt;= 127，介于-128~127之间的short和int被包装到固定的对象中。这句话乍一看很诡异，其实都是同一个意思。 char 的范围是从 0 ~ 65535。 在运行时使用反射分析对象setAccessible方法时AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。 利用get方法可以访问域的值，但是有一个需要解决的问题。如果域是一个String类型，把它当作Object返回没有什么问题，但是，假设这个域是double类型的，而Java中数值类型不是对象，该怎么办呢？其实反射机制会自动地将这个域值打包到相应的对象包装器中。invoke 方法也是如此。 继承的设计技巧 将公共操作和域放在超类 不要使用受保护的域 protect 在某种程度上破坏了封装，因为同一个包类的代码也可以访问该域。 子类也可以随便访问超类的protect域。 使用继承实现“is-a”关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多的使用反射 第六章 接口、lambda表达式与内部类Comparable&lt;T&gt; 接口 如果子类之间的比较含义不一样，那就属于不同类对象的非法比较。每个compareTo方法都应该在开始时进行下列检测： 123if (getClass() != other.getClass) &#123; throw new ClassCastException();&#125; 如果存在一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。 静态方法在Java SE8中，允许在接口中增加静态方法。只是有违于将接口作为抽象规范的初衷。 目前为止，通常的做饭都是将静态方法放在伴随类中。Collection/Collections…… 默认方法可以为接口提供一个默认方法。必须用default修饰符标记这样的一个方法。 一般来说，这并没有太大的用处。但是当一个接口的方法特别多是就可以很有用。 1234567public interface Listener &#123; void fa(); void fb(); void fc(); void fd(); void fe();&#125; 大多数情况下，我们只关心其中的一两个方法。在Java SE8 中我们就可以将它声明为默认方法，什么也不做。 1234567public interface Listener &#123; default void fa() &#123;&#125;; default void fb() &#123;&#125;; default void fc() &#123;&#125;; default void fd() &#123;&#125;; default void fe() &#123;&#125;;&#125; 这样一来，使用者就只需要覆盖真正关心的方法。 默认方法的一个重要作用是“接口演化”。以Collection接口为例，假设你有一个类实现了这个接口： 1public class Bag implements Collection &#123;...&#125; 后来，在Java SE8中，又为这个接口增加了一个stream方法。 假设steam不是默认方法。那么Bag类将无法编译，因为它没有实现这个方法。为接口增加一个非默认方法不能保证源代码兼容。 不过，如果不重新编译这个类，而是使用原来的包含这个类的JAR文件，这个类仍然可以正常加载。为接口增加方法可以保证二进制兼容。不过，如果调用了steam方法，就会抛出一个AbstractMethodError。 解决默认方法冲突如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况呢？ 超类优先。如果超类提供了具体的方法，会忽略接口的默认方法。可以保证与Java SE7的兼容性。 接口冲突。如果一个接口提供了默认方法，另一个接口提供了一个同名且参数类型相同的方法（不管是不是默认的），必须覆盖这个方法来解决冲突。 千万不要让一个默认方法重新定义Object类中方法！！！ 对象克隆clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。 默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。 Cloneable接口并没有什么作用，它只是一个标记，指示类设计者了解克隆过程，clone方法是从Object类中继承过来的。 必须当心子类的克隆。 为什么引入lambda表达式lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。 lambda表达式的语法如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如： 12Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length(); 无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。 如果，一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。 1(int x) -&gt; &#123; if(x &gt;= 0) return 1;&#125; 函数式表达式对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口成为函数式接口。 最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。 不过，Java现在对lambda表达式能做的也只是转换为函数式接口。 Java API 在 java.util.function 包中定义了很多通用的函数式接口。例如：BiFunction&lt;T,U,R&gt;。 方法引用有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如： 1Timer t = new Timer(1000, event -&gt; System.out.println(event)); 这样，看起来很简洁了，但是如果能把 println 方法传递到 Timer 的构造器就更好了，如下： 1Timer t = new Timer(1000, System.out::println); 表达式 System.out::println 是一个方法引用，它等价于 x-&gt; System.out.println(x); 方法引用的写法有3中： objcet::instanceMethod Class::staticMethod Class::instanceMethod 前两种情况，方法引用等价于提供方法参数的lambda表达式。 对于第三种情况，第一个参数会成为方法的目标。例如： 12String::compareToIgnoreCase 等价于(x, y) -&gt; x.compareToIgnoreCase(y); 可以在方法引用种使用 this 与 super。 构造器引用构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。但是它具体引用的是哪个构造器与上下文有关。 12ArrayList&lt;String&gt; names = ..;Stream&lt;Person&gt; stream = names.steam().map(Person::new); map方法会调用Person(String) 构造器。 可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，它有一个参数：即数组的长度。 Java有一个限制，无法构造泛型类型T的数组。new T[] 会产生错误。 变量作用域有时候，我们会在lambda表达式种访问外围方法或类中的变量。例如： 1234567String text = "ok";ActionListener listener = event -&gt; &#123; Sysout.out.println(text); &#125;;// 1000年之后new Timer(delay, listener); 仔细想想，这里会有问题。lambda表达式的代码可能会在很久之后才运行，那个时候，text可能已经不存在了。要了解发生了什么，我们先来了解lambda表达式的组成： 一个代码块 参数 自由变量的值，这是指非参数而且不在代码中定义的变量。 lambda表达式的数据结构必须存储自由变量的值。 关于代码块与自由变量在别的语言里面有一个术语叫闭包。 lambda表达式引用了自由变量，无法对这个自由变量进行更改，因为会引发多线程问题。 在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。 1234567public class Application &#123; public void init &#123; ActionListener listener = event -&gt; &#123; Sysout.out.println(this.toString()); &#125; &#125;&#125; 表达式会调用Application的toString，而不是 ActionListener的toString。 处理lambda表达式如果设计你自己的接口，其中只有一个抽象方法，可以用 @FunctionalInterface 注解来标记这个接口。 再谈Comparator静态 comparing 方法取一个“键提取器”函数，它将类型T映射为一个可比较的类型。对要比较的对象应用这个函数，然后对返回的键完成比较。 1Arrays.sort(people, Comparator.comparing(Person::name)); 还有很多其他的方法，需要自己去戳源码。 内部类的特殊规则语法可以通过显示的命名将外围类引用设置为其他的对象。 12345678public class Out&#123; public class In &#123; &#125;&#125;-----------------------------Out o = new Out();Out.In in = o.new In(); 非静态内部类的所有静态域都必须是final的。 非静态内部类不能有static方法。 非static的内部类，在外部类加载的时候，并不会加载它，所以它里面不能有静态变量或者静态方法。 static类型的属性和方法，在类加载的时候就会存在于内存中。 要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。 基于以上两点，可以看出，如果一个非static的内部类如果具有static的属性或者方法，那么就会出现一种情况：内部类未加载，但是却试图在内存中创建static的属性和方法，这当然是错误的。原因：类还不存在，但却希望操作它的属性和方法。 内部类是否有用、必要和安全内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 符号分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。 内部类是如何访问外部的？ 123456789101112class Out &#123; private int a; class In &#123; &#125; // 这是编译器自动生成的方法，我们在内部类中调用a，实际上是使用了这个方法 static int access$0(Out); &#125; 匿名内部类由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是将构造参数传递给超类构造器。 对于静态方法的日志问题，如果我们希望在静态方法中输出当前类的类名，但是静态方法没有this，可以使用如下方法： 1new Object()&#123;&#125;.getClass().getEnclosingClass(); 代理的特性所有的代理类都覆盖了Object类中的方法 toString、equals和hashCode。 对于特定的类加载器和预设的一组接口来说，只能有一个代理类。如果使用同一个类加载器和接口数组调用两次 newProxyInstance 方法的话，那么只能得到同一个类的两个对象。 如果代理类实现的所有接口都是public的，那么代理类不属于某个特定的包。否则。所有非公有的接口都必须属于同一个包，代理类也属于这个包。 第七章 异常、断言和日志异常分类 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。 Exception分为两个分支： 一个分支派生于RuntimeException，另一个包含其他异常。 划分规则是：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像IO错误这类问题的异常属于其他异常。 声明受查异常如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。 如果超类方法没有抛出任何受查异常，子类也不能抛出任何异常。 捕获异常通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续传递。 捕获多个异常在Java SE 7中，同一个catch子句中可以捕获多个异常类型。 只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。 捕获多个异常类型时，异常变量隐含为final。 再次抛出异常与异常链在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。 12345try &#123; ...&#125; catch (AException a) &#123; throw new BException("msg");&#125; 不过，有一种更好的处理方法，并且将原始异常设置为新异常的“原因”： 1234567try &#123; ...&#125; catch (AException a) &#123; Throwable t = new BException("msg"); t.initCause(a); throw t;&#125; 这样我们调用 e.getCause() 就可以拿到原始异常。强烈推荐使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。 在Java SE 7之前，无法抛出声明异常之外的类型（虽然现在也是，但是编译器的行为不一样了）： 1234567public void update() throws SQLException &#123; try &#123; ... &#125; catch(Exception e) &#123; throw e; &#125;&#125; 在Java SE 7之前，会有一个问题，编译器会指出这个方法可以抛出任何异常，而不仅仅是SQLException。 现在编译器会跟踪到 e 来自 try 块。假设这个try中仅有的已检查异常是 SQLException的实例，另外，e没有被改变，那么这个方法就是合法的。 finally子句强烈建议解耦 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。 12345678910InputStream in = ...;try &#123; try &#123; ... &#125; finally &#123; ... &#125;&#125; catch (Exception e) &#123; ...&#125; 这种设计方式不仅清楚，而且还有一个功能，可以捕获 finally 里面的异常。 当 finally 子句包含return语句时： 12345678try &#123; int r = n * n; return r;&#125; finally &#123; if (n == 2) &#123; return 0; &#125;&#125; 在方法返回之前，finally 子句的内容将会执行。如果finally子句中也有一个return语句，这返回值将会覆盖原始的返回值。 finally 子句的异常可能会覆盖try中的异常： 123456InputStream in = ...;try &#123; ...&#125; finally &#123; in.close();&#125; 假设try块中抛出了非IOException，而close方法也出了异常，那么最后抛出的是 close 方法的 IOException。一般我们对 try 块中的异常更感兴趣，但是这时异常已经被丢失了，除非给 close 也加上 try 语句，这样就会非常繁琐。 带资源的 try 语句如果资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。 123try (Resource res = ...) &#123; ...&#125; try 块退出时，或者存在一个异常，都会自动调用 res.close();，资源会被关闭。 这种 try 语句自身也可以带 catch 和 finally 语句，但是一般不用。 第八章 泛型程序设计定义简单泛型类泛型类可以看作普通类的工厂。 类型变量的限定一个类型变量或通配符可以有多个限定： 1T extends Comparable &amp; Serializable 限定类型用 &amp; 分隔，而逗号用来分隔类型变量。如果用一个类来做限定，它必须是限定列表中的第一个。 类型擦除虚拟机没有泛型对象，它会擦除类型变量，并替换为限定类型（无限定类型的变量用Object）。 如果有多个限定，会怎么样呢？ 1class Interval&lt;T extends Serializable &amp; Compareable&gt; 原始类型用 Serialzable 替换 T，编译器会在必要的时候将其强制转换为 Comparable。为了提高效率，应该将标签接口（没有方法的接口）放在边界列表的末尾。 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。 翻译泛型方法假设我们有这样的一个类： 123456789101112131415161718192021222324class Pair&lt;T&gt; &#123; private T first; private T second; ... public void setSecond(T second) &#123; this.second = second; &#125; &#125;-----------------------------------// 擦除之后，这里 T 擦除之后是 Objectclass Pair &#123; private Object first; private Object second; ... public void setSecond(Object second) &#123; this.second = second; &#125; &#125; 使用一个类继承它： 12345678910class Date extend Pair &#123; &#125;-----------------------------------------------class Date extend Pair&lt;LocalDate&gt; &#123; // 这里不是重写，只是展示有一个从父类继承过来的方法 public void setSecond(LocalDate second) &#123; ... &#125;&#125; 于是问题就来了，假设我使用父类引用子类的变量，然后调用 setSecond 方法，那么它本来应该走到子类的方法里面去，但是由于泛型的擦除，导致子类方法签名不一致了（父类是 Object，子类是 LocalDate）。 1234Date date = new Date();Pare&lt;LocalDate&gt; pair = date;// 猜猜它会调用那个方法pair.setSecond(aDate); 现在多态与泛型擦除出现了冲突，解决方法是需要编译器在 Date类中生成一个桥方法。 123public void setSecond(Object second) &#123; setSecond((Date)second);&#125; 然而，桥方法也会引出别的问题！ 假设 Date 类覆盖了 getSecond 方法： 1234567class Date extend Pair &#123; // 这里是重写 @Override public LocalDate getSecond() &#123; ... &#125;&#125; 那么，Date 类里面就有两个同名方法了，参数一样，只有返回值不一样。编译器是不允许这样的，但是，在Java虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机可以正确处理这样的情况。 如果你记忆力比较好的话，前面也提到过在覆盖父类的方法时，可以返回更加严格的类型，这也是利用的桥方法。 Java泛型转换的事实： 虚拟机中没有泛型，只有普通的类和方法 所有的类型参数都用它们的限定类型替换 桥方法被合成类保持多态 为保持类型安全性，必要时插入强制类型转换 不能用基本类型实例化类型参数其原因是类型擦除，擦除之后，没有限定类型的使用 Object 代替，而 Object 不能引用基本类型。 运行时类型查询只适用于原始类型1if (a instanceof Pair&lt;String&gt;) 这里只是测试了 a 是否时一个 Pair 对象，与 String 毫无关系。 同样的道理，getClass 也总是返回原始类型。 Varargs 警告Java 不允许创建泛型数组，其原因可以自己研究研究（泛型擦除）。假设我们有这样方法： 1public static &lt;T&gt; void addAll(Collection coll, T... ts) &#123;&#125; ts 实际上时一个数组，考虑一下调用： 1234Collection&lt;Pair&lt;String&gt;&gt; table = ...;Pair&lt;String&gt; p1 = ...;Pair&lt;String&gt; p2 = ...;addAll(table, p1, p2); 所以，Java虚拟机必须建立一个Pair&lt;String&gt; 数组，这就违反了不循序创建泛型数组的规定。不过对于这种情况，只是会显示一个警告。 不能构造泛型数组最好让用户提供一个数组构造器的表达式。 泛型类的静态上下文中类型变量无效不能在静态域中引用类型变量。 123public class Singleton&lt;T&gt; &#123; private static T singleInstance; // ERROR&#125; 因为如果能使用的话，不同的实例会有不同的类型。 不能抛出或捕获泛型类的实例泛型类扩展 Throwable 都是不合法的。 1class P&lt;T&gt; extends Exception &#123;&#125; // ERROR 在异常规范中使用类型变量是合法的。 1public static &lt;T extends Throwable&gt; void fun(T t) throws T &#123;&#125; // OK 可以消除对受查异常的检查1234@SuppressWarnings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable t) throws T &#123; throw (T)t;&#125; 编译器会认为t是一个非受查异常。 再利用下面的代码就会把所有异常转换为编译器所认为的非受查异常： 12345try &#123; do work&#125; catch (Throwable t) &#123; throwAs(t);&#125; 这样，在某些不允许抛出任何受查异常的方法中，就可以使用这个方法来抛出受查异常。 注意擦除后的冲突123public class Pair&lt;T&gt; &#123; public boolean equals(T t);&#125; 擦除之后，就是 public boolean equals(Object t); 与 Object 的方法重复了，会引发错误。 通配符概念1void set(? extends Person) &#123;...&#125; 这个 set 方法不能传递任何参数，因为编译器只知道需要某个 Person 的子类，但是不知道具体是什么类型。 1void set(? super Person) &#123;...&#125; 该方法只能传递Person或者Person的子对象。 直观的讲，带有超类型限定的通配符可以向泛型写入，带有子类型限定的通配符可以从泛型对象读取。 举一个 super 限定符的应用： LocalDate 实现了 ChronoLocalDate，而 ChronoLocalDate 扩展了 Comparable&lt;ChronoLocalDate&gt;。 因此，LocalDate 实现的是 Comparable&lt;ChronoLocalDate&gt;，而不是 Comparable&lt;LocalDate&gt;。 在这种情况下，可以使用超类限定符来救助（要注意泛型的 extends 与类的 extends 的不同意义）： 1public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a) &#123;...&#125; 上个图来意思意思： 无限定通配符123? getFirst()void setFirst(?) getFirst 的返回值只能赋值给 Object。setFirst不能被调用，Object 也不行。 通配符捕获123public static void swap(Pair&lt;?&gt; p)public staic &lt;T&gt; void swapHelper(Pair&lt;T&gt; p) 比较有趣的是，可以在 swap 里面调用 swapHelper。这种情况下，参数 T 捕获通配符。 通配符捕获只有在有许多限制的情况下才是合法的，编译器必须能够确信通配符表达的是单个、确定的类型。 第九章 集合迭代器对 next 方法和 remove 方法的调用具有互相依赖性。 集合框架中的接口List接口定义了多个用于随机访问的方法： 1234void add(int index, E element);void remove(int index);E get(int index);E set(int index, E element); 坦率的讲，集合框架的这个方面设计的很不好。 集合框架中有两种类型的集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。而链表尽管也是有序的，但是随机访问会很慢，所以最好使用迭代器来遍历。所以如果原先就提供了两个接口就会容易理解些了。 为了避免对链表完成随机访问操作，Java SE 1.4 引入了一个标记接口 RandomAccess。用来测试一个特定的集合是否支持高效的随机访问： 12345if (c instanceof RandomAccess) &#123; // 支持&#125; else &#123; // 不支持&#125; Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。 add 方法不允许增加重复的元素 equals 方法：只要两个集合包含相同的元素就认为是相等的，而不要求这些元素有相同的顺序 hashCode 方法：要保证含相同元素的两个集会得到相同的散列码 既然两个接口的方法签名是一样的，为什么还要建立一个单独的接口呢？ 从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接收集的方法。 链表在 Java 程序设计语言中，所有链表实际上都是双向链接的。 ListIterator 是 Iterator 的一个子接口，它新增了一些方法。LinkedList 的 listIterator 方法会返回一个 ListIterator 的实例。注意，在使用 ListIterator 的 remove 方法时需要谨慎。 在调用 next 之后，remove 方法会删除迭代器左侧的元素，但是，如果调用 previous 会删除迭代器右侧的元素。 ConcurrentModificationException 异常的检测有一个特例： 链表只负责跟踪对列表的结构性修改，例如，添加元素，删除元素。set方法不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有的结点的内容进行修改。 不要使用下面的方法来遍历链表： 123for (int i=0; i&lt;list.size(); i++) &#123; Element e = get(i);&#125; 虽然 get 方法做了微小的优化（如果 i 大于 size()/2，会从后面开始遍历），但是这样写每次循环都要遍历一次。 散列表在 Java中，散列表用链表数组实现。 树集Java SE 8 中使用的是红黑树。 将一个元素添加到树中要比添加到散列表中慢，不过与检查数组或链表中重复元素相比还是快很多。 优先级队列优先级队列并没有对所有的元素进行排序。它使用了一个优雅且高效的数据结构——堆。 映射 （Map）总感觉翻译有点奇怪！！！ 更新映射项看一个例子，统计单词出现的频率： 1counts.put(word, counts.get(word) + 1); 这会有一个问题，就是 get 可能会返回 null。于是可以这样写，给一个默认值： 1counts.put(word, counts.getOrDefault(word, 0) + 1); 另一种方法就是先调用 putIfAbsent： 12counts.putIfAbsent(word, 0);counts.put(word, counts.get(word) + 1); 不过，还可以有更简单的方式，使用 merge 方法，可以简化这个常见的操作： 1counts.merge(word, 1, Integer::sum); 如果键值不存在，则将 word 置为 1，否则使用 Integer::sum 函数组合原值和 1。 映射视图集合框架不认为Map本身是一个集合。 Map提供了方法用来获取映射视图，映射视图是实现了Collection接口或某个子接口的对象。 123Set&lt;K&gt; keySet();Collection&lt;V&gt; values();Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 这3个方法会分别返回3个视图。要注意这些视图并不是 TreeSet 或者 HashSet 的实例，而是实现了 Set 接口的另外某个类的实例。 视图与包装器再来说说 keySet 方法。初看起来，好像这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet 方法返回一个实现 Set 接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。 轻量级集合包装器1List&lt;Card&gt; cardList = Arrays.asList(cardDeck); asList 返回的并不是一个 ArrayList。它是一个视图对象，带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个 UnsupportedOperationException 异常。 子范围12List group2 = staff.subList(10, 20);group2.clear(); 元素自动的从 staff 列表中清除，并且 group2 为空。 不可修改的视图简而言之，就是对所有更改器方法直接抛出一个异常。 由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。 注意，视图并没有重新定义 Object 的 equals 和 hashCode 方法（内容是否相等的检测在分层结构的这一层上没有定义妥当）。 受查视图“受查”视图用来对泛型类型发生问题时提供调试支持。 123ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();ArrayList rawList = strings;rawList.add(new Date()); 这个错误在 add 的时候检测不到。相反，只有在调用 get 方法的时候才会抛出异常。受查视图可以探测这类问题。 123List&lt;String&gt; safeStrings = Collections.checkList(strings, String.class);ArrayList rawList = safeStrings;rawList.add(new Date()); // Error 虚拟机在运行到 add 方法时，就会抛出异常。 排序与混排可以使用归并排序对链表进行高效的排序。但是Java中不是这样做的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制会链表。 集合类库中使用的排序算法比快速排序要慢一些，快速排序时通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。 二分查找只有采用随机访问，二分查找才有意义。 第十四章 并发中断线程没有可以强制线程终止的方法。然而，interrupt 方法可以用来请求线程终止。 但是，如果线程被阻塞，就无法检测中断状态。 当在一个被阻塞的线程（sleep或者wait）上调用 interrupt 方法时，阻塞调用将会被 Interrupted Exception 异常中断。 如果在每次工作迭代之后都调用 sleep 方法（或者其他可中断方法），isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并抛出InterruptedException。 不要将 InterruptedException 捕获在低层次上！ 要么捕获然后再次设置中断状态，要么直接抛出。 可运行线程在任何给定时刻，一个可运行的线程可能在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行）。 被阻塞线程和等待线程被阻塞状态与等待状态是有很大不同的。其实这句话我还不太能够理解，是本质上不同，还是Java行为上不同？ 线程优先级每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。 守护线程守护线程应该永远不去访问固有资源，如文件，数据库，因为它会在任何时候甚至在一个操作的中间发生中断。 setDaemon 必须在线程启动之前调用。 未捕获异常处理器线程的 run 方法不会抛出任何受查异常，非受查异常会导致线程终止。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。 setUncaughtExceptionHandler 方法会未任何线程安装一个默认的处理器。 也可以用Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有的线程安装一个默认的处理器。 如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。 ThreadGroup 类实现 Thread.UncaughtExceptionHanlder 接口。它的 uncaughtException 方法做如下操作： 如果该线程组有父线程组，那么父线程组的 uncaughtException 方法被调用。 否则，如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器，则调用该处理器。 否则，如果 Throwable 是 ThreadDeath 的一个实例，什么都不做。 否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。 锁对象 （ReentrantLock）如果使用锁，就不能使用带资源的 try 语句。 一是无法释放锁，二是会新创建一个变量。 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。 条件对象使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。 一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。 signalAll 方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。 每一个对象有一个内部锁，并且该锁有一个内部条件。初学者常常对条件感到困惑，推荐先学习ReentrantLock 的 Condition。 wait、nofity、notifyAll 方法都需要当前线程持有锁，否则会抛出异常。 同步阻塞举一个有趣的例子： 123456789101112131415public class Sync &#123; private Map&lt;String, Person&gt; pList = Collections.synchronizedList(new HashMap&lt;&gt;()); public synchronized void putIfAbsent(String key, Person p) &#123; if(!pList.contains(p)) &#123; pList.put(p); &#125; &#125; public Person get(String key) &#123; pList.get(key); &#125; &#125; 先不管这个程序有什么意义，只问一个问题，这个类是线程安全的吗？ 虽然看起来很像是线程安全的，但是实际上不是，因为 Collections.synchronizedList 使用的锁，肯定不是 Sync 的实例。 Volatile 域仅仅为了读写一个或两个实例域就使用同步，显得开销过大了。Volatile 可以帮助我们在这种情况下避免使用锁。 先来看看多个线程为什么会出现值不一致的原因： 多处理器的计算机能够暂时在寄存器或本地内存缓存区中保存内存的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。 编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显示的修改指令时才会改变。然而，内存的值可以被另一个线程改变！ 早期的CPU使用的是总线锁的方式来保证 Volatile 域的一致性，现在都使用的是缓存一致性。 final 变量如果在某个类中，将一个域声明为 final 类型，那么会起到这样的一个效果： 其他的线程会在该类的构造函数执行完毕之后才能看到这个 final 域的值。 原子性假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 volatile。 java.util.concurrent.atomic 包中有很多类使用了很高级的机器级指令（不是使用锁）来保证其他操作的原子性。 稍微提一下，使用 compareAndSet 实现乐观锁的常用写法： 1234do &#123; oldValue = largest.get(); newValue = Math.max(oldValue, observed);&#125; while (!largest.compareAndSet(oldValue, newValue)); compareAndSet 的工作原理：期望内存中的值是 oldValue，是则用 newValue 替换它，返回 true，不是则返回 false。 如果有大量线程要访问相同的原子值，函数性能会大幅下降，因为乐观更新需要太多次重试。 锁测试与超时lock 方法不能被中断，在获得锁之前会一直阻塞，如果出现死锁，则 lock 方法无法终止。可以使用 tryLock 来响应中断。 tryLock 还有一个隐藏特性：这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此。 为什么弃用 stop 和 suspend 方法stop 方法：该方法终止所有未结束的方法，包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。 例如：从 A 转账到 B，线程突然被终止，钱已经转出去了，却没有进入 B 账户，那么 Bank 对象就被破坏了。 suspend 方法：如果用该方法挂起一个持有锁的线程，那么该锁在恢复之前是不可用的。如果调用 suspend 方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。 ConcurrentHashMap1234// map 是 ConcurrentHashMap 的实例Long oldValue = map.get(word);Long newValue = oldValue == null ? 1 : oldValue + 1;map.put(word, newValue); 在上面的例子中，由于操作不是原子的，所以最终的结果不可预料。但是，要理解 ConcurrentHashMap 与 HashMap 的区别，这里的 get 与 put 都是原子操作，在多线程情况下不会破坏 map 的结构，而 HashMap 在多线程情况下会出现循环链表等问题。 ConcurrentHashMap 返回的迭代器具有弱一致性。这意味着迭代器不一定能反映出它们被构造之后的所有的修改（可以认为是某一特定时刻的快照），它们不会将同一个值返回两次，不会抛出 ConcurrentModificationException。 CopyOnWriteArrayList 和 CopyOnWriteArraySetCopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。 线程池调用 shutdown 方法，该线程池不再接收新任务。当所有任务完成后，线程池死亡。 调用 shutdownNow 方法，该线程池取消尚未开始的所有任务，并视图中断正在运行的线程。 ExecutorCompletionService如果有大量的 Callable 要执行，可以使用这个类。 Fork-Join 框架这个框架用来分解子任务，提高线程利用率。 123456789101112131415class Counter extends RecursiveTasks&lt;Integer&gt; &#123; protected Integer compute() &#123; if (to - from &lt; THRESHOLD) &#123; // ..... &#125; else &#123; int mid = (from + to) / 2; Counter first = new Counter(values, from, mid, filter); Counter second = new Counter(values, mid, to, filter); // 阻塞 invokeAll(first, second); // 合并 return first.join() + second.join(); &#125; &#125;&#125; 信号量任何线程可以释放任何数量的许可，这可能会增加许可数目以至于超出初始数目。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-多线程的代价]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0004-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[多线程的代价虽然没有这么大，但是也有很多让人头疼的地方。我们在使用多线程的时候，最好先衡量一下。除非我们确定了使用多线程带来的好处要比付出的代价大，才应该使用。如果不确定，应该测试一下更改前后的程序性能，不要仅靠猜测。（我就有一次，优化程序的某个地方，花了两天时间，改成多线程之后，最后测量的时候发现速度只提升了 200ms，说实话，挫败感很大，原以为会有很大的提升，最后为了避免改动过大带来的影响，把代码回退了） 使代码变复杂虽然有些多线程程序写起来要比单线程简单，但是毕竟是少数情况，一般情况下，设计一个多线程程序需要考虑很多东西。 特别是关于共享数据的问题，这部分的代码需要特别注意。线程之间的交互可能非常复杂，需要理清楚的之后正确的使用同步。 还有一个问题就是，多线程产生的bug，可能难以复现，可能线上出现了几次，然后就再也不出现了，自己怎么弄都复现不出来，多线程的bug难以解决。 上下文切换开销当 CPU 从一个线程切换到另一个线程的时候，需要做很多事，不是仅仅换个线程执行就好了。 这是因为在切换的时候，我们需要保存关于这个线程的所有信息，比如：这个线程执行到哪里了，线程里面的栈数据。（它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。）如果不储存这些信息，那么 CPU 再次切回来的时候，就一脸懵逼了。 上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。 增加资源消耗曾经，我遇到过有人问这样的一个问题： 我们创建线程的数量有限制吗？ 线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。而且操作系统也需要管理这些线程。 我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。 就算线程不占别的资源，它也是一个类吧，创建一个类对象也需要资源。我们能创建无限个对象吗，显然不行。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E7%9F%A5%E8%AF%86%E7%82%B9%2FBitmap%2F</url>
    <content type="text"><![CDATA[记录一下以前看到过的知识点。Bitmap 像素数据的储存位置先看官方文档： 在Android Android 2.2（API级别8）及更低版本上，当 GC 发生时，应用程序的线程会停止。这会导致延迟，从而降低性能。 Android 2.3添加了并发GC，这意味着在位图不再被引用后很快就会被回收。 2.3之前的像素存储需要的内存是在native上分配的，并且生命周期不太可控，可能需要用户自己回收。 2.3-7.1之间，Bitmap的像素存储在Dalvik的Java堆上，而8.0之后的像素内存又重新回到native上去分配，不需要用户主动回收，8.0之后图像资源的管理更加优秀，极大降低了OOM。 假设我们有这样的一个手机，它的 system/build.prop 配置如下： 1234567891011121314151617// 表示应用程序启动后为其分配的初始大小为8mdalvik.vm.heapstartsize=8m// 每个应用程序最大内存可分配到64mdalvik.vm.heapgrowthlimit=192m// 单个虚拟机可分配的最大内存256m// 使用大堆时，极限堆大小。一旦dalvik heap size超过这个值，直接引发oom。// 在android开发中，如果要使用大堆，需要在manifest中指定android:largeHeap为true。这样dvm heap最大可达dalvik.vm.heapsize。dalvik.vm.heapsize=512m// 设定内存利用率的百分比，当实际的利用率偏离这个百分比的时候，虚拟机会在GC的时候调整堆内存大小，让实际占用率向个百分比靠拢。dalvik.vm.heaptargetutilization=0.75dalvik.vm.heapminfree=512kdalvik.vm.heapmaxfree=8m 我们不断的解析图片并持有所有图片的引用： 1234567void test&#123; Map&lt;String, Bitmap&gt; map = new HashMap&lt;&gt;(); for(int i=0 ; i&lt;10;i++) &#123; Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.green); map.put("" + System.currentTimeMillis(), bitmap); &#125;&#125; 在 6.0 的手机中，实际测试应用出现OOM的时候，是在 200M 左右。对于现在动辄6G内存的手机而言，存在严重的资源浪费。所以8.0之后，Android也向这个方向靠拢，最好的下手对象就是Bitmap，因为它是耗内存大户。图片内存被转移到native之后，一个APP的图片处理不仅能使用系统绝大多数内存，还能降低Java层内存使用，减少OOM风险。 在 8.0 的手机中，实际测试应用出现OOM的时候，是在 2G 左右，所以，内存无限增长的情况下，也会导致APP崩溃，但是这种崩溃已经不是OOM崩溃了，Java虚拟机也不会捕获。 注意，上面的测试都是针对图片而言。 Bitmap 的复用 一是使用缓存：使用LruCache对Bitmap进行缓存，当再次使用到这个Bitmap的时候直接获取，而不用重走编码流程。 二是使用 inBitmap 字段：Android3.0(API 11之后)引入了BitmapFactory.Options.inBitmap字段，设置此字段之后解码方法会尝试复用一张存在的Bitmap。这意味着Bitmap的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。不过，使用这个字段有几点限制： 12345声明可被复用的Bitmap必须设置inMutable为true；Android4.4(API 19)之前只有格式为jpg、png，同等宽高（要求苛刻），inSampleSize为1的Bitmap才可以复用；Android4.4(API 19)之前被复用的Bitmap的inPreferredConfig会覆盖待分配内存的Bitmap设置的inPreferredConfig；Android4.4(API 19)之前待加载Bitmap的Options.inSampleSize必须明确指定为1。Android4.4(API 19)之后被复用的Bitmap的内存必须大于需要申请内存的Bitmap的内存； 使用 inBitmap 之前： 使用 inBitmap 之后： 我刚开始看到这两张图的时候是很蛋疼的，因为它看起来就像是3张图片同时使用了一块内存，这特么怎么可能呢。但是实际上它是这样工作的： 假设我们需要在Android应用程序中加载一些图。 当我们加载bitmap1时，它将为bitmap1分配内存。 然后，如果我们不再需要bitmap1，请不要回收位图（因为回收涉及调用GC）。相反，使用此bitmap1作为bitmap2的inBitmap。这样，bitmap2可以复用bitmap1的内存位置。 Bitmap 占用的内存大小 getByteCount()：代表存储Bitmap的像素需要的最少内存。 getAllocationByteCount()：代表在内存中为Bitmap分配的内存大小。 一般情况下两者是相等的。但是通过复用Bitmap来解码图片，如果被复用的Bitmap的内存比待分配内存的Bitmap大,那么getByteCount()表示新解码图片占用内存的大小（并非实际内存大小,实际大小是复用的那个Bitmap的大小），getAllocationByteCount()表示被复用Bitmap真实占用的内存大小（即mBuffer的长度）。 如何计算Bitmap占用的内存大小公式：占用的内存 = width * height * 一个像素所占的内存。 一般情况下是正确的，但是有时候还需要考虑屏幕密度问题。比如，我们从资源文件中加载一张图片（BitmapFactory.decodeResource）： 它占用的内存 = width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存 nTargetDensity/inDensity 实际上就是图片被缩放了，因为屏幕密度与图片资源文件夹密度不一致时，系统就会缩放图片，所以这里就会影响到计算结果。 除了加载本地资源文件的解码方法会默认使用资源所处文件夹对应密度和手机系统密度进行缩放之外，别的解码方法默认都不会。 Bitmap 的压缩inSampleSize不多说了，注意会将所设置的值自动更正为2的幂次方（接近并且小于所设置的值），有人说不是所有版本都这样，但也无从考究了。 compress压缩了文件的质量。这个玩意要了解还需要一定的储备知识，让我们从头说起。 首先我们需要了解的是图片各种相关的大小，文件大小、占用硬盘大小、占用内存大小。对于文件的大小实际就是它本身的包含的信息的大小，即实际具有的字节数，它以Byte为衡量单位，只要文件内容和格式不发生变化，文件大小就不会发生变化。我们可以直接拿File的length()方法就能获得文件的大小。那么硬盘的大小是什么呢？不管在什么系统中，我们经常会看到文件大小和占用磁盘空间的大小不一致，这是为什么呢？ 文件在磁盘上的所占空间不是以Byte为衡量单位的，它最小的计量单位是“簇(Cluster)”。 扇区是磁盘最小的物理存储单元，但由于操作系统无法对数目众多的扇区进行寻址，所以操作系统就将相邻的扇区组合在一起，形成一个簇，然后再对簇进行管理。每个簇可以包括2、4、8、16、32或64个扇区。显然，簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。 为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个簇中只能放置一个文件的内容，因此文件所占用的空间，只能是簇的整数倍；而如果文件实际大小小于一簇，它也要占一簇的空间。从上面的图可以看出，Windows 的一簇是4KB，所以，一般情况下文件所占空间要略大于文件的实际大小，只有在少数情况下，即文件的实际大小恰好是簇的整数倍时，文件的实际大小才会与所占空间完全一致。 这样我们就理解了为什么文件大小和实际占用硬盘大小不一样了。那么现在就剩内存的大小了。图片在内存里占用的大小和它本身的大小没有关系。我们知道图像是由一个一个的像素组成的，我们的图片的尺寸就是像素的多少，例如宽高是1024*1024的图像就是横竖都有1024个像素的图片，根据图片的编码格式不同，每个像素所占的内存大小是不一样的： ALPHA_8：表示8位Alpha位图,即A=8,一个像素点占用1个字节,它没有颜色,只有透明度 ARGB_4444：表示16位ARGB位图，即A=4,R=4,G=4,B=4,一个像素点占4+4+4+4=16位，2个字节 ARGB_8888：表示32位ARGB位图，即A=8,R=8,G=8,B=8,一个像素点占8+8+8+8=32位，4个字节 RGB_565：表示16位RGB位图,即R=5,G=6,B=5,它没有透明度,一个像素点占5+6+5=16位，2个字节 其中A代表透明度；R代表红色；G代表绿色；B代表蓝色。 最终，图片在内存所占空间的大小是：图片长度 x 图片宽度 x 一个像素点占用的字节数。即，例如我们有一个1024*1024大小的ARGB的图，那么它在内存里的大小为1024*1024*4=4M，但是在硬盘上的大小甚至可以小到6.4k。 这是为什么，为什么差别这么大？因为图片在内存中时是完整的图片信息，例如即使一个图是全白不透明或全黑全透明也会全部在内存中 (FFFFFFFF/00000000) 占用空间。但是在硬盘上却是被压缩的状态，例如平时我们常见的jpg和png，都是将图片信息进行了压缩，然后存储在了硬盘上。所以说一个图片在内存中占用的空间要远大于在硬盘的空间。 以上说了这么多，最后的引出的结论很关键：jpg和png都是对图片信息进行压缩然后存储到硬盘上的。它们有什么区别呢？jpg实际是有损压缩，而png是无损压缩。现在来看最上面的图片压缩的方法，可以看到Bitmap的压缩格式是JPEG（即jpg）。为什么是jpg，因为只有jpg才支持压缩，png是无损的，根本就不能进行再压缩。所以说Bitmap的compress方法只能对jpg起作用，当然，局限不仅仅是这一点。我们不禁要问，jpg能再压缩，那到底压缩了什么呢？ 首先jpg与png不同，png支持透明度，但是jpg不支持，所以jpg本身就比png小了四分之一的空间。其次jpg是有损压缩，除了透明度被干掉外，本身的RGB颜色也被压缩了，当然了，压缩的算法非常复杂，不在本文的研究范围内。压缩本身也是有等级的，压缩的越厉害，图像失真也越厉害，但是最终压缩都是有上限的，就是说从算法上来说就不支持任意一个图片压缩到任意小。我们可以参考PS工具最后保存jpg图片的质量（品质）那个选项，可以选择从0到100，0当然代表质量最差了，我们选择0那么就会出来最小的图片，这个应该就是这张jpg图片能够压缩到的最小值。有人说可以把压缩到0后的图片再去重复一遍这个步骤就好了嘛。实际这样是不行的，这里要说明的是0到100是一个绝对值，就是说一个图片的质量（品质）就是0到100，不能循环压缩，你可以试一下，用一个已经是0得图片再次压缩到50，那么它的大小不但不会小，反而会增大！！！ 最后，compress方法是质量压缩，压缩后改变大小的是jpg文件的大小，图片在内存中的大小还是不变的！因为宽高和每个像素占的空间都是没有变化的！ inDensity 与 inTargetDensity这个是我在《Android权威编程指南》上看到的。 上面说的，inSampleSize 只能缩放 2 的幂次方。这个在某些情况下可能不好满足需求，比如：一张1200 * 1200 的图，想要缩放到 500 * 500。这个时候使用 inSampleSize 就搞不定了！ 所以可以借助于 inDensity 和 inTargetDensity，用 inDensity 与 inTargetDensity 就能做到任意等比缩放。 可以先使用 inSampleSize 缩小到 600 * 600（不直接使用 inDensity 与 inTargetDensity的原因书上没有说，但是我猜想应该是它的效率高），然后再使用 inDensity 与 inTargetDensity ，将 inDensity 设置成 600，将 inTargetDensity 设置成 500，就可以了。 实际上原理，就是与 android.graphics.BitmapFactory#decodeResourceStream 差不多啦。 给出项目代码： 123456789101112131415public static int calInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; final int halfHeight = height / 2; final int halfWidth = width / 2; while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123; inSampleSize *= 2; &#125; &#125; return inSampleSize;&#125; 12345678910public static BitmapFactory.Options getOptions( BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; options.inSampleSize = calInSampleSize(options, reqWidth, reqHeight); options.inScaled = true; // 这里使用设置要缩放的宽高比，与 decodeResource 的缩放一样 options.inDensity = options.outHeight; options.inTargetDensity = reqHeight * options.inSampleSize; options.inJustDecodeBounds = false; return options;&#125; 使用这个方法就可以做出任意的等比例缩放了。]]></content>
      <tags>
        <tag>Android-知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003多线程的优点]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0003-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[尽管使用多线程会遇到很多困难，但是由于它带来的好处实在是太大了，所以掌握多线程是必须的。下面我们举几个例子来说一下多线程的好处：更高的资源利用率想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要5秒，处理一个文件需要2秒。处理两个文件则需要：1234561 | 5s读取文件A2 | 2s处理文件A3 | 5s读取文件B4 | 2s处理文件B-----------------一共耗时 5 + 5 + 2 + 2 = 14s 我们思考一下可以优化的地方： 从磁盘中读取文件的时候，这段时间内，CPU 是没有做任何事情的，就白白浪费了 在这段时间里，CPU非常的空闲。它可以做一些别的事情。那么，怎么利用这段时间，用 CPU 去做别的事情呢。 通过改变操作的顺序，就能够更好的使用CPU资源。看下面的顺序： 1234561 | 5秒读取文件A2 | 5秒读取文件B + 2秒处理文件A3 | 2秒处理文件B----------------------------一共耗时 5 + 5 + 2 秒(仔细想了一下，这个例子应该是单CPU的情况下的顺序) CPU等待第一个文件被读取完，然后开始读取第二个文件。当第二文件在被读取的时候，CPU会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU大部分时间是空闲的。 总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。 更简单的程序设计在单线程应用程序中，如果你想编写程序处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。 但是如果你启动两个线程，每个线程处理一个文件的读取和操作。线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。 其结果就是，磁盘总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。 更快的响应速度假设我们有一个服务器，我们写了一个服务应用用来处理用户的请求，它的大致流程如下： 1234while(server is active) &#123; listen for request process request&#125; 假如处理有的用户请求需要占用很长的时间，那么在这段时间之内，服务器就无法响应别的用户的请求了。 所以我们可以这样设计： 1234while(server is active)&#123; listen for request hand request to worker thread&#125; 我们为每个请求单独分配一个线程去处理，然后服务端线程立刻再去监听用户请求。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。 我们的应用也是如此。如果我们点击了一个按钮，要去开始一个非常耗时的任务，如果我们直接在 UI 线程执行，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。 但是如果我们开启一个工作线程去处理，当工作者线程在繁忙地处理任务的时候，UI线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。UI线程便可以更新应用程序窗口，并显示任务的结果。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android V1 V2 签名机制]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FAndroid%20V1%20V2%20%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[很早之前就想写这个，直到现在才有时间。理解了这个发现对 HTTPS 也有了进一步的理解。 为什么需要签名 ？了解 HTTPS 通信的同学应该知道，在消息通信时，必须至少解决两个问题： 一是确保消息来源的真实性 二是确保消息不会被第三方篡改 我们先来看 HTTPS 签名以及校验的过程：这里只是简单的理了一下核心思路，有不懂的还是应该查看相关文献。 在安装 APK 时，同样需要确保 APK 来源的真实性，以及 APK 没有被第三方篡改。如何解决这两个问题呢？方法就是开发者对 APK 进行签名：在 APK 中写入一个“指纹”。指纹写入以后，APK 中有任何修改，都会导致这个指纹无效，Android 系统在安装 APK 进行签名校验时就会不通过，从而保证了安全性。 V1 签名过程首先我们任意选取一个签名后的 APK（Sample-release.APK）解压： 在 META-INF 文件夹下有三个文件：MANIFEST.MF、CERT.SF、CERT.RSA。它们就是签名过程中生成的文件，它们就是签名三贱客。 MANIFEST.MF该文件中保存的内容其实就是逐一遍历 APK 中的所有条目，如果是目录就跳过，如果是一个文件，就用 SHA1（或者 SHA256）消息摘要算法提取出该文件的摘要然后进行 BASE64 编码后，作为“SHA1-Digest”属性的值写入到 MANIFEST.MF 文件中的一个块中。该块有一个“Name”属性， 其值就是该文件在 APK 包中的路径。 在这个文件里面，我们也可以搜索到我们的dex文件的摘要，资源的摘要，有兴趣的可以自己动手试试，将apk拖到AS里面就搞定了。需要注意的是，这个文件中存放了未压缩之前的所有文件的摘要。 CERT.SF 发现这里里面的内容与 MANIFEST.MF 的文件差不多。MANIFEST.MF是对APK中的每个文件进行摘要，那么这个文件里面的条目是什么东西的摘要呢？ SHA1-Digest-Manifest：对整个 MANIFEST.MF 文件做 SHA1（或者 SHA256）后再用 Base64 编码 SHA1-Digest：对 MANIFEST.MF 的各个条目做 SHA1（或者 SHA256）后再用 Base64 编码 所以，CERT.SF 做了这些东西： 计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下 逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest CERT.RSA这里会把之前生成的 CERT.SF 文件，用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。这里要注意的是，Android APK 中的 CERT.RSA 证书是自签名的，并不需要这个证书是第三方权威机构发布或者认证的，用户可以在本地机器自行生成这个自签名证书。Android 目前不对应用证书进行 CA 认证。 我们在 gradle 文件中配置的签名文件： 12345678signingConfigs &#123; release &#123; storeFile file('..\\release.jks') storePassword 'release' keyAlias = 'key0' keyPassword 'release' &#125;&#125; .jks 文件里面就包含了这些东西（通过 keytool 命令可以查看，但是看不到私钥）： 私钥 证书 这里会把之前生成的 CERT.SF文件， 用私钥计算出签名, 然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。 签名校验签名验证是发生在APK的安装过程中，一共分为三步： 检查 APK 中包含的所有文件，对应的摘要值与 MANIFEST.MF 文件中记录的值一致。 使用证书文件（RSA 文件）检验签名文件（SF 文件）没有被修改过。 使用签名文件（SF 文件）检验 MF 文件没有被修改过。 由于使用了自签名证书，没有CA的参与，所以公钥有被替换的可能，但是由于是第三方重新签名，所以无法覆盖已安装的应用。 基于V1的多渠道打包方案最早的多渠道打包方案是这样的，由于以前都是使用的友盟统计，按照友盟官方文档说明，渠道信息通常需要在AndroidManifest.xml中配置如下值： 1&lt;meta-data android:value="Channel ID" android:name="UMENG_CHANNEL"/&gt; 然后，在build.gradle设置productFlavors： 12345678910111213141516171819android &#123; productFlavors &#123; kuan &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "kuan"] &#125; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"] &#125; qh360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "qh360"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "baidu"] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"] &#125; &#125; &#125; 这样打包虽然可以工作，但是只是为了替换一个 AndroidManifest.xml 里面的 meta-data 就需要将所有的 apk 文件重新打进一个新包里面，非常的浪费时间。 那么，有没有快速打包方法呢？显然是有的，下面介绍一下美团的打包方案。 美团V1签名打包方案我们上面分析过APK签名的校验，但是仔细想想，它有个漏洞，它校验了所有的 APK 里面的文件，以及签名3剑客，但是却没有对 MATE-INF 这个文件夹做校验。那么我们就可以这样做： 在 META-INF 目录下添加空文件，用空文件的名称来作为渠道的唯一标识。 这样我们的渠道信息就写入apk中的，而且不会影响签名。然后在app运行的时候，从 apk 文件里面读取出来就好了。 具体过程如下： 123456789# 创建渠道名的空文件f_empty_channel = open(channel_name, 'w')f_empty_channel.close() # 往渠道apk中添加空的渠道文件dest_channel_path = "./META-INF/" + channel_namef = zipfile.ZipFile(dest_apk, 'a')f.write(channel_name, dest_channel_path)f.close() 这样就搞定了，是不是很简单呢？这种方式的特点是：生成一个渠道包，需要经过解压缩、创建空文件、压缩这些步骤。 一种更快速的打包继美团多渠道打包方案之后，万能的网友又想出了一种更快速的打包方式。 由于apk文件实质上就是个zip包，因此可以利用zip包的文件结构，将渠道信息带进去即可。这种方式的特点：没有解压缩、压缩、重签名等步骤，比美团的打包效率还要高。 有兴趣的可以找找代码看看。 V2签名过程APK 签名方案 v2 是一种全文件签名方案，该方案能够发现对 APK 的受保护部分进行的所有更改，从而有助于加快验证速度并增强完整性保证。 从 Android 7.0 开始，Android 支持了一套全新的 V2 签名机制，为什么要推出新的签名机制呢？通过前面的分析，可以发现 v1 签名有两个地方可以改进： 签名校验速度慢校验过程中需要对apk中所有文件进行摘要计算，在 APK 资源很多、性能较差的机器上签名校验会花费较长时间，导致安装速度慢。 完整性保障不够META-INF 目录用来存放签名，自然此目录本身是不计入签名校验过程的，可以随意在这个目录中添加文件，比如一些快速批量打包方案就选择在这个目录中添加渠道文件。 为了解决这两个问题，在 Android 7.0 Nougat 中引入了全新的 APK Signature Scheme v2。 V2 带来的影响由于在 v1 仅针对单个 ZIP 条目进行验证，因此，在 APK 签署后可进行许多修改 — 可以移动甚至重新压缩文件。事实上，编译过程中要用到的 ZIPalign 工具就是这么做的，它用于根据正确的字节限制调整 ZIP 条目，以改进运行时性能。而且我们也可以利用这个东西，在打包之后修改 META-INF 目录下面的内容，或者修改 ZIP 的注释来实现多渠道的打包，在 v1 签名中都可以校验通过。 v2 签名将验证归档中的所有字节，而不是单个 ZIP 条目，因此，在签署后无法再运行 ZIPalign（必须在签名之前执行）。正因如此，现在，在编译过程中，Google 将压缩、调整和签署合并成一步完成。 V2签名过程v2 签名模式在原先 APK 块中增加了一个新的块（签名块），新的块存储了签名，摘要，签名算法，证书链，额外属性等信息，这个块有特定的格式，具体格式分析见后文，先看下现在 APK 成什么样子了。 为了保护 APK 内容，整个 APK（ZIP文件格式）被分为以下 4 个区块： ZIP 条目的内容（从偏移量 0 处开始一直到“APK 签名分块”的起始位置） APK 签名分块 ZIP 中央目录 ZIP 中央目录结尾 其中，应用签名方案的签名信息会被保存在 区块 2（APK Signing Block）中，而区块 1（Contents of ZIP entries）、区块 3（ZIP Central Directory）、区块 4（ZIP End of Central Directory）是受保护的，在签名后任何对区块 1、3、4 的修改都逃不过新的应用签名方案的检查。 ZIP 文件结构需要了解一下，不然不明白 ZIP 中央目录子类的东西。 zip文件分为3部分： 数据区 此区块包含了zip中所有文件的记录，是一个列表，每条记录包含：文件名、压缩前后size、压缩后的数据等； 中央目录 存放目录信息，也是一个列表，每条记录包含：文件名、压缩前后size、本地文件头的起始偏移量等。通过本地文件头的起始偏移量即可找到压缩后的数据； 中央目录结尾记录 标识中央目录结尾，包含：中央目录条目数、size、起始偏移量、zip文件注释内容等。 继续回到正题。 V2 签名摘要计算 说一下摘要计算规则： 将每个部分拆分成多个大小为 1 MB大小的chunk，最后一个chunk可能小于1M。之所以分块，是为了可以通过并行计算摘要以加快计算速度； 计算chunk摘要：字节 0xa5 + 块的长度（字节数） + 块的内容 进行计算； 计算整体摘要：字节 0x5a + chunk数 + 块的摘要的连接（按块在 APK 中的顺序）进行计算。 最后，将 APK 的摘要 + 数字证书 + 其他属性生成签名数据写入到 APK Signing Block 区块。 V2 签名多渠道打包方案这里就不细说 APK Signing Block 区块里面的结构了，有兴趣的可以查查资料。 V2 签名这种方案，只保证了第1、3、4部分和第 2 部分（APK签名分块）包含的APK 签名方案 v2分块中的 signed data 分块的完整性。 APK签名分块包含了4部分：分块长度、ID-VALUE序列、分块长度、固定magic值。其中APK 签名方案 v2分块存放在ID为0x7109871a的键值对中。 所以，我们可以定义一个新的ID-VALUE，将渠道信息写入APK签名分块中。 V2 V1 签名校验2 签名机制是在 Android 7.0 以及以上版本才支持。因此对于 Android 7.0 以及以上版本，在安装过程中，如果发现有 v2 签名块，则必须走 v2 签名机制，不能绕过。否则降级走 v1 签名机制。 v1 和 v2 签名机制是可以同时存在的，其中对于 v1 和 v2 版本同时存在的时候，v1 版本的 META_INF 的 .SF 文件属性当中有一个 X-Android-APK-Signed 属性： 1X-Android-APK-Signed: 2 因此如果想绕过 v2 走 v1 校验是不行的。 下一篇讲 V2 机制下的多渠道打包。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（四）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的本篇主要分析 RxJava2 中的线程池与线程调度时的源码流程。顺便介绍RxJava2中常用的几个线程池。上一篇文章，我们的demo中，指定线程时，使用的是 Schedulers 这个类。那我们直接从这个类入手。 Schedulers.java 12345/** * Static factory methods for returning standard Scheduler instances. * &lt;p&gt; */public final class Schedulers &#123;...&#125; 一般看一个类的时候，先看注释会让你对这个类又一个全局的概念，它起一个什么作用。 上面的注释说的比较清楚了，它是一个工厂方法，返回一些 Scheduler 对象的实例。 那么下面我们看看 Scheduler 类。 Scheduler.java 这个类提供了API，用来调度工作单元。你可以指定延迟时间，周期性。 我们可以想到很多别的东西，Timer，Executors.newScheduledThreadPool(2)等等 1public abstract class Scheduler &#123;...&#125; 这个类的代码不多，我们打开 Structure 视图，可以看到该类的一个结构，这里展示一下 Scheduler 最核心的定义部分： Scheduler.java 12345678910111213141516171819202122232425262728293031323334public abstract class Scheduler &#123; @NonNull public abstract Worker createWorker(); public Disposable scheduleDirect(@NonNull Runnable run) &#123; ... &#125; public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; ... &#125; @NonNull public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) &#123; ... &#125; public abstract static class Worker implements Disposable &#123; @NonNull public Disposable schedule(@NonNull Runnable run) &#123; ... &#125; @NonNull public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit); @NonNull public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) &#123; ... &#125; &#125;&#125; 从上面的定义可以看出，Scheduler 本质上就是用来调度 Runnable 的，支持立即、延时和周期形式的调用。 我们从其中一个方法入手，就选择最简单的 public Disposable scheduleDirect(@NonNull Runnable run) {...} 方法。分析完这个方法之后，在看其他的方法，应该就是差不多的了。 Scheduler.java 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 上面说过，Scheduler 支持延迟调用，那么这里传递0，就表示不延迟。 Scheduler.java 123456789101112131415public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; // ① 创建了一个 Worker final Worker w = createWorker(); // 装饰一下，但是通常会将 run 原封不动的返回 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // ② 创建 Task DisposeTask task = new DisposeTask(decoratedRun, w); // ③ 执行 task w.schedule(task, delay, unit); return task;&#125; 上面的代码中，我加了一点注释，下面来一行一行的分析。 io.reactivex.Scheduler#scheduleDirect(java.lang.Runnable, long, java.util.concurrent.TimeUnit) 1final Worker w = createWorker(); 由于，Scheduler 是一个抽象类，所以只有它的子类才知道具体的实现，这里我们用 Schedulers.io 为例。 由于篇幅问题，如果这里深入的话，会很容易丢失目标，所以我将 IoScheduler 这个类的分析提出来了，放到了[另外一篇文章](https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-源码解析/RxJava2/RxJava2 源码分析（2.5）.md)中。 看完这篇文章之后，就知道 Worker 有点像命令，它里面指定了任务需要执行的线程池（因为Worker是Scheduler的子类创建的，Scheduler的子类创建了自己的线程池），当我们调用 work.schedule 的时候，就会将任务交给work中指定的线程池去执行。 这样一来，①处与③处的代码都说清楚了。现在还剩②处的代码。看看 DisposeTask 这个类吧。 DisposeTask DisposeTask 看它的构造方法与类结构，可以大概猜到它可能会起一个代理委托的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142static final class DisposeTask implements Runnable, Disposable &#123; final Runnable decoratedRun; final Worker w; Thread runner; DisposeTask(Runnable decoratedRun, Worker w) &#123; this.decoratedRun = decoratedRun; this.w = w; &#125; @Override public void run() &#123; runner = Thread.currentThread(); try &#123; // 运行 task 中的代码 decoratedRun.run(); &#125; finally &#123; // 执行完之后，调用 dispose dispose(); runner = null; &#125; &#125; @Override public void dispose() &#123; if (runner == Thread.currentThread() &amp;&amp; w instanceof NewThreadWorker) &#123; // 如果 worker 是 NewThreadWorker，则关闭自己 ((NewThreadWorker)w).shutdown(); &#125; else &#123; // 调用 worker 的 dispose // 之前我们分析过 IoScheduler.EventLoopWorker 类 // 它的 dispose 会将自己重新放到线程池中，重复利用 w.dispose(); &#125; &#125; @Override public boolean isDisposed() &#123; return w.isDisposed(); &#125;&#125; 所以这个类的主要作用是起到一个让 worker 重复利用的作用，但是这只是针对 IoScheduler 的 Worker 来说，别的 Worker 可能会不一样。 因为它调用了 Worker 的 dispose 方法，所以 Worker 的收尾工作可以全部放到这个方法中。 Scheduler类的重要方法都分析完了，其他的方法，就交给你们了。看完了这几篇文章，你应该具有了能够看懂其他 Scheduler 的能力，GOOD LUCK !!! 参考文档https://juejin.im/post/5b75207ce51d45565d23e093]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（一）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是第二次写源码分析，之前的一次已经是一年前了。为何要重写？主要是由于今天看到了一些关于线程池的东西，我联想到了RxJava2中的线程分类。再想到项目中的线程池相关的地方，感觉很乱，所以有一个整合的想法，想将原来自己创建的线程池替换成RxJava2中的线程池，于是就有了翻看源码的心思。择日不如撞日，反正是看源码，顺便把以前的东西再整理一下，还有就是以前写的东西，思路太乱，看着不舒服。 回想起来，RxJava2的源码有很多套路，只要掌握了这个套路，阅读源码起来就会有一切尽在掌握的感觉，否则，就会觉得源码很绕。 所以第一篇文章的主要目的，是讲明白这个套路，然后配上图，能够更容易让人理解，如果以后忘记了，再回来看一遍也能迅速跟上思路，不会又要再次撸一遍源码。 从一个简单的例子开始1234567891011121314151617181920212223242526272829// 观察者 -- 蝙蝠侠// 这里之所以没有用 Consumer，是怕引起歧义// 毕竟源码利用将我们传递进去的 Consumer， 又封装了一层，封装成了 Observerval observerBatMan = object : Observer&lt;Int&gt; &#123; override fun onComplete() &#123; &#125; override fun onNext(t: Int) &#123; Assert.assertEquals(1, t) &#125; override fun onError(e: Throwable) &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125;&#125;// 数据源 -- 小丑val sourceClown = ObservableOnSubscribe&lt;Int&gt; &#123; it.onNext(1) it.onComplete()&#125;// 开始观察Observable.create&lt;Int&gt;(sourceClown) .subscribe(observerBatMan) 嗯，果然 kotlin 还是看起来舒服。 这个例子非常简单了，数据源发送一个int值 1，然后接收者判断值是不是1。 现在开始分析源码了，先看 Observable 的 create 方法： Observable.java 该方法创建一个 Observeable 对象。分析完成之后，你就会发现实际上就是创建了一个 ObservableCreate 对象。 12345public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; // 这个是判空，嗯，没啥好说的，我一般用注解。 ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 套路一 别看有些人表面上风风光光，背地里却连只大熊猫都没有。 上面的 create 方法中，看起来有两行代码，感觉做了一些了不得的东西，但是实际上只有半行代码在起主要作用。 第二行代码的前半行： RxJavaPlugins.java 该方法在 onObservableAssembly 不会空的情况下会对 source 做一个变换，否则返回 source。 12345678public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 因为 onObservableAssembly 绝大部分情况下为空，其实就是返回了传进来的参数。所以该方法基本可以忽略。 需要注意，这个套路在源码中很常见。 所以最后，我们可以把 Observeable 的 create 方法理解为： Observable.java create 简化后的代码 123public static &lt;T&gt; Observable&lt;T&gt; create(@NotNull ObservableOnSubscribe&lt;T&gt; source) &#123; return new ObservableCreate&lt;T&gt;(source);&#125; 这样看是不是很简单！！！ 继续深入，看看 ObservableCreate 有何德何能！ ObservableCreate .java ObservableCreate 继承至 Observable。这个继承还有一个非常重要的作用，就是方便链式调用。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;...&#125; 别看 Observable 有1w 多行代码，但是实际上只有一个抽象方法，其他的都是用来做操作符等等。 下面来看看这个抽象方法，后面会分析到。 Observable.java 该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx); subscribe 就会调用 subscribeActual 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 套路二 遵循模板： 将source封装一下，变成一个 Observable 将 observer 封装一下，变成一个Emitter， 然后调用 source 的 onSubscribe 方法， 然后调用 source 的 subscribe 方法，将 Emitter 传进去。 其实只要你知道 observer 是谁，source 是谁，很简单的啦。 ObservableCreate 的核心代码就在这个被覆盖的抽象方法里面，嗯，一起来看看吧。 ObservableCreate.java 该方法由 Observable 的 subscribe 方法调用，即 Observable.create(xxx).subscribe(xxx); 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 看上面的代码，需要搞清楚几个变量，不然绕着绕着就糊涂了。 source 是我们创建并传递进来的。额，忘记贴构造函数了，里面有赋值，这个 source 就是我们在 create 方法里面创建的对象啦。 ObservableCreate.java 构造方法 123public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source;&#125; observer 这里暂时分析不出来，因为是父类调用了这个方法，所以我们去父类看看 Observable.java 这个方法的主要作用，就是将数据源与观察者关联起来 它还调用了 subscribeActual 方法，子类必须实现 subscribeActual 方法。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 使用套路一，我们简化一下代码： Observable.java subscribe 简化后的代码 12345678910111213 public final void subscribe(Observer&lt;? super T&gt; observer) &#123; try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; ... RxJavaPlugins.onError(e);... throw npe; &#125; &#125; 如果，是走正常流程，没有错误，还可以简化（第一次分析主流程，就是要这样简化简化再简化）： Observable.java subscribe 简化后的代码 1234public final void subscribe(Observer&lt;? super T&gt; observer) &#123; observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer);&#125; 实际上，RxJavaPlugins.onSubscribe 也含有套路一，所以再次简化： Observable.java subscribe 简化后的代码 12345public final void subscribe(Observer&lt;? super T&gt; observer) &#123; // 可以忽略 observer = observer; subscribeActual(observer);&#125; 所以，最终实际上 subscribe 方法，就是调用了 subscribeActual 方法而已，只不过它增加了错误与钩子处理。 看到这里，不知道你有没有反应过来，这个 subscribe(observer) 方法是不是很熟悉呢？ 这个方法，就是我们上面例子中的： 我们写的 demo 的代码 1234// 开始观察Observable.create&lt;Int&gt;(sourceClown) // 这里就是调用的 subscribe 方法 .subscribe(observerBatMan) 是不是有点恍然大悟的感觉呢！ 所以到这里，心里应该由一个大致框架了。 同时也会发现，ObservableCreate 的 subscribeActual 方法中的 observer 参数，也是我们new出来的对象。 分析到了这里，一个轮廓就出来了!!! ObservableCreate 的 subscribeActual 方法中的 参数分别对应如下： ObservableCreate.java ObservableCreate 继承至 Observable，所以它必须实现 subscribeActual 方法。 这个方法也是核心，是链式调用的核心，线程切换的核心 123456789101112131415@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // observer 就是 observerBatMan CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; // source 就是 sourceClown // 这个 subscribe 就将两个包装的观察者与数据源对象关联起来了 source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 如果，不考虑错误的情况，我们简化一下代码： ObservableCreate.java subscribeActual 简化后的代码 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; // observer 就是 observerBatMan CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 调用 observerBatMan 的 onSubscribe 方法，这个是一个钩子方法 // 一般专门用来告诉 observerBatMan，我，sourceClown，要搞事情了 observer.onSubscribe(parent); // source 就是 sourceClown source.subscribe(parent);&#125; 由于，onSubscribe 我们暂时也不用，所以去掉，再简化： ObservableCreate.java subscribeActual 简化后的代码 123456@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); // 注意这里 subscribe 传递的是 parent source.subscribe(parent);&#125; 嘿嘿嘿，这样就舒服多了，就3个变量，两个是我们自己创建的，知根知底，还有一个货，CreateEmitter我们先放一放，为啥呢，因为关于 source 的代码还没有分析完成呢。 别看 source.subscribe(parent);就一行代码，但是由于 source 对象是我们自己创建的，所以这个方法实际上调用了我们写的代码： ObservableOnSubscribe.java 123public interface ObservableOnSubscribe&lt;T&gt; &#123; void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;&#125; ObservableOnSubscribe是一个接口，所以，我们实际上是创建了一个匿名内部类，传递给了 source，然后 source 又调用了 subscribe 方法，所以也就调用了我们写的代码。 嗯，用伪代码表示如下： 1234567891. 匿名内部类 = new ObservableOnSubscribe()&#123;&#125;2. oc = Observerable.create(匿名内部类)3. oc.subscribe(xxx)，这个方法会调用到 -&gt; subscribeActual4. subscribeActual 会调用到 -&gt; 匿名内部类.subscribe(emiiter)5. 我们的代码 我们自己写的 demo 代码 123// 这里的 it 是 ObservableEmitterit.onNext(1)it.onComplete() 那么，当 it.onNext(1) 执行之后，又会发生什么呢？ 这个 it 就是 CreateEmitter，嗯，虽然有点突然，但是这个应该没有疑问吧？！！ 我们把 sourceClown 传进去，并且调用了 ObservableEmitter 的 onNext 等方法 sourceClown 被封装成了 CreateEmitter source 的 subscribe 方法接收的是 CreateEmitter， 所以，ObservableEmitter 在运行时就是 CreateEmitter 对象。 我们先不忙着去看它的 onNext 方法，先看看这个类。 套路三 由老父亲来替你打理一切 我们知道在套路二里面，我们传递的 sourceClown 被封装了一下，变成了一个 CreateEmitter 。 CreateEmitter 这个变量名就很叼，一看就是 observer 的老父亲，那么，可以先猜一猜，为啥它要起这样一个名呢？ 由于ObservableOnSubscribe 的 subscribe方法只接受 ObservableEmitter ，所以 CreateEmitter 必须要实现这个接口。 好，我们看源代码： CreateEmitter.java 123static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123;...&#125; AtomicReference是java类，就不展开讲了，不知道的人（比如我）这个时候应该打开了文档，开始学习了。 继续看构造方法： CreateEmitter.java 123CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer;&#125; 嗯，很好，observer 被保存起来了。 由于，在 sourceClown 中我们调用了： 我们写的 demo 的代码 1it.onNext(1) 上面说过，it 就是 CreateEmitter，所以 CreateEmitter的 onNext 方法会被调用。 现在，我们来分析它的 onNext 方法： CreateEmitter.java 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; RxJava2 中不允许数据源发射的数据为 null，所以我们简化一下： CreateEmitter.java onNext 简化后的代码 123456@Overridepublic void onNext(T t) &#123; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法，就是判断观察者有没有解除订阅，毕竟，蝙蝠侠也会心累。 这上面做了这么多判断，现在知道为啥起名叫 parent 了不？ 在我们的例子中，我们没有解除订阅，再简化一下，就是： CreateEmitter.java onNext 简化后的代码 1234@Overridepublic void onNext(T t) &#123; observer.onNext(t);&#125; 这下，够直白了吧，直接调用了 observer 的 onNext 方法。 还记得 observer 是谁吗，就是你，蝙蝠侠，observerBatMan。所以它的 onNext 方法会被调用。 我们写的 demo 的代码 123override fun onNext(t: Int) &#123; Assert.assertEquals(1, t)&#125; 那么，整个流程就跑通了。 至于，onComplete 方法，差不多的啦。 最后上一张图： 最后，还有一个很重要的东西，就是这个小demo 的起始点，并不是 sourceClown，上面的图不是程序执行流程图，而是一种关系图。 现在我们来看看，程序的起始点在哪？ 我们写的 demo 代码 123// 开始观察Observable.create&lt;Int&gt;(sourceClown) .subscribe(observerBatMan) 程序的起始点是 subscribe 方法，这个方法是属于 ObservableCreate 的，所以程序的起始点在 ObservableCreate 的 subscribe 方法。 下面，贴上程序执行流程图：]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（二）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的这篇文章的主要目的就是弄清楚链式调用与线程切换。如果你读懂了第一篇文章，这篇文章阅读起来还是非常简单的。因为链式调用和线程切换无非就是多了些 “数据源-观察者” 对。线程切换还涉及到线程池相关的东西，由于篇幅问题，线程池相关的东西会放到下一篇。从一个例子开始：1234567891011121314151617181920212223242526272829303132333435363738 // 观察者 -- 蝙蝠侠 val observerBatMan = object : Observer&lt;Int&gt; &#123; override fun onComplete() &#123; &#125; override fun onNext(t: Int) &#123; System.out.println(Thread.currentThread().name + "--observer") &#125; override fun onError(e: Throwable) &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125; &#125; // 数据源 -- 小丑 val sourceClown = ObservableOnSubscribe&lt;Int&gt; &#123; it.onNext(1) it.onComplete() System.out.println(Thread.currentThread().name + "--source") &#125; // 开始观察 Observable // ① .create&lt;Int&gt;(sourceClown) // ② 指定数据源执行的线程 .subscribeOn(Schedulers.computation()) // ③ 指定观察者执行的线程 .observeOn(Schedulers.io()) // ④ .subscribe(observerBatMan)&#125; 嗯，和上一篇文章的例子差不多，就多了几行线程切换而已，我们先给出数据的日志。有一个大致的印象，再来深入分析。 12RxComputationThreadPool-1--sourceRxCachedThreadScheduler-1--observer demo 里面的 ② 处有了第一篇的基础，那么我们直接从 demo 里面的 ② 处入手： Observable.java 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 你使用了套路一，效果拔群，得到结果如下： Observable.java 简化之后的 subscribeOn 代码，实际上就是创建并返回了一个 ObservableSubscribeOn 对象 123public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; return new ObservableSubscribeOn&lt;T&gt;(this, scheduler);&#125; 我们继续看 ObservableSubscribeOn。 ObservableSubscribeOn.java AbstractObservableWithUpstream.java 12345// ObservableSubscribeOn 继承了 AbstractObservableWithUpstreampublic final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123;...&#125;// AbstractObservableWithUpstream 继承了 Observableabstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123;...&#125; 所以，ObservableSubscribeOn 最终还是继承至 Observable的。 在第一篇文章中，我们分析的对象是 ObservableCreate，而现在我们分析的对象是 ObservableSubscribeOn。为了能够更加清晰的列出不同点，还是搞一个表格吧： ObservableSubscribeOn ObservableCreate 直接父类 AbstractObservableWithUpstream（最终还是继承 Observable） Observable 构造方法参数个数 两个：(ObservableSource&lt;T&gt; source, Scheduler scheduler) 一个：(ObservableOnSubscribe&lt;T&gt; source) 主要的不同点，还是在构造参数这里。 参数个数不同，这个好理解，因为需要切换线程，肯定需要指定切换到哪个线程，所以多一个参数 source 类类型不同，这个需要深入分析，往下看 看看 source 类有哪些不同之处： ObservableOnSubscribe.java ObservableSource.java 1234567public interface ObservableOnSubscribe&lt;T&gt; &#123; void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;&#125;public interface ObservableSource&lt;T&gt; &#123; void subscribe(@NonNull Observer&lt;? super T&gt; observer);&#125; 这两个类都是接口，都只有一个 subscribe 方法，看起来比较类似。 除了类名不同之外，就只有方法的参数不同了。 ObservableOnSubscribe 接收的参数 ObservableEmitter，上一篇文章说过，是将 Observer 包装了一层。 ObservableSource 直接接收了 Observer，嗯，很牛逼，后面我们来分析看看，它为啥不要包装，你也可以思考一下，嘿嘿嘿。 经过上面的分析，总的来说，区别不大，所以我们仍然可以套第一篇的套路来分析。 到这里先上个图，为后面做好心理准备。 demo 里面的 ③ 处接下来，我们看 demo 里面的 ③ 处： Observable.java 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; 调用了同名方法： Observable.java 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 使用套路一，简化代码： Observable.java observeOn 简化后的代码 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; return new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize);&#125; 可以看出，实际上就是创建了一个 ObservableObserveOn 对象。 看看这个对象吧，不出意外，和 ObservableOnSubscribe 应该很像。 先看类的结构： ObservableObserveOn.java 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123;...&#125; 与 ObservableOnSubscribe 一样，继承同一个类。 再看类的构造方法： ObservableObserveOn.java 123456public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) &#123; super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize;&#125; 这个方法的参数就更多了，前面两个我们应该熟悉了，看看后面的两个参数是什么意思。虽然这里没有注释，但是这个参数的值是从别处传来的，所以只要找到源头，还是可以找到相关注释的。 delayError 1indicates if the onError notification may not cut ahead of onNext notification on the other side of the scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received from upstream 额，我只能明白一个大概：若存在Error事件，则如常执行，执行完后再抛出错误异常 bufferSize 缓存大小，暂时还不知道缓存在哪里，所以先放着。 到了这里，我们再上一个图吧，后面的流程要起飞了。 demo 里面的 ④ 处接下来，就到了一个转折点，就是 demo 中的 ④ 处，它调用了 subscribe 方法。 在第一篇中，我们分析过，subscribe 方法会调用 subscribeActual 方法，所以这里，我们直接进入到 ObservableObserveOn 的 subscribeActual 方法中，看看它做了什么。 ObservableObserveOn .java 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 由于，我们传递的 scheduler 肯定不是 TrampolineScheduler，所以会直接进入到 else 分支。 else 分支里面的代码也很简单，我们先跳过线程池相关的东西，所以需要分析的就只有一行代码： ObservableObserveOn.java subscribeActual 方法的 else 分支 1source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); 按照套路二，ObserveOnObserver 其实就是对 observer 做了一个包装。 这个 observer 就是我们自己创建的 observerBatMan，上个图： 现在比较绕的是，ObservableObserveOn 类中的 subscribeActual 方法中的 source 变量是谁。由于 source 是从构造函数传递进来的，我们再回到 Observerable 的 observeOn 方法： Observable.java 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 可以看到，在创建 ObservableObserveOn 对象的时候，第一个参数传递的是 this。 这里有一个稍微绕的点，因为 observerOn 方法是 ObservableSubscribeOn 对象调用的，所以 this，指向的是 ObservableSubscribeOn。 所以，这里相当于 ObservableObserveOn 是一个桥梁，让 ObservableSubscribeOn 与 ObservableOnObserve 搭上了关系。 上一个图： 同样的，我们再来分析 ObservableSubscribeOn类的 subscribeActual 方法： ObservableSubscribeOn.java 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这个 subscribeActual 内部的代码风格与想象的完全不一样啊，虽然前2行很熟悉，但是第3行完全没见过啊。 现在，我们来分析第3行代码，先看 parent.setDisposable(xxx)： SubscribeOnObserver.java 123void setDisposable(Disposable d) &#123; DisposableHelper.setOnce(this, d);&#125; DisposableHelper.java 该方法，用来将 field 的值，设置为 d。 如果，设置的时候，field 已经有值了，返回false。 如果 field 有值， 并且值不是 DISPOSED，抛出异常。 123456789101112public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; // 抛出异常 reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这样来看，其实 parent.setDisposable(xxx)这行代码也没做什么，正常情况下，就是将 scheduler.scheduleDirect(new SubscribeTask(parent)) 的值设置给了 parent。 下面，继续看 scheduler.scheduleDirect()做了什么，由于篇幅问题，这里不分析线程池的东西，只说一下这个方法的作用，其实就是将一个 runnable，放到线程池中去执行，这里可以知道，线程切换了。 再继续，看看 SubscribeTask 类： SubscribeTask.java 1234567891011121314151617public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; ... // 内部类 final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; // source 变量是 ObservableSubscribeOn 的变量 source.subscribe(parent); &#125; &#125;&#125; 继承了 Runnable，在 run 方法中，我们终于看到了 subscribe 方法。 继续深入，看看 source 对象是谁： Observable.java 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; source 参数传递的是this，所以 source 对象是 ObservableCreate 对象。 到这里，还可以解释上面的问题：为啥 ObservableSource 的 subscribe 方法的参数是一个 Observer？ ObservableSource.java 为了方便，我又把这个接口代码贴了一遍 123public interface ObservableSource&lt;T&gt; &#123; void subscribe(@NonNull Observer&lt;? super T&gt; observer);&#125; 在我们的例子中，observer 参数就是 ObservableCreate 对象。 其实，从这个类名都可以看出 ObservableSource 这个接口表示的是数据源，因为 Observerable 类就实现了这个接口，所以这个接口的 subscribe 方法的实现就是 Observable 的内部实现。 当我们调用 subscribeOn 与 observeOn 这两个方法的时候，其实是将调者这做为数据源的意思。 另外，可以推出 ObservableOnSubscribe 这个接口，应该是专门用来处理数据源的源头的（方便我们调用 emitter.onNext 等方法），两个接口的意义不一样。 所以，我们可以得到这样的一个图： 把这几个类，整合到调用图里面，得到如下图： 上面的图，看起来还算清晰，但是没有线程切换的内容，下面会说到。 与上一篇一样，我们再来整理一下这个demo的执行流程图，你可以先自行想一下这个图应该是什么样子的。 图中灰色的长方体，表示的是调用 subscribeOn 与 observerOn 产生的 “数据源-观察者”对。 图中 subscribeOn 蓝色方块表示的是 subscribeOn 指定的线程切换的地方，可以看到，它指定的线程会影响到后续的所有流程。 图中 observerOn 黄色的方块表示的是 observerOn 指定的线程切换的地方，它会影响后续流程。 在回想一下，其实每次 observerOn 或者 subscribeOn 都创建了一个链条一样的节点，然后在 subscribeActual 将这些节点连接起来： 好了，这篇文章的东西就差不多了，关于线程剩下的东西，本章中都只是一笔带过，详细的内容，留到下一篇。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（六）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的分析Flowable的相关源码，了解一下背压的知识。从例子开始 demo 123456789Flowable .create&lt;Int&gt;(&#123; it.onNext(1) it.onNext(2) it.onComplete() &#125;, BackpressureStrategy.BUFFER) .subscribe &#123; System.out.println(it) &#125; 看看 create 方法创建了一个什么对象： Flowable io.reactivex.Flowable#create 12345public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) &#123; ObjectHelper.requireNonNull(source, "source is null"); ObjectHelper.requireNonNull(mode, "mode is null"); return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));&#125; 创建了一个 FlowableCreate 对象，由于 Flowable 与 Observerable 差不多，所以下面我们按照分析 Observerable 的思路来分析 Flowable。 ####FlowableCreate 类结构 1public final class FlowableCreate&lt;T&gt; extends Flowable&lt;T&gt; &#123;...&#125; 这个没啥说的，与 Observerable 一样。 构造函数 1234public FlowableCreate(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy backpressure) &#123; this.source = source; this.backpressure = backpressure;&#125; 也与 Observerable 差不多，就是两套代码吧。一个以 Observerable 开头，一个以 Flowable 开头，嗯，现在我对源码的探究就只到了这个程度，可能还有别的不同，暂时还未发现。 subscribeActual 方法 demo 中 backpressure 我们传递的是 BackpressureStrategy.BUFFER，所以 emitter 的值是 BufferAsyncEmitter。 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void subscribeActual(Subscriber&lt;? super T&gt; t) &#123; BaseEmitter&lt;T&gt; emitter; switch (backpressure) &#123; case MISSING: &#123; emitter = new MissingEmitter&lt;T&gt;(t); break; &#125; case ERROR: &#123; emitter = new ErrorAsyncEmitter&lt;T&gt;(t); break; &#125; case DROP: &#123; emitter = new DropAsyncEmitter&lt;T&gt;(t); break; &#125; case LATEST: &#123; emitter = new LatestAsyncEmitter&lt;T&gt;(t); break; &#125; default: &#123; // 走这里 emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize()); break; &#125; &#125; // 下面的就不分析了，参考前面的文章 t.onSubscribe(emitter); try &#123; source.subscribe(emitter); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); emitter.onError(ex); &#125;&#125; 所以，我们只需要分析 BufferAsyncEmitter 这个类就好了。 ####FlowableCreate.BufferAsyncEmitter 类结构 这个类是 FlowableCreate 的内部类，可以想到其他的 Emitter 应该也是内部类 继承了 BaseEmitter 1static final class BufferAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; &#123;...&#125; ####FlowableCreate.BaseEmitter 类结构 注意这个类继承至 AtomicLong 123abstract static class BaseEmitter&lt;T&gt;extends AtomicLongimplements FlowableEmitter&lt;T&gt;, Subscription &#123;...&#125; 这个类实现了一些通用的方法，比如 onError，onComplete，cancel等等。 其中只有一个方法需要看看： BaseEmitter#request 1234567891011@Overridepublic final void request(long n) &#123; // 判断 n 是不是正数 if (SubscriptionHelper.validate(n)) &#123; // 是正数，将 n 设置给自己 // 上面有说，这个类继承了 AtomicLong，所以它可以持有一个 Long 型的引用 BackpressureHelper.add(this, n); // 钩子方法 onRequested(); &#125;&#125; 好了，到这里 BaseEmitter 的方法就分析的差不多了，这个类只是提供了一些默认的实现方法，没有别的逻辑，把它当成一个普通的父类就好了。 ####FlowableCreate.BufferAsyncEmitter 再回到 BufferAsyncEmitter 里面，看构造函数 构造函数 123456BufferAsyncEmitter(Subscriber&lt;? super T&gt; actual, int capacityHint) &#123; super(actual); // 这里有一个新类 this.queue = new SpscLinkedArrayQueue&lt;T&gt;(capacityHint); this.wip = new AtomicInteger();&#125; SpscLinkedArrayQueue 这个类不展开介绍了，贴一段注释就明白了。 123A single-producer single-consumer array-backed queue which can allocate new arrays in case the consumer is slowerthan the producer.一个单生产者单消费者数组支持的队列，它可以在消费者比生产者慢的情况下分配新的数组（自动增长）。 机翻都能看的懂吧，源码就是实现了这样功能的队列，有兴趣的可以看看。 我们把 SpscLinkedArrayQueue 当成一个队列就好。注意这里的初始容量是 128，但是会自动增长。 看完构造方法，再看 onNext 方法。 onNext 12345678910111213141516171819202122@Overridepublic void onNext(T t) &#123; // isCancelled 是父类的方法 // 当我们调用 setDisposable 方法的时候，父类就会保存这个 Disposable 的引用到 serial 字段 // 如果该 Disposable 调用了 dispose 方法，那么 isCancelled 会返回 true // 调用父类的 cancel 方法，isCancelled 也会返回 true（内部调用了 serial.dispose()） // 数据发送完毕或者发生错误，isCancelled 也会返回 true（内部调用了 serial.dispose()） // done 只有数据发生完毕或者发生错误才会为true if (done || isCancelled()) &#123; return; &#125; // 不允许发送的数据为null if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; // 先将数据添加到队列里面 queue.offer(t); // 调用 drain 方法 drain();&#125; 看来，onNext 的主要目的，就是先将数据加入到队列里面，然后调用 drain 方法。继续看 drain 方法。 drain 这个方法有点长，变量名也有点蛋疼，但是慢慢分析，不难 在阅读源码的时候，一定要有耐心。阅读源码的过程其实是一个提升自己理解力的过程。 既然你需要阅读别人的源代码，那么你的理解力肯定是处于弱势的，不然的话，你一看就懂，那就说明源码的东西在作者写出来之前你都已经掌握了，那么阅读源码对自己没有任何好处。 所以，阅读源码的过程，就是需要慢慢提升自己的理解力，来达到与作者的理解力一样的程度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100void drain() &#123; // wip 这个变量到后面分析，因为涉及到别的方法，单看这一个方法看不出什么东西来 if (wip.getAndIncrement() != 0) &#123; return; &#125; int missed = 1; // 这两个变量名有点吊 final Subscriber&lt;? super T&gt; a = actual; final SpscLinkedArrayQueue&lt;T&gt; q = queue; for (;;) &#123; // 这里，获取设置的引用值，因为这个类是继承的 AtomicLong // 前面我们分析过，只有 request 方法才会设置引用值 // 至于哪里调用了 request 方法，我们后面分析 // 这里将这个值当作 Long.MAX_VALUE long r = get(); long e = 0L; // 进入循环 while (e != r) &#123; // 判断是否取消了 if (isCancelled()) &#123; // 取消了就清空队列 q.clear(); return; &#125; // 时候发送完毕了，或者出现了错误 boolean d = done; // 从队列中取出一个数据 T o = q.poll(); // 队列是否为空 boolean empty = o == null; // 数据发送完毕了，并且队列为空 if (d &amp;&amp; empty) &#123; Throwable ex = error; if (ex != null) &#123; // 调用父类 error 方法，会调用 onError error(ex); &#125; else &#123; // 调用父类 complete 方法，会调用 onComplete complete(); &#125; return; &#125; // 队列为空，则跳出循环 if (empty) &#123; break; &#125; // 调用 onNext 方法，o 是从队列取出来的数据 a.onNext(o); // e 的值累加 e++; &#125; // 这里要判断一下 e 与 r 是否相等， // 因为如果队列为空的话，e 是不等于 r 的 // 相等的话，说明请求的个数刚好等于发送的个数，做一下收尾工作就好了 if (e == r) &#123; // 下面的一段与上面的很相似，不一句一句写了 if (isCancelled()) &#123; q.clear(); return; &#125; boolean d = done; boolean empty = q.isEmpty(); if (d &amp;&amp; empty) &#123; Throwable ex = error; if (ex != null) &#123; error(ex); &#125; else &#123; complete(); &#125; return; &#125; &#125; if (e != 0) &#123; // 因为发送了 e 个数据，所以将引用值更新 // 内部就是将引用自减少了 e BackpressureHelper.produced(this, e); &#125; // 这个后面分析 missed = wip.addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; drain 的主要作用，就是当我们调用 request(num) 请求 num 个数据的时候，这个方法会从队列中取出 num 个数据出来给我们。 可以思考一下，如果我们没有调用，request 方法，会怎么样？ drain 简化后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142void drain() &#123; ... for (;;) &#123; long r = get(); long e = 0L; // 没有调用 request，导致 r 为 0，这里进不去 while (e != r) &#123; ... &#125; // 相等 if (e == r) &#123; // 没有取消 if (isCancelled()) &#123; ... &#125; boolean d = done; // 队列不为空 boolean empty = q.isEmpty(); // 进不去 if (d &amp;&amp; empty) &#123; ... &#125; &#125; // 进不去 if (e != 0) &#123; ... &#125; missed = wip.addAndGet(-missed); // 满足，跳出循环 if (missed == 0) &#123; break; &#125; &#125;&#125; 可以看到，如果我们没有调用 request 方法，虽然 onNext 方法被调用了，将数据加入到了队列中，但是却无法从队列中取出数据，即下游的观察者收不到任何数据。 还有两个遗留的问题： wip 变量的作用？ request 方法在哪里调用的？ 先看第一个问题： drain 123456789101112131415161718192021222324 void drain() &#123; // 将值加 1，返回未加 1 之前的值 // 就是判断 wip 的引用值是否是0，然后加1 if (wip.getAndIncrement() != 0) &#123; return; &#125; // 到了这里 wip 引用的值理论上为1 // 但是多线程的情况下， onUnsubscribed 会将 wip 加 1 int missed = 1; ... for (;;) &#123; ... // 将 wip 的值减 - missed // 这里处在一个循环中，最终 wip 的值会变成 0，missed 也会变成0，跳出循环 missed = wip.addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125; &#125;&#125; onUnsubscribed 123456789@Overridevoid onUnsubscribed() &#123; // 取消的时候，wip 的值为 0 的话，清空队列 // 就是说，此时，drain 方法运行到了 for 循环的最后几行 // 这里应该是为了保证，数据从队列里面取出来，一定要发送出去才行 if (wip.getAndIncrement() == 0) &#123; queue.clear(); &#125;&#125; 在 BufferAsyncEmitter 这个类中，使用到 wip 这个变量的，只有上面这几个地方。 onUnsubscribed 会在父类的 cancel 方法中调用，所以我们调用 cancel 就会改变 wip 的值： FlowableCreate.BaseEmitter cancel 12345@Overridepublic final void cancel() &#123; serial.dispose(); onUnsubscribed();&#125; 好了，第一个问题说完了，我们来看看第2个问题： 首先我们回到 demo 中，既然 create 方法中没有调用 request 的地方，那么我们只能从 subscribe 方法入手了。 ####Flowable io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;) 1234public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123; return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);&#125; 它调用了名方法： io.reactivex.Flowable#subscribe(io.reactivex.functions.Consumer&lt;? super T&gt;, io.reactivex.functions.Consumer&lt;? super java.lang.Throwable&gt;, io.reactivex.functions.Action, io.reactivex.functions.Consumer&lt;? super org.reactivestreams.Subscription&gt;) 12345678910111213public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123; ObjectHelper.requireNonNull(onNext, "onNext is null"); ObjectHelper.requireNonNull(onError, "onError is null"); ObjectHelper.requireNonNull(onComplete, "onComplete is null"); ObjectHelper.requireNonNull(onSubscribe, "onSubscribe is null"); LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe); subscribe(ls); return ls;&#125; 创建了一个 LambdaSubscriber 对象，并调用了 subscribe 方法，将 ls 传递了进去。 所以这个方法其实就是将我们的 consumer 包装成了 LambdaSubscriber，然后调用真正的 subscribe 方法。 LambdaSubscriber看看 LambdaSubscriber 类： 构造方法 123456789public LambdaSubscriber(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) &#123; super(); this.onNext = onNext; this.onError = onError; this.onComplete = onComplete; this.onSubscribe = onSubscribe;&#125; 保存了一些变量，onSubscribe 值得注意，因为这个 Consumer 在订阅的时候会回调，是调用 request 的最好时机。 直接看 onSubscribe 的实现。 onSubscribe 123456789101112@Overridepublic void onSubscribe(Subscription s) &#123; if (SubscriptionHelper.setOnce(this, s)) &#123; try &#123; onSubscribe.accept(this); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.cancel(); onError(ex); &#125; &#125;&#125; 这里调用了 onSubscribe 对象的 accept 方法。我们看看这个对象的实现吧。 FlowableInternalHelper.RequestMax.INSTANCE从前面的代码中（Flowable.subscribe()方法中），我们知道 onSubscribe 对象是 FlowableInternalHelper.RequestMax.INSTANCE。所以看看这个类的代码吧。 FlowableInternalHelper.RequestMax.INSTANCE 1234567public enum RequestMax implements Consumer&lt;Subscription&gt; &#123; INSTANCE; @Override public void accept(Subscription t) throws Exception &#123; t.request(Long.MAX_VALUE); &#125;&#125; 嗯，果然是这里调用了 request 方法。 到这里，Flowable 的分析就告一段落。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 源码分析（五）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FRxJava2%2FRxJava2%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目的本文主要分析操作符的实现原理，关于操作符的使用不做讲解，想了解的可以参考Github上的例子项目以及官方文档。从一个例子开始这里我们以最常用的 map 为例。首先我们写一个demo： Demo 这个demo演示了如何将一个int转成string。Kotlin 赛高！！！ 虽然看起来没有什么屌用，但是如果int值是一个图片的资源id，我们要将这个id转成一个Bitmap，那么也可以用map操作法，再配上前几篇文章说的线程切换，岂不美哉！~ 1234567Observable.just(1).map &#123; // map 的作用主要是做一个变化，这里是将发射的 int 值变成 string "$it-covert"&#125;.subscribe &#123; // 打印接收到的 string System.out.println(it)&#125; 这个为了简单我用到了 just 操作符，其实和 create 差不多，如果你强迫症想搞清楚，可以自己戳戳源码，前面的文章如果你真的看懂了，戳进去几分钟就知道它的原理啦。 这里我们直接从 map 方法开始分析： Observable Observable 1234public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, "mapper is null"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));&#125; 按住 ctrl 键，点击鼠标左键： ObservableMap 类结构 它也是继承了 AbstractObservableWithUpstream，这个是我们的老相好了，就不介绍了 1public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123;...&#125; 下面看构造函数： 构造函数 123456public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123; // source 不多说 super(source); // 这里就是我们做变换的函数 this.function = function;&#125; 接下来就是看 subscribeActual 方法了，看，只要掌握了套路，分析起源码来，还是比较轻松的。 subscribeActual 方法 1234@Overridepublic void subscribeActual(Observer&lt;? super U&gt; t) &#123; source.subscribe(new MapObserver&lt;T, U&gt;(t, function));&#125; 这个方法很直接，不做作，直接将 t 与 functiaon 全部扔进 MapObserver 里面，交给 MapObserver 去处理。下面来分析分析 MapObserver 这个类。 ObservableMap.MapObserver 类结构 MapObserver 继承了 BasicFuseableObserver 1static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123;...&#125; BasicFuseableObserver书里说过，信息太多与信息太少，都会对理解力造成阻碍。 这个类的蛋疼之处就在于，里面的代码不多，很简单，但是又没简单到你可以一下子就能明白这个类的作用。所以如果我把这个类的代码贴出来，作用也不大，我说不出一个道道来。 这里我说一下我自己对这个类的理解： 1Base class for a fuseable intermediate observer. 上面的一串英文是类的注释，翻译过来就是说 一个用于可融合的中间观察者的基类，反正我还是没太明白。 既然它是一个中间观察者，我们就看看它作为一个“中介”，搞了一些啥事情。 BasicFuseableObserver#onSubscribe 在这个方法里面，它作为第三者，插入到了原来的 parent 与 observer 之间 1234567891011121314151617181920212223242526@Overridepublic final void onSubscribe(Disposable s) &#123; // 该方法用于判断 this.s 为 null，并且 s 不为 null if (DisposableHelper.validate(this.s, s)) &#123; // 这行代码很重要 this.s = s; // QueueDisposable 是一个接口，后面会讲 if (s instanceof QueueDisposable) &#123; this.qs = (QueueDisposable&lt;T&gt;)s; &#125; // 这里有两个钩子 if (beforeDownstream()) &#123; // 调用了 actual 的 onSubscribe // 这个方法我们在之前分析 subscribeActual 方法的时候，都是跳过的 // 下面我们会分析这个方法的作用 actual.onSubscribe(this); afterDownstream(); &#125; &#125;&#125; 由于在之前的文章中，我们忽略了 onSubscribe，而这个类用到了这个方法，所以现在我们拿 ObservableCreate 来分析一下 onSubscribe 这个方法的作用。 ObservableCreate ObservableCreate#subscribeActual 1234567@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); ...&#125; 其实从这两行代码就可以看出，onSubscribe 的参数就是我们的老父亲 parent。 之前我们说过，CreateEmitter 就是将 observer 包装了一下，即 CreateEmitter 持有 observer 。 现在看 onSubscribe 方法就是反过来，即 observer “参数持有” CreateEmitter 。 让我们再次回到 BasicFuseableObserver 类中的 onSubscribe 方法里面： ####BasicFuseableObserver BasicFuseableObserver#onSubscribe 12345678// 这行代码很重要// s 是原来的 parent，它把这个对象保存起来this.s = s;// actual 是我们 demo 中创建的匿名内部类（虽然真正的情况是将 consumer 包成了 observer）// 将 this 作为 parent 传递进去// 所以，这样他就成了一个中间观察者actual.onSubscribe(this); 上面的代码，你可以联想一下链表的插入操作。 前面的文章里面，onSubscribe 的调用都是放在 subscribeActual 中的，这里为啥要放到 Observer 类里面呢？我猜想是因为操作符会导致数据源的不稳定（同步，异步数据），因为 BasicFuseableObserver 还实现了 QueueDisposable 这个接口，这个接口类注释比较多，可以详细看看。 那么，分析到了这里，我们就将 MapObserver 当作一个普通的 Observer 的包装类来看待吧。反正这里我们还用不到里面的 poll 方法。 ObservableMap.MapObserver我们直接看 onNext 方法： onNext 这里该方法由 MapObserver 的包装类调用，我们了解了套路，更不需要从头跟踪源码，就知道它由谁调用。只要知道它会被调用，在具体的代码中会被谁调用，分析源码的时候管他调用者是谁呢。 123456789101112131415161718192021222324@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; // 在这个 demo 中，sourceMode 一直为 NONE if (sourceMode != NONE) &#123; actual.onNext(null); return; &#125; U v; try &#123; // 这里就执行变化了，注意变换结果不能返回null v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value."); &#125; catch (Throwable ex) &#123; fail(ex); return; &#125; // 将变化的结果返回 actual.onNext(v);&#125; 嗯，到这里，demo的流程就分析完了，还是很简单的，主要是例子简单。 其实，该类还有一个 poll 方法，应该会在某些情况下调用，这里没有用到，里面的水应该还有点深。 其他的操作符，这里就不讲了。]]></content>
      <categories>
        <category>RxJava2</category>
      </categories>
      <tags>
        <tag>Android-源码解析-RxJava2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FileProvider]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FFileProvider%2F</url>
    <content type="text"><![CDATA[从 Android N（7.0） 开始，将严格执行 StrictMode 模式，也就是说，将对安全做更严格的校验。而从 Android N 开始，将不允许在 App 间，使用 file:// 的方式，传递一个 File ，否者会抛出 FileUriExposedException 的错误，会直接引发 Crash。只能使用FileProvider 将file:// 替换为 content://。 FileProvider 本质上就是一个 ContentProvider ，它其实也继承了 ContentProvider 的特性。ContentProvider 其实就是在可控的范围内，向外部其他的 App 分享数据。而 FileProvider 将这样的数据变成了一个 File 文件而已。 下面的代码演示了如何使用 FileProvier： 12345678910111213141516&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapp"&gt; &lt;application ...&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.myapp.fileprovider" android:grantUriPermissions="true" android:exported="false"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/filepaths" /&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; provider 标签下，配置了几个属性： name ：配置当前 FileProvider 的实现类。 authorities：配置一个 FileProvider 的名字，它在当前系统内需要是唯一值。 exported：表示该 FileProvider 是否需要公开出去，这里不需要，所以是 false。 granUriPermissions：是否允许授权文件的临时访问权限。这里需要，所以是 true。 在配置 Provider 的时候，还需要额外配置一个 &lt;meta-data/&gt; 标签，它用于配置 FileProvider 支持分享出去的目录。这个 &lt;meta-data/&gt; 标签的 name 值是固定的，resource 需要指向一个 根节点为 paths 的 xml 资源文件。在 src/main/res/xml/文件夹下面: 1234&lt;paths&gt; &lt;!-- 表示 files/images/myimages 下的路径 --&gt; &lt;files-path path="images/" name="myimages" /&gt;&lt;/paths&gt; path下面可以配置多个节点： root-path：表示根目录，『/』。 files-path：表示 content.getFileDir() 获取到的目录。 cache-path：表示 content.getCacheDir() 获取到的目录 external-path：表示Environment.getExternalStorageDirectory() 指向的目录。 external-files-path：表示 ContextCompat.getExternalFilesDirs() 获取到的目录。 external-cache-path：表示 ContextCompat.getExternalCacheDirs() 获取到的目录。 具体可以参考 FileProvider 的官方说明文档 。 定义好需要分享的文件之后，在ClientApp请求文件的时候，我们就可以返回一个 Uri 给它。 1234567891011val requestFile = File(imageFilenames[position])val fileUri: Uri? = try &#123; FileProvider.getUriForFile( this@MainActivity, "com.example.myapp.fileprovider", requestFile)&#125; catch (e: IllegalArgumentException) &#123; Log.e("File Selector", "The selected file can't be shared: $requestFile") null&#125; 获取文件的 Uri 一定要使用 FileProvider.getUriForFile 这个方法，不要使用Uri.fromFile()这个方法。因为这个方法要求 ClientApp 具有读权限，并且无法跨App分享文件。 在返回Uri之后，还需要给 Intent 加上临时权限： 123456// Grant temporary read permission to the content URIresultIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)// Put the Uri and MIME type in the result IntentresultIntent.setDataAndType(fileUri, contentResolver.getType(fileUri))// Set the resultsetResult(Activity.RESULT_OK, resultIntent) 还有另外一种授权方式，但是不建议使用： 使用 Context.grantUriPermission() 为其他 App 授予 Uri 对象的访问权限。这种情况下，授权的有效期限，从授权一刻开始，截止于设备重启或者手动调用 Context.revokeUriPermission() 方法，才会收回对此 Uri 的授权。 而使用 Flag 的方式，当 ClientApp 的任务栈结束的时候，就会自动收回权限。 ClientApp 获取到 Uri 之后，就可以访问文件了： 1234567891011121314151617181920212223// Get the file's content URI from the incoming IntentreturnIntent.data?.also &#123; returnUri -&gt; /* * Try to open the file for "read" access using the * returned URI. If the file isn't found, write to the * error log and return. */ inputPFD = try &#123; /* * Get the content resolver instance for this context, and use it * to get a ParcelFileDescriptor for the file. */ contentResolver.openFileDescriptor(returnUri, "r") &#125; catch (e: FileNotFoundException) &#123; e.printStackTrace() Log.e("MainActivity", "File not found.") return &#125; // Get a regular file descriptor for the file val fd = inputPFD.fileDescriptor ...&#125;]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle Transform API ：直接修改 class 文件]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2FGradle%20Transform%20API%20%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%20class%20%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首先，我要说的是，我没想到写这篇文章会遇到那么多的难点。其次在写这篇文章的时候，我还是处于一个半吊子的状态，但是我想应该还是会比现有的大部分blog要好的多。我几乎将Google到的索引到的前几页文章全部看了一遍，但是大部分都是相同的内容，就只有一篇我印象比较深，写的比较全面，但是我仍然还有很多疑问。 下面的文章我会提出我自己在学习这个知识点时想要问的问题，有些问题我可以自己解答，但是有些还是摸棱两可。 首先列出阅读这篇文章所需要的基础知识，如果你连这些都没有掌握的话，就不建议往下看了，会很痛苦，除非你只是想了解一下。 Goorvy 基本语法 Gradle 构建 ASM 前两个知识点有一个快速掌握的方法，阅读这个 PDF 文件，写的还是非常不错的，我花了一个小时看完，我看的比较快，因为我看过《Gradle权威指南》这本书。 好了，从这里开始，我就当你已经掌握了上面的相关知识点。 Gradle 工作流程Gradle 是一个框架，它定义一套自己的游戏规则。我们要玩转 Gradle，必须要遵守它设计的规则。 下面我们来讲讲 Gradle 的基本组件： Gradle 中，每一个待编译的工程都叫一个 Project。每一个 Project 在构建的时候都包含一系列的 Task。比如一个 Android APK 的编译可能包含：Java 源码编译 Task、资源编译 Task、JNI 编译 Task、lint 检查 Task、打包生成 APK 的 Task、签名 Task 等。 一个 Project 到底包含多少个 Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义 Task，并具体执行这些 Task 的东西。 Gradle 作为框架，它负责定义流程和规则，而具体的编译工作则是通过插件的方式来完成的。比如编译 Java 有 Java 插件，编译 Groovy 有 Groovy 插件，编译 Android APP 有 Android APP 插件，编译 Android Library 有 Android Library 插件。好了，到现在为止，你知道 Gradle 中每一个待编译的工程都是一个 Project，一个具体的编译过程是由一个一个的 Task 来定义和执行的。 在 Android Stuido 中，每个 moudle 都有自己的 build.gradle 文件。在构建的时候，每一个 build.gradle 文件都会转换成一个 Project 对象。 一个 Project 会包含若干 Tasks。另外，由于 Project 对应具体的工程，所以需要为 Project 加载所需要的插件，比如：为 Java 工程加载 Java 插件，为 Android 工程加载 Android 插件。 这里就为该工程加载了 3 个插件。一般的插件可以直接使用，但是有的插件可能还需要配置扩展。 如上图所示，这是属于 com.android.application 插件的一个 android 扩展。在这里我们就可以配置该扩展的一些属性。 了解了这些，我们继续。 Gradle 工作包含三个阶段： 首先是Initiliazation阶段：对我们前面的 multi-project build 而言，就是执行 settings.gradle。 然后是 Configration 阶段：Configration 阶段的目标是解析每个 project 中的 build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过 API 来添加的。 Configuration 阶段完了后，整个 build 的 project 以及内部的 Task 关系就确定了。前面说过，一个Project 包含很多 Task，每个 Task 之间有依赖关系。Configuration 会建立一个有向图来描述 Task 之间的依赖关系。所以，我们可以添加一个 HOOK，即当 Task 关系图建立好后，执行一些操作。 最后一个阶段就是执行任务了。 Transform API 为什么可以修改 class 文件我们知道，一个 project 的构建是由很多 task 组成的，而这些 task 是有依赖关系的。我们结合一下 App 的打包流程来看一下，各个 task 是发生在什么时候。 在 App 打包的时候，首先需要先将 java 文件编译为 class 文件（这里不关心一些其他的 AIDL 之类的），然后将 jar 与 class 文件达成 dex 文件。由于工程是 Gradle 构建的，Gradle 的构建是基于 Task 的，所以这些编译java文件，打包 class 文件都是在 task 中执行的。 在构建的过程中，这些 Task 都是由 TaskManager 管理的： com.android.build.gradle.internal.TaskManager#createCompileTask 123456protected void createCompileTask(@NonNull VariantScope variantScope) &#123; TaskProvider&lt;? extends JavaCompile&gt; javacTask = createJavacTask(variantScope); addJavacClassesStream(variantScope); setJavaCompilerTask(javacTask, variantScope); createPostCompilationTasks(variantScope);&#125; 这里是先执行了 javac 的编译任务，然后执行 post 编译任务。 com.android.build.gradle.internal.TaskManager#createPostCompilationTasks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void createPostCompilationTasks( @NonNull TaskFactory tasks, @NonNull final VariantScope variantScope) &#123; ... // ----- External Transforms ----- // 添加自定义的 Transform List&lt;Transform&gt; customTransforms = extension.getTransforms(); List&lt;List&lt;Object&gt;&gt; customTransformsDependencies = extension.getTransformsDependencies(); for (int i = 0, count = customTransforms.size() ; i &lt; count ; i++) &#123; Transform transform = customTransforms.get(i); AndroidTask&lt;TransformTask&gt; task = transformManager .addTransform(tasks, variantScope, transform); ... &#125; ... // ----- Minify next ----- // minifyEnabled 为 true 表示开启混淆 // 添加 Proguard Transform if (isMinifyEnabled) &#123; boolean outputToJarFile = isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode; createMinifyTransform(tasks, variantScope, outputToJarFile); &#125; ... // non Library test are running as native multi-dex if (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123; ... // 添加 JarMergeTransform // create a transform to jar the inputs into a single jar. if (!isMinifyEnabled) &#123; // merge the classes only, no need to package the resources since they are // not used during the computation. JarMergingTransform jarMergingTransform = new JarMergingTransform( TransformManager.SCOPE_FULL_PROJECT); variantScope.addColdSwapBuildTask( transformManager.addTransform(tasks, variantScope, jarMergingTransform)); &#125; // 添加 MultiDex Transform // create the transform that's going to take the code and the proguard keep list // from above and compute the main class list. MultiDexTransform multiDexTransform = new MultiDexTransform( variantScope, extension.getDexOptions(), null); multiDexClassListTask = transformManager.addTransform( tasks, variantScope, multiDexTransform); multiDexClassListTask.optionalDependsOn(tasks, manifestKeepListTask); variantScope.addColdSwapBuildTask(multiDexClassListTask); &#125; ... // 添加 Dex Transform // create dex transform DefaultDexOptions dexOptions = DefaultDexOptions.copyOf(extension.getDexOptions()); ...&#125; 这个方法会遍历所有的 Transform，然后一一添加进 TransformManager。 添加完自定义的 Transform 之后，再添加 Proguard, JarMergeTransform, MultiDex, Dex 等 Transform。所以 Transform API 可以接触到 class 文件，这个时机是最好的处理时机。 Transform API 的使用根据 Transform API 的 文档，我们先自定义一个 Transform，然后将这个 Transform 注册到 android 扩展中即可。 自定义 Transform 我们后面会说到，这里我们想说如何注册。文档中对注册的描述只有一句话： To insert a transform into a build, you simply create a new class implementing one of the Transform interfaces, and register it with android.registerTransform(theTransform) or android.registerTransform(theTransform, dependencies). 但是实际上设计到的问题很多。比如：如何拿到 android 扩展？？？ 要拿到 android 扩展，一般我们是使用自定义一个插件的方式。由于 android 扩展中提供了 registerTransform 方法，所以是可以直接在 build.gradle 中调用的，但是它蛋疼的地方是这样搞的话，所有的逻辑都糅合在一起了。 下面我们介绍如何自定义一个插件，但是我们先来了解一下 Gradle 编程模型会好很多。 Gradle 编程模型Gradle 基于 Groovy，Groovy 又基于 Java。所以，Gradle 执行的时候和 Groovy 一样，会把脚本转换成 Java对象。Gradle 主要有三种对象，这三种对象和三种不同的脚本文件对应，在 gradle 执行的时候，会将脚本转换成对应的对端： Gradle 对象：当我们执行 gradle xxx 或者什么的时候，gradle 会从默认的配置脚本中构造出一个 Gradle对象。在整个执行过程中，只有这么一个对象。Gradle 对象的数据类型就是 Gradle。我们一般很少去定制这个默认的配置脚本。 Project 对象：每一个 build.gradle 会转换成一个 Project 对象。 Settings 对象：显然，每一个 settings.gradle 都会转换成一个 Settings 对象。 自定义 Gradle 插件新建一个 module删除其他目录，只留下 src/main 目录与 build.gradle 文件。 然后在 main 目录下面，新建 groovy 目录 与 resouce 目录。 groovy 就是用来放 groovy 文件的，与 java 目录的作用一样。 resources 目录是用来配置插件的相关信息的。接着我们在 resources 目录下新建一个 META-INF 目录，再在 META-INF 目录下新建一个 gradle-plugins 目录。然后在 gradle-plugins 新建一个 aaa.bbb.properties 文件。 需要注意的是，这个文件的名字很重要，aaa.bbb 是你定义的插件的名字。什么意思呢？还记得我们是如何加载一个插件的吗？ 1apply plugin: 'log.inject' 看，这个文件的名字就是加载插件时用到的名字。 文件的内容，比较简单，由于我们是要自定义一个插件，所以需要在这里声明一下插件的名字。 1implementation-class=com.aprz.log.LogPlugin 这样，我们的第一步就完成了。 实现一个插件类一般的，我们需要自定义一个东西，都会有一个父类给我们使用，插件也不例外。我们需要实现 Plugin 接口： 12345678910111213141516171819202122class LogPlugin implements Plugin&lt;Project&gt; &#123; @Override void apply(Project project) &#123; println('welcome to log inject plugin...') // 找到项目中的 某个继承至 BaseExtension 的扩展 def ext = project.extensions.getByType(BaseExtension) // 往该扩展中添加 transform // 这里其实就是将我们自定义的这个 transform 添加到了集合中 // 但是这里让我想不明白的是，为什么这个添加 transform 的方法是在 extension 里面 // 而不是 project 里面，如果像 Java 工程，没有使用有扩展的插件该怎么办 // 查看源码发现了这样的代码：com.android.build.gradle.internal.TaskManager.createPostCompilationTasks // AndroidConfig extension = variantScope.getGlobalScope().getExtension(); // 它获取到了 android 扩展，然后拿到了其中的所有 transform // 嗯，看来这个是针对 Android 构建的 ext.registerTransform(new LogsTransform(project)) &#125;&#125; 当这个插件按被加载（build.gradle 执行到 apply plugin: &#39;xxxx&#39;）的时候，它的 apply 方法就会被调用，我们在这里可以注册我们的 Transform 了。其实如果不需要注册 transform，我们只想打印一下 log 的话，它也是一个插件，只不过是一个没啥屌用的插件而已。 要想自定义一个有用的插件，还需要对 Groovy 语法，gradle 文档有相当的了解才行。 发布插件前面我们自定义了一个插件，但是需要发布之后，自己以及别人的项目才能使用，这里简单的说一下，如何发布到本地自己使用，想要发布到 bintray 等网站，可以自行查阅文档。 为了方便，我是使用了第三方的辅助插件。首先我们在根目录的 build.gradle 中添加依赖： TransformAPIDemo\build.gradle 12345dependencies &#123; classpath 'com.novoda:bintray-release:0.9' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files&#125; 然后在插件工程的 build.gradle 中添加配置： TransformAPIDemo\log_transform\build.gradle 12345678910111213141516171819202122apply plugin: 'com.novoda.bintray-release'uploadArchives &#123; repositories &#123; mavenDeployer &#123; pom.groupId = 'com.aprz.log.inject' pom.artifactId = 'log' pom.version = '1.0.0' repository(url: uri('E:/maven/repository')) &#125; &#125;&#125;publish &#123; userOrg = 'aprz512' groupId = 'com.aprz.log.inject' artifactId = 'log' publishVersion = '1.0.0' desc = 'log inject demo' website = 'https://github.com/aprz512/Transform-API-demo' repoName = 'gradle_plugins'&#125; groupId,artifactId,version这3个应该经常接触，就不说了，这里看 repository 的配置，是可以配置本地路径的。这里我配置的是 E 盘。执行发布命令： 点击这个玩意，查看控制台输出： 然后就可以在E盘看到发布的插件了。 自定义 Transform上面我们自定义插件时提到了 Transform 的注册，里面创建了一个 Transform，但是我们没有深究，这里会仔细的分析一下。 自定义 Transform 同样的也需要继承一个父类： 1234567891011121314151617181920212223242526272829303132class LogsTransform extends Transform &#123; LogsTransform() &#123; &#125; @Override String getName() &#123; return this.getClass().getSimpleName() &#125; @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; @Override Set&lt;QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT &#125; @Override boolean isIncremental() &#123; return false &#125; @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) &#125; &#125; 我们先用一张图来说明，transform 是如何工作的，然后再细说上面的每个方法是什么意思。 Transform每次都是将一个输入进行处理，然后将处理结果输出，而输出的结果将会作为另一个Transform的输入。每个 Transform 会处理某些特定的资源流，如何指定需要处理的资源流是通过 getInputTypes 与 getScopes 一起决定的。 下面一一解释上面的几个方法： getName 指明本Transform的名字，随意，但是不能包含某些特殊字符，否则会报错。 getInputTypes 指明Transform的输入类型，例如，返回 TransformManager.CONTENT_CLASS 表示配置 Transform 的输入类型为 Class。 getScopes 指明Transform的作用域，例如，返回 TransformManager.SCOPE_FULL_PROJECT 表示配置 Transform 的作用域为全工程。 isIncremental 指明是否是增量构建 transform 用于处理具体的输入输出，核心操作都在这里。上例中，配置 Transform 的输入类型为 Class， 作用域为全工程，因此在transform方法中，inputs 会传入工程内所有的 class 文件。 通过 Scope 和 ContentType 可以组成一个资源流。例如，PROJECT 和 CLASSES，表示了主项目中java 编译成的 class 组成的一个资源流。再如，SUB_PROJECTS 和 CLASSES ，表示的是本地子项目中的 java 编译成的 class 组成的一个资源流。Transform 用来处理和转换这些流。 查看我们的代码中指定的域与类型，表示我们处理的是整个工程的 java 编译成的 class 文件。 接下来，我们来实现一个实例，自定义一个 Transform，这个 Transform 的作用是可以给所有父类是 androidx.appcompat.app.AppCompatActivity的类的 onCreate 方法都加入一个 log 语句。比如，原来的代码是这样： 12345678class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; &#125; 改变 class 之后应该是这样： 123456789class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; Log.e("log_inject", "onCreate") super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; &#125; 废话不多说，我们直接进入正题，由于 Transform 的主要内容都在 com.aprz.log.LogsTransform#transform 方法里面，我们就直接说这个方法： com.aprz.log.LogsTransform#transform 12345678910111213141516171819202122232425262728293031@Overridevoid transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) // inputs 包含了 jar 包和目录。 // 子 module 的 java 文件在编译过程中也会生成一个 jar 包然后编译到主工程中。 transformInvocation.inputs.each &#123; input -&gt; // 遍历目录 // 文件夹里面包含的是我们手写的类以及R.class、BuildConfig.class以及R$XXX.class等 input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt; directoryInput.file.eachFileRecurse &#123; File file -&gt; if (checkFileName(file.name)) &#123; injectClassFile(file) &#125; &#125; copyDirectory(directoryInput, transformInvocation.outputProvider) &#125; // 遍历 jar，我们不需要对 jar 进行处理，所以直接跳过 // 但是后面的 transform 可能需要处理，所以需要从输入流原封不动的写到输出流 input.jarInputs.each &#123; jarInput -&gt; copyJar(jarInput, transformInvocation.outputProvider) &#125; &#125;&#125; 需要注意的是，inputs 分为两种类型的资源，一种是目录（目录里面都是生成的 class 文件），一种是 jar 包，它们需要分开遍历。由于我们只需要要处理目录，所以只针对目录讲解。 首先，我们对目录集合进行遍历，在对集合中的每个目录进行递归处理，最终到每个 class 文件，拿到这个 class 文件，我们就可以使用 ASM 修改这个 class 文件了。 com.aprz.log.LogsTransform#injectClassFile 123456789101112static void injectClassFile(File file) &#123; ClassReader classReader = new ClassReader(file.bytes) ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) ClassVisitor cv = new LogClassVisitor(classWriter) // 访问者模式 classReader.accept(cv, ClassReader.EXPAND_FRAMES) byte[] code = classWriter.toByteArray() FileOutputStream fos = new FileOutputStream( file.parentFile.absolutePath + File.separator + file.name) fos.write(code) fos.close()&#125; 从这里开始，就是 ASM 的使用了。 ASM 的使用这里不介绍 API 的使用了，网上很多，还有官方文档，哪个都比我写得好。 这里介绍一下 ASM 的设计思想。 从上面的代码可以看到，ClassReader 的 accept 方法中传进来了一个参数ClassVisitor。在内部，ClassVisitor会不断的读取ClassReader的二进制byte[]，然后在解析后通过参数classVisitor的抽象visitXXX方法将属性全部转发出去，将其中的visitXXX方法按顺序抽离出来就是： 123456789classVisitor.visit(readInt(items[1] - 7), access, name, signature,superClass, interfaces);classVisitor.visitSource(sourceFile, sourceDebug);classVisitor.visitOuterClass(enclosingOwner, enclosingName,enclosingDesc);classVisitor.visitTypeAnnotation(context.typeRef,context.typePath, readUTF8(v, c);classVisitor.visitAttribute(attributes);classVisitor.visitInnerClass(readClass(v, c),readClass(v + 2, c), readUTF8(v + 4, c),readUnsignedShort(v + 6));classVisitor.visitField(access, name, desc,signature, value);classVisitor.visitMethod(context.access,context.name, context.desc, signature, exceptions);classVisitor.visitEnd(); 这里有很多 visit 方法，但是与真正的 class 文件的处理有关的，只有几个，比如：visitMethod，visitField 等。 这些 visit 方法，会创建一个相对应的 Writer 对象。 Writer 对象是什么呢？？？Writer 对象是 Visitor 的一个实现类。 ASM 在读取一个 class 文件的时候，会创建出一个 ClassWriter 对象，但是它不会把对元素（字段，方法，注解）的访问放到 ClassWriter 中，而是使用 访问者模式，将对这个元素的访问放到了 ClassVisitor 中。为何这样做，可以去看访问者模式。 当 ClassWriter 处理 class 文件的字节码的时候，比如遇到了一个方法，就会调用 ClassVisitor 的 visitMethod 方法。而 visitor 的实现实际上是 writer 类，所以会调用 writer 类的对应方法。这些方法会将字节码对应的部分给保存起来。而最后 classWriter.toByteArray 就会将所有的 writer 保存的字节码全部合并在一起，生成一个新的 class 文件。 如果，我们自定义一个 MethodVisitor 就可以改变字节码。 这里，我们覆盖 ClassVisitor 的 visitMethod 方法： com.aprz.log.asm.LogClassVisitor#visitMethod 12345678910111213141516171819@OverrideMethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; if (!checkSuperClass(this.superName)) &#123; return super.visitMethod(access, name, desc, signature, exceptions) &#125; // 由于是一个例子，我们就只处理 onCreate 方法了，想要深入应该去研究一下一个正规的开源项目 // 我的 demo 是 kotlin，tools里面有工具可以直接查看字节码，就非常方便 if ('onCreate(Landroid/os/Bundle;)V' == (name + desc)) &#123; println "log &gt;&gt;&gt; method name = $&#123;name + desc&#125;" MethodVisitor methodVisitor = this.cv.visitMethod(access, name, desc, signature, exceptions) return new LogMethodVisitor(methodVisitor, name) &#125; return super.visitMethod(access, name, desc, signature, exceptions)&#125; 可以看到，我们返回了我们自己定义的 LogMethodVisitor，将原来的 MethodVisitor 作为成员变量保存起来 。当 MethodVisitor 的相关方法被调用的时候，实际上会调用 LogMethodVisitor 的方法。这样，我们就可以搞事情了。比如：在刚进入方法的时候，会触发 visitCode 的调用： com.aprz.log.asm.LogMethodVisitor#visitCode 1234567891011121314151617181920/** * L2 * LINENUMBER 13 L2 * LDC "log_inject" * LDC "onCreate" * INVOKESTATIC android/util/Log.e (Ljava/lang/String;Ljava/lang/String;)I * POP */@Overridevoid visitCode() &#123; super.visitCode() // 在方法之前插入 Log.e("", "") // 这两个是参数 this.mv.visitLdcInsn('log_inject') this.mv.visitLdcInsn(this.name) this.mv.visitMethodInsn(Opcodes.INVOKESTATIC, 'android/util/Log', 'e', '(Ljava/lang/String;Ljava/lang/String;)I', false) // 这里的用法有点奇怪，还需要研究一下 // visitXXX 实际上会触发 MethodWriter 的方法，这些方法会将我们想要写入的字节码存放起来 // 最后统一的写入到输出的 class 文件中&#125; 在这里，我们就可以插入我们的字节码了。 到这里，东西就都介绍完毕了，只说了皮毛，要深入还是要看一个真正的项目才行。 demoTransform-API-demo]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[在 【Android V1 V2 签名机制】里面分析了美团在 V1 签名机制下的多渠道打包，但是没有分析 V2 机制的多渠道打包。由于 V2 机制下多渠道打包涉及到 APK 结构，所以这里专门新起一篇。由于 APK 也是一个压缩包，所以我们先来看一下 ZIP 文件的结构。ZIP 文件结构一个普通的 ZIP 文件结构如下： 1[文件头+文件数据+数据描述符]&#123;此处可重复n次&#125; + 中央目录 + 中央目录结束标识 我们对着这个图看一下，apk在签名前和一个普通的 zip 文件的结构一样，中央目录 与 中央目录结束标识 对应后面两块。 ZIP 文件分3块，每块内容大致如下： 123数据区（Contents of ZIP entries）：存储文件压缩内容中央目录区（Central Directory Header）：存储zip文件里面包含的所有目录中央目录结束标识（End of Central Directory Record：ECDR）：存储zip文件的整体信息 其中，中央目录结束标识的结构是我们最需要搞清楚的。 我们拿一个例子来分析 中央目录结束标识 里面都有什么东西。 新建一个名为123.txt的文本文件，内容为123456，将123.txt压缩为123.zip 使用notepad++打开该文件，如下图： 有8根红线，每根红线对应的数据意义如下： 地址 字节数 字节内容 意义 00000062 4 50 4b 05 06 中央目录结束标记（0x06054b50，固定内容） 00000084 2 00 00 当前磁盘编号 00000088 2 00 00 中央目录开始位置的磁盘编号 0000008a 2 01 00 该磁盘上所记录的核心目录数量 0000008c 2 01 00 中央目录结构总数 0000008e 4 59 00 00 00 中央目录的大小 00000090 4 2b 00 00 00 中央目录开始位置相对于archive开始的位移 00000094 2 00 00 注释长度 中央目录结束标识 这一块的数据长度是不固定的，因为注释的长度不固定。 但是 中央目录结束标识 的起始位置的内容是固定的，我们就可以从 ZIP 文件的最后往前遍历，直到找到 4 个连续直接的内容与 0x06054b50 相等。找到了起始地址，从这个起始地址往后偏移 20 个字节，我们就知道了注释的长度。 我们看一下 walle 的代码吧： 123456789101112131415161718192021222324252627282930313233for (int expectedCommentLength = 0; expectedCommentLength &lt;= maxCommentLength; expectedCommentLength++) &#123; // 这里假设 注释的长度为 expectedCommentLength，从 0 开始一个一个试 // 我们从文件的倒数第 22 个字节开始往前遍历 final long eocdStartPos = eocdWithEmptyCommentStartPosition - expectedCommentLength; // 分配4个字节 final ByteBuffer byteBuffer = ByteBuffer.allocate(4); // 定位到倒数第22、23、24...个字节的位置 fileChannel.position(eocdStartPos); // 读取4个字节到buffer中 fileChannel.read(byteBuffer); // 将字节排序，因为 zip 文件的字节排序与我们阅读的顺序不一样 // 比如：0X0ff8，在 zip 文件中是这样存放的：f8 0f byteBuffer.order(ByteOrder.LITTLE_ENDIAN); // 判断该 4 个字节的值是不是 0x06054b50 if (byteBuffer.getInt(0) == ZIP_EOCD_REC_SIG) &#123; // 分配2个字节 final ByteBuffer commentLengthByteBuffer = ByteBuffer.allocate(2); // 往前 22 个字节，定位到存放 注释长度 的字节处 fileChannel.position(eocdStartPos + ZIP_EOCD_COMMENT_LENGTH_FIELD_OFFSET); fileChannel.read(commentLengthByteBuffer); commentLengthByteBuffer.order(ByteOrder.LITTLE_ENDIAN); // 获取 final int actualCommentLength = commentLengthByteBuffer.getShort(0); if (actualCommentLength == expectedCommentLength) &#123; return actualCommentLength; &#125; &#125;&#125; 拿到注释长度之后，我们就可以准确的定位到记录“中央目录开始位置”的字节处（其实上面如果不往后20个字节，只往后16个字节，就可以直接拿到，但是这里为了分析源码）。 再看代码： 123456 final ByteBuffer zipCentralDirectoryStart = ByteBuffer.allocate(4); zipCentralDirectoryStart.order(ByteOrder.LITTLE_ENDIAN);// 6 = 2 (Comment length) + 4 (Offset of start of central directory, relative to start of archive) fileChannel.position(fileChannel.size() - commentLength - 6); fileChannel.read(zipCentralDirectoryStart); final long centralDirStartOffset = zipCentralDirectoryStart.getInt(0); 这都不用说了，很清晰，ZIP 文件的长度 - 注释的长度 - 存放注释长度的2个字节 - 存放中央目录偏移位置的4个字节，就是存放中央目录偏移位置的字节起始位置了。 我们知道，apk 签名之后是多了一块叫做 ‘APK Signing Block’ 的东西，这块内容正好在中央目录的前面。而上面我们又知道了中央目录的偏移位置，所以只要我们知道 ‘APK Signing Block’ 的大小，我们就能将 ‘APK Signing Block’ 这一块里面的所有字节都取出来。 要想知道 ‘APK Signing Block’ 的大小，我们还是要了解 ‘APK Signing Block’ 的结构： 偏移 字节数 描述 @+0 （从前往后第0个字节） 8 这个 block 的长度 （不包括这8个字节） @+8 （从前往后第8个字节） n 一组 ID-VALUE @-24 （从后往前第24个字节） 8 这个 block 的长度（与上面的值一样） @-16 （从后往前第16个字节） 16 魔数 “APK Sig Block 42” 可以看出，APK Signing Block 分为4小块，第1、3块都储存的是 APK Signing Block 的大小。第 4 块是固定的。第 3块是不固定的，我们的渠道信息就是写在这个键值对区域的。 我们知道了中央目录的偏移位置，知道了中央目录的偏移位置前是一个固定的魔数，魔数前就是 APK Signing Block 的大小，这样，我们就可以拿到整个 APK Signing Block 块里面的所有东西了。 看看代码： 12345678910111213141516171819// 中央目录偏移位置往前24个字节，就是存 APK Signing Block 的长度的字节起始位置fileChannel.position(centralDirOffset - 24);// 分配24个字节空间final ByteBuffer footer = ByteBuffer.allocate(24);fileChannel.read(footer);// 读取前8个字节，就是 APK Signing Block 的长度final long apkSigBlockSizeInFooter = footer.getLong(0);// 拿到储存的 APK Signing Block 的长度，还要加上 8 个字节，才是整个 APK Signing Block 的长度final int totalSize = (int) (apkSigBlockSizeInFooter + 8);// 计算 APK Signing Block 的起始偏移位置final long apkSigBlockOffset = centralDirOffset - totalSize;// 定位到 APK Signing Block 的起始偏移位置fileChannel.position(apkSigBlockOffset);final ByteBuffer apkSigBlock = ByteBuffer.allocate(totalSize);// 读取整个 APK Signing Block 块fileChannel.read(apkSigBlock);apkSigBlock.order(ByteOrder.LITTLE_ENDIAN); 拿到了 APK Signing Block 块，我们就可以拿到里面 ID-VALUE 键值对了，由于我们在打包时放入了渠道名，现在我们就可以取出来。 我们先看看一个 ID-VALUE 键值对的结构： 字节数 描述 8 该 ID-VALUE 的长度（不包括自己） 4 ID n - 4 VALUE 看看代码： 123456789101112131415161718192021// 去掉前8与后24个字节final ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24);int entryCount = 0;while (pairs.hasRemaining()) &#123; entryCount++; // 取当前这个 ID-VALUE 对的长度 final long lenLong = pairs.getLong(); final int len = (int) lenLong; // 下一个 ID-VALUE 对的起始位置 final int nextEntryPos = pairs.position() + len; // 取 ID 的值 final int id = pairs.getInt(); // 取 VALUE 的值 idValues.put(id, getByteBuffer(pairs, len - 4)); pairs.position(nextEntryPos);&#125; 这里还需要判断一下，是否有V2签名标识： https://source.android.com/security/apksigning/v2.html#apk-signing-block 根据官方文档的描述，V2签名信息储存在 ID 为 0x7109871a 的键值对中。 我们可以判断一下： 1234567// Find the APK Signature Scheme v2 Block inside the APK Signing Block.final ByteBuffer apkSignatureSchemeV2Block = originIdValues.get(ApkUtil.APK_SIGNATURE_SCHEME_V2_BLOCK_ID);if (apkSignatureSchemeV2Block == null) &#123; throw new IOException( "No APK Signature Scheme v2 block in APK Signing Block");&#125; 到此为止，我们就完整了分析了多渠道相关的知识，现在我们看看 walle 是如何注入 ID-VALUE 渠道信息的，因为注入信息之后，必然需要更新相关的地址值，否则就错乱了。 我们可以回想一下，需要更新哪些值。 当我们写完渠道信息之后，中央目录起始偏移肯定变了，所以需要更新储存这个值的字节。 APK Signing Block 块的大小也变了，也需要更新，这有两个地方存，所以一共需要更新3个地方。 但是由于我们有了 APK Signing Block 的所有字节信息，所以我们可以直接覆盖原来的 APK Signing Block 块，最后更新 中央目录起始偏移 位置就好了。 12345678910111213141516171819202122232425// 将中央目录与中央目录结尾标识的所有字节存起来centralDirBytes = new byte[(int) (fileChannel.size() - centralDirStartOffset)];fIn.read(centralDirBytes);// 写更新之后的 APK Signing BlockfileChannel.position(apkSigningBlockOffset);final long length = apkSigningBlock.writeApkSigningBlock(fIn);// 写中央目录与中央目录结尾标识fIn.write(centralDirBytes);// 更新长度fIn.setLength(fIn.getFilePointer());// 定位到储存中央目录结束标志的字节位置fIn.seek(fileChannel.size() - commentLength - 6);// 更新该值// 6 = 2(Comment length) + 4 (Offset of start of central directory, relative to start of archive)final ByteBuffer temp = ByteBuffer.allocate(4);temp.order(ByteOrder.LITTLE_ENDIAN);temp.putInt((int) (centralDirStartOffset + length + 8 - (centralDirStartOffset - apkSigningBlockOffset)));// 8 = size of block in bytes (excluding this field) (uint64)temp.flip();fIn.write(temp.array()); 好了， walle 的核心代码就分析的差不多了，多渠道打包的原理也讲的差不多了。 手动的分析一个apk随便取一个 apk，用 notepad++ 打开，定位到文件末尾： 可以看到，确实是有一个固定的标识的。 然后我们找到 中央目录的偏移位置： 中央目录结束标记 0x06054b50 的后面 16 个就是中央目录的偏移地址了。 偏移位置为 74 ee 50 02，但是我们知道这个地址是反过来的，所以正确的地址为 0x0250ee74。 我们搜索这个地址： 在这个地址的前面，应该是也是固定的字节，为魔数”APK Sig Block 42”，将它换成字节，是 41 50 4B 20 53 69 67 20 42 6C 6F 63 6B 20 34 32，我们对比一下： 果然是一摸一样的。 魔数前面8个字节存放的是 APK Signing Block 的长度，我们往前找8个字节看看： 看来，APK Signing Block 的长度为 0x0ff8。由于中央目录偏移地址为 0x025ee74，减去这个地址得到0x0250de7c： 再搜索这个地址： 可以看到，这个地址往前8个字节也是储存的 APK Signing Block 的长度，这样就说明，我们分析的过程是正确的。所以 APK Signing Block 的所有字节如下： 图中 1 和 2 之间的内容，就是 ID-VALUE 键值对了。由于我分析的这个 apk 没有写入渠道信息，所以我找了一个网上的图片： 这个里面，写入了渠道信息： ID 为：0x71777777 渠道信息为：{&quot;channel&quot;:&quot;meituan&quot;} 我们直接在 ID-VALUE 里面搜索 0x71777777，就可以得到上面的图了。 长度：00 00 00 00 00 00 00 19=25 （长度是25字节） ID：71 77 77 77 （我们自定义的ID） 存入内容： {“channel”:”meituan”} 21字节 21+4=25，刚好等于长度的值 至此，我们就成功的通过分析APK的二进制数据，得到了walle注入的数据。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合编译器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E9%AB%98%E7%BA%A7%2F%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[我们先来看一看编译器的发展历程，顺便也看一下虚拟机（与它有关系）的。虚拟机的变迁：编译器的变迁：我们知道，Java是有自己的虚拟机的，那么Google为何放着现有的JVM不用，而是设计一个新的虚拟机？？？在解答这问题之前，我们先来看看 Dalvik 与 JVM 的不同之处吧。 JVM Dalvik 基于堆栈的Java指令(1个字节) 基于寄存器的Dalvik指令(2、4或者6个字节) 执行同样的功能， Java虚拟机需要更多的指令（主要是load和store指令），需要更多指令意味着要多占用CPU的时间。 执行同样的功能，Dalvik虚拟机需要更多的指令空间，需要更多指令空间意味着指令缓冲（i-cache）更易失效 使用class格式的类文件 使用dex（Dalvik Executable）格式的类文件 从这个表格中，能看出为什么不？ 一个dex文件可以包含若干个类，而一个class文件只包括一个类。由于一个dex文件可以包含若干个类，因此它可以将各个类中重复的字符串只保存一次，从而节省了空间，适合在内存有限的移动设备使用。提前调整好字节序和字对齐方式，使得它们更适合于本地机器，以便提高指令执行速度。 Dalvik虽然设计精巧，但是每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高，会让用户经常感到系统卡顿。 为了解决这个的问题，Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。 但是它也有自己的问题： 使用JIT也不一定加快执行速度，如果大部分代码的执行次数很少，那么编译花费的时间不一定少于执行dex的时间。所以JIT不对所有dex代码进行编译，而是只编译执行次数较多的dex为本地机器码。 dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要进行JIT编译。 对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间。 JIT 虽然在某种程度上弥补了 Dalvik 的不足，但是仍然浪费了不少性能，所以从 Android 5.0 开始，就摒弃了 Dalvik 虚拟机，开发出了 ART 虚拟机。 与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，直接使用本地机器码运行，因此运行速度提高。 ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%。由于有了一个转码的过程，所以应用安装时间难免会延长。 安装的时候，字节码会预先编译成机器码就是由 AOT 编译器执行的，对比JIT就很好理解了，一个是运行时编译，一个是安装时编译。 编译好的文件是OAT文件，该文件本质上是一个ELF文件，这里与dex(Odex)文件最大的区别是OAT文件不再是字节码文件，而是一个可执行文件，可以更底层的与硬件接触，运行时也省去了预编译和转译的时间。 ART + AOT 虽然解决了 Dalvik + JIT 的不足，但是它也带来了新的问题： 更多需要解决的问题： 有一张图，我们应该会非常熟悉，大多数人应该都碰到过这样的场景： 这就是由于使用 ART + AOT 导致的。由于系统更新时，所有的应用都需要重新安装，这会导致所有的应用都需要在重新编译一遍，导致更新时间非常久。 那么，应该如何去解决这些问题呢？ 首先，我们思考一个问题：用户会使用App里面的每个功能吗？ 绝大多数用户只会使用App的部分功能。只有被用户频繁使用的功能（这个功能背后的代码）才值得被编译成本地代码。 所以，我们就可以不用预编译整个app，这样做： 在 JIT 阶段，我们可以先找出被频繁执行的代码，然后在使用预编译来优化和加速这些被频繁执行的代码，从而避免编译那些很少被用户使用的代码带来的额外消耗（储存空间，编译行为等等）。 当用户安装App的时候，不再进行预编译了，这个和KitKat的时候一样。当用户安装之后立即使用该App，仍然使用JIT编译模式来执行App，但是同时会生成一个离线的 profile 文件，这个 profile 文件会记录JIT运行时的所有 hot code（热点代码）信息。然后在未来的某个时间点，Android Framework 会基于这个 profile 文件来启动一个预编译行为，它只便于记录的热点代码。 在 JIT 阶段，它带来的好处： 快速安装 系统快速更新 在 AOT 阶段，它带来的好处： 快速启动，更好的运行性能 低消耗：CPU，储存空间，电量… 可以看到，它们 JIT 与 AOT 互相弥补了自己的不足。 获取有的人会觉得，JIT 是即时编译会比较慢，但是真的是这样吗？下面看一组数据测试： AOT与JIT在Micro Benchmark测试中各有优劣，所以预编译还不一定快。 下面贴出几组使用混合编译后的数据： 提升还是非常明显的。]]></content>
      <tags>
        <tag>Android-高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[productFlavors与buildTypes]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FGradle%2FproductFlavors%E4%B8%8EbuildTypes%2F</url>
    <content type="text"><![CDATA[modify at 2019-8-26 节操社要祸祸“食戟之灵”了，我TM…口吐芬芳 之所以会想到要写这个，是发现了很多以前没注意过的东西，记录一下。 起因是由于一个紧急版本，然后我需要配置一下一个新增的H5地址，发现在配置的过程中非常的麻烦。 config.gradle 中添加地址 app / build.gradle 添加 manifestPlaceholders ，为不同的 productFlavors 配置不同的地址 AndroidManifest.xml 中添加 meta-data Java 中添加Key 这是在是太麻烦了，很容易哪一步就忘记了。于是问了一下，为啥要写在 AndroidManifest.xml 里面？然后给出的答案是为了安全！ 嗯，无稽之谈，于是我就收集了一些证据： 将 debug，release，加固后的release包都拖到 AS 中，打开 AndroidManifest.xml，显然里面的每一根毛都看的清清楚楚 使用压缩文件解压apk包，用notepad++等工具打开，显示是二进制 显然用文本编辑器打开，看不出什么，就是所谓的“安全”了。当是这种东西就相当于序列化一个 Java 对象，你看不出什么来，不代表别人看不出来，写一个工具就好了，里面的二进制数据都是有规则的，不然怎么读取里面的东西。 好了，有了这个作为前提，由于我们的包是加固的，所以放在 Java 里面比 AndroidManifest.xml 要安全很多，至少你要懂脱壳（这里不讨论别的了）。于是我就想将地址放在 BuildConfig 里面，减少配置的步骤，我使用一个单独的 gradle 文件配置一下，然后每个 variant 取相应的地址就好了。（虽然后来才发现，需要在base库里面生成才能有用，但是在学习的过程中还是很有收获的。） 比如，我在 urls.gradle 中这样写： 1234567891011121314151617ext &#123; urls = [ HOME: [ DEBUG_HOST : "https://www.debug.com", RELEASE_HOST: "https://www.release.com", PATHS : [ a: '/1', b: '/2', c: '/3', d: '/4' ] ] ]&#125; 然后在BuildConfig里面生成这样的东西： 1234public static final String HOME_a = "https://www.debug.com/1";public static final String HOME_b = "https://www.debug.com/2";public static final String HOME_c = "https://www.debug.com/3";public static final String HOME_d = "https://www.debug.com/4"; 当我将 Build Variant 切换为 release 的时候，BuildConfig 会变为： 1234public static final String HOME_a = "https://www.release.com/1";public static final String HOME_b = "https://www.release.com/2";public static final String HOME_c = "https://www.release.com/3";public static final String HOME_d = "https://www.release.com/4"; 那么，如何才能做到上面的效果呢？我们先从 build type 说起。 BuildType首先，我们需要知道的是，当我们创建一个 module 的时候，AS 会自动的为我们创建 debug 与 release 这两个构建类型，不管我们写没写，就算你把它给删了，仍然会有。从源码里面没有找到对应的地方，可能是在插件的代码里面，不管这个，我们继续。 我们点击 release 进入源码，发现它是一个 com.android.build.gradle.internal.dsl.BuildType 对象。 里面会有很多我们熟悉的方法，比如： 1234567@NonNullpublic BuildType proguardFiles(@NonNull Object... files) &#123; checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, "proguardFiles"); for (Object file : files) &#123; proguardFile(file); &#125; return this; 这个货，就对应着我们配置的混淆文件。如下： 1proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' 由于上面的方法是一个可变参数作为参数，所以我们可以在 proguardFiles后面，添加多个 proguard 文件。 除了 proguardFiles，还有其他的很多属性可以配置： 123456789minifyEnabled falseapplicationIdSuffix ".debug"debuggable truebuildConfigField "boolean", "DEBUG", "true"// release版的签名signingConfig signingConfigs.app// 还有一个 initWith 属性initWith debug 说一下这个 initWith 属性，比如上面我们指定了 debug，那么就是说将 debug 里面的所有属性都继承过来，算是一种复用。 再说 product flavors。 Product Flavorsbuild type，我们比较好理解，debug 用于开发，release 用于发布，一般这两个就够用了。那么 product flavors 又是什么鬼呢？可以这样想，幸平创真在创造一道新菜的时候，在创造的过程中，会慢慢的调配各种配料的比例，这中间烧的菜就是 debug，当创造完成之后可以端给客人吃了，烧的菜就是 release。但是经过观察后，幸平创真发现，不同的人口味不同，然后他就又为不同的人调配了不同口味的蘸料，这些不同口味的蘸料就是 product flavors。 我们看看配置代码： 123456789101112131415productFlavors &#123; demo &#123; // productFlavors 需要指定 dimension // 如果你的 flavorDimensions 只有一个值， // 那么可以不用指定，会自动赋值，但是一定要声明 flavorDimensions dimension "version" applicationIdSuffix ".demo" versionNameSuffix "-demo" &#125; full &#123; dimension "version" applicationIdSuffix ".full" versionNameSuffix "-full" &#125;&#125; 配置好了 product flavors 之后，你就可以打多个不同的包了，包的个数为 【build type 的个数】x 【product flavors 的个数】，相当于交叉的集合： demoDebug demoRelease fullDebug fullRelease 这个很好理解，拿煎饼举例： 开发版鸡蛋煎饼 完成版鸡蛋煎饼 开发版培根煎饼 完成版培根煎饼 下面再说说 flavorDimensions 的作用，不知道从哪个版本开始，productFlavors 需要配合 flavorDimensions 使用才行。一般的，没有特殊需求的话，buildTypes加上 productFlavors 已经完全够用了，flavorDimensions 是用于这样的需求的： 还是拿煎饼举例，有的人喜欢鸡蛋煎饼，有的人喜欢培根煎饼，但是有的人都喜欢，那怎么办呢？总不能买两个吧，所以好的办法是做一个加鸡蛋和培根的煎饼。这个就是 flavorDimensions 的作用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960android &#123; ... buildTypes &#123; debug &#123;...&#125; release &#123;...&#125; &#125; // Specifies the flavor dimensions you want to use. The order in which you // list each dimension determines its priority, from highest to lowest, // when Gradle merges variant sources and configurations. You must assign // each product flavor you configure to one of the flavor dimensions. flavorDimensions "api", "mode" productFlavors &#123; demo &#123; // Assigns this product flavor to the "mode" flavor dimension. dimension "mode" ... &#125; full &#123; dimension "mode" ... &#125; // Configurations in the "api" product flavors override those in "mode" // flavors and the defaultConfig block. Gradle determines the priority // between flavor dimensions based on the order in which they appear next // to the flavorDimensions property above--the first dimension has a higher // priority than the second, and so on. minApi24 &#123; dimension "api" minSdkVersion 24 // To ensure the target device receives the version of the app with // the highest compatible API level, assign version codes in increasing // value with API level. To learn more about assigning version codes to // support app updates and uploading to Google Play, read Multiple APK Support versionCode 30000 + android.defaultConfig.versionCode versionNameSuffix "-minApi24" ... &#125; minApi23 &#123; dimension "api" minSdkVersion 23 versionCode 20000 + android.defaultConfig.versionCode versionNameSuffix "-minApi23" ... &#125; minApi21 &#123; dimension "api" minSdkVersion 21 versionCode 10000 + android.defaultConfig.versionCode versionNameSuffix "-minApi21" ... &#125; &#125;&#125;... 这样我们就可以打更多的包了： Build variant: [minApi24, minApi23, minApi21][Demo, Full][Debug, Release] Corresponding APK: app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk flavorDimensions 有两个值，一个值有 3 个对应的 productFlavor，一个值有 2 个对应的 productFlavor。buildTypes 有 2 个 ，所以共有 3 x 2 x 2 = 12 个构建变体。 我们知道，productFlavors 相当于蘸料，作为一个蘸料，它肯定要与主食材配合，互相激发各自的味道才行，那么 productFlavors是如何影响打包内容的呢？我们介绍一下 sourceSet。 SourceSets中的属性，可以指定哪些文件夹下的源文件、资源要被编译，哪些源文件要被排除。 从我们的工程目录可以看出来，com.android.application插件默认就给我们定了3个 sourceSet： main androidTest test 默认情况下，main里面的东西大概是这样的： 123456main &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java.srcDirs = ['src/main/java'] res.srcDirs = ['src/main/res'] assets.srcDirs = ['src/main/assets']&#125; 可以看到这都是我们熟悉的目录，既然 sourceSet 是可以配置的，就说明只要我们有需求，我们的 Java 文件就可以写到其他地方，而不是只能在 src/main/java 中。比如我们再添加一个 java 目录： 123456main &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java.srcDirs = ['src/main/java', 'src/main/java2'] res.srcDirs = ['src/main/res'] assets.srcDirs = ['src/main/assets']&#125; 这样，我们就有了两个 java 目录，用于存放不同作用的文件集合。这个功能配合 productFlavors 管理不同作用版本的源代码就很方便了。比如，我出一个 free 版的应用，功能简单，代码都放在 java 里面，我再出一个 pro 版的，高级功能，代码放在 java2 里面，打包的时候将 java2 与 java 都打进去，就是一个完整版的。 我们的 src 是存放所有源代码与资源的目录，默认它有3个子目录，但是我们也可以添加自己的目录。比如： src/demoDebug/ 这个就是 productFlavors 为 demo，buildTypes为 debug 的构建变体的目录。 src/debug/ 这个是 buildTypes为 debug 的构建变体的目录。 当我们构建的时候，会根据选择的构建类型来合并某些目录，比如构建 demoDemo，会合并 main + debug + debugDemo，合并的时候会有优先级的，构建变体越具体的优先级越高，demoDebug 就比 debug 要具体，所以 demoDebug 的优先级高，而 debug 又比 mian 高。资源会替换，但是 Java 类会报类重复的错。 当然 sourceSet 还有更多的用法，这里就不深入了。 还有一个很重要的知识需要补充，因为我最早是认为为不同 build type 产生不同的 BuildConfig 文件内容是不可行的，因为我们的 BuildConfig 需要在APP结构的最底层生成，这样才能被其他组件所引用到。而我是一直认为 library 工程只能打 release 包的，所以它只能生成 release 版的 BuilConfig 文件。直到我看到了官方文档的描述： Android plugin 3.0.0 and higher include a new dependency mechanism that automatically matches variants when consuming a library. 也就是说从 3.0.0 的插件开始，就可以自动匹配了，而不是一直打 release 版的了，Nice~ 另外说一句，如果 library 没有匹配的，可以使用 matchingFallbacks 指定备用匹配的。 123456789101112131415// In the app's build.gradle file.android &#123; buildTypes &#123; debug &#123;&#125; release &#123;&#125; staging &#123; // Specifies a sorted list of fallback build types that the // plugin should try to use when a dependency does not include a // "staging" build type. You may specify as many fallbacks as you // like, and the plugin selects the first build type that's // available in the dependency. matchingFallbacks = ['debug', 'qa', 'release'] &#125; &#125;&#125; 下面我们正式进入主题，实现我们所说的功能，有了上面的基础，我们缺的就只是 gradle api 的熟悉程度了，这个没什么办法，只能自己查资料了。 首先，根据官方文档的例子，我们知道，android 为我们提供了一个叫做 variantFilter的东西，就是一个过滤器，显然是用来过滤哪些我们不想打的包： 1234567891011121314151617181920212223android &#123; ... buildTypes &#123;...&#125; flavorDimensions "api", "mode" productFlavors &#123; demo &#123;...&#125; full &#123;...&#125; minApi24 &#123;...&#125; minApi23 &#123;...&#125; minApi21 &#123;...&#125; &#125; variantFilter &#123; variant -&gt; def names = variant.flavors*.name // To check for a certain build type, use variant.buildType.name == "&lt;buildType&gt;" if (names.contains("minApi21") &amp;&amp; names.contains("demo")) &#123; // Gradle ignores any variants that satisfy the conditions above. setIgnore(true) &#125; &#125;&#125;... 嗯，不符合我们的要求，但是它给了我们一个提示，既然有过滤器，那么应该也有一个遍历所有构建变体的方法，我们在遍历的时候，去读取 urls.gradle 里面的 map，然后动态的添加进去不就好了吗！！ 经过搜索之后，我就发现了这个东西： 123456789101112131415161718applicationVariants.all &#123; variant -&gt; def buildType = getBuildType() rootProject.ext.urls.each &#123; entry -&gt; entry.value['PATHS'].each &#123; path -&gt; def key = "$&#123;entry.key&#125;_$&#123;path.key&#125;" def value if (getFlavorName() == 'full' &amp;&amp; buildType.name == 'release') &#123; value = "$&#123;entry.value['PRODUCT_HOST']&#125;$&#123;path.value&#125;" &#125; else &#123; value = "$&#123;entry.value['SIT_HOST']&#125;$&#123;path.value&#125;" &#125; variant.buildConfigField "String", key, "\"$&#123;value&#125;\"" &#125; &#125;&#125; applicationVariants 里面有所有需要打包的变体，我们遍历一下，既可以获取变体对象，然后动态的添加我们想要添加的 buildConfigField。 需要注意的是，我最开始以为 com.android.build.gradle.api.BaseVariant#getBuildType返回的是com.android.build.gradle.internal.dsl.BuildType ，但是没想到返回的是com.android.builder.model.BuildType，稍不注意就搞错了。 com.android.builder.model.BuildType里面是无法添加 buildConfigField 的。]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-并发介绍]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0002-%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[在远古时代，我们的计算机只有一个 CPU，而且一次只能运行一个程序。接着多任务系统被引入，单个 CPU 可以同时运行多个程序了，虽然并不是真正意义上的“同一时间点”。它是这样工作的：多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。 从多任务系统开始，程序设计者就需要考虑该程序不能独占所有的CPU时间、所有的内存和其他计算机资源，因为别的程序也要运行。 再接着，多线程被引入：使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。但是需要注意的是，虽然名义上叫多线程，因为只有一个CPU，所以两个线程从来不会得到真正的并行执行。 （之所以能够这么设计，是因为 CPU 实在是太快了，看过 三体 么，里面的智子只有一个，但是却监控了整个地球，就是因为它跑的太快了，让人感觉到它无处不在，同样的，CPU 在切换线程的时候，我们根本就感觉不到） 再接着，多核 CPU 出现了，意味着不同的线程能被不同的CPU核得到真正意义的并行执行。以前的程序可能会出现一些从未见过的问题：因为多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。 如果一个线程在读一个内存时，另一个线程正向该内存进行写操作，那进行读操作的那个线程将获得什么结果呢？是写操作之前旧的值？还是写操作成功之后的新值？或是一半新一半旧的值？或者，如果是两个线程同时写同一个内存，在操作完成后将会是什么结果呢？是第一个线程写入的值？还是第二个线程写入的值？还是两个线程写入的一个混合值？因此如没有合适的预防措施，任何结果都是可能的。而且这种行为的发生甚至不能预测，所以结果也是不确定性的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-引言]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0001-%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[这个系列为并发入门系列，有些东西不会深入介绍，主要是有一个对并发全局的掌握，有兴趣可以自行深入了解。 该系列参考文章为： http://tutorials.jenkov.com/java-concurrency/index.html]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CompletableFuture 的使用]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FCompletableFuture%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[遇到这样的一个实际问题：写一个任务控制器，支持添加多个任务异步执行，任务间可以设置依赖，没有依赖的任务并行，有依赖的串行。我刚开始一想，发现这个不是很简单么，写了包装类包装一下 Runnable，然后给它加一个添加依赖的功能不就好了么。后来发现没有我想的这么简单，首先循环依赖没有解决，这个问题这里就不深入了，就假设它没有循环依赖。 有了这个假设作为前提，我写出了第一版代码： 1234567891011121314151617181920212223class Task(private var name: String) : Runnable &#123; private var dependencies = mutableListOf&lt;Task&gt;() fun addDependency(vararg task: Task) &#123; dependencies.addAll(task) &#125; override fun run() &#123; // 让 dependencies 先运行 dependencies.forEach &#123; it.run() &#125; // 自己再运行 doSome() &#125; protected fun doSome() &#123; println(name) &#125;&#125; 当我，发给另一个小伙伴看的时候，他就说了，这个没有处理并发的执行啊，我一想，果然是这样。这里都没有多线程，全是一个线程。 问题的关键就是在于，需要将循环的那部分代码变为多线程代码。 本来，我想的是使用一些别的方法来做，比如，搞几个 future，等他们全部拿到结果了，在执行 doSome 的逻辑，但是这样写就有点麻烦了。突然，我想起了看《Java并发实践》这本书的时候，有提到过一个叫做 CompletableFuture 的类，它可以控制多个 Future，用在之类正好啊。 先看一下说明： future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的： 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第 一个的结果。 等待 Future 集合中的所有任务都完成。 仅等待 Future 集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同 一个值），并返回它的结果。 通过编程方式完成一个 Future 任务的执行（即以手工设定异步操作结果的方式）。 应对 Future 的完成事件（即当 Future 的完成事件发生时会收到通知，并能使用 Future 计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果） 新的 CompletableFuture 将使得这些成为可能。 来看一下，改版之后的代码吧： 1234567891011121314@RequiresApi(Build.VERSION_CODES.N) override fun run() &#123; // 让 dependencies 先运行 val cfs = dependencies.stream() .map &#123; CompletableFuture.runAsync(it) &#125; .collect(Collectors.toList()) val array = cfs.toTypedArray() CompletableFuture.allOf(*array).join() // 自己再运行 doSome() &#125; 这里就是不直接执行 it.run() 了，而是交给 CompletableFuture 里面的 pool 去执行，这样就是并发的了。 拿到所有结果之后，自己的代码才能执行，所以我们使用了 join 方法。 逻辑还是非常清晰的，对 Stream 不了解的就需要去学习一下了。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk 打包流程及扩展]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FApk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们开发一个应用，大概会有这些东西： 源代码 三方库 图片，so等一些资源 那我们从源文件说起，一个项目的源文件一般都是java文件，有需要还可能会有AIDL 文件。 Java文件会毫无疑问的被 javac 编译成 class 文件。 而 AIDL 文件经过 aidl 工具编译之后也会生成相应的 Java 代码，被编译成 class 文件。 还有一个不要忘记了，资源文件经过编译之后会生成 R.java 文件，它也会被编译成 class 文件。 这里扩展一下，我们知道 app 的 R.java 文件里面的变量都是 final 的，如下： 1public static final int main=0x7f030004; 而 lib 工程的 R.java 文件的变量却不是 final 的（从 ADT14 开始），如下： 1public static int main=0x7f030004; 那么这个又是什么原因呢？ 其实很简单，如果lib中 R.java 文件里面的变量是 final 的，那么会有两个问题： 编译速度：每次编译都需要将所有的资源与代码都编译一次，以免变量值产生碰撞 lib无法复用：如果生成的值是 final 的，那么这个lib给别人用的时候，值很可能与其他 lib 一样，导致问题 所以，为了避免上面的问题，就将变量改为非 final 的，从而 lib 中使用 id 的时候，就只能使用 if-else，而不是使用 switch。 好的，源代码我们处理完了，接下来就需要处理 class 文件了，class 文件除了上面生成的之外，还有我们引入的三方库，他们也是 class 文件。 dx工具会将这些 class 文件打包成 dex 文件。 主要工作是将Java字节码转成成Dalvik字节码、压缩常量池、消除冗余信息等。 我们回头在说说资源文件的处理。 Android中的资源文件有那些呢? res 文件夹下的资源，以及 assets 目录下的资源。 res 资源经过 aapt 的编译之后，会编译为二进制文件。 会为每个文件赋予一个resource id。对于该类资源的访问，应用层代码则是通过resource id进行访问的。 生成一个resource.arsc文件，resource.arsc文件相当于一个文件索引表，记录了很多跟资源相关的信息。 而 assets 的资源保持不动，所以我们只能通过名字来获取它。 资源处理完了，class文件也达成dex包了，接下来就要使用 apkBuilder 将编译后的资源、dex文件、so文件等等打成 apk 包了。 打好apk包了之后，需要签名，因为一旦APK文件生成，它必须被签名才能被安装在设备上。 签好名之后，还需要对apk文件进行对齐处理。那么对齐的作用是什么呢？让我们细细道来。 在开发人员的眼中，CPU是这样访问内存的： CPU 读取内存中的数据是一个一个读取的。 然而，实际上CPU是这样读取内存数据的： 它是一块一块的读取的，CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的，可以当成是内存读取粒度。 那么这样会导致啥问题呢？假设我们需要读取一个 int 值到寄存器，分两种情况讨论： 数据从地址0开始 数据从地址1开始 当该数据是从0字节开始时，很CPU只需读取内存一次即可把这4字节的数据完全读取到寄存器中。 当该数据是从1字节开始时，问题变的有些复杂，此时该int型数据不是位于内存读取边界上，这就是一类内存未对齐的数据。此时CPU先访问一次内存，读取0—3字节的数据进寄存器，并再次读取4—5字节的数据进寄存器，接着把0字节和6，7，8字节的数据剔除，最后合并1，2，3，4字节的数据进寄存器。对一个内存未对齐的数据进行了这么多额外的操作，大大降低了CPU性能。 最后贴一张Google官方为我们提供的详细的构建过程图： PS： AnnotationProcessor 发生在 java -&gt; class 之前，因为它需要生成 java 文件。 Transform 发生在 class -&gt; dex 之前，它需要修改class。 Proguard 发生在 Transform 之后，因为混淆后就找不到方法名了。 流程是这样的： annotationProcessor -&gt;javac-&gt; proguard -&gt; Transform]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的事件分发]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[事件的传递流Activity -&gt; Window -&gt; ViewGroup - &gt; View Activity.java 12345678910public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; // 交给 window if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; PhoneWindow.java 因为 PhoneWindow 暂时是 Window 类的唯一实现： 1234@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 这里的 mDecor 就是 DecorView 了，它继承至 FrameLayout，所以它是一个 ViewGroup。 然后 ViewGroup 可能会将事件就传递给它的子 View。 onTouch &amp; onTouchEvent &amp; onClick在 View 的 dispatchTouchEvent 方法中，在调用 onTouchEvent 之前，会先调用 mListenerInfo.mOnTouchListener.onTouch 方法，这个就是我们在外部设置的监听了。如果这个方法返回了 true，那么 onTouchEvent 方法就不会调用。 12345678910 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125;// result 为 true 是无法进入这个条件的 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; onClick 是在 onTouchEvent 中调用的，现在的 Android studio 在我们复写 View 的 onTouchEvent 的时候，都会给这么一个警告： Custom view MotionView overrides onTouchEvent but not performClick less… (Ctrl+F1)Inspection info:If a View that overrides onTouchEvent or uses an OnTouchListener does not also implement performClick and call it when clicks are detected, the View may not handle accessibility actions properly. Logic handling the click actions should ideally be placed in View#performClick as some accessibility services invoke performClick when a click action should occur. 简单来说就是，复写这个方法可能会导致 performClick 方法不会触发。从而影响 accessibility 的动作行为。 onClick &amp; onLongClick一般的，手指点击然后抬起，就会触发一个 onClick 时间，但是不知道你有没有想过，onLongClick 是如何触发的呢？系统是如何判断我们是长按，而不是点击？ 话说，肯定是一句时间来判断，但是具体的思路是怎么样的呢？ 使用 Handler post 一个延时 xxx ms消息，如果收到这个延时消息就会触发一个事件。 然而某些情况下，会提前将该消息 remove 掉，这样就收不到这个消息，无法触发事件。 拿长按事件举例：比如长按1s算一个长按事件，那么我们就可以post一个延时1000ms的消息，收到这个消息就触发长按回调，如果没到1s用户就放开了手指，那么就移除这个消息，这样就不会触发长按回调了。 onLongClick 方法有返回值，返回 true 表示消耗这个事件，那么 onClick 就无法触发了。 clickable &amp; enable一个 View 只有是 clickable 才会消耗事件，与 enable 没有关系。 onInterceptTouchEvent 的调用onInterceptTouchEvent 这个方法只有 ViewGroup 才有。 这个方法的调用条件有两个： 1if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 第一个是按下事件才会触发，第二个是有可以消耗这次事件的子 View。 根据这个我们可以推理出如下结论： 当一个 ViewGroup 拦截事件的时候，它会将事件交给自己处理，那么它不会把事件传递给子 View，也就是说，它没有可以消耗这次事件的子View。即在接下来的 MOVE、UP等事件，都不会调用这个方法。 requestDisallowInterceptTouchEvent当子View调用这个方法之后，ViewGroup 无法拦截除了 ACTION_DOWN 以外的事件。 这是因为，ACTION_DOWN 事件会重置和清除一些状态，其中就包括 FLAG_DISALLOW_INTERCEPT。 ViewGroup 拦截事件当 ViewGroup 决定拦截事件，那么 mFirstTouchTarget == null，那么 ViewGroup 的 dispatchTouchEvent 方法会调用 super.dispatchTouchEvent(event); 方法。 12345if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 123if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; 这里的 super 就是 View，因为 ViewGroup 也是继承至 View 的。 所以就调用到了 View 的 dispatchTouchEvent 方法，我们都知道，View 的 dispatchTouchEvent 方法会直接调用自己的 onTouchEvent 方法，而这里自己表示ViewGroup。所以，当 ViewGroup 决定拦截事件，会将事件交给自己处理。 ACTION_DOWN当某个 View 可以消耗事件的时候，这个 View 的父布局的 mFirstTouchTarget 变量就指向了这个 View，然后接下来的事件都会交给这个 View 来处理。 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 可以看到，直接调用 child （mFirstTouchTarget 指向的值） 的 dispatchTouchEvent。 当 View 不消耗 ACTION_DOWN 事件的时候，它的父布局的 mFirstTouchTarget 就为null，后面的事件该View 的 父布局就不会再往下传递了。它也就接受不到后续事件了。 ACTION_CANCEL当一个 ViewGroup 不拦截 ACTION_DOWN 事件，并且有可以消耗 ACTION_DOWN 的子 View 时，接下来的事件都会交给这个子 View 来处理，但是每次都会询问父布局是否拦截： 1234567891011if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; // 因为 mFirstTouchTarget 不会空，所以会走这里 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; 而如果在后续的事件中，父布局突然拦截了事件，即 intercepted 为 true，那么先前可以处理该事件的子View会收到一个 ACTION_CANCEL 事件。后面的事件就都会传递给父布局，而不往下传递。 12345// intercepted 为 true，则 cancelChild 也为 truefinal boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true;&#125; 123456789101112final int oldAction = event.getAction();if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; // 强制将 action 改成 cancel event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled;&#125; 可以看到，这里它将 ACTION_CANCEL 传递给了子 View。 传递 cancel 成功之后，会重置一些状态，包括 mFirstTouchTarget，将它的值清空。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navigation 的使用记录]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FNavigation%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[接到一个处理流程的需求，有好几个界面，界面之间的跳转有点复杂，还需要支持回退，于是想到使用 Jetpack 的 Navigation 包。具体的使用可以参考官方文档 。暂时不做介绍，考虑做一个翻译系列，将 Jetpack 全部翻译一遍，不过现在没有精力。等使用 Navigation 写完全部的跳转之后，发现一个严重的问题，那么就是 Navigation 不支持 Fragment 的状态保存。也就是说我在 FragmentA 做了一些操作，然后调到 FragmentB，在 FragmentB 中准备做一些操作的时候，突然发现有问题，想回到 FragmentA ，于是我点击了返回键回到 FragmentA ，就会发现 FragmentA 中的数据被重置了，我在 FragmentA 的操作没有了，这是用户无法接受的。 然后我去看了官方的 demo，发现它居然可以记录操作，我对比了一下工程代码，发现官方demo里面的是 EditText，我的项目里面是 CheckBox，只有控件的区别，于是我果断在官方的demo里面添加了CheckBox控件，发现也无法保存CheckBox的状态。这就让我无法理解了，为啥 EditText 可以保存状态，CheckBox 就不行？这个问题我现在还没有答案。 我又去翻了一下，Navigation 的相关源码，控制 Fragment 跳转的是androidx.navigation.fragment.FragmentNavigator。 它有一个 navigate 方法： androidx.navigation.fragment.FragmentNavigator#navigate 123456789101112131415161718 @Nullable @Override public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) &#123; ... final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); final FragmentTransaction ft = mFragmentManager.beginTransaction();... ft.replace(mContainerId, frag); ft.setPrimaryNavigationFragment(frag); ... ft.commit(); ... &#125; 这个逻辑很明显了，首先实例化要跳转到的 Fragment，然后直接替换原来的 fragment。 这里说一下，当使用 replace 的时候会发生什么： 假设 A 已经添加到了 mContainerId，这个时候调用了 replace B。 Fragment B 123onAttachonCreate Fragment A 123456789onPauseonStoponDestroyViewonDestroyonDetach Fragment B 1234567onCreateViewonActivityCreatedonStartonResume 可以看到，Fragment A 执行了 onDestroyView 与 onDetach，也就是说它完全从 Activity 上脱离了。再显示出来需要重新走一遍生命周期流程，但是这里需要注意的是，这个生命周期流程是没有添加到会退栈的，添加到会退栈的有点不一样。 因为 FragmentNavigator 内部将 Fragment A 添加到了会退栈，所以调用 replace B 的生命周期流程如下： Fragment B 123onAttachonCreate Fragment A 12345onPauseonStoponDestroyView Fragment B 1234567onCreateViewonActivityCreatedonStartonResume 可以看到与上面的区别是，Fragment A 只执行到了 onDestroyView，并没有走下面的 onDestroy 等方法。虽然它只执行到了 onDestroyView，但是它重新显示的时候，肯定要重新走 onCreateView，而一般我们的初始化逻辑都是在 onCreateView 中执行的，所以操作就都被重置了。 要想解决这个问题，现在就有两种选择：一是放弃 Navigation，二是自定义 FragmentNavigation，虽然我知道 第二种方法比较蛋疼，但是我还是想试一下，虽然最后还是失败了，但是还是记录一下过程。 自定义 Navigation 的文档在 这里，也可以参考这个项目 。 首先要处理 Fragment 每次都实例化的问题，这里可以自己缓存起来。 然后是想办法将 replace 替换为 add 之类的方法。我是覆盖了 navigate 方法，然后copy出了一部分源码，效果是达到了。 最后是处理返回键，这个我没有处理好。其实，不继承 FragmentNavigation，而是继承 Navigator，完全自己实现一个，或许会更简单一些，不过需要对 Fragment 的理解比较深入。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解 RecyclerView 的缓存机制]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FRecyclerView%20%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[以后会尽量写非源码的东西，因为过一段时间之后，发现自己看自己的文章都费劲，而且，源码大部分是在分析方法的调用链，意义不大，需要多写写自己的体悟才行。如果有时候必须要写，也要简化调用链的分析，提供类图，写重点和结论。 本文的思路与结论是基于参考文档的Anatomy of RecyclerView: a Search for a ViewHolder与 Anatomy of RecyclerView: a Search for a ViewHolder (continued) 这两篇文章而来。由于这两篇文章的某些观点与其他文章的的不一致，我经过自己的理解与推断调试后，是支持这两篇文章的观点的，所以当你阅读参考文档时，需要自己考量。 首先来从整体上来了解一下 RecyclerViewRecyclerView 有五虎上将： 类名 作用 RecyclerView.LayoutManager 负责Item视图的布局的显示管理 RecyclerView.ItemDecoration 给每一项Item视图添加子View,例如可以进行画分隔线之类 RecyclerView.ItemAnimator 负责处理数据添加或者删除时候的动画效果 RecyclerView.Adapter 为每一项Item创建视图 RecyclerView.ViewHolder 承载Item视图的子布局 RecyclerView.Recycler 负责处理View的缓存 RecyclerView的职责就是将Datas中的数据以一定的规则展示在它的上面，但说破天RecyclerView只是一个ViewGroup，它只认识View，不清楚Data数据的具体结构，所以两个陌生人之间想构建通话，我们很容易想到适配器模式，因此，RecyclerView需要一个Adapter来与Datas进行交流： 如上如所示，RecyclerView表示只会和ViewHolder进行接触，而Adapter的工作就是将Data转换为RecyclerView认识的ViewHolder，因此RecyclerView就间接地认识了Datas。 事情虽然进展愉快，但RecyclerView是个很懒惰的人，尽管Adapter已经将Datas转换为RecyclerView所熟知的View，但RecyclerView并不想自己管理些子View，因此，它雇佣了一个叫做LayoutManager的大祭司来帮其完成布局，现在，图示变成下面这样： 如上图所示，LayoutManager协助RecyclerView来完成布局。但LayoutManager这个大祭司也有弱点，就是它只知道如何将一个一个的View布局在RecyclerView上，但它并不懂得如何管理这些View，如果大祭司肆无忌惮的玩弄View的话肯定会出事情，所以，必须有个管理View的护法，它就是Recycler，LayoutManager在需要View的时候回向护法进行索取，当LayoutManager不需要View(试图滑出)的时候，就直接将废弃的View丢给Recycler，图示如下： 到了这里，有负责翻译数据的Adapter，有负责布局的LayoutManager，有负责管理View的Recycler，一切都很完美，但RecyclerView乃何等神也，它下令说当子View变动的时候姿态要优雅(动画)，所以用雇佣了一个舞者ItemAnimator，因此，舞者也进入了这个图示: 如上，我们就是从宏观层面来对RecylerView有个大致的了解，可以看到，RecyclerView作为一个View，它只负责接受用户的各种讯息，然后将信息各司其职的分发出去。 还有最后一个 ，ItemDecoration 是为了显示每个 item 之间分隔样式的。它的本质实际上就是一个 Drawable。当 RecyclerView 执行到 onDraw() 方法的时候，就会调用到他的 onDraw()，这时，如果你重写了这个方法，就相当于是直接在 RecyclerView 上画了一个 Drawable 表现的东西。 而最后，在他的内部还有一个叫getItemOffsets()的方法，从字面就可以理解，他是用来偏移每个 item 视图的。当我们在每个 item 视图之间强行插入绘画了一段 Drawable，那么如果再照着原本的逻辑去绘 item 视图，就会覆盖掉 Decoration 了，所以需要getItemOffsets()这个方法，让每个 item 往后面偏移一点，不要覆盖到之前画上的分隔样式了。 PS: 其实 ItemDecoration 的宽高是计算在 itemview 中的，只不过 itemview 本身绘制区域没有那么大，留出来的地方正好的透明的，于是就透过 itemview 显示出了 ItemDecoration。那么就很有意思了，如果我故意在 ItemDecoration 的偏移量中写成0，那么 itemview 就会挡住 ItemDecoration，而在 itemview 的增加或删除的时候，会短暂的消失(透明)，这时候就又可以透过 itemview 看到 ItemDecoration 的样子。使用这种组合还可以做出意想不到的动画效果。 虽然，Google 尽力的解耦了，但是在源码中有的地方还是会有逻辑混杂在一起的地方，比如：动画的处理。 为了能够更好的理解下面的内容，这里先介绍一下 pre-layout 与 post-layout 是什么。有这样的一个场景：我们有3个item【a, b, c】，其中a与b显示在屏幕上，当我们删除b的时候，c会显示出来。 我们希望看到的是 c 从底部顺利滑动到它的新位置。 但这是如何发生呢？ 我们知道新布局中 c 的最终位置，但我们如何知道它应该从何处开始滑动？ 谷歌的解决方案提供如下： 在adapter发生更改后，RecyclerView会从LayoutManager请求两个布局。 第一个 —— pre-layout，因为我们可以收到适配器的变化，所以这里我们可以做一些特殊的处理。在我们的例子中，因为我们现在知道b被删除了，所以我们会额外的显示出c，尽管它已经超出界限。 第二个 ——post-layout，一个正常的布局，对应于更改后的适配器状态。 现在，通过比较pre-layout和post-layout中c的位置，我们可以正确地为其设置动画。 仔细思考一下这个动画，This kind of animation — when the animated view is not present either in previous layout or in the new one — is called predictive animation。 再思考一个场景：如果b只是发生了变化，而不是被删除了，那么会怎么样呢？ ![](https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-View/RecyclerView/0_zzI5wYYr3KdkexZ4_ (1).png?raw=true) 答案是，仍然会在 pre-layout 阶段将 C 放置到后面！为什么呢？因为无法预测C的动画是什么动画，也许动画使b的高度变小了呢，那么c就需要显示出来，如果没有，那么 C 就会被放到缓存里去。 缓存介绍123456789101112131415161718public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;(); ArrayList&lt;ViewHolder&gt; mChangedScrap = null; final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;(); private final List&lt;ViewHolder&gt; mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap); private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; int mViewCacheMax = DEFAULT_CACHE_SIZE; RecycledViewPool mRecyclerPool; private ViewCacheExtension mViewCacheExtension; static final int DEFAULT_CACHE_SIZE = 2;&#125; scrapscrap 缓存是 recyclerView 最先搜索的缓存，网上有很多缓存调用图，第一个缓存调用就是 scrap。 scrap 仅仅在 layout 期间不为空。当 LayoutManager 开始 layout 的时候（pre-layout 或 post-layout），会将所有的 viewHolder 都放到 scrap 中。然后一个个在取回来，除非有些 view 发生了变化。 这里说一个题外话，就是有人可能会问，为啥要先放到 scrap 了之后，再取出来啊，这不是没事找事么？ 我的观点是：layout 的事归 LayoutManager 管，缓存的事归 Recycler 管。LayoutManager 不应该知到哪个 viewHolder 是否有效，这是一种职责分离设计。 scrap 分为两个集合：mAttachedScrap 和 mChangedScrap：这两个比较特殊，我跟踪了一下 mAttachScrap 添加的时机，在 LinearLayoutManager 的 onLayoutChildren 方法里面： 12345678public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; ... onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection); // 这里调用了 mAttachedScrap.add(holder); // 这里也调用了 mChangedScrap.add(holder); detachAndScrapAttachedViews(recycler); ...&#125; 这里的调用时机很值得思考，它在布局的时候就放到缓存里面了，这里说明这个缓存针对的是屏幕上显示的View. 那么问题就来了，屏幕上显示的为什么要缓存起来呢？我的想法倾向于是减少 layout 方法调用带来的影响。 比如说，当我们调用 notifyItemRangeChanged 方法的时候，会触发 requestLayout 方法，就会重新布局，重新布局的话，就会先将 viewHolder 放到 scrap 中（屏幕上变化的放入mChangedScrap 中，其余的放入mAttachedScrap 中），然后 fill 布局的时候，再从 mAttachedScrap 里面取出来直接使用。mChangedScrap 中的 viewHolder 会被移动到 RecycledViewPool 中，所以 mChangedScrap 对应的 item 需要从 pool 中取对应的 viewHolder，然后重新绑定。 现在再来思考一下，为什么需要 mChangedScrap 与 mAttachedScrap 这两个缓存？ 因为 mChangedScrap 表示 item 变化了，有可能是数据变化，有可能是类型变化，所以它的 viewHolder 无法重用，只能去 RecycledViewPool 中重新取对应的，然后再重新绑定。 然后一点需要注意：mChangedScrap 只能在 pre-layout 中使用，mAttachedScrap 可以在 pre-layout 与 post-layout 中使用。 在继续讨论之前，需要先说明几个方法之间的区别： View中的detach和remove detach 在ViewGroup中的实现很简单，只是将当前View从ParentView的ChildView数组中移除，将当前View的mParent设置为null, 可以理解为轻量级的临时remove。 remove 代表真正的移除，不光从ChildView数组中移除，其他和View树各项联系也会被彻底斩断。 Recycled View中的Scrap View Scrap View指的是在RecyclerView中，经历了detach操作的缓存。RecyclerView源码中部分代码注释的detach其实指代的是remove，此类缓存是通过position匹配的，不需要重新bindView。 Recycled View指代的就是真正的移除操作remove后的缓存，取出时需重新bindView使用。 cache 与 poolcache 与 pool 中储存的均属于 Recycled View ，需要重新 add 到 列表中。 mCachedViews，这个比较简单。 它是一个 ArrayList 类型，不区分 viewHolder 的类型，大小限制为2，但是你可以使用 setItemViewCacheSize()这个方法调整它的大小。 由于它不区分 viewHolder 的类型，所以只能根据 position 来获取 viewHolder 。 RecycledViewPool，它储存了各个类型的 viewHolder 最大数量为5，可以通过 setMaxRecycledViews() 方法来设置每个类型储存的容量。 还有一个重要的点就是，可以多个列表公用一个 RecycledViewPool，使用 setRecycledViewPool() 方法。 这里顺便说一下，各个缓存的使用上的区别，也好对各个缓存池有一个大概的了解： 如果在所有缓存中都没有找到 viewHolder，那就会调用 create 和 bind 方法。 如果在 pool （RecycledViewPool ） 中找到了，那么会调用 bind 方法。 如果在 cache （mCachedViews）中找到了，啥都不用做，直接显示就好了。 所以，需要注意他们的区别，一个 viewHolder 进入到 cache 与进入到 pool 中是不一样的。 现在，我们来思考下一个问题：mCachedViews 的大小是有限制的，如果存不下了，怎么办？ 实际上，mCachedViews 虽然是一个 ArrayList ，但是它的工作方式却和链表有点类似。当 mCachedViews 满了之后，它会将最先存入的元素移除，放入到 pool 中，如下图： 当我们滑动列表的时候，一旦 item 超出了屏幕，那么就会被放入到 mCachedViews 中，如果满了，就会将“尾部”的元素移动到 pool 中，如果 pool 也满了，那么就会被丢弃，等待回收。 下面，用几个场景来巩固一下我们学到的知识： 场景一： 先看图的左边（此时假设 cache 与 pool 中没有东西），当向下滑动时，3 最先进入 mCachedViews，随后是 4 与 5，5 会将3挤出来，3就会跑到 pool 中去了。 再看图的右边，继续向下滑动时，4 被 6 挤出来，放到了 pool 中，同时，8需要显示，那么就会先从 pool 中取，发现正好有一个 3，那么就会取出来，将 3 重新显示到屏幕上。 场景二： 如果，向下滑倒7显示出来之后，不再继续向下，而是往上滑动，那么又会怎么样呢？ 看图的右边，很明显，5 从 cache 中被取出来直接复用，不用重新绑定，7 被放入了 cache 中。 思考一下，对于这种情况，我们应该如何加以利用呢？ 比如，我们有一个壁纸库的列表，用户经常会上下（左右）滑动，那么我们增加 cache 的容量，就会获得更好得性能。然而对于feed流之类得列表，用户很少返回，所以增加 cache 容量意义不大。 再深入一下，我们继续向上滑动，那么，4 与 7 会放入到 cache 中，3 会从 pool 中取出来，但是，这里需要注意，因为 3 是从 pool 中取出来的，所以它需要重新绑定，但是从逻辑上来说，如果 3 位置的数据没有发生变化，它不需要重新绑定，也是有效的。所以，你也可以把这里当作一个优化点，在 onBindViewHolder() 方法中，检查一下。 再再深入一下，在我们滑动的过程中，一个类型的 viewHolder 在 pool 中应该一直只会存在一个（除非你使用了 GridLayoutManager），所以，如果你的 pool 中存在多个 viewHolder 的话，他们在滚动过程中基本上是无用的。 场景三： 当我们调用 notifyDataSetChanged() 或者 notifyItemRangeChanged(i, c) （c这个范围非常大的时候），那么很多 viewHolder 都会最终被放入到 pool 中，因为 pool 只能放置 5 个，那么多余的就会被丢弃，等待回收。最重要的是会重新 create 与 bind 对性能影响比较大。如果你的列表能够容纳很多行，而且使用 notifyDataSetChanged 方法比较频繁，那么你应该考虑设置一下容量大小。 1recyclerView.getRecycledViewPool().setMaxRecycledViews(0, 20); ViewCacheExtension这个是需要自定义的，而且使用有很大的限制，所以不深入介绍了。 因为它需要你自己创建 viewHolder，并将它缓存起来，那么问题就来了。当我们删除或添加一个 item 的时候，AdapterHelper 回调 RecyclerView 通知它需要处理变化。 RecyclerView 会遍历当前显示的 viewHolder 然后移动它们的位置。但是这里有个bug，RecyclerView 根本不知道你创建的 viewHolder，所以它不会管你自己缓存的 viewHolder。 所以，如果你想使用的话，需要满足一些条件： 位置固定，比如，广告位。 不会改变 数量合理，保存在内存中没啥关系。 Stable Ids之前我们说过，当调用 notifyDataSetChanged 的时候，recyclerView 不知道到底发生了什么，所以它只能认为所有的东西都发生了变化，即，将所有的 viewHolder 都放入到 pool 中。 但是，如果我们设置了 stable ids，那么就会不一样了： viewHolder 被放入了 scrap 中，而不是 pool 中。注意，这里，它的性能提升了很多！ 不用重新绑定，重新创建新的 viewHolder，不用重新 addView。addView会导致重新测量… 原来我们需要调用 notifyItemMoved(4, 6)，但是现在直接调用 notifyDataSetChanged() 就好了，因为 RecyclerView 可以自己推断出来（这是一个比较简单的，所以可以推断）。 到了这里，你应该可以回答下面的问题了： notifyDataSetChanged 与 notifyItemRangeChanged 的区别？ RecyclerView 与 ListView 缓存的区别？这个问题，即使你不知道 ListView 的缓存机制，也应该能说些什么。 如何对一个列表进行性能优化？调用 notifyDataSetChanged 时闪烁的原因？ 参考文档https://www.kymjs.com/code/2016/07/10/01/ https://juejin.im/post/5b79a0b851882542b13d204b https://blog.saymagic.cn/2016/10/21/understand-recycler.html Anatomy of RecyclerView: a Search for a ViewHolder Anatomy of RecyclerView: a Search for a ViewHolder (continued) RecyclerView机制解析: ChildHelper]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drawable 介绍]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FDrawable%20%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Drawable 的内部宽高比较重要，通过 getIntrinsicWidth 等可以获取。不是所有的 Drawble 都有内部宽高，对于图片形成的 drawble ，它的内部宽高就是图片的宽高，对于颜色形成的 drawable，它没有内部宽高。Drawble 没有大小的概念，都会拉伸到与 View 一样大。 BitmapDrawable属性介绍： antialias： 抗锯齿，就是画线的时候锯齿会减少，特别是画斜线与园 dither： 开启抖动效果。当图片的像素配置和手机屏幕的像素配置不一样的时候，开启这个可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果。 比如：图片的色彩模式为 ARGB8888，手机屏幕只支持 RGB555，这个时候，开启抖动选项可以让图片显示不会太过失真。 filter：图片拉伸或者压缩时可以保持较好的效果 gravity：与 scaleType 类似 tileMode：平铺模式，有重复平铺（repeat），镜像平铺（mirror），边缘拉伸（clamp），禁止（disable） BitmapDrawable 用起来比较简单。 .9 图片需要特殊说明以下： left 线：表示纵向可拉伸区域 top 线：表示横向可拉伸区域 bottom 线 与 right 线交叉的区域：表示内容显示的区域 具体的请点击这里 。 ShapeDrawable比较常用，可以画各种图形，渐变，只有 size 属性需要说一下。 size ： 这个属性可以设置 getIntrinsicWidth 的返回值。表示 drawble 的内部宽高。 这里有个比较神奇的地方： 首先，我们写一个 shape： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:dither="true" android:shape="rectangle"&gt; &lt;size android:width="1dp" android:height="1dp" /&gt; &lt;solid android:color="@color/colorAccent" /&gt; &lt;corners android:radius="5dp" /&gt; &lt;stroke android:width="2dp" android:color="@color/colorPrimaryDark" android:dashWidth="3dp" android:dashGap="3dp" /&gt;&lt;/shape&gt; 然后，设置到一个 View 上面： 12345678&lt;TextView android:id="@+id/tv" android:layout_width="200dp" android:layout_height="100dp" android:layout_centerInParent="true" android:background="@drawable/shape_drawable" android:gravity="center" android:text="Hello World!" /&gt; 然后，获取它的 background： 12TextView tv = (TextView)findViewById(R.id.tv);Drawble drawable = (GradientDrawable) tv.getBackground(); 你会发现，它获取到的不是 ShapeDrawable，而是 GradientDrawable。 LayerDrawable层叠的 drawble。它可以画出单一边线的效果，其实就是利用几个大小差一点点的矩形做成的效果： 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--底层使用蓝色填充色--&gt; &lt;item&gt; &lt;shape&gt; &lt;solid android:color="#02a0ef"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!--上面一层距离底层的顶部1dp,类似marginTop,填充色为白色，这样就形成了一个带有蓝色顶部边线的白色背景的图--&gt; &lt;item android:top="1dp"&gt; &lt;shape&gt; &lt;solid android:color="#fff"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; ![](F:\note-markdown\Drawable 介绍\20161206100146670.jpg) StateListDrawble就是对应于 selector 标签，还是非常常用的。 不过需要注意的是，系统会根据当前的状态从selector中选择对应的 item，系统会按照从上往下的顺序查找，知道找到第一条匹配的 item。 这里就要注意了，如果你把默认的item放在第一条的话，系统寻找的时候，无论是选中，按压等所有的情况都会匹配第一条，因为默认的不带任何状态，系统认为它匹配所有的状态。 LevelListDrawble对应于 level-list 标签。 可以用于切换图片，一个等级对应一张图，换图的时候只需要调用 img.setImageLevel 就好了。 TransitionDrawable对应于 transition 标签。 可以用于给一张图切换到另一张图时的过渡动画。 InsetDrawable对应于 inset 标签。 当一个 View 需要背景比内容区域要小的时候，可以使用这个。 ScaleDrawable对应于 scale 标签。 ScaleDrawable 有一个等级的概念，等级不仅会影响缩放的比例，还会影响绘制。 android.graphics.drawable.ScaleDrawable#draw 1234567@Overridepublic void draw(Canvas canvas) &#123; final Drawable d = getDrawable(); if (d != null &amp;&amp; d.getLevel() != 0) &#123; d.draw(canvas); &#125;&#125; 显然，如果 level 是 0 的时候，不会绘制 drawble。 对于缩放比例，它内部还有这样的一个公式： 12// 伪代码w -= (int) (w * (10000 - level) * mScaleState.mScaleWidth / 10000) 可以看到，如果 level 越接近于0（需要大于0），那么缩放的比例就与 （1- mScaleState.mScaleWidth） 越相近。如果 level 为 10000，那么就是不缩放，不管 mScaleState.mScaleWidth 的值为多少。 mScaleState.mScaleWidth 就是我们在 xml 中设置的 scaleWidth 等属性。 看一个例子，将一张图缩小为原来的30%左右（之所以是为左右，是因为 level 最小为1，所有会有 1/10000的 误差）： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/logo" android:scaleGravity="center_vertical|center_horizontal" android:scaleHeight="70%" android:scaleWidth="70%"/&gt; 注意，这里是缩小 70%。由于 level 默认为0，所以我们还需要用代码设置以下： 1scaleDrawable.setLevel(1); ClipDrawable对应于 clip 标签。 对一个drawable进行裁剪。其中 gravity 属性表示裁剪方向。 需要设置 leve 来表示裁剪多少，范围是 0~10000，0表示完全裁剪，即整个drawable都不见了，而 10000 表示不裁剪。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的工作原理]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRootImpl &amp; DecorView当我们在 Activity 中调用 setContentView 方法的时候，实际上 Activity 是将这个方法转发给了 Window。 android.app.Activity#setContentView(int) 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; 而 Window 的 setContentView 方法会创建 DecorView 对象。 1234567891011@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 这个方法里面就实例化了一个 DecorView installDecor(); &#125; ... &#125; 那么，有了 DecorView 之后，后面的流程就是解析我们在 xml 中写的布局，将xml转换成真正的 View 对象，然后添加到 DecorView 中（DecorView 是继承至 FrameLayout）。 但是我们都知道，在 onCreate 中我们是无法看到布局的，就像我们在内存中创建了一个 View 对象，我们是看不到它的，只有将它添加到界面上我们才能看到。 那么，如何将一个 View 添加到界面上呢？想必大家都知道以前手机上的悬浮按钮很流行，我们自己想要做一个这样的效果，一般都是通过 WindowManager 来实现的。所以说，使用 WindowManger 就可以将一个 View 显示到界面上了。当一个 View 已经显示到界面上之后，在给他添加子 View 就不用 WindowManager 了，可以直接添加，这就是我们可以动态更改布局，而不用通过WindowManager 的原因，因为 Activity 已经通过 WindowManager 将 DecorView 添加到了 PhoneWindow 上。我们操作的是 DecorView 的子 View。 android.app.ActivityThread#handleResumeActivity 12// 这里的 l 是 WindowManager.LayoutParams 对象的类型wm.addView(decor, l); 可以看到在 Activity 的 onResume 执行后，View 才会被添加到 Window 上，所以在这之前，我们是看不到界面的，故而不要在这之前做太多的事件，以免黑（白）屏时间太长，给用户一个不好的体验。 看到这里，我们已经知道 DecorView 与 WindowManager 是如何产生关系的了！ 那么 ViewRootImpl 又是如何插一脚的呢？ 上面的 addView 方法中，其实创建了一个 ViewRootImpl 对象： android.view.WindowManagerGlobal#addView 1234567ViewRootImpl root;...root = new ViewRootImpl(view.getContext(), display);...// 这个 view 就是上面的 DecorView 对象// 这里将 view 保存到了自己的成员变量 mView 中root.setView(view, wparams, panelParentView); 我们先来看看官方对 ViewRootImpl 的介绍： ViewRootImpl是View中的最高层级，属于所有View的根（但ViewRootImpl不是View，只是实现了ViewParent接口），实现了View和WindowManager之间的通信协议，实现的具体细节在WindowManagerGlobal这个类当中。 也就是说，View 并不会与 WindowManager 直接交流，他们有一个中间人，就是 ViewRootImpl，但是它的功能不止于此，它还负责 View 的测量-布局-绘制流程。可以看作是 View 树的操纵者。 View的测量过程对于 DecorView ，其 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来共同决定。 对于普通的 View，其 MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定。 具体一点来说： 当 View 采用具体数值的宽高时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是EXACTLY并且其大小遵循 LayoutParams 中的大小。 当 View 的宽/高是 match_parent 时，如果父容器的模式是EXACTLY模式，那么 View 也是EXACTLY模式并且其大小是父容器的剩余空间。如果父容器是AT_MOST模式，那么View 也是AT_MOST模式并且大小为父容器的剩余空间（可以看出，View 与 父容器的模式一样）。 当 View 的宽/高是 warp_content 是时，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是 AT_MOST 模式并且大小为父容器的剩余空间。 决定了 View 的 MeasureSpec 值之后，就可以开始执行 View 的 measure 方法了。 measure 方法就是执行测量过程的方法，它会调用 onMeasure 方法，经常自定义控件的就很熟悉这个方法了。我们可以通过复写 onMeasure 这个方法来绝定一个控件在各种情况下应该有多大。 onMeasure 方法有两个参数： android.view.View#onMeasure 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; widthMeasureSpec 与 heightMeasureSpec 这两个值就是根据上面的规则得到的（虽然上面我们只说了测量模式，没有测量大小）。View 有了这两个值就可以知道自己在各种情况下应该占多大的位置了。 一般情况下，View 测量出来的大小就是 widthMeasureSpec / heightMeasureSpec 中的 size 值。 但是也有例外，这个时候，View 的宽/高由 minWidth 与 background 一起决定，如果 background 为空，那么值就是 minWidth/minHeight，如果有 background，那么值就取 minWidth/minHeight 与 background 的原始宽/高 中的较大者。 当我们继承一个 View 来自定义控件的时候，如果不复写 onMeasure 就会出现一个问题： 在使用 wrap_content 属性的时候，是不生效的，效果与 match_parent 一样！！ 导致这个的原因是：View 为 wrap_content 的时候，模式是 AT_MOST，大小为父容器的剩余空间。这样的话，与match_parent 的表现形式是一样的。 所以，可以这样解决： 12345678910111213141516171819202122@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int modeW = MeasureSpec.getMode(widthMeasureSpec); int sizeW = MeasureSpec.getSize(widthMeasureSpec); int modeH = MeasureSpec.getMode(heightMeasureSpec); int sizeH = MeasureSpec.getSize(heightMeasureSpec); int width, height; if (modeW == MeasureSpec.AT_MOST) &#123; width = mMyWidth; &#125; else &#123; width = sizeW; &#125; if (modeH == MeasureSpec.AT_MOST) &#123; height = mMyHeight; &#125; else &#123; width = sizeH; &#125; setMeasuredDimension(width, height);&#125; 其实，只是指定了 AT_MOST 模式下的值，其他的没有改变。 ViewGroup 的测量过程ViewGroup 在测量的时候，会先去测量所有的 Child。调用 child 的 measure 方法来测量 child 的大小，然后根据 child 的大小以及自己的布局规则来决定自己的大小。 之所以，还涉及 ViewGroup 的布局规则，是因为每个ViewGroup 都不一样，比如：LinearLayout 是按照线程布局，FrameLayout是按照层叠布局，即使他们的所有child都一样，测量出来的结果肯定不是一样的。 android.view.ViewGroup#measureChildren 12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; android.view.ViewGroup#measureChild 1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 显然，measureChild 就是取出LayoutParams，然后和 parentMeasureSpec 一起来决定child 的 MeasureSpec，这个过程与 View 的测量过程是一样的。 android.view.ViewRootImpl#performTraversals 是谁触发的我们知道在 ViewRootImpl 创建出来之前，View是不会执行测量等一系列流程的，这是因为View的测量等都是由 ViewRootImpl 操纵的。 那么，View的第一次测量是从什么时候开始的呢？ android.view.ViewRootImpl#setView 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); 当 View 被添加到 window 上之前，ViewRootImpl 会执行一次 requestLayout，这个货会触发一系列连锁反应，最后调用到 performTraversals 里面。 为什么使用 view.post(xxx) 可以获取到 view 的宽高？？？这是因为 view 将 runnable 都存到了自己维护的一个队列中。 android.view.HandlerActionQueue#postDelayed 1234567891011public void postDelayed(Runnable action, long delayMillis) &#123; final HandlerAction handlerAction = new HandlerAction(action, delayMillis); synchronized (this) &#123; if (mActions == null) &#123; mActions = new HandlerAction[4]; &#125; mActions = GrowingArrayUtils.append(mActions, mCount, handlerAction); mCount++; &#125;&#125; 等到 view 显示出来的时候，才会取出来执行。 android.view.ViewRootImpl#performTraversals 12// Execute enqueued actions on every traversal in case a detached view enqueued an actiongetRunQueue().executeActions(mAttachInfo.mHandler); 可以看到，每次执行 performTraversals 的时候，就调用了 View 维护的队列的 executeActions 方法。 123456789101112public void executeActions(Handler handler) &#123; synchronized (this) &#123; final HandlerAction[] actions = mActions; for (int i = 0, count = mCount; i &lt; count; i++) &#123; final HandlerAction handlerAction = actions[i]; handler.postDelayed(handlerAction.action, handlerAction.delay); &#125; mActions = null; mCount = 0; &#125;&#125; 而这个队列，将 runnable 交给了 handler 去执行，这个 handler 是主线程的 handler。那么这个 runnable 会什么时候执行呢？这里我们先不管，我能只需要知道这个 runnable 与 测量流程 那个先执行就好了。 performTraversals 在调用了 executeActions 之后，将 runnable 放入主线程的队列，然后就接续往下执行，下面就是 View 的测量-布局-绘制流程了，所以说不管 runnable 什么时候执行，它肯定是在测量流程的后面执行，这也是为什么能在 view.post 的 runnable 可以拿到 view 的宽高的原因。 View 的 layout 过程一个 view 在 layout 方法中会决定自己在父布局的位置，如果这个 view 还有 child，那么它会在 onLayout 方法中调用 child 的 layout 方法，决定 child 的位置。这样达到一个循环… 其实自定义一个 ViewGroup，它的 onLayout 实现还是比较简单的，只要按照业务流程，慢慢写就好了，就和摆东西一样，每个东西的大小你都知道了，想怎么摆就怎么摆。就是里面的 margin 比较蛋疼，需要细心一点。 View 的 draw 过程 先绘制背景（肯定的，不然内容被背景盖住了） 绘制自己（onDraw） 绘制 children （dispatchDraw） 绘制装饰 （onDrawScrollBars） 与这个过程有关的有一个很重要的东西，就是补间动画执行的原理。 1234567891011121314151617181920212223242526272829303132333435363738boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ... //获取当前Animation final Animation a = getAnimation(); if (a != null) &#123; more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); ... &#125; ... //处理滑动 if (offsetForScroll) &#123; canvas.translate(mLeft - sx, mTop - sy); &#125; else &#123; if (!drawingWithRenderNode) &#123; //处理滑动 canvas.translate(mLeft, mTop); &#125; if (scalingRequired) &#123; ... // mAttachInfo cannot be null, otherwise scalingRequired == false final float scale = 1.0f / mAttachInfo.mApplicationScale; //处理缩放 canvas.scale(scale, scale); &#125; &#125; //处理透明度 float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha()); ... if (drawingWithRenderNode) &#123; renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha()); &#125; else if (layerType == LAYER_TYPE_NONE) &#123; canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha); &#125; ... return more;&#125; 可以看到，在 View 的绘制过程中，会获取 view 相关的动画，然后根据动画来计算当前 view 应该所处的位置，透明度等等。所以，如果一个 view 不执行重绘，动画是显示不出来的。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压缩、混淆、优化你的App]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%B1%89%E5%8C%96%2F%E5%8E%8B%E7%BC%A9%E3%80%81%E6%B7%B7%E6%B7%86%E3%80%81%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84App%2F</url>
    <content type="text"><![CDATA[为了让App的体积尽可能的小，我们在打 release 包的时候，应该开启 shrinking 选项来移除无用代码和资源。当开启 shrinking 后，还会带来一些额外好处，比如混淆，它会缩短App里面类与成员的名字，比如优化，它会采取一些激进的策略来进一步减小App的大小。当我们的项目使用的是 Android Gradle plugin 3.4.0 及以上的时候，gradle 插件不再使用 ProGuard 来执行编译时的代码优化，而是使用 R8 编译器来处理下面的编译时任务： 代码压缩：检测 App 与依赖的 library 中的无用类，字段，方法，属性并移除它们（可以缓解一下 64K 问题）。比如：如果我们只使用了一个依赖库中的少量方法，代码压缩就可以识别这些使用的代码，并且移除哪些未使用的代码。 资源压缩：移除打包App中的未使用的资源，包括library中未使用的资源。它最好与代码压缩一起使用，因为代码被移除之后，这些代码引用的资源也就可以安全移除了。 混淆：缩短类与成员的名字的长度，也就可以减少 dex 的大小。 优化：检查并重写代码，来进一步减小 dex 的大小。比如：R8发现 else{} 是一段无法到达的代码（永远不会走这个分支），那么它会移除这个 else{}分支。 当构建 release 版本的时候，R8 会默认执行上面说的任务。你也可以通过 ProGuard 规则文件禁止这些任务的执行。实际上，R8 编译器与 ProGuard 一样，都会受到 ProGuard 规则文件的影响。 开启压缩，混淆与优化当使用Android Studio 3.4或Android Gradle插件3.4.0及更高版本时，将项目的Java字节码转换为在Android平台上运行的DEX文件的默认编译器是 R8。但是，使用Android Studio创建新项目时，默认情况下不会启用这些优化。这是因为这些编译时优化会增加项目的构建时间，而且如果你不知道如何去自定义的保留代码，可能会导致运行时错误。 所以，最好是在准备发布，打包App的最终版本的时候，开启这些选项（module下的 build.gradle）： 123456789101112131415161718192021android &#123; buildTypes &#123; release &#123; // Enables code shrinking, obfuscation, and optimization for only // your project's release build type. minifyEnabled true // Enables resource shrinking, which is performed by the // Android Gradle plugin. shrinkResources true // Includes the default ProGuard rules files that are packaged with // the Android Gradle plugin. To learn more, go to the section about // R8 configuration files. proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; ...&#125; R8 配置文件R8使用 ProGuard 规则文件来修改其默认行为，还可以更好地了解应用程序的结构，例如那些作为应用程序代码入口点的类。尽管这些规则文件可以修改，但是有些规则文件是编译工具自动生成的，比如 AAPT2，还有些是从 library 中继承过来的。 下面这个表描述了 R8 使用的规则文件的来源： Source Location Description Android Studio &lt;module-dir&gt;/proguard-rules.pro 创建一个新的工程的时候，IDE会在 module 目录下生成一个文件，里面默认是没有应用任何规则，但是我们可以添加自定义规则。 Android Gradle plugin Gradle 插件在编译时生成文件 Android Gradle插件会生成proguard-android-optimize.txt，其中包含对大多数Android项目有用的基本规则，并且还启用了 @Keep 注解。 Library dependencies AAR libraries: &lt;library-dir&gt;/proguard.txt JAR libraries: &lt;library-dir&gt;/META-INF/proguard/ 如果AAR库在发布时使用自己的ProGuard规则文件，当我们的项目依赖该 AAR 时，则R8会在编译项目时自动应用其规则。为AAR库配置打包的规则文件非常有用，因为它意味着——库开发人员已经为我们执行了故障排除步骤。但是，我们应该知道，因为ProGuard规则是附加的，所以AAR库依赖项包含的某些规则无法删除，并且可能会影响应用程序其他部分的编译。例如，如果库包含禁用代码优化的规则，则该规则将禁用整个项目的优化。 Android Asset Package Tool 2 (AAPT2) 设置 minifyEnabled 为 true，构建之后，会生成文件 &lt;module-dir&gt;/build/intermediates/proguard-rules/debug/aapt_rules.txt AAPT2根据应用程序manifest，布局和其他应用程序资源中的类的引用生成保留规则。例如，AAPT2为应用程序manifest中作为入口点注册的每个Activity都有保留规则。 自定义配置文件 与第一个一样，我们可以额外的创建一些文件用来指定规则，创建之后需要在 build.gradle 中配置 可以包含其他配置，R8会在编译时应用它们。 将minifyEnabled属性设置为true时，R8会合并上面列出的所有可用来源的规则。当使用R8进行故障排除时，你一定要了解这些，以免出现一些你无法理解的行为，比如 library 中的规则影响到整个工程。 你可以使用下面的命令来输出一份详细的关于 R8 编译的报告文件： 12// You can specify any path and filename.-printconfiguration ~/tmp/full-r8-config.txt 包含其他配置使用Android Studio创建新项目或模块时，IDE会创建| /proguard-rules.pro文件，以便我们包含自己的规则。我们还可以通过将其他规则文件添加到模块的build.gradle文件中的proguardFiles属性中来包含其他的规则。 例如，可以通过在相应的productFlavor块中添加另一个proguardFiles属性来为指定的构建变体添加额外的规则。下面的示例将flavor2-rules.pro添加到flavor2的 product flavor中。现在，flavor2 就有了3个规则文件，因为 release 块中配置的文件也包含在里面。 1234567891011121314151617181920212223android &#123; ... buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), // List additional ProGuard rules for the given build type here. By default, // Android Studio creates and includes an empty rules file for you (located // at the root directory of each module). 'proguard-rules.pro' &#125; &#125; flavorDimensions "version" productFlavors &#123; flavor1 &#123; ... &#125; flavor2 &#123; proguardFile 'flavor2-rules.pro' &#125; &#125;&#125; 压缩代码将minifyEnabled属性设置为true时，默认情况下会启用使用R8的代码压缩。 代码压缩是 R8 删除在运行时不需要的代码的过程。整个过程可以极大的减少App的体积，特别是你引入很多库，但是每个库都只使用了少量的功能。 要压缩应用程序的代码，R8首先根据组合的配置文件集确定应用程序代码中的所有入口点。这些入口点包括Android平台可用于打开应用程序的所有Activity或Service。R8会从每个入口点开始检查应用程序的代码，检测应用程序可能在运行时访问的所有方法，成员变量和其他类，然后构建一个图。未连接到该图的代码被视为无法访问，可能会从应用中删除。如下图所示： 上图中建立的图结构中，OkayApi 类没有在其中，所以它会被删除。 R8 通过工程的配置文件集来决定所有入口点，也就是说，keep规则指定R8在缩小应用程序时不应丢弃的类，R8将这些类视为应用程序的可能入口点。Android Gradle插件和AAPT2会自动生成大多数应用项目所需的保留规则，例如应用的activities，views和services。当然，如果又需要，你也可以添加自己的规则。 或者，您可以将@Keep注释添加到要保留的代码中。在类上添加@Keep会使整个类保持原样。在方法或字段上添加它将保持方法/字段（及其名称）以及类名完整。请注意，此注释仅在使用AndroidX注释库时以及包含随Android Gradle插件打包的ProGuard规则文件时才可用。 压缩资源资源压缩只有配合代码压缩才会起作用。在代码缩减器删除所有未使用的代码之后，资源缩减器可以识别应用程序仍在使用哪些资源。添加包含资源的代码库时尤其如此 - 必须删除未使用的库代码，以便库的资源不会被引用，从而这些资源可以被资源缩减器移除。 想要开启资源缩减，只需要配置一下： 1234567891011android &#123; ... buildTypes &#123; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 自定义需要保留的资源通过配置一个 xml 文件，你可以自定义需要保留或者丢弃的资源。 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:keep="@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*" tools:discard="@layout/unused2" /&gt; tools:keep 与 tools:discard都可以指定多个资源，使用分号隔开。还可以使用 * 号作为通配符。 将该文件放置到工程的资源目中，比如：res/raw/keep.xml。 该文件不会被打包到 APK 中。 指定哪些资源需要被删除，看起来没啥屌用，因为我们可以直接的手动删除这个资源。但是如果我们在构建多个 variants 的时候就非常有用了，比如，我们可能将所有资源放在了一个 common 工程中，然后创建了 keep.xml 来为每个 variant 来指定需要保留与丢弃的资源。因为这个时候，资源都在代码里面被引用了，所以资源缩减器不会移除这些资源。还有另外一种情况，构建工具可能无法区别资源id的引用与 int 值的区别，如果刚好某个资源的id与我们代码中int值相等，它也不会移除这个资源。 开启严格引用检查通常情况下，资源缩减器可以正确的识别哪些资源被引用了。但是，如果我们这样引用资源： 1Resources.getIdentifier() 或者，我们的依赖库中有这样使用的（AppCompat就是）。遇到这种情况，资源缩减器默认情况下会采取防御措施，并将所有具有匹配名称格式的资源标记为可能已使用且无法删除。 举个例子： 12val name = String.format("img_%1d", angle + 1)val res = resources.getIdentifier(name, "drawable", packageName) 这会将具有img_前缀的所有资源标记为已使用。 资源缩减器还会查看代码中的所有字符串常量以及各种res/ raw/资源，以及类似于file:///android_res/drawable//ic_plus_anim_016.png的格式的资源URL。如果它发现像这样的字符串或者 url，它就不会移除这些资源。 这个行为默认是开启的，但是如果想要关闭它，就可以使用 strict 模式： 123&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:shrinkMode="strict" /&gt; 开启了严格模式之后，使用上面的方式引用的资源也会被删除，所以我们需要在 keep.xml 里面保留这些资源。 移除未使用的可选资源Gradle资源缩减器仅删除应用程序代码未引用的资源，这意味着它不会删除不同设备配置的备用资源。 如有必要，您可以使用Android Gradle插件的resConfigs属性来删除您的应用不需要的备用资源文件。 例如，如果您使用的是包含语言资源的库（例如AppCompat或Google Play服务），那么您的APK会包含这些库中所有翻译语言的字符串。如果您只想保留应用正式支持的语言，可以使用resConfig属性指定这些语言，删除未指定语言的资源。 下面的代码就展示了如何只保留两种语言资源： 123456android &#123; defaultConfig &#123; ... resConfigs "en", "fr" &#125;&#125; 只保留了英语与法语。同样的，我们还可以只保留某一屏幕密度下的资源。 合并重复资源默认情况下，Gradle还会合并具有相同名称的资源，例如可能位于不同资源文件夹中的同名的drawable（这里应该指的是不同library的资源）。此行为不受shrinkResources属性控制，并且无法禁用，因为当多个资源与您的代码查找的名称匹配时，必须避免这种情况。 仅当两个或多个文件共享相同的资源名称，类型和限定符时，才会发生资源合并。 Gradle选择它认为最合适的一个并保留。 Gradle 从下面的路径来寻找重复的资源： src/main/res build flavor 与 build type 依赖库 资源优先级从低到高： 依赖库 → Main → Build flavor → Build type 举个例子：如果Main和build flavor中出现重复的资源，Gradle将选择build flavor中的资源。 如果重复资源在同一层次出现，比如src/main/res/ 和 src/main/res2/，则 gradle 无法完成资源合并，这时会报资源合并错误。 代码混淆混淆的目的是通过缩短APP的类，方法和字段的名称来减少应用程序的大小。以下是使用R8进行混淆处理的示例： 12345678910androidx.appcompat.app.ActionBarDrawerToggle$DelegateProvider -&gt; a.a.a.b:androidx.appcompat.app.AlertController -&gt; androidx.appcompat.app.AlertController: android.content.Context mContext -&gt; a int mListItemLayout -&gt; O int mViewSpacingRight -&gt; l android.widget.Button mButtonNeutral -&gt; w int mMultiChoiceItemLayout -&gt; M boolean mShowTitle -&gt; P int mViewSpacingLeft -&gt; j int mButtonPanelSideLayout -&gt; K 虽然混淆不会从程序中删除代码，但是如果你的程序中有许多类，方法和字段，那么节省的大小还是很可观的。但是需要注意是，由于代码进行了混淆，那么运行时发生了错误，打印出来的堆栈，我们就看不懂了，需要一些额外的工具来帮助我们进行还原代码信息。 另外，如果你写的代码需要依赖原本类或者方法的名字（比如，反射等），那么你就需要在 ProGuard 文件中 keep 你使用到的类或者方法。 解码混淆后的堆栈信息在 R8 混淆了代码之后，阅读堆栈信息几乎是不可能的了，因为方法名类名都换成了很简单的英文字母了。除了重命名，R8 还会改变堆栈信息代码所在的行号。不过还好，我们可以通过 mapping.txt 文件来还原堆栈信息，我们每次构建App的时候，都会生成一个 mapping.txt 文件，里面会包含所有类，方法，字段的混淆前与混淆后的映射关系，当然，里面也有行号的对应关系。该文件一般在 &lt;module- name&gt;/build/outputs/mapping/&lt;build-type&gt;/ 目录下面。 R8每次构建项目时都会覆盖生成的mapping.txt文件，因此每次发布新版本时都必须小心保存副本。通过为每个发布版本保留mapping.txt文件的副本，如果用户从旧版本的应用程序提交混淆后的堆栈信息，您将能够追踪调试问题。 在Google Play上发布您的应用时，您可以为每个版本的APK上传mapping.txt文件。然后，Google Play会根据用户报告的问题对传入的堆栈跟踪进行反混淆处理，以便您可以在Google Play控制台中查看这些堆栈信息。有关详细信息，请参阅帮助中心的文章，了解如何对崩溃堆栈跟踪进行反混淆处理。 要将混淆的堆栈跟踪转换为可读的堆栈跟踪，请使用 ReTrace 脚本，在SDK/tools/proguard/bin 目录下。 代码压缩为了进一步的减小 App 的体积，R8 会在更深的层次上来检查你的代码，然后移除无用代码，甚至有时候会重写我们的代码，让其更简洁。下面举几个例子： 如果你写了一个 else{} 块，但是任何情况下都不会走这个分支，那么R8可能会将它删除。 如果某个方法只在唯一一个地方被调用，那么 R8 可能会将方法内联到调用的地方，并将这个方法移除。 如果某个类只有一个子类，并且该类没有被实例化（举个例子，一个抽象类，只有一个子类），那么 R8 会将这两个类合成一个类。 更多内容请看大神的博客 R8 optimization blog posts R8不允许您禁用或启用离散优化，或修改优化的行为。实际上，R8忽略了任何试图修改默认优化的ProGuard规则，例如-optimizations和 - optimizepasses。此限制很重要，因为随着R8的不断改进，维护标准的优化行为有助于Android Studio团队轻松排除故障并解决您可能遇到的任何问题。 启动更加激进的优化策略R8 里面还包含一些默认没有开启的优化行为。你可以开启它们，自需要在 gradle.properties 里面添加： 1android.enableR8.fullMode=true 假设您的代码通过Java Reflection API引用了一个类。默认情况下，R8假定您打算在运行时检查和操作该类的对象 - 即使您的代码实际上没有 - 并且它会自动保留该类及其静态初始化程序。 但是，当使用“完整模式”时，R8不会做出这种假设，如果R8断言你的代码在运行时从不使用该类，它会从你应用程序的最终DEX中删除该类。也就是说，如果要保留类及其静态初始化程序，则需要在规则文件中包含保留规则才能执行此操作。 有问题，查看文档，并报告问题。 If you encounter any issues while using R8’s “full mode”, refer to the R8 FAQ page for a possible solution. If you are unable to resolve the issue, please report a bug. 使用R8进行故障排除当我们开启了代码压缩，资源压缩等选项的时候，可能会遇到一些问题，可以查看帮助文档。 If you do not find a solution to your issue below, also read the R8 FAQ page and ProGuard’s troubleshooting guide. 生成被移除代码报告记录为了帮助您解决某些R8带来问题，查看R8从您的应用中删除的所有代码的报告可能会很有用。将-printusage &lt;output-dir&gt; /usage.txt添加到自定义规则文件中，就可以为模块生成报告记录。当您启用R8并构建应用程序时，R8会输出一个包含您指定的路径和文件名的报告。已删除代码的报告类似于以下内容： 1234567891011121314androidx.drawerlayout.R$attrandroidx.vectordrawable.Randroidx.appcompat.app.AppCompatDelegateImpl public void setSupportActionBar(androidx.appcompat.widget.Toolbar) public boolean hasWindowFeature(int) public void setHandleNativeActionModesEnabled(boolean) android.view.ViewGroup getSubDecor() public void setLocalNightMode(int) final androidx.appcompat.app.AppCompatDelegateImpl$AutoNightModeManager getAutoNightModeManager() public final androidx.appcompat.app.ActionBarDrawerToggle$Delegate getDrawerToggleDelegate() private static final boolean DEBUG private static final java.lang.String KEY_LOCAL_NIGHT_MODE static final java.lang.String EXCEPTION_HANDLER_MESSAGE_SUFFIX... 如果你想查看，R8保留了哪些类，可以添加 -printseeds &lt;output-dir&gt;/seeds.txt 到自定义规则文件中。文件内容大致如下： 1234567com.example.myapplication.MainActivityandroidx.appcompat.R$layout: int abc_action_menu_item_layoutandroidx.appcompat.R$attr: int activityChooserViewStyleandroidx.appcompat.R$styleable: int MenuItem_android_idandroidx.appcompat.R$styleable: int[] CoordinatorLayout_Layoutandroidx.lifecycle.FullLifecycleObserverAdapter... 资源故障排除压缩资源时，“构建”窗口 会显示从APK中删除的资源的摘要。 比如： 123:android:shrinkDebugResourcesRemoved unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%:android:validateDebugSigning Gradle还在&lt;module-name&gt; / build / outputs / mapping / release /（与ProGuard的输出文件相同的文件夹）中创建名为resources.txt的诊断文件。此文件包含详细信息，例如哪些资源引用其他资源以及使用或删除了哪些资源。 比如，你想知道为啥 @drawable/ic_plus_anim_016 这个文件被打包到了 APK 中，你可以打开 resource.txt 文件，然后搜索这个文件名。你就可以找到谁引用了这个资源： 1216:25:48.005 [QUIET] [system.out] &amp;#64;drawable/add_schedule_fab_icon_anim : reachable=true16:25:48.009 [QUIET] [system.out] &amp;#64;drawable/ic_plus_anim_016 这个说明了，add_schedule_fab_icon_anim 引用了 ic_plus_anim_016，现在你要找出为什么 add_schedule_fab_icon_anim 是可达的！继续向上搜索，你会发现这个资源在 The root reachable resources are: 下面的列表中。这表示有代码引用了 add_schedule_fab_icon_anim 。 如果我们没有使用 strict 检查，还有一种情况下资源id也可能被标记为可达的： 1210:32:50.590 [QUIET] [system.out] Marking drawable:ic_plus_anim_016:2130837506 used because it format-string matches string pool constant ic_plus_anim_%1$d. 这个显然就是使用资源名来动态加载资源的情况。遇到这种情况，你需要手动的指定该资源需要被移除。]]></content>
      <tags>
        <tag>Android-汉化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程与应用的生命周期]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%B1%89%E5%8C%96%2FAndroid%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[官方文档在这里。本来，官方文档的部分内容已经汉化了，但是翻译实在是惨不忍睹，而且有些内容与原文还不一致，真不晓得是怎么回事。大多数情况下，每个 Android 应用程序运行在自己的 Liunx 进程当中。在应用中的某些代码需要运行的时候，这个进程就会被创建出来，它会一直运行，直到该进程不再被需要了或者系统需要释放该进程占用的内存以便让别的应用运行。 Android 有一个特殊的基本特征：应用程序进程的生命周期不是由自己本身直接控制的。取而代之的，是由系统通过几个方面的综合考量来决定的：系统知道的正在运行的应用程序，这些应用程序对用户的重要性，系统可用的剩余内存。 开发者需要理解应用程序的不同组件（特别是 Activity，Service，BroadcastReceiver）对应用程序进程生命周期的影响。如果没有正确的使用这些组件，可能会导致你在执行某些很重要的任务时突然进程被系统给干掉了。 这里有一个例子，是关于进程生命周期的 bug 的。我们在使用 BroadcastReceiver 的时候，当它的 onReceive 方法被触发，我们会开启一个线程去执行任务，onReceive 方法会直接返回。一旦 onReceive 方法返回了，系统就会认为 BroadcastReceiver 不再处于活动状态，所以，它所在的进程也就不需要了（除非进程里面还有其他的组件处于活动状态）。然后系统可能在任何时候杀掉这个进程来回收内存，这样就会终止进程里面正在运行的线程。这个问题的解决方案是使用 JobService，使用了 JobSerive 之后，系统就会知道进程里面仍然有活要干。 为了确定在内存不足的时候应该干掉哪些进程，Android 会根据进程中运行的组件以及这个组件的状态来给每个进程分配一个级别（按重要性排序）： 前台进程：用户正在与之交互的进程。前台进程有多种产生的情况： 有一个用户正在交互的处于屏幕最顶部的 Activity（onResume 执行过了） 有一个正在运行的广播（BroadcastReceiver.onReceive() 方法正在执行） 有一个正在执行回调方法代码（onCreate，onStart，onDestroy）的 Service 系统中这样的进程非常少，只有当可用内存极少，而且这些进程都无法正常运行的时候，才会将它们杀掉。 文档还有一句话，我不是很理解： Generally, at this point, the device has reached a memory paging state, so this action is required in order to keep the user interface responsive. 内存分页我知道，内存分页状态是个啥？？？ 可见进程：可见进程中运行的任务用户是可以注意到的，所以杀掉它会给用户体验产生明显的负面影响。满足下面的一些条件的是可见进程： Activity 可见但是不处于前台，比如：一个前台的 activity 以 dialog 的形式显示出来，那么在它后面的那个 activity 就是可见状态。 Service 调用了 Service.startForeground() 方法。这会让系统意识到该服务是会让用户注意到或者可见的。 It is hosting a service that the system is using for a particular feature that the user is aware, such as a live wallpaper, input method service, etc. 这个我不太明白意思。 可见进程的数量比前台进程要多，但是也多不了多少，处于可管控的范围之内。这些进程是非常重要的，只有在前台进程无法正常运行的时候，才会杀掉它们。 服务进程：一个Service通过 startService() 方法启动即为服务进程。尽管它们对用户不可见，但是它们通常都在后台做一些用户关系的事情（比如：上传与下载）。所以系统一般也不会杀掉它们，除非系统无法保证所有的前台与可见进程正常运行。 长时间运行的服务（超过30分钟）其优先级会降低（在下面所说的 LRU 表中会向后移动）。这有助于避免出现内存泄漏或其他问题的长时间运行的服务占用大量RAM而导致系统无法有效使用缓存进程的情形。 缓存进程：缓存进程是指当前不需要的，当系统需要内存的时候是可以随意杀掉的进程。在一个正常运行的系统中，内存管理应该只会涉及到缓存进程：运行良好的系统将始终提供多个缓存进程（以便在应用程序之间进行更高效的切换），并根据需要定期终止最旧的进程。只有在非常极端（且不可取）的情况下，系统才会杀死所有缓存进程，而且必须开始终止服务进程。 这些进程通常保留了一个或者多个 Activity 的实例（onStop 方法被调用而且返回了），这些 Activity 对用户都不可见。如果开发者正确的实现了 Activity 的生命周期，当系统杀掉这些进程的时候，用户是感知不到的，而且当用户返回这个 App 的时候，也不会影响用户体验：因为系统保存了当前 Activity 的状态，会重新创建该 Activity。 这些进程保存在伪LRU列表中，列表中的最后一个进程是第一个被回收内存的进程。这个列表通常会将更有用的进程（桌面应用程序，用户最后一个使用的 app）放到其他进程的前面。杀掉进程可能还会有其他的策略（依赖于具体平台的实现）：对进程的数量进行限制，对进程可缓存的时间进行限制。 在决定如何对进程进行分类时，系统将根据进程中当前活动的所有组件中找到的最重要级别做出决策。具体查看 Activity, Service, and BroadcastReceiver 的文档。它们的文档都详细地描述了它们是如何影响应用程序的整个生命周期的。 当一个进程被其他进程依赖时，该进程的优先级可能会增加。例如，进程A使用Context.BIND_AUTO_CREATE标志绑定到Service，或者正在使用进程B中的ContentProvider，则进程B的重要级别将始终至少与进程A一样重要。]]></content>
      <tags>
        <tag>Android-汉化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Activity 的 onDestroy 方法里面调用 finish 会发生什么]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2F%E5%9C%A8%20Activity%20%E7%9A%84%20onDestroy%20%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E8%B0%83%E7%94%A8%20finish%20%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[发现这个奇怪问题的起因在于同事看了MVVM的相关文章，里面提到屏幕旋转时，Activity 销毁重建不会导致 ViewModel随着销毁而重建。于是，就在项目中写了测试代码来验证。然后就发现了一个诡异的问题，打开的界面旋转后自动关闭了！！后来断点调试发现是因为 onDestroy 走了两次，分析逻辑之后，还原了执行流程，如下代码所示： Demo123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 由于历史原因，我们的项目里面出现了这样的代码（经过简化逻辑之后）。 finish();&#125; 那么问题就来了，Activity 在重建时，是创建了新的对象，为何旧的对象调用 finish 方法会将新创建的 Activity 对象给销毁？ 查看 finish 的源码： Activity android.app.Activity#finish(int) 12345678910111213141516171819202122private void finish(int finishTask) &#123; // mParent 为空，走里面的逻辑 if (mParent == null) &#123; ... try &#123; ... // 这里是最可疑的地方，AMS 是根据 mToken 的值去判断该 finish 哪个 Activity if (ActivityManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) &#123; mFinished = true; &#125; &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.finishFromChild(this); &#125; ...&#125; 那么，打印 mToken 的值看一下： Demo1234567891011121314151617181920@Override protected void onDestroy() &#123; super.onDestroy(); Class aClass = this.getClass(); while (aClass != Activity.class) &#123; aClass = aClass.getSuperclass(); &#125; try &#123; Field mToken = aClass.getDeclaredField("mToken"); mToken.setAccessible(true); Object o = mToken.get(this); Log.e("mToken", o.toString()); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; finish(); &#125; 输出 log 如下： 12E/mToken: android.os.BinderProxy@57d9656E/mToken: android.os.BinderProxy@57d9656 不出所料，那么现在就来看看源码，看 AMS 是如何根据 mToken 来管理 Activity 的。 Android 是如何根据手机方向来旋转屏幕的，这个我没法探究，但是 Activity 有一个方法，也可以设置屏幕方向，想来分析这个方法也是可行的。 Activity android.app.Activity#setRequestedOrientation 1234567891011121314public void setRequestedOrientation(@ActivityInfo.ScreenOrientation int requestedOrientation) &#123; // mParent 为null if (mParent == null) &#123; try &#123; // 走这里 ActivityManagerNative.getDefault().setRequestedOrientation( mToken, requestedOrientation); &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.setRequestedOrientation(requestedOrientation); &#125;&#125; 根据 Binder 机制，ActivityManagerNative.getDefault() 会返回 ActivityManagerProxy 对象，然后会调用到 ActivityManagerService 的 setRequestedOrientation 方法。 ActivityManagerService com.android.server.am.ActivityManagerService#setRequestedOrientation 1234567891011121314@Overridepublic void setRequestedOrientation(IBinder token, int requestedOrientation) &#123; synchronized (this) &#123; ... if (config != null) &#123; r.frozenBeforeDestroy = true; // 这里处理了方向的改变，里面还涉及到对 activity 方向改变的回调 if (!updateConfigurationLocked(config, r, false)) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; 后面的代码还是比较深的，这里就不贴出来了，跟踪到后面，会发现它调用了这样的一个方法。 com.android.server.am.ActivityStack#ensureActivityConfigurationLocked 123456 boolean ensureActivityConfigurationLocked( ActivityRecord r, int globalChanges, boolean preserveWindow) &#123; ...relaunchActivityLocked(r, r.configChangeFlags, true, preserveWindow); ... &#125; 这里它重新启动了这个 Activity（demo里面没有对方向变化做任何处理）。 我们知道，AMS 处理 Activity 的方法，都会通知到到应用进程，由应用进程自己处理。 ActivityThread android.app.ActivityThread#handleRelaunchActivity 1234567891011121314151617private void handleRelaunchActivity(ActivityClientRecord tmp) &#123; ... // tmp 是从需要重启的集合中找出来的 // 这里再次找一下，按照正常逻辑这里找出来的，应该还是同一个对象 ActivityClientRecord r = mActivities.get(tmp.token); ... // r.token 传递进去 handleDestroyActivity(r.token, false, configChanges, true); ... // r 传递进去 handleLaunchActivity(r, currentIntent, "handleRelaunchActivity"); ...&#125; ActivityClientRecord 是属于应用进程的，它里面存有 Activity 的信息。一个 ActivityClientRecord 对应一个 Activity。 这里可以看出，Activity销毁重建的时候，都使用的是同一个 ActivityClientRecord，mToken 没有变化。 当我们在 onDestroy 里面，调用 finish 的时候，传递的 mToken 值与重新创建的 Activity 的 mToken 值是一样的，所以会销毁掉刚刚启动的 Activity。 参考文章https://juejin.im/post/5c88fac76fb9a049c16013c6 https://blog.csdn.net/guoqifa29/article/details/46819377 https://www.jianshu.com/p/94816e52cd77]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window 与 View的动态更改思考]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FWindow%20%E4%B8%8E%20View%E7%9A%84%E5%8A%A8%E6%80%81%E6%9B%B4%E6%94%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[我们创建一个悬浮窗的时候，需要使用 WindowManager 来创建。WindowManager 是一个接口，它继承至 ViewManager，主要有3个方法供我们使用：123public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view); 我们获取WindowManager： 1WindowManager windowManager = (WindowManager)context().getSystemService(Context.WINDOW_SERVICE); 一般通过这种方法调用的，最终都会触发一个 IPC 调用。 那么，这就引发了我的一个猜想：我们在 Activity 的布局里面，每次动态添加和删除 View 的时候，里面有没有触发 IPC 调用？？？ 我们拿 WindowManager的addView方法来分析一下，它的实现类是 android.view.WindowManagerGlobal。 android.view.WindowManagerGlobal#updateViewLayout 1root.setLayoutParams(wparams, false); 它调用了 ViewRootImpl 的 setLayoutParams 方法。 android.view.ViewRootImpl#setLayoutParams 1scheduleTraversals(); 这个方法内部又会调用 performTraversals方法，这个方法我们就很熟悉了，它就是 View 的绘制流程的入口。 android.view.ViewRootImpl#performTraversals 1relayoutWindow(...) 这个方法就会发起IPC调用来更新Window。 我们的普通的 ViewGroup 的addView等方法，会触发 requestLayout 方法，同样的会导致 scheduleTraversals 方法的调用，所以也会有 IPC 调用。 可以想象到，addView 是一个比较重量的操作。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcelable与Serializable]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FParcelable%E4%B8%8ESerializable%2F</url>
    <content type="text"><![CDATA[通常，在Android里面传递数据都是使用的 Intent，而 Intent 里面想要放一个 Java 对象，那这个对象要么实现 Parcelable 要么实现 Serializable 。一般我们都是选择实现 Parcelable，因为它的效率高，而且不会产生很多的临时对象。当然这些都是网上说的，并没有证明，现在我们来测试一下，从传输效率开始。当然我也懒得做测试的，所以我找了一篇文章，个人觉得还是可以的，有好奇心的小伙伴可以自己测试一下。 测试过程如下： 模拟将对象传递给Activity的过程：直接调用 [Bundle#writeToParcel(Parcel, int)](https://developer.android.com/reference/android/os/Bundle.html#writeToParcel(android.os.Parcel, int))，然后再取出来。 循环 1000 次 做10次测试，取平均值 在多个设备上测试 下面给出该作者测试的结果： Nexus 10Serializable: 1.0004ms, Parcelable: 0.0850ms - 10.16x improvement. Nexus 4Serializable: 1.8539ms - Parcelable: 0.1824ms - 11.80x improvement. Desire ZSerializable: 5.1224ms - Parcelable: 0.2938ms - 17.36x improvement. 可以看出，区别还是很明显的。可能几ms对我们人类来说，感觉不到什么，但是对于CPU就像是过了几个月了。特别是Android需要16ms来绘制一帧，你传递一个对象就花了几ms，就没剩多少时间了。 好了说完了效率，我们再说说为啥 Serializable 会产生很多临时对象。 看一个简单的对象： 12345678910111213public class Phone implements Serializable&#123; public String name; public String address; public Phone() &#123; &#125; public Phone(String name, String address) &#123; this.name = name; this.address = address; &#125;&#125; 当我们把这个对象序列化到文件中的时候，它的内容如下： 1234567aced 0005 7372 0011 636f 6d2e 6578 616d706c 652e 5068 6f6e 6551 4868 16d4 8afd8702 0002 4c00 0761 6464 7265 7373 7400124c 6a61 7661 2f6c 616e 672f 5374 72696e67 3b4c 0004 6e61 6d65 7100 7e00 01787074 0007 6265 696a 696e 6774 0008 7a68616e 6773 616e 我就不解释一个个解释它们代表什么了，这些数据包含了如下内容： 序列化协议，固定值 序列化协议版本 对象的开始标记，类的开始标记 类名长度，类名 有多少个字段 每个字段长度，字段名，字段值 嗯，还有一些东西，特别是有父类的，更蛋疼。可以看到，本来我们只需要传递 name 与 address 的值，它给我们搞了一大堆东西，非常的浪费。还有反序列的时候，由于它使用了反射机制，所以会产生很多的临时变量，可能会增加GC的频率。 Parcelable 的序列化与反序列化的过程就不一样了，它不像 Serializable 那么严格，它只存放了变量的值，其他的都没有存放。我们看一下实现 Parcelable 的过程。 123456@Overridepublic void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); dest.writeString(type); dest.writeString(accessId);&#125; 可以看到，我们将对象的属性值写入到了 parcel 中。 而 parcel 里面可以理解为有一块内存空间，用来储存这些属性值，还有一个指针指向准备写入的位置，写入一个属性后就往后偏移一段距离。所以读取的时候，一定要按照写入的顺序，否则会出错。 然后在使用 parcel 读取出来： 123456789public Account createFromParcel(Parcel source) &#123; return new Account(source);&#125;public Account(Parcel in) &#123; this.name = in.readString(); this.type = in.readString(); this.accessId = in.readString();&#125; 序列化与反序列化的核心都是 Parcel。 Parcel 的注释上说了，它是消息的容器，可以通过 IBinder 来传输。 我们再来思考一下，Bundle 中的 Serializable 数据是如何传输的。 android.os.Parcel#writeValue 12345else if (v instanceof Serializable) &#123; // Must be last writeInt(VAL_SERIALIZABLE); writeSerializable((Serializable) v); &#125; writeSerializable 里面仍然是调用了 java.io.ObjectOutputStream#writeObject 方法来写对象。 android.os.Parcel#readSerializable(java.lang.ClassLoader) 同样的，读取一个 Serializable 对象的时候，也是通过 java.io.ObjectInputStream#readObject 来获取的，走的是 Java 的序列化与反序列化逻辑。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewModel 与数据保存思考]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FViewModel%20%E4%B8%8E%20setRetainInstance%2F</url>
    <content type="text"><![CDATA[今天在做一个需求的时候，为了用户的体验，我想在进程被回收的时候保存一下数据，等 activity 重新创建的时候再取出来。我之前看过一些文章，关于 ViewModel 的，说是 ViewModel 在屏幕方向发生变化的时候不用重新储存数据（与版本有关系）。我也是看了相关代码，确实是这样。我们可以看看 ViewModel 是如何创建与保存的。 当我们调用 ViewModelProviders.of(this).get(xxx.class);来获取（创建一个）viewModel 的时候： android.arch.lifecycle.ViewModelProvider#get(java.lang.String, java.lang.Class) 123456789101112131415161718public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 可以看到这个方法内部实际上是缓存了 ViewModel 对象的，所以你多次调用get方法，不会创建多个。再看看 key 值： 1DEFAULT_KEY + ":" + canonicalName 可以看到 key 只与 class 有关，所以只要 class 一样，就会获取到同一个对象。 那么，即使屏幕旋转之后，activity创建了新的对象，但是它的 class 是不会变的，所以仍然可以引用到同一个 ViewModel。 嗯，上面是有关activity方向的处理，但是我的需求是内存不足被回收，如果进程都被回收掉了，堆里面的对象就也都被回收了，ViewModel 对象也就不存在了，也就是说，ViewModel 无法满足我的需求。 但是我又想到了一件事，ViewModel 之所以能感知宿主的声明周期，是因为它内部创建了 android.arch.lifecycle.HolderFragment 对象（不了解原理的可以去看 Glide 源码）。而这个对象的构造方法里面有这样的一行代码： android.arch.lifecycle.HolderFragment#HolderFragment 1setRetainInstance(true); 我以前一直对这个方法有误解，没有理解它的真正作用，现在来看看为什么写这个方法： 调用了这个方法的fragment不会随着activity一起被销毁。相反，它会一直保留(进程不消亡的前提下)，并在需要时原封不动地传递给新的Activity。 当设备配置发生变化时，FragmentManager首先销毁队列中fragment的视图（因为可能有更合适的匹配资源）；紧接着，FragmentManager将检查每个fragment的retainInstance属性值。 如果retainInstance属性值为false，FragmentManager会立即销毁该fragment实例。 随后，为适应新的设备配置，新的Activity的新的FragmentManager会创建一个新的fragment及其视图。 如果retainInstance属性值为true，则该fragment的视图立即被销毁，但fragment本身不会被销毁。 为适应新的设备配置，当新的Activity创建后，新的FragmentManager会找到被保留的fragment，并重新创建其试图。 虽然保留的fragment没有被销毁，但它已脱离消亡中的activity并处于保留状态。 尽管此时的fragment仍然存在，但已经没有任何activity托管它。 只有调用了fragment的setRetainInstance(true)方法， 并且因设备配置改变，托管Activity正在被销毁的条件下，fragment才会短暂的处于保留状态。 如果activity是因操作系统需要回收内存而被销毁，则所有的fragment也会随之销毁。 理解了上面的话，现在想一下，为何要保存 fragment 的实例？是因为 android.arch.lifecycle.HolderFragment 1private ViewModelStore mViewModelStore = new ViewModelStore(); 它有这样的一个变量，而这个 ViewModelStore 实际上就是一个 map，它保存它对应的 ViewMode 对象。如果 fragment被回收了，那么这个 ViewModel 肯定也会被回收（没有其他地方引用它了），这样ViewModel就达不到设计的目的了。 所以最终，还是要配合 onSaveInstanceState 来保存数据，因为 onSaveInstanceState 是将数据存到了系统进程中。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MultiDex]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FMultiDex%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[出现的原因Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，其中包含用来运行您的应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内可引用的方法总数限制在 65,536，其中包括 Android 框架方法、库方法以及您自己代码中的方法。 单个Dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。 对于Dex文件，则是将工程所需全部class文件合并且压缩到一个DEX文件期间，也就是使用Dex工具将class文件转化为Dex文件的过程中， 单个Dex文件可被引用的方法总数（自己开发的代码以及所引用的Android框架、类库的代码）被限制为65536。 这就是65536问题的根本来源。 另外还有一种情况，有时候方法数没有达到 65536，并且编译器也正常的完成了编译工作，但是应用在低版本手机安装是异常终止，异常信息如下： 12E/dalvikvm: Optimization failedE/installd: dexopt failed on '/data/dalvik-cache/data@app@com.aprz.test.apk@classes.dex' res = 65433 为什么会出现这种情况呢？其实是这样的，dexopt是一个程序，应用在安装时，系统会通过dexopt 来优化dex文件，在优化的过程中 dexopt 采用一个固定大小的缓冲去来储存应用中的所有方法的信息，这个缓冲区就是 LinearAlloc。LinearAlloc缓冲区在新版本的 Android 系统中其大小时是 8MB 或者 16MB，但是在 Android 2.2和2.3中却只有5MB，当待安装的apk方法数比较多的时候，尽管它没有达到65536的限制，但是它的储存空间仍然有可能超过5MB，这中情况下dexopt程序就会报错。 Android 5.0 之前版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 限制应用的每个 APK 只能使用单个 classes.dex 字节码文件。想要绕过这个限制，就需要使用Google提供的Dalvik 可执行文件分包支持库。 因为Android系统在启动应用时只加载了主dex（Classes.dex），其他的 dex 需要我们在应用启动后进行动态加载安装。 123456789public class MyApplication extends SomeOtherApplication &#123; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // 加载其他的dex文件 // 原理就是：通过反射手动添加其他Dex文件中的class到 ClassLoader 的 pathList字段中，就可以实现类的动态加载 MultiDex.install(this); &#125;&#125; 这个过程一般只在第一次冷启动应用的时候比较耗时，除了要抽取其他的 dex 文件，Dalvik 虚拟机还会使用 dex2oat 将 dex 文件优化成 odex 文件，将生成的文件放在手机的data/dalvik-cache目录下，便于以后使用。以后再次运行时，因为不用再次生成 odex，所以运行速度很快。 Android 5.0 及更高版本的 Dalvik 可执行文件分包支持Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，后者原生支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 classesN.dex 文件，并将它们编译成单个 .oat 文件，供 Android 设备执行。因此，如果您的 minSdkVersion 为 21 或更高值，则不需要 Dalvik 可执行文件分包支持库。只需要在模块级 build.gradle 文件中将 multiDexEnabled 设置为 true，如此处所示： 123456789android &#123; defaultConfig &#123; ... minSdkVersion 21 targetSdkVersion 28 multiDexEnabled true &#125; ...&#125; MultiDex.install 带来的问题当我们使用了分包支持库之后，在运行app时可能会出现这样的错误 java.lang.NoClassDefFoundError出现这个问题的原因是： 在应用启动期间，需要该类，但是这个类不在 MainDex 中，所以解决方案就是将这个类放到 MainDex 中。 具体可以参考官方文档： 声明主 DEX 文件中需要的类 。 dexopt faileddalvik的dexopt程序分配一块内存来统计你的app的dex里面的classes的信息，由于classes太多方法太多超过这个linearAlloc 的限制 。 解决方案就是减少 dex 的大小。 12345678910android.applicationVariants.all &#123; variant -&gt; dex.doFirst&#123; dex-&gt; if (dex.additionalParameters == null) &#123; dex.additionalParameters = [] &#125; dex.additionalParameters += '--set-max-idx-number=48000' &#125;&#125; 启动过程中 ANR启动期间在设备数据分区中安装 DEX 文件的过程相当复杂，如果辅助 DEX 文件较大，可能会导致应用无响应 (ANR) 错误。在此情况下，您应该通过 ProGuard 应用代码压缩以尽量减小 DEX 文件的大小，并移除未使用的那部分代码。 这个是官方给出的建议，但是显然不太合适中国程序员国情，所以需要使用别的方案： 异步加载方案 多进程加载方案 插件化 这两个实现其实差不多，都是提供了一种避免在其他Dex文件未加载完成时，造成的ClassNotFoundException的手段。 分包后 MainDex 仍然爆掉 MainDex 瘦身 自行分包，直接指定哪些类放到 MainDex]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WorkManager 与 LowMemoryKiller 理解]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FWorkManager%E4%B8%8ELowMemoryKiller%2F</url>
    <content type="text"><![CDATA[今天在查看bugly的时候，发现了如下错误：12android.app.RemoteServiceExceptionContext.startForegroundService() did not then call Service.startForeground()发现是由于WorkManager引起的，原因是由于我们刚刚引入了WorkManager，不想对原来的代码改动太大，所以只是将AlarmManager替换成了WorkManager。 但是我突然想到，既然已经使用了WorkManager，它能保证任务的执行，那为啥还要启动Service呢？不是多次一举吗！ 现在我们来从头理一下，为啥我们需要在Service里面启动线程？ Android是基于linux内核的系统，但是它与其他基于linux内核的系统有一个不同之处，就是它没有“交换空间”。 交换空间的作用：当 RAM 满了之后，而系统还需要额外的内存空间，系统会将内存中的相对不经常使用的内存页放入到硬盘上，腾出位置给正在运行的应用程序。 取而代之的，它使用 OOM Killer 来管理内存。 OOM Killer 的目标是通过基于其“可见性状态”和消耗的内存量来杀死进程来释放内存。 ActivityManager 会给每个进程一个 oom_adj 值，这个值越大，表示该进程的优先级越低。比如，前台进程的优先级就是0。 12345678910# Define the oom_adj values for the classes of processes that can be# killed by the kernel. These are used in ActivityManagerService. setprop ro.FOREGROUND_APP_ADJ 0 setprop ro.VISIBLE_APP_ADJ 1 setprop ro.SECONDARY_SERVER_ADJ 2 setprop ro.BACKUP_APP_ADJ 2 setprop ro.HOME_APP_ADJ 4 setprop ro.HIDDEN_APP_MIN_ADJ 7 setprop ro.CONTENT_PROVIDER_ADJ 14 setprop ro.EMPTY_APP_ADJ 15 Android 中，存在着一张内存阈值表，这张阈值表是可以在 init.rc 中进行配置的，合理配置这张表，对于小内存设备有非常重要的作用。我们来看 lowmemorykiller.c 中这张默认的阈值表： 1234567891011121314static int lowmem_adj[6] = &#123; 0, 1, 6, 12,&#125;;static int lowmem_adj_size = 4;static int lowmem_minfree[6] = &#123; 3 * 512,/* 6MB */ 2 * 1024,/* 8MB */ 4 * 1024,/* 16MB */ 16 * 1024,/* 64MB */&#125;;static int lowmem_minfree_size = 4; 这个表的意思是： 当系统的可用内存小于6MB时，警戒级数为0；当系统可用内存小于8M而大于6M时，警戒级数为1；当可用内存小于64M大于16MB时，警戒级数为12。 比如，当 LMK 被触发的时候，发现系统的内存只剩下了 7M，那么查找上面的表会发现，警戒级数为 1。那么 LMK 会开始遍历系统所有进程，过程如下： 123456789101112131415161718192021for (遍历所有进程) &#123; if (p is 内核进程) &#123; continue; &#125; if (p.oom_score_adj &lt; 警戒值) &#123; continue; &#125; if (有被选中的进程) &#123; if (当前进程的 oom_score_adj 比选中进程的小) &#123; continue; &#125; if (当前进程的 oom_score_adj 等于选中进程的小 &amp;&amp; 当前进程占用的内存小) &#123; continue; &#125; &#125; 选中当前进程&#125; 可以看出如下结论： 内核线程不参加这个杀进程的游戏进程的 oom_score_adj 越大越危险进程的 oom_score_adj 相同的情况下，占用内存越大越危险 Low memory killer的规则就是根据当前系统的可用内存多少来获取当前的警戒级数，如果进程的oom_adj大于警戒级数并且最大，进程将会被杀死（具有相同omm_adj的进程，则杀死占用内存较多的）。omm_adj越小，代表进程越重要。一些前台的进程，oom_adj会比较小，而后台的服务，omm_adj会比较大，所以当内存不足的时候，Low memory killer必然先杀掉的是后台服务而不是前台的进程。 所以，我们要使用 Service 的原因： 我们需要执行一个长时间运行的操作，所以需要一个比较低的 oom_adj 值 （服务进程比后台进程值小） 可以单独开启一个进程 但是随着Android版本的升级，使用 Service 会带来一些其他的问题： 电量消耗 开发人员可以在后台做任何他们想做的事情，没有任何限制。 所以Google搞了一个Doze模式： 简而言之 - 在用户关闭设备屏幕后，Doze 模式启动并禁用网络，同步，GPS，警报和wifi扫描。直到用户打开屏幕或连接到充电器。这是为了 - 减少执行不重要工作的应用程序的数量，并且这样做 - 节省了用户的电量 使用限制 从 API 26 开始，如果应用的 targetSdkVersion 在 26 以上，在后台进程里面调用 startService 方法会抛出 IllegalStateException。 说了这么多，得出一个结论：苍天已死，黄天当立。 既然Service已经不再能够实现它的主要目的（在后台长时间的运行任务），所以最好就不要在使用它了。 WorkManager ： Just because work should be easy to do. WorkManager可以简化开发人员的工作，它提供了一流的api。 它适用于即使应用程序不再位于前台也应运行的后台作业。 在可能的情况下，它使用JobScheduler或Firebase JobDispatcher来完成工作。 如果你的应用程序在前台，它甚至会尝试直接在你的进程中完成工作。 WorkManger 的使用可以查看最后面的官方文档，讲的非常详细，这里并不介绍。 WorkManger 的体系结构如下： 可以看到，WorkManger 在 enqueue work 的时候，将 work 保存到了数据库中（使用 room），用于满足条件之后再执行。所以，如果遇到报数据库相关的错误，而你的项目又没有相关代码，记得检查这里。 # 参考文档Services. The life with/without. And WorkManager. Android low memory killer 机制 Schedule tasks with WorkManager Location all the time with WorkManager!!]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent 数据传输限制]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FIntent%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[当我们启动一个Activity的时候，这个过程是需要与AMS进行进程之间通信的。启动 Activity 的时候，需要使用Intent，所以我们在intent中携带的数据也要从APP进程传输到AMS进程，再由AMS进程传输到目标Activity所在进程。通过阅读 Activity 的启动过程，我们知道app与AMS 的进程通信是使用Binder来完成的，看一张图： 普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 (1x1024x1024) - (4096 x2) ，但是由于Intent中还有其他的信息，所以能够放入的数据肯定比这个值还要小。 这个限制定义在frameworks/native/libs/binder/processState.cpp类中： 1#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) 如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的。 PS：注意上面的图：Binder进行数据传递的时候，只需要一次数据拷贝。 这是因为Binder借助内存映射，在内核空间和接收方的用户空间的数据缓存区做了一层内存映射。也就是说，在发送方将数据拷贝到内存空间的时候，内核空间的这部分地址同时也会被映射到接收方的内存缓存中，这样子，就少了一次从内和空间拷贝到用户空间。 代替方案 写入临时文件或者数据库，通过FileProvider将该文件或者ContentProvider通过Uri发送至目标。一般适用于不同进程，比如分离进程的UI和后台服务，或不同的App之间。之所以采用FileProvider是因为7.0以后，对分享本App文件存在着严格的权限检查。 因为 ContentProvider 是使用匿名共享内存来交换数据的，所以没有限制。 同一个进程中，通过单利来传递数据。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 无障碍服务]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FAndroid%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[由于某种原因，我们需要屏蔽某些界面上的无障碍服务的使用，刚开始我以为是做不到的。因为我们的思路出了问题，就直接想着要去停止系统的这个服务。但是经过一番搜索之后，没有发现任何结果。官方文档也说了： The lifecycle of an accessibility service is managed exclusively by the system and follows the established service life cycle. 无障碍服务是只由系统管理的。 然后我就又开始搜索其他方面的资料，比如：无障碍的原理与使用。巧合的是，我搜索到了这篇文章： 随手记Android无障碍实践 看着看着，我发现这是一篇关系如何优化自己的App，让应用可以被障碍人士使用的文章。当我失望的准备关掉页面的时候，突然我想到了，既然他能优化使用，那我是不是能做一个反优化，让它不能使用呢！！！ 于是，我仔细的看了文章，果然找到了一个令我感兴趣的东西。 在它们改造非标准组件的选中状态的时候，是这样做的： 给控件添加无障碍代理（AccessibilityDelegate），在onInitializeAccessibilityNodeInfo()方法中调用AccessibilityNodeInfo对象的setChecked方法设置选中状态。 12345678rootView.setAccessibilityDelegate(new View.AccessibilityDelegate() &#123; @Override public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(host, info); info.setCheckable(true); info.setChecked(itemData.isSelected()); &#125;&#125;); 看到没有，View 是可以设置一个关于无障碍的代理的。 既然可以设置代理，那么思路就很清晰了，一个好的代理，可以省很多事，但是我也可以搞一个吊都不吊你的代理。 在设置了一个代理之后，在用我们自己写的无障碍app测试的时候，果然无效了，而且自动化测试也失效了，效果还是可以的，对原来的逻辑也基本没有影响。 后来，我又找了一些关系 AccessibilityService 的文章，也看官方文档的东西，总算对这个东西有了一个整体的了解。贴一个比较有趣的图： 这个图讲的是 AccessibilityEvent 事件产生后是如何发送到 AccessibilityService 的。 刚开始，我有点无法理解这个图，因为我对无障碍的理解，最初是从抢红包开始的，总觉得它是一个可以用来在别的App里面搞一些操作的东西。所以我总搞不明白为啥事件是从 App 里面传到 Service 里面，而不是 Service 传递到 App 里面，如果不是这样，它是怎么点别的 App 里面的东西的呢？？？ 在我看完了官方文档，我才知道能够点击别的App的方法是在后来才加进去的，原本是没有这些操作的。也就是说 AccessibilityService 最初涉及出来是用来做一些辅助操作的，比如我们有一个 App，我们可以在这个 App 里面自己实现一个 AccessibilityService，当用户点击了某个按钮的时候，我们就可以提示用户你点击了啥按钮，你点击的按钮是啥颜色的等等…，这样的话事件的传递才是有用的，正确的。 后面加入的按钮点击操作，应该与 AccessibilityEvent 无关。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 应用是如何编译与运行的]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%80%9D%E8%80%83%2FAndroid%20%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Android Studio 负责如何构建与部署我们的应用。但是你有没有想过当你按下Run按钮时发生了什么？构建Java compilation我们的代码是用Java编写的。但是，Java代码的编译和运行方式与Web应用程序相同吗？Android应用程序的编译过程与其他Java应用程序有很大不同。但是它们的开始过程都是一样的： 使用javac命令将Java源代码文件编译为.class文件。 它会将下面的java代码： 1234public MainActivity() &#123; super(); currentPosition = 0;&#125; 转换成这样的java字节码： 12345678public com.hfad.bitsandpizzas.MainActivity(); Code: 0: aload_0 1: invokespecial #5; //Method android/app/Activity.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: iconst_0 6: putfield #3; //Field currentPosition:I 9: return Conversion to Dalvik bytecodes.class文件包含标准的Oracle JVM Java字节码。但Android设备不使用此字节码格式。相反，Android有自己独特的字节码格式，称为Dalvik。 Dalvik字节码，与Oracle JVM字节码一样，是理论处理器的机器代码指令。 编译过程需要将.class文件和任何.jar库转换为包含Dalvik字节码的单个classes.dex文件。这是通过dx命令完成的： dx命令将所有.class和.jar文件拼接成一个以Dalvik字节码格式编写的classes.dex文件。 1230x0000: iput-object v1, v0, Lcom/hfad/bitsandpizzas/MainActivity; com.hfad.bitsandpizzas.MainActivity$2.this$0 // field@48690x0002: invoke-direct &#123;v0&#125;, void java.lang.Object.&lt;init&gt;() // method@136820x0005: return-void Put classes.dex and resources into a package file然后将classes.dex文件和应用程序中的资源（如图像和布局）压缩为类似zip的文件，称为Android Package或.apk文件。这是通过 Android Asset Packaging Tool 或 aapt 完成的： 这个步骤完成之后，.apk文件就可以安装了。但是，还有一个步骤需要做… You might then also sign the .apk file如果想要通过Google Play商店分发应用，则需要对其进行签名。对应用程序包进行签名意味着您在.apk中存储了一个附加文件，该文件基于.apk内容的校验和以及单独生成的私钥。 .apk文件使用标准的jarsigner工具，该工具是Oracle Java Development Kit的一部分。创建jarsigner工具是为了签署.jar文件，但它也可以使用.apk文件，因为它们也是压缩文件。 如果您对.apk文件进行签名，则还需要通过名为zipalign的工具运行它，这将确保文件的压缩部分在字节边界上排列。 Android希望它们按字节对齐，以便它可以轻松读取它们而无需解压缩文件。 网上还有上面所有步骤的详细图： 部署The adb server starts if it’s not already running该应用程序将通过Android Debug Bridge部署到Android设备。 在我们的开发端上开启一个 adb 服务进程，在 Android 设备上开启一个类似的 adb 服务（adbd）。 如果您的计算机上未运行adb进程，则adb命令将启动它。 adb进程将打开网络套接字，并在端口5037上侦听命令。您输入的每个adb命令都会将其指令发送到此端口。 The .apk file is transferred to the deviceadb命令用于将.apk文件传输到Android设备上的文件系统中。该位置由应用程序的包名定义。 因此，例如，如果包是com.hfad.bitsandpizzas，则.apk文件将放在/data/app/com.hfad.bitsandpizzas中。 运行Android应用程序的运行方式最近发生了变化。 从API级别21开始，旧的Dalvik虚拟机已被新的Android Runtime取代。 让我们看一下应用程序运行时一步一步发生的事情。 A user asks for an app to be launched一个名为Zygote的过程用于启动应用程序。 Zygote是Android进程的不完整版本 —— 其内存空间包含任何应用程序所需的所有核心库，但它尚未包含特定于特定应用程序的任何代码。 Zygote使用fork系统调用创建自己的副本。 Android是一个Linux系统，fork调用可以很快复制像Zygote这样的进程。这就是使用Zygote进程的原因：复制像Zygote这样的半启动进程比从主系统文件加载新进程要快得多。 Zygote意味着您的应用程序启动速度更快。 Android converts the .dex code to native OAT format新的app进程现在需要加载我们的应用程序的代码。请记住，您的应用代码存储在.apk包中的classes.dex文件中。因此，会从.apk中提取classes.dex文件并放入一个单独的目录中。但是，不是简单地放置classes.dex文件的副本，Android会将classes.dex中的Dalvik字节码转换为本机机器码。 所有以Java代码开头的代码现在都转换为一段本机编译代码。从技术上讲，classes.dex将转换为ELF共享对象。 Android调用此库格式OAT，转换classes.dex文件的工具称为dex2oat。（Android 5.0 开始，dex -&gt; oat 这个转换过程发生在安装过程中） 转换后的文件存储在如下的目录中： 1/data/dalvik-cache/x86/data@app@com.hfad.bitsandpizzas@base.apk@classes.dex 该路径将包含应用程序的包名称，以确保它不会覆盖任何其他应用程序。 转换后的代码将在特定于Android设备CPU的机器代码中。例如，如果Android设备是x86，则OAT文件将如下所示： 123456789100x001db888: 85842400E0FFFF test eax, [esp + -8192]suspend point dex PC: 0x0000GC map objects: v0 (r5), v1 (r6)0x001db88f: 83EC1C sub esp, 280x001db892: 896C2410 mov [esp + 16], ebp0x001db896: 89742414 mov [esp + 20], esi0x001db89a: 897C2418 mov [esp + 24], edi0x001db89e: 8BF8 mov edi, eax0x001db8a0: 890424 mov [esp], eax... The app loads the native library然后将 native library 直接映射到应用程序进程的内存中。 此时开始，应用程序将启动初始界面，应用程序将出现在屏幕上。]]></content>
      <tags>
        <tag>Android-思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义LayoutManager]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2F%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%2F</url>
    <content type="text"><![CDATA[在做了这么长时间的Android开发，还没有遇到过这个需求，不过看了别人的很多效果，感觉很棒，所以找了时间就研究了一下，现在做一些记录，等以后有了相关需要可以快速回顾。在我学习的过程中，不可避免的遇到了很多问题，有的已经解决，有的还未解决，所以这个 Demo 就是看个乐呵吧。自定义一个 LayoutManager 整体给我的感觉是与实现自定义 ViewGroup 的 onLayout 比较像。其他的测量绘制方法都不需要我们实现，测量方法还有很多可以直接使用的： 12androidx.recyclerview.widget.RecyclerView.LayoutManager#measureChildandroidx.recyclerview.widget.RecyclerView.LayoutManager#measureChildWithMargins 这两个方法可以测量 child 的大小，一个不计算 child.layoutParams，一个计算。 测量完成之后，我们就可以获取 child 的大小了： 12androidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredWidthandroidx.recyclerview.widget.RecyclerView.LayoutManager#getDecoratedMeasuredHeight 这里不直接使用 child.getMeasureWidth 显然是因为 RecyclerView 是有一个 ItemDecorate 可以设置，不设置就是获取的 getMeasureWidth 的值。 更完美的是，layout child 的时候，也有相应的方法： 1androidx.recyclerview.widget.RecyclerView.LayoutManager#layoutDecoratedWithMargins 使用这个方法，我们就可以将 child 摆到我们想要摆放的位置了，我们只需要传递四大金刚的位置：l,t,r,b。网上看到一个效果就是，它计算出某个 path 的所有点，然后存起来，根据滚动的距离，来取相应的点，然后根据这个点以及child的大小，就可以将这个 child 摆到 path 的路径上，实现一个 item 跟随 path 的效果。只要想清楚了还是不难的。 了解这些，我们还需要了解一下 RecyclerView 的回收机制，因为 RecyclerView 最吊的地方就是回收复用，如果你搞了一个 LayoutManager 但是却无法回收复用，那岂不是很沙雕，关于回收这里就不仔细讲了，看[我的另一篇文章](https://github.com/aprz512/blog4aprz512/blob/master/Blog/Android-View/RecyclerView 的缓存机制.md) 吧。 有了上面这些基础，我们就可以开始动手写了。 首先，我们需要确定我们想要的效果，我们先看一下这个效果图： 可以看到： 最左边，是有几个 item 堆在一起了的，那么是怎么实现的呢，其实就是 layout 的时候将 item 之间摆进一点就好了。比如：item 的宽度是 100，高度是 150，第一个item的位置为 【（0，0），（100， 150）】，第二个 item 的位置（假设 item 的 divider 宽度为 0）为 【（100, 0），（200, 150）】。但是我在摆第二个 item 的时候，我偏不从 100 开始摆，我从 20 开始摆，那么第二个 item 就叠在第一个 item 上面了。 右边的就简单了，按照通常的摆法就好了，不搞啥幺蛾子。 对效果了然于胸，我们就可以开始敲代码了，首先自然是继承父类： androidx.recyclerview.widget.RecyclerView.LayoutManager#LayoutManager 它只有一个抽象方法： 123456override fun generateDefaultLayoutParams(): LayoutParams &#123; return LayoutParams( LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT )&#125; 首先，网上一致都是这样实现的，我就很蛋疼了，都不说为什么。 然后，我就去查看了注释，它是这样说的：为 RecyclerView 的 child 生成一个默认的 LayoutParams。那么为何要生成一个默认的 LayoutParams 呢？比如，有的同学在 Adapter 里面加载布局的时候，parent 会传 null，这个时候 child 的就是没有 LayoutParams 的，所以需要生成一个。同样的，PopupWindow 也会遇到。这里我就清楚了，传递 WRAP_CONTENT 是一个保险行为，有最好，没有就使用这个。 注释还说了，这个返回的是 RecyclerView.LayoutParams，所以如果你还想带一些自带的信息在 LayoutParams 里面，你可以继承这个 LayoutParams，然后实现下面3个方法： 123androidx.recyclerview.widget.RecyclerView.LayoutManager#checkLayoutParamsandroidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.view.ViewGroup.LayoutParams)androidx.recyclerview.widget.RecyclerView.LayoutManager#generateLayoutParams(android.content.Context, android.util.AttributeSet) 就 OK 了。 搞定了唯一的一个抽象方法，我们就可以正常运行了，但是没啥效果，我们还需要实现 child 的摆放与回收。首先我们搞定 child 的摆放。child 的摆放是在 androidx.recyclerview.widget.RecyclerView.LayoutManager#onLayoutChildren 这个方法里面。我们复写一下： 123override fun onLayoutChildren(recycler: Recycler?, state: State?) &#123; super.onLayoutChildren(recycler, state)&#125; 好奇的点进去看看父类做了什么： 123public void onLayoutChildren(Recycler recycler, State state) &#123; Log.e(TAG, "You must override onLayoutChildren(Recycler recycler, State state) ");&#125; 嗯，他要我们必须重写这个方法，但是又不是抽象的方法，嗯…有趣的女人… 一开始，我是完全不知道应该怎么搞了，所以我看了别人的 demo，发现他们都在最开头搞了这样的一个开头： 123456789// 这个方法看不出来有啥意义啊，应该是根据// androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren// copy 出来的if (state?.itemCount == 0) &#123; recycler?.apply &#123; removeAndRecycleAllViews(this) &#125; return&#125; 嗯，我是很奇怪的，为啥要写这个玩意啊，后来我戳到 LinearLayoutManager 学习了一下，发现它有一个类似的代码，但是它是嵌套在 if 里面的： 123456if (mPendingSavedState != null || mPendingScrollPosition != RecyclerView.NO_POSITION) &#123; if (state.getItemCount() == 0) &#123; removeAndRecycleAllViews(recycler); return; &#125;&#125; 这里，我是真的没有搞懂哦。除非是 itemCount 突然变成 0 了，那么需要将所有 child 都移除并且放到 recycler 里面，但是为啥 LinearLayoutManager 是有条件的呢？？？嗯，猜一下与动画相关吧… 好的，我们继续往下，这里只不过是一个前置处理，处理某些特殊情况，下面我们开始摆放 child，为了方便我们写一个方法： 123456789101112131415override fun onLayoutChildren(recycler: Recycler?, state: State?) &#123; super.onLayoutChildren(recycler, state) // 这个方法看不出来有啥意义啊，应该是根据 // androidx.recyclerview.widget.LinearLayoutManager.onLayoutChildren // copy 出来的 if (state?.itemCount == 0) &#123; recycler?.apply &#123; removeAndRecycleAllViews(this) &#125; return &#125; layoutChildren(recycler, state)&#125; 这样看着会舒服一点，一般我不知道咋下手的时候，就会抽一个方法出来，把能写的都写了，至少思路清晰。 开始摆放 child，我们需要计算出第一个 item 的 left： 1var left = paddingLeft 嗯，很简单。 这个时候，就有一个问题浮现出来了，我们的每个 item 是一样大吗？？？ 如果是的话，好说，但是 RecyclerView 就成了岳不群了。如果不是的话，那就复杂了。这里为了简单，我们要求 item 是一样的，毕竟，不一样大也没法堆叠。所以其实仔细想想，实现一个看起来特别酷的效果，限制也很多。 我们定义两个索引值，一个指向屏幕上的第一个 item，一个指向屏幕上的最后一个 item 的后一个位置，就像一个半开区间。 12private var firstVisiblePos = 0private var lastVisiblePos = 0 然后，我们随便取一个 item，测量一下它的大小： 123456// 需要每个child一样大小val firstView: View = recycler.getViewForPosition(firstVisiblePos)measureChildWithMargins(firstView, 0, 0)unitDistance = getDecoratedMeasuredWidth(firstView) + gap// 这个时候，还没有开始摆放，所以用完了再放回去，为了后面的逻辑统一处理recycler.recycleView(firstView) 这里的逻辑很简单，算出 child 的大小，加上 item 之间的距离，算作一个单元距离，就是一个item从一个位置移动到相邻位置的绝对距离。 这里要说的一个重要的点就是，如果我们需要摆一个 child，只能像 recycler 要，并且，用完了还给 recycler，这样我们神不知鬼不觉的就达成了复用的效果。 接着，我们根据滚动的距离来计算出第一个item的索引： 12// 根据 scroll 的距离来计算 firstPos 的位置firstVisiblePos = floor(abs(scrollX).toDouble() / unitDistance).toInt() 这里，我们也可以利用 RecyclerView 的宽度算出 lastVisiblePos 的值，但是就有点重复了，我们在摆放 child 的时候去动态的计算会更好一点，所以这里，我们将 lastVisiblePos 赋值为 itemCount。 12// 该值会动态更新lastVisiblePos = state.itemCount 计算好了两个索引值，我们还需要处理一个问题，就是根据滚动的距离来计算出 View 的偏移距离。 123val frac: Float = (abs(scrollX) % unitDistance) / (unitDistance * 1f)val stackOffset = (frac * stackGap).toInt()val viewOffset = (frac * unitDistance).toInt() unitDistance 是相邻item的单位距离，frac就表示移动到的百分比。利用这个百分比换算出堆叠区域和普通区域布局起始位置的偏移量，然后可以开始布局了。 1234567// 属于堆叠区域if (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123; // 手指向左滑动，则 scrollX 的值会越来越大，frac 也会慢慢变大（0 -&gt; 1 为一个周期） // item 会向右移动 // 这里需要减去，item 才会向左移动 left -= stackOffset&#125; 这里又有几个问题： 这个 layoutManager 一初始化就会堆叠起来，导致前面几个的内容看不到了， 解决办法就是做出一个无限循环的效果，这样就会对数目有所限制，至少是知道有多少数据，或者是做成动态的，一开始不会堆叠， 滑动的时候再考虑如何堆叠。 stackOffset 只需要减去一次，后面的 item 不用重复减去该值，这里我使用了笨办法，搞一个变量标识一下 1234567if (i - firstVisiblePos &lt; MAX_STACK_COUNT) &#123; if (!stackOffsetDone) &#123; left -= stackOffset stackOffsetDone = true &#125; left += stackGap&#125; 这个 left 就是 child 布局时用到的值了。对于非堆叠区域同样处理。 后面的代码就简单了： 123456789val view = recycler.getViewForPosition(i)addView(view)measureChildWithMargins(view, 0, 0)val l = leftval t = paddingTopval r = l + getDecoratedMeasuredWidth(view)val b = t + getDecoratedMeasuredHeight(view)layoutDecoratedWithMargins(view, l, t, r, b) 把上面的这些逻辑放入循环就搞定了。 这里效果基本就实现了，但是实际上测试的时候会发现，回收复用会有问题。这个有两个方面的问题： 在 layout 的时候需要将所有 view 全部 detach 再重新布局 detach 的 view 被放入了 scrap 中，我们需要将 scrap 中残留的 item 全部放入 pool 中。 所以，我们可以不用自己一个一个的手动回收，而是可以这样： 在 layout 的前面调用 detachAndScrapAttachedViews ，然后在最后回收。 1234567891011121314151617181920private fun layoutChildren( recycler: Recycler?, state: State?) &#123; if (recycler == null || state == null) &#123; return &#125; detachAndScrapAttachedViews(recycler) ... val scrapList = recycler.scrapList for (i in scrapList.indices) &#123; val holder = scrapList[i] removeAndRecycleView(holder.itemView, recycler) &#125;&#125; 实际上我测试的效果比之前好了很多，但是我还是不太满意，因为有的时候还是会出现 createViewHolder 的调用，虽然次数极少，但是肯定是哪里出了问题，不然是不会这样的。 所以建议还是手动的一个个标记回收。我也对回收这个问题还有疑问，所以这里就不说下去了。 除了回收还有一个问题，就是关于 fling 效果。我测试这个demo 的时候，发现我从最后一个一下滑动到第一个的时候，item停留的位置总是不对，我一直以为是我的计算有问题： 1234567891011121314151617181920212223242526272829303132333435363738/** * dx(dy) 表示本次较于上一次的偏移量，&lt;0为 向右(下) 滚动，&gt;0为向左(上) 滚动； * 这个算法还是无法满足 fling 的要求，fling 的时候 停留的位置不对 * 查了一些资料，可能还需要自定义一个 SnapHelper -&gt; https://www.jianshu.com/p/0e4a93d8e2de */private fun consume(dx: Int): Int &#123; val consumed: Int // dx &lt; 0 表示向右滚动，需要显示左边的内容 if (dx &lt; 0) &#123; // 到了最左边 if (scrollX + dx &lt; 0) &#123; consumed = if (scrollX &gt; 0) &#123; dx - scrollX &#125; else &#123; 0 &#125; scrollX = 0 return consumed &#125; &#125; // dx &gt; 0 表示向左滚动，右边的内容需要显示出来 if (dx &gt; 0) &#123; if (scrollX + dx &gt; maxScrollX) &#123; consumed = if (scrollX &lt; maxScrollX) &#123; maxScrollX - scrollX &#125; else &#123; 0 &#125; scrollX = maxScrollX return consumed &#125; &#125; scrollX += dx return dx&#125; 但是，经过我的打印，发现，这个计算是没有问题了。 顺便说一下，要想滑动，需要重写 LayoutManager 的方法： 123override fun canScrollHorizontally(): Boolean &#123; return true&#125; 然后，在 scrollHorizontallyBy 返回消耗的值： 12345678910override fun scrollHorizontallyBy(dx: Int, recycler: Recycler?, state: State?): Int &#123; if (dx == 0 || state?.itemCount == 0) &#123; return 0 &#125; layoutChildren(recycler, state) return consume(dx)&#125; 我就感觉这个与 NestedScrolling 接口很相似。 跑题了，关于 fling，查了一些资料，可能还需要自定义一个 SnapHelper -&gt; https://www.jianshu.com/p/0e4a93d8e2de。 当然你也可以自己监控滑动状态，然后自动的调整滑动位置，就像画廊一样。 项目地址： https://github.com/aprz512/LayoutManagerDemo]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值器与估值器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2F%E6%8F%92%E5%80%BC%E5%99%A8%E4%B8%8E%E4%BC%B0%E5%80%BC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[想来了解以下动画的定义： 动画是指由许多帧静止的画面，以一定的速度（如每秒16张）连续播放时，肉眼因视觉残象产生错觉，而误以为画面活动的作品。 Android中的动画也遵循这个原理，只不过它的每一帧都是通过插值器与估值器动态计算出一个矩阵，然后应用到控件上得到的。在计算的过程中，插值器负责计算动画执行的百分比，估值器负责根据百分比来计算属性值。 举个例子： 12ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100);valueAnimator.setDuration(1000); 这里，我们以 ValueAnimator 举例，做一个值动画，让 1 在 1000ms 内匀速变到 100。 假设这个动画有11帧，那么在第一帧的时候，是保持原来的位置不动，随着时间的流逝，在过了100ms之后，来到了第2帧，这个时候插值器就派上用场了。根据匀速运行的计算，在 100ms 的时候，动画应该执行了 10%，所以会出现一个时间 t 与动画值的函数： f(t) = t / duration * 100 记住这个函数，后面的东西都是围绕它来的 让我们看看线性插值器的代码，来对比一下： android.view.animation.LinearInterpolator#getInterpolation 12345 public float getInterpolation(float input) &#123; return input; &#125;// 转换成函数就是 f(x) = x，这个f(x) 相当于上面函数的 t / duration// 也就是说，这里只是计算了动画执行的百分比，还没有计算到动画的具体值 这里的 input 参数，表示的是时间的流逝百分比，它返回的是动画执行的百分比。 这与上面的 f(t) 函数的意义是一样的，只不过 f(t) 的参数是 t， 而 getInterpolation 的参数是 t/duration。 回想一下，刚接触函数的时候，f(x) = x 这个函数，就是一条直线，所以这个插值器叫线性插值器。 我们再来看看加速插值器的代码： android.view.animation.AccelerateInterpolator#getInterpolation 1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 这里我们只考虑 mFactor == 1.0f 的情况，所以有这样的一个函数 f(x) = x * x 。 那么这个函数是什么意思呢？首先，输入范围是 【0，1】，经过函数变换之后，还是【0，1】。这个是很重要的，虽然你可以返回大于1或者小于0的值，但是大于1的会被当成最后一帧处理，小于0的作为第一帧处理。具体请看 android.animation.KeyframeSet#getValue 这个方法。 再回想一下 f(x) = x * x 这个函数的图像，在【0，1】的范围，它的斜率是从低到高的，所以表现出来的就是一个加速行为。想不通的可以这样想，在前面的 【0， 0.5】 的范围内，f(x) 的值从0只增加到了0.25，而在后面的【0.5，1】的范围内，f(x) 的值从 0.25 增加到了 1，所以是增加的速度越来越快。 那么，这里我们自定义一个插值器： 123public float getInterpolation(float input) &#123; return 1 - input;&#125; 猜猜，它会是一个什么样的行为？其实就是一个反向的线性插值器，比如，从 1 到 100，这个插值器会从 100 变到 1。 再看估值器，一般的我们很少会自定义估值器，除非有特殊的需要，比如计算颜色，颜色的算法不像数值的计算，按照百分比乘一下就完事了，因为颜色涉及到 RGB 3个值，所以需要将 RGB 分开来计算。 我们还是看看自带的几个估值器的代码。 先看简单的 int 估值器，这个我们也能写出来，动画的百分比知道了，需要变化的范围我们也知道，用百分比乘以变化范围再加上起始值就ok了。 android.animation.IntEvaluator#evaluate 12345 public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 嗯，和我们想的一摸一样，下一个。 看看 ARGB 的估值器： android.animation.ArgbEvaluator#evaluate 123456789101112131415161718192021222324252627282930313233343536public Object evaluate(float fraction, Object startValue, Object endValue) &#123; int startInt = (Integer) startValue; float startA = ((startInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float startG = ((startInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float startB = ( startInt &amp; 0xff) / 255.0f; int endInt = (Integer) endValue; float endA = ((endInt &gt;&gt; 24) &amp; 0xff) / 255.0f; float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f; float endG = ((endInt &gt;&gt; 8) &amp; 0xff) / 255.0f; float endB = ( endInt &amp; 0xff) / 255.0f; // convert from sRGB to linear startR = (float) Math.pow(startR, 2.2); startG = (float) Math.pow(startG, 2.2); startB = (float) Math.pow(startB, 2.2); endR = (float) Math.pow(endR, 2.2); endG = (float) Math.pow(endG, 2.2); endB = (float) Math.pow(endB, 2.2); // compute the interpolated color in linear space float a = startA + fraction * (endA - startA); float r = startR + fraction * (endR - startR); float g = startG + fraction * (endG - startG); float b = startB + fraction * (endB - startB); // convert back to sRGB in the [0..255] range a = a * 255.0f; r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f; g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f; b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f; return Math.round(a) &lt;&lt; 24 | Math.round(r) &lt;&lt; 16 | Math.round(g) &lt;&lt; 8 | Math.round(b);&#125; 嗯，看上去代码很多，但是我们这里取 R 来分析，G、B 是一样的。 123456789101112131415// 拿到起始颜色值的16-24位float startR = ((startInt &gt;&gt; 16) &amp; 0xff) / 255.0f;// 拿到终止颜色值的16-24位float endR = ((endInt &gt;&gt; 16) &amp; 0xff) / 255.0f;// 将起始颜色与终止颜色转化为线性的，便于用百分比计算startR = (float) Math.pow(startR, 2.2);endR = (float) Math.pow(endR, 2.2);// 这里我们就很熟悉了，与 int 是一样的float r = startR + fraction * (endR - startR);// 再将线性的转回 RGBr = (float) Math.pow(r, 1.0 / 2.2) * 255.0f; 这样一看，是不是条理很清晰。 总结一下： 插值器负责计算动画执行的百分比 估值器起始就是根据动画的百分比、动画变化量（插值器计算得到的）来计算动画值，如果不能直接计算的，需要转换一下再计算。嗯，就这么多。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewGroup 的 generateLayoutParams 方法的作用]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FViewGroup%20%E7%9A%84%20generateLayoutParams%20%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[不知道大家在编写布局的时候有没有这样的疑问：在 RelativeLayout 布局里面可以对子控件使用 layout_alignParentRight 等属性，但是在 FrameLayout 或者 LinearLayout 中就没有，这是为什么呢？12345678910&lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentRight="true" /&gt;&lt;/RelativeLayout&gt; 而且，在代码中，我们获取子控件的 LayoutParams 的时候，默认是 ViewGroup.LayoutParams 类型的，我们想要使用某些特殊的字段，还需要转换为 RelativeLayout.LayoutParams 或其他具体的 LayoutParams 才行。这又是为什么呢？ 下面，我们一一道来。 当我们自定义一个控件的时候，如果我们做的灵活一点，一般会提供一些属性配置方法。 1234567891011121314public TagGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TagGroup); int targetColorInt = typedArray.getInt(R.styleable.TagGroup_targetColor, 0); if (targetColorInt != 0) &#123; targetColor = context.getResources().getColor(targetColorInt); &#125; else &#123; targetColor = Color.WHITE; &#125; typedArray.recycle();&#125; 在 attrs.xml 中配置： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="TagGroup"&gt; &lt;attr name="targetColor" format="integer"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 但是使用这种方式的话，不管你在什么 ViewGroup 下使用，它都有这个属性。而且，在xml中，这个属性只能给自己用，无法给它的子控件使用。 显然，RelativeLayout 没有使用这种方式。那它是怎么做的呢？答案是通过复写 ViewGroup 的 generateLayoutParams 方法实现的。 这里我们据一个例子来说明，我们自定义一个控件： com.aprz.myapplication.MyViewGroup 1234567891011class MyViewGroup @JvmOverloads constructor( context: Context, attributeSet: AttributeSet? = null, defStyleAttr: Int = 0) : ViewGroup(context, attributeSet, defStyleAttr) &#123; override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) &#123; // TODO("not implemented") &#125; &#125; 由于我们关注的重点不在控件的功能，所以我们不重写 onLayout 方法。这里我们需要重写的是它的 generateLayoutParams 方法： com.aprz.myapplication.MyViewGroup#generateLayoutParams 123override fun generateLayoutParams(attrs: AttributeSet?): LayoutParams &#123; return MyLayoutParams(context, attrs)&#125; 这里我们返回了我们自己创建的 MyLayoutParams 对象。它的实现如下： com.aprz.myapplication.MyViewGroup.MyLayoutParams 123456789101112131415161718class MyLayoutParams(context: Context, attrs:AttributeSet?) : ViewGroup.MarginLayoutParams(context, attrs) &#123; private var stayLeft : Int = 0 private var stayRight : Int = 0 init &#123; val a = context.obtainStyledAttributes( attrs, R.styleable.MyViewGroup_Layout ) stayLeft = a.getResourceId(R.styleable.MyViewGroup_Layout_stayLeft, 0) stayRight = a.getResourceId(R.styleable.MyViewGroup_Layout_stayRight, 0) a.recycle() &#125;&#125; 这里的代码应该就很熟悉了，与自定义控件的属性的配置方式与流程基本是一摸一样的。同样的也需要在 attrs.xml 中配置： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="MyViewGroup_Layout"&gt; &lt;attr name="stayLeft" format="reference" /&gt; &lt;attr name="stayRight" format="reference" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这样，我们在 xml 中使用该布局的时候，就可以给子控件配置这两个属性了： 123456789101112131415&lt;com.aprz.myapplication.MyViewGroup android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tv1" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;TextView app:stayRight="@id/tv1" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/com.aprz.myapplication.MyViewGroup&gt; 其实generateLayoutParams方法的作用其实就是定义你的控件下所有子控件所使用的layoutParams类，通过这种形式使你的控件可以按自己想要的方式和属性来操作它的子view，你甚至不需要关心子view本身，只要你重写过generateLayoutParams方法，他们就会使用你给的LayoutParams来修饰自己。 但是，这里有个问题，就是 IDE 好像无法识别自定义的属性，在 xml 中使用的时候会报红线，但是可以运行。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多指触控]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2F%E5%A4%9A%E6%8C%87%E8%A7%A6%E6%8E%A7%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（二）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CoordinatorLayout.BehaviorCoordinatorLayout 根据 官方文档 的描述，它是一个“超级FrameLayout“，专门用来帮助实现布局中的View相互交互。我们只需要为布局里面的 Views 创建自定义的或者分配现有的 *Behavior** 即可。Behavior 是 *Material Design 独一无二的核心，例如滑动抽屉和面板，滑动消失元素，和跟随其他空间移动的按钮等等。 我们先来看看 Behavior 是如何工作的，后面还会配上几个例子便于理解。 Behavior 用来表示同一个布局中2个或者2个以上的控件之间的交互。通常分为以下几类： Layout-Based Behaviors:先来看一个效果图： 当 snackbar 从底部出现的时候，FAB 会立即向上平移一个 SnackBar 的高度。 Anchoring 是 Layout-Based Behaviors 的一种，比如我们将 FAB anchored to AppBarLayout，看下面的效果图（注意观察红色的类似短信图标的按钮）： 可以看到 FAB 随着 AppBarLayout 在移动，而且最后还会消失。这种 anchored to 的行为，在 CoordinatorLayout 中对应着一个属性，我们下面会说到。 Scroll-Based Behaviors还是看上面的图，这次不看 FAB，而是观察下面的长文本。TextView 本身是不可滚动的，所以它的外面有一层 NestedScrollView 包裹。 一个 CoordinatorLayout 中有两个可以滚动的控件，一个是 AppBarLayout，一个是 NestedScrollView 。通过效果图，可以看出，他们并没有产生冲突，而是将滑动联动起来了，我们向上滚动 NestedScrollView 的时候，会向将 AppBarLayout 往上推，推到顶部之后，NestedScrollView 才开始滚动，之间没有停顿，无缝衔接。 之所以能够产生这样的行为，是因为这两个控件都被分配了一个 Behavior。 12@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)public class AppBarLayout extends LinearLayout &#123; 12345&lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" &gt; Implementing the Behaviors介绍完了两类 Behaviors，接下来我们看看如何自定义一个 Behavior。 首先，我们的 Behavior 必须继承至 Coordinator.Behaviors&lt;V&gt;，V 就是需要这个Behavior 的控件的类型。比如我想给 TextView 指定一个 Behavior，那么 V 就是 TextView 类型。 然后，Coordinator.Behaviors&lt;V&gt; 有一些方法需要覆盖来达到我们想要的效果，其中有3个方法尤其重要（额，还有滚动相关的方法，与第一篇是以一样的就不介绍了）。 layoutDependsOn(…)这个方法用来决定，当前 View 需要依赖哪个 View。比如你需要根据同一布局中的 ImageView 的位置来决定自己的位置，那么就可以这样写： 123override fun layoutDependsOn(parent: CoordinatorLayout, child: View, dependency: View): Boolean &#123; return dependency is ImageView&#125; 这个方法的返回值，true 表示当前 View 是有依赖对象的，反之则无。但它返回 false 的时候，onDependentViewChanged 方法不会被调用。 嗯，有一种情况我还没有搞清楚，当我们新建一个空项目的时候，模板选择第一个，那么我们的MainActivity 的布局是这样的： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:id="@+id/cl" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;com.google.android.material.appbar.AppBarLayout android:layout_height="wrap_content" android:layout_width="match_parent" android:theme="@style/AppTheme.AppBarOverlay"&gt; &lt;androidx.appcompat.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" app:popupTheme="@style/AppTheme.PopupOverlay"/&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;include layout="@layout/content_main"/&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" app:srcCompat="@android:drawable/ic_dialog_email"/&gt;&lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 可以看到最下面有一个 FloatingActionButton。 MainActivity 的部分代码如下： 123456789101112override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) fab.setOnClickListener &#123; view -&gt; Log.e("e", "h = $&#123;cl.measuredHeight&#125;") Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG) .setAction("Action", null).show() Log.e("e", "h = $&#123;cl.measuredHeight&#125;") &#125;&#125; 当我们点击 FAB 的时候，发现，随着 Snackbar 的出现， FAB 上移了，而且 CoordinatorLayout 的高度并没有改变，也就是说，FAB ”依赖“了 Snackbar ，随着 Snackbar 的上移，FAB 也移动了自己的位置。 那么，我找了以下 FAB 的 Behavior 源码，发现它的 layoutDependsOn 返回了 false（它根本就没有复写这个方法）。那么它是怎么做到的呢？ 我在源码里面发现了这样的一个字段： androidx.coordinatorlayout.widget.CoordinatorLayout.LayoutParams 123456/** * A &#123;@link Gravity&#125; value describing how this child view dodges any inset child views in * the CoordinatorLayout. Any views which are inset on the same edge as this view is set to * dodge will result in this view being moved so that the views do not overlap. */public int dodgeInsetEdges = Gravity.NO_GRAVITY; 然后我在布局里面添加了一个 View，设置了如下属性： 12345678&lt;View android:id="@+id/test" android:layout_width="wrap_content" android:layout_height="100dp" android:layout_gravity="bottom|end" android:layout_margin="@dimen/fab_margin" android:background="@color/colorPrimary" app:layout_dodgeInsetEdges="bottom"/&gt; 运行之后，果然可以跟随 Snackbar 。那么现在可以得出结论，FAB 跟随 Snackbar 是 CoordinatorLayout 自带的功能，与 Behavior 没有关系。 但是这里还是有一个疑问，CoordinatorLayout 是从哪里获取到 Snackbar 的高度的？？？ onDependentViewChanged(…)一旦我们确定了依赖关系，那么就可以根据依赖关系来处理交互逻辑了。比如：我想让一个 TextView 跟随 ImageView 的底部： 123456override fun onDependentViewChanged(parent: CoordinatorLayout, child: TextView, dependency: View): Boolean &#123; // 让 child 跟随 dependency 的底部 val bottom = dependency.y.roundToInt() + dependency.height child.top = bottom return true&#125; 这里我们让 child （TextView）的 top 值等于 dependency （ImageView）的 bottom 值就可以达到我们想要的效果了。 onDependentViewRemoved(…)这个方法看名字就很好理解了，就是当依赖的View被删除的时候，会调用这个方法。 例子项目NestedScrollingDemos 这个项目里面的例子有很详细的注释，可以参考。]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（三）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ViewDragHelper 定义Android 官方对 ViewDragHelper 的定义是： 可以用于自定义 ViewGroup 可以进行拖拽移动或者重新定位ViewGroup中子视图View 提供有效操作和状态追踪 ##使用 ViewDragHelper下面说说，如何使用 ViewDragHelper（下面简称 VDH） 。 创建一个 VDH 对象： androidx.customview.widget.ViewDragHelper#create(android.view.ViewGroup, androidx.customview.widget.ViewDragHelper.Callback) 123public static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull Callback cb) &#123; return new ViewDragHelper(forParent.getContext(), forParent, cb);&#125; VDH 构造函数是私有的，但是有多个可供访问的静态方法。使用它就可以创建一个 VDH 对象。 上面的静态方法中，cb 参数很重要，因为，ViewDragHelper.Callback是用来连接ViewDragHelper和parent view的。 要让VDH能够处理相关的拖动事件就需要将拖动时触发事件状态传给VDH，所以我们要针对onInterceptTouchEvent、onTouchEvent 做特别的处理。 123override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123; return viewDragHelper.shouldInterceptTouchEvent(ev!!)&#125; 直接委托给 vdh，让它判断是否需要拦截事件，如果这里有自己的逻辑，也可以添加，比如： 1234override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123; val myIntercept = someCondition(ev) return myIntercept and viewDragHelper.shouldInterceptTouchEvent(ev!!)&#125; 然后，就是 onTouchEvent，一般情况下，自定义ViewGroup，而 ViewGroup 默认不会处理事件，所以我们需要在 ACTION_DOWN 的时候，处理这个事件： 12345678910111213@SuppressLint("ClickableViewAccessibility")override fun onTouchEvent(event: MotionEvent?): Boolean &#123; // 在这里，将事件传递给 VDH，让它去处理 viewDragHelper.processTouchEvent(event!!) // 处理下 down 事件按，让后续事件都传过来 if (event.action == MotionEvent.ACTION_DOWN) &#123; return true &#125; return super.onTouchEvent(event)&#125; 下面，看看 ViewDragHelper.Callback 中的几个常用方法： pointerId：区分多点触控时的 id position 1234override fun tryCaptureView(child: View, pointerId: Int): Boolean &#123; // 限制指定的控件才可以拖动 return child.id == R.id.video&#125; 123override fun getViewVerticalDragRange(child: View): Int &#123; return verticalRange&#125; 这个方法，需要返回一个大于0的数，然后指定的 View 才会在垂直方向移动。我试过，只要大于 0 即可，似乎没有别的要求。暂时没有去探究这个值有什么意义。 top： 表示拖动指定 view 时，view 的 top 值 dy ：是每次的差值 12345override fun clampViewPositionVertical(child: View, top: Int, dy: Int): Int &#123; // 限制竖向拖动的范围为 【0，verticalRange】 val min = Math.min(top, verticalRange) return Math.max(0, min)&#125; 上面的代码，是将 top 的值限制了，避免 view 被拖出指定的范围。 12345678override fun onViewPositionChanged(changedView: View, left: Int, top: Int, dx: Int, dy: Int) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy) changeVideo(changedView, top) changeVideoDetail(top) changeVideoTitle(top) changePlayButton(top) changeCloseButton(top) &#125; 这个方法表示，当指定的 View 被拖动时，这个方法就会被回调，然后我们就可以在这个方法里面做一些操作，比如改变另外的View 的位置，这样就可以实现一个联动效果。 123override fun onViewReleased(releasedChild: View, xvel: Float, yvel: Float) &#123; super.onViewReleased(releasedChild, xvel, yvel)&#125; 当指定的View 被释放的时候（手指抬起等），这个方法会被回调。如果我们想要一个回弹效果，在这里处理是一个很好的解决方法。比如： 12345override fun onViewReleased(releasedChild: View, xvel: Float, yvel: Float) &#123; super.onViewReleased(releasedChild, xvel, yvel) dragHelper.settleCapturedViewAt(mDragOriLeft , mDragOriLeft) invalidate()&#125; settleCapturedViewAt 是 VDH 提供的一个方法，实际上是使用的 scroller，所以调用这个方法，还需要和使用 Scroller 一样，实现 computeScroll 方法。 还有一些判断边缘拖拽的方法就不介绍了，我实现了一些效果，给我的感觉用起来还是挺方便的。 但是这里有一个问题，就是如果你想实现一些很复杂的效果，其实核心不在拖拽的处理上，而是在一些计算方面，就比如你想要一个回弹效果，直接使用 scroller 可以实现，但是这个回弹效果很普通，UI想要更加炫酷的回弹效果。这个时候考验的不是你对View的理解，而是你对数学的理解。就像我刚接触自定义控件的时候，看的aige的系列文章，其中有一个翻书效果，要想实现这个效果，如果你没有空间想象能力，没有一定的数学知识，无论你对View的绘制，对各种工具有多么熟练，你仍然无从下手。 我实现的一些demo： NestedScrollingDemos]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的滑动处理（一）]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NestedScrollingNestedScrolling 是从Lollipop开始出现的，用来专门处理嵌套滑动的一套机制。NestedScrolling 仍然是基于View与ViewGroup的事件滑动机制，但是它将一个滑动事件的参与者分成了两个角色，child 与 parent。比如：ScrollView 中嵌套了 RecyclerView，ScrollView 在这里扮演 parent，RecyclerView扮演 child。 要想触发 NestedScrolling，首先 child 需要要能够处理滑动事件，因为 NestedScrolling 的思想是： 由 child 来接收滑动事件，然后在它的 onTouchEvent 中，做滑动处理。 做任何处理之前，先询问 parent，看parent能不能处理 所以整个流程就是，在一个move产生后： child 先询问 parent，能够消耗多少，没有消耗完 child 自己消耗，没有消耗完 child 再次询问 parent，我这还有没消耗完的，你能消耗多少，如果 parent 还是没有消耗完 child 自己处理 可以仔细思考一下整个处理流程，刚开始可能会觉得有些怪异，但是要想让嵌套滚动无缝衔接，这样的逻辑是必要的。 了解了 NestedScrolling 的流程之后，那么就会产生许多问题： 第一个是：child 是如何认定 parent 的？ 答案就是通过接口： 12androidx.core.view.NestedScrollingChildandroidx.core.view.NestedScrollingParent 当然现在，这两个接口已经发展到第3个版本了，NestedScrollingChild3 与 NestedScrollingParent3。 在我们上面的例子中，RecyclerView 就需要实现 NestedScrollingChild 这个接口，ScrollView 需要实现 NestedScrollingParent 接口。 然后，通过循环遍历 parent 的方式找到实现了 NestedScrollingParent 接口的 parent ： 12345678ViewParent p = mView.getParent();while (p != null) &#123; if (parent instanceof NestedScrollingParent) &#123; ... return true; &#125; p = p.getParent();&#125; 从这里，可以看出，嵌套关系不需要是直接关系，隔几层也没有问题。 当然，上面的代码是不需要我们自己实现的，Google已经替我们实现了两个工具类，后面会详细说到。 第二个是：child 与 parent 是如何传递各自需要消耗的距离的？ 这个问题比较复杂了，虽然Google替我们实现了两个工具，但是遗憾的是，由于业务的逻辑的多样性，工具里面只封装了一些通用的操作，所以我们需要学习如何使用这两个工具来实现我们想要的效果。 但是幸运的是，使用这两个工具是有模板的，我们只要照着来，问题不大。 下面，我们就参考 RecyclerView 的做法来仔细说道说道。 先看ACTION_DOWN的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 123case MotionEvent.ACTION_DOWN: &#123; startNestedScroll(nestedScrollAxis, TYPE_TOUCH);&#125; break; 一般的，我们在 ACTION_DOWN 事件中来开启嵌套滚动，那么具体怎么开启呢？使用工具类就好了： androidx.recyclerview.widget.RecyclerView#startNestedScroll(int, int) 1234@Overridepublic boolean startNestedScroll(int axes, int type) &#123; return getScrollingChildHelper().startNestedScroll(axes, type);&#125; 可以看到，它是直接使用了 NestedScrollingChildHelper 的 startNestedScroll 方法。所以说，使用很简单。 但是这里需要注意了，startNestedScroll 方法内部会先判断该控件是否开启了支持嵌套滚动，如果没有开启的话也是不行的，具体请看 NestedScrollingChild 接口的 isNestedScrollingEnabled 方法，要想支持嵌套滚动，这个方法返回 true 就好了。 然后，startNestedScroll 方法内部还会调用 ViewParentCompat.onStartNestedScroll(p, child, mView, axes, type) 这个方法。 androidx.core.view.ViewParentCompat#onStartNestedScroll(android.view.ViewParent, android.view.View, android.view.View, int, int) 这个方法里面做了一些转发操作。 12345if (parent instanceof NestedScrollingParent2) &#123; // First try the NestedScrollingParent2 API return ((NestedScrollingParent2) parent).onStartNestedScroll(child, target, nestedScrollAxes, type);&#125; 可以看到，它拿到了 parent，然后调用了 parent 的 onStartNestedScroll 方法，它将一些滑动信息传递到了 parent 中。 androidx.core.view.NestedScrollingParent2#onStartNestedScroll 12boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); 仔细介绍一下这个方法的各个参数： child：是 parent 的某个直接子View，这里parent 就是 ViewParentCompat.onStartNestedScroll 中的参数 p。 target：就是嵌套的控件，在我们的例子中，就是 RecyclerView。 axes：是滚动的方向，横向与竖向 type：是触摸类型，一种是用户触摸，另一种一般是惯性滑动 返回值：true，表示 parent 接收滑动操作，false 则不会，后面分发滚动的流程也就不会走了。 PS: 一般的，我们在实现 parent 的 NestedScrollingParent 接口时，onStartNestedScroll 这个方法一般根据滚动方向来返回值，比如：(axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0; 再看ACTION_MOVE的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 12345case MotionEvent.ACTION_MOVE: &#123; if (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123; &#125;&#125; 一般，在 ACTION_MOVE 中来分发滑动事件，这里的分发与事件分发不是一个东西。 androidx.recyclerview.widget.RecyclerView#dispatchNestedPreScroll(int, int, int[], int[], int) 123456@Overridepublic boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow, int type) &#123; return getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type);&#125; 同样的，这里我们使用工具来帮助我们处理。它的内部调用了 ViewParentCompat.onNestedPreScroll(parent, mView, dx, dy, consumed, type); 方法。 androidx.core.view.ViewParentCompat#onNestedPreScroll(android.view.ViewParent, android.view.View, int, int, int[], int) 1234if (parent instanceof NestedScrollingParent2) &#123; // First try the NestedScrollingParent2 API ((NestedScrollingParent2) parent).onNestedPreScroll(target, dx, dy, consumed, type);&#125; 它调用了 NestedScrollingParent2 的 onNestedPreScroll 方法。 androidx.core.view.NestedScrollingParent2#onNestedPreScroll 12void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); 基本上是与前面的 startNestedScroll 是一样的流程，所以也好理解。这里重要的是需要搞清楚这个方法的参数是什么意思！！！ target： 就是嵌套的控件，在我们的例子中，就是 RecyclerView。 dx：**滑动的x方向距离，一般计算如下： 12345678910111213141516171819switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; mLastTouchX = (int) (e.getX() + 0.5f); mLastTouchY = (int) (e.getY() + 0.5f); &#125; break; case MotionEvent.ACTION_MOVE: &#123; final int x = (int) (e.getX(index) + 0.5f); final int y = (int) (e.getY(index) + 0.5f); int dx = mLastTouchX - x; int dy = mLastTouchY - y; mLastTouchX = x; mLastTouchY = y;&#125; dy：滑动的y方向的距离，计算方式同 dx consumed：这个就比较奇特了，它是由child创建的，然后作为参数传递进取，方法内部需要改变它的值。嗯，有点抽象，举个例子，比如由一个函数 fun1，它没有返回值，但是它接收一数组作为参数，函数的内部会给这个数组赋值。consumed 的工作方式就是这样。一般情况下，我们声明一个成员变量 final int[] mReusableIntPair = new int[2]; 传递给 consumed就好了。 type：是触摸类型，一种是用户触摸，另一种一般是惯性滑动 consumed 被传递到了 parent 中，我们根据需要来处理这个值，比如我们需要竖向消耗 pdy个距离，那么我们在 parent 的 onNestedPreScroll 方法中调用 consumed[1] = pdy 就好了，全部消耗则 consumed[1] = dy。 然后 child 中就需要减去 parent 中消耗的值： androidx.recyclerview.widget.RecyclerView#onTouchEvent 123456case MotionEvent.ACTION_MOVE: &#123; if (dispatchNestedPreScroll(dx, dy, mReusableIntPair, mScrollOffset, TYPE_TOUCH)) &#123; dx -= mReusableIntPair[0]; dy -= mReusableIntPair[1]; &#125;&#125; 然后，判断自己是否可以滚动，并且对应的滚动方向的值是否有剩余： 1if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) 如果有剩余，自己来处理滚动： 123mReusableIntPair[0] = 0;mReusableIntPair[1] = 0;scrollStep(x, y, mReusableIntPair); 然后再次分发滑动事件： 12dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset, TYPE_TOUCH, mReusableIntPair); 同样的，这个方法会调用到 parent 的 onNestedScroll 方法，我就不贴逻辑了，与上面的传递步骤还是一样的。 说一下该方法的参数： androidx.core.view.NestedScrollingParent2#onNestedScroll 12void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); target：不说了 dxConsumed：就是child处理自己的滚动，横向消耗的值 dyConsumed：就是child处理自己的滚动，竖向消耗的值 dxUnconsumed：就是一次滑动的距离 - parent 在 onNestedPreScroll 未消耗 - child也未消耗的，最后剩余的横向的值 dxUnconsumed：同 dxUnconsumed type：不说了 最后，再判断一下，还有没有剩余的，如果还有剩余的，child 自己处理： 1pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY); RecyclerView 这里是利用未消耗完的给出了一个 overScroll 效果。 PS：在自己能够处理滑动事件的时候，不能让parent拦截掉事件 1getParent().requestDisallowInterceptTouchEvent(true); 再看ACTION_UP等的处理 androidx.recyclerview.widget.RecyclerView#onTouchEvent 123case MotionEvent.ACTION_UP: &#123; stopNestedScroll(TYPE_TOUCH);&#125; break; 同样的，也借用工具的方法： 1234@Overridepublic void stopNestedScroll(int type) &#123; getScrollingChildHelper().stopNestedScroll(type);&#125; 最后，也会调用到 parent 的 onStopNestedScroll 方法。 现在，回过头来看看这两个接口： NestedScrollingChild 123456789public void setNestedScrollingEnabled(boolean enabled);public boolean isNestedScrollingEnabled();public boolean startNestedScroll(int axes);public void stopNestedScroll();public boolean hasNestedScrollingParent();public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow);public boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow);public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed);public boolean dispatchNestedPreFling(float velocityX, float velocityY); NestedScrollingParent 12345678public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes);public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes);public void onStopNestedScroll(View target);public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed);public void onNestedPreScroll(View target, int dx, int dy, int[] consumed);public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed);public boolean onNestedPreFling(View target, float velocityX, float velocityY);public int getNestedScrollAxes(); 这些方法都是有调用关系的，理清楚了就好了。 这里关于 NestedScrollingParent，我说的不太多，只是说了方法的参数意思，下面附上一个demo，实现了微信运行排行榜的滑动效果，希望可以加深理解。 项目地址 有兴趣的可以自己添加demo进去。 参考文档Android NestedScrolling全面解析 - 带你实现一个支持嵌套滑动的下拉刷新（上篇） NestedScrollWebView.java]]></content>
      <categories>
        <category>View 的滑动</category>
      </categories>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 的 onMeasure 方法]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-View%2FView%20%E7%9A%84%20onMeasure%20%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[View 的测量过程中，有一个比较重要的类需要掌握：MeasureSpec。我们在阅读源码的时候会发现，在 View 的测量过程中，MeasureSpec 是一个会经常出现的类，如果不先掌握这个类的话，是没法阅读下去的。MeasureSpec 会在很大程度上决定一个 View 的尺寸规格，之所以是很大程度上是因为这个过程还受父容器的影响，因为父容器影响 View 的 MesaureSpec 的创建过程。 在测量过程中，系统会将 View 的 LayoutParams 根据父容器所施加的规则转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来测量出 View 的宽/高。 MeasureSpecMeasureSpec 是一个int值，但是这个int值被分为了两部分，一部分表示 SpecMode （测量模式），一部分表示 SpecSize（在某种测量模式下的大小）。 可能有很多人想不通，一个int型整数怎么可以表示两个东西（大小模式和大小的值），一个int类型我们知道有32位。而模式有三种，要表示三种状态，至少得2位二进制位。于是系统采用了最高的2位表示模式。如图： 最高两位是00的时候表示”未指定模式”，即MeasureSpec.UNSPECIFIED。 最高两位是01的时候表示”‘精确模式”，即MeasureSpec.EXACTLY。 最高两位是11的时候表示”最大模式”，即MeasureSpec.AT_MOST。 精确模式（MeasureSpec.EXACTLY） 在这种模式下，尺寸的值是多少，那么这个组件的长或宽就是多少。 最大模式（MeasureSpec.AT_MOST） 这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。 未指定模式（MeasureSpec.UNSPECIFIED） 这个就是说，当前组件，可以随便用空间，不受限制。 MeasureSpec 通过将 SpecMode 与 SpecSize 打包成一个 int 值来避免过多的对象内存分配。为了方便操作，它还提供了对应的打包与解包方法。 12345678// 将 size 与 mode 组合成一个 MeasureSpec 对象android.view.View.MeasureSpec#makeMeasureSpec// 从 MeasureSpec 中获取 modeandroid.view.View.MeasureSpec#getMode// 从 MeasureSpec 中获取 sizeandroid.view.View.MeasureSpec#getSize 在 View 测量的时候，系统会将 LayoutParams 在父容器的约束下转换成对应的 MeasureSpec，然后再根据这个 MeasureSpec 来确定 View 测量后的大小。（这里需要注意，MeasureSpec 不是由 LayoutParams 唯一决定的，而是由 LayoutParams 与父布局一起决定的） 各种 View 测量的区别顶层 View我们知道一般的 View 都会有父布局，但是最顶层的 View 是没有的，那么它是如何测量的呢？ 首先它会获取 LayoutParams，再判断 LayoutParams 宽高的值： 如果为 LayoutParams.MATCH_PARENT，这表示精确模式，大小就是窗口大小。 如果为 LayoutParams.WRAP_CONTENT，这表示最大模式，大小未定，但是不能超过窗口大小。 这就比较简单了，顶层View的测量，一般宽高都是 LayoutParams.MATCH_PARENT，大小为窗口大小。 子 View对于普通的 View 来说，它的测量与父布局有关，而每个父布局的特性又不同，无法每个都涉及到，所以这里采取一个“管中窥豹，可见一斑”的方法。 这里介绍一下 ViewGroup 的 measureChildWithMargins 方法。 android.view.ViewGroup#measureChildWithMargins 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 方法中的 getChildMeasureSpec 方法比较长，就不贴代码了，下面会有文字说明。 getChildMeasureSpec 其实最后就是生成了一个 MeasureSpec 对象。 它的 size 由两部分决定，一个是 parentWidthMeasureSpec，一个是 lp.width / lp.height。 具体的规则用表说明： 从这个表中我们可以看到，在构造 child 的 MeasureSpec 还是优先考虑了 child 自身的 size 的，特别是 child 直接要求一个固定的值的时候。 我们深入思考一下，比如我们经常使用到的 LinearLayout（竖向），它在决定 child 的大小的时，肯定不能让 child 的高度与自己的高度一样大，那么它是如何处理的呢？我们看看源码： android.widget.LinearLayout#measureVertical 123final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,lp.width);child.measure(childWidthMeasureSpec, childHeightMeasureSpec); 可以看到，LinearLayout 并没有使用 ViewGroup 提供的 measureChild 方法，因为它并不符合 LinearLayout 的特性。那么哪一个布局符合呢？？？FrameLayout！！！ android.widget.FrameLayout#onMeasure 123456789101112131415@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); ... for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);... &#125; &#125; ...&#125; 可以看到，它就是直接使用了 measureChildWithMargins 方法，因为它的特性只是做了一个层叠，并没有其他对 child 有其他限制，所以可以直接使用。 例子说了这么多，我们来看看一个实际的应用场景吧。 我们知道，TextView 是有自己的 onMeasure 方法的。系统提供的 TextView，文字是从做到右的，那么我们现在想做这样的一个效果，将 TextView 的显示旋转一下，从上到下。如下图： 变成这样： 那么，有的同学就说话了，这旋转一下不就不可以了吗！是这样吗？在我们的屏幕中，不可能只会有一个 TextView，所以这个 TextView 很可能会与其他控件一起排列，当我们在旋转之前，假设它的宽与高是 100*300，那么旋转之后，它的高度变成了300，这个时候，由于父布局的限制，我们很可能看不到整个 TextView。而且我们在 xml 中也不好去预览它的效果。 那么下面，我们就来实现一下这个效果。 首先我们需要处理该控件的大小。 12345@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.measure(heightMeasureSpec, widthMeasureSpec); setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth());&#125; 我们首先来看这个方法：super.measure(heightMeasureSpec, widthMeasureSpec);。 这行代码非常容易引起误解，有的人就以为，我们将 widthMeasureSpec 与 heightMeasureSpec 换了一下，那么它测量出来的宽高自然就会互换。这是错误的理解！！！ 比如，我们在 xml 中是这样使用这个自定义控件的： 12345678910111213&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res/com.yoog.widget" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" &gt; &lt;com.yoog.widget.VerticalTextView android:text="20:59" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt; 我们假设20：59这串文字的长度为 300，高度为 100。父布局的宽高均大于 300。 所以，TextView 测量出来的就是 300*100，VerticalTextView 测量出来的值应该是 100 * 300。 但是，如果父布局的高度只有 250 的时候，横着测量的时候，是完全没有问题的，仍然测量出 300 * 100，但是竖着测量的时候，高度只能有 250，它需要换行，所以，结果是 200 * 250。 所以说，将 widthMeasureSpec 与 heightMeasureSpec 互换，只是为了正确的将父布局对 child 的影响正确的传递进去。 由于，正确的传递了父容器的宽与高，走 TextView 的方法自然就会测量出正确的值，然后我们调用 setMeasuredDimension(getMeasuredHeight(), getMeasuredWidth()); 方法，就可以将宽与高换过来了。 至于 onDraw 方法，我们就不深入了，只需要在 view 的左上角旋转一下画布就好了。]]></content>
      <tags>
        <tag>Android-View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding 原理分析]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-JetPack%2FDataBinding%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[DataBinding 是一个支持库，它可以将布局中的界面组件绑定到数据源上，做到UI与数据的单项或者双向监听。说白一点就是数据发生变化可以直接反映到界面上，不用再次手动操作了。当然它的作用远远不止于此，本文从这个点入手，来略微深入一下它的实现过程。首先，DataBinding可以将数据的变化反应到UI上，实际上就是帮助我们更新UI，那么它肯定需要持有（直接或者间接）UI的引用，不然的话，是没法操作UI的。用过DataBinding 的小伙伴应该都知道，DataBinding 会根据布局生成一个类，这个类里会有许多成员变量，每个变量对应着布局里面各个控件。 PS：因为每个项目生成的代码不一致，而且我使用了多个项目生成的代码，所以看的时候不要太纠结，尽量理解为主。 举个例子吧，我们的布局如下： app\src\main\res\layout\content_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.test.user" /&gt; &lt;import type="android.view.View" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;viewModel.name&#125;" /&gt; &lt;TextView android:id="@+id/tv_sex" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="@&#123;viewModel.sex&#125;" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" /&gt; &lt;TextView android:id="@+id/tv_class" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="@&#123;viewModel.age&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 这里面看起来有很多高级的用法，实际上它经过编译之后，是下面这个样子的（因为没有在工程里面找到生成的文件，可能是新版本又换了位置，所以只能看apk里面的资源文件了）： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="1" android:tag="layout/content_main_0" android:layout_width="-1" android:layout_height="-1"&gt; &lt;TextView android:id="@ref/0x7f0800c8" android:tag="binding_1" android:layout_width="-2" android:layout_height="-2" /&gt; &lt;TextView android:id="@ref/0x7f0800c9" android:tag="binding_2" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:id="@ref/0x7f0800c7" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt; &lt;TextView android:tag="binding_3" android:layout_width="-2" android:layout_height="-2" android:layout_marginTop="dimension(12801)" /&gt;&lt;/LinearLayout&gt; 不要在意哪些 dimension/ref 之类的东西，关键点在于它给使用了 @{} 的控件都生成了一个 tag 属性。可以看出，tag 是有规律的： 如果是根布局，为xml的名字，跟一个数字0，本例为 content_main_0。 如果不是根布局，为binding_x，x是数值，从1开始（根布局把0用了）。 我们手动添加的layout，data，以及 @{viewModel.name} 这些看似高级的东西，其实在编译后都去掉了。那么它为什么要添加一个 tag 呢？？？其实是因为它在内部是使用了这个tag来获取view的引用。 我们知道，要使用 DataBinding，除了布局需要特殊写法，加载布局的时候，也需要特殊处理。拿 Activity 举例，我们要使用 DataBinding 加载布局，就不能像以前一样直接调用 setContentView，而是要使用 DataBindingUtil.setContentView 这个方法，那么我们就来分析一下这个方法。 androidx.databinding.DataBindingUtil#setContentView(android.app.Activity, int) 这个方法里面调用了其他方法，我们一直追踪下去，发现了它的核心方法是这个： androidx.databinding.DataBindingUtil#bind(androidx.databinding.DataBindingComponent, android.view.View, int) 12345678 private static DataBinderMapper sMapper = new DataBinderMapperImpl(); ... static &lt;T extends ViewDataBinding&gt; T bind(DataBindingComponent bindingComponent, View root, int layoutId) &#123; return (T) sMapper.getDataBinder(bindingComponent, root, layoutId); &#125; DataBinderMapperImpl 是编译器生成了一个类，它的 getDataBinder 内容大致如下： com.aprz.snackbardemo.DataBinderMapperImpl#getDataBinder(androidx.databinding.DataBindingComponent, android.view.View, int) 12345678910111213141516171819@Overridepublic ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) &#123; int localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId); if(localizedLayoutId &gt; 0) &#123; final Object tag = view.getTag(); if(tag == null) &#123; throw new RuntimeException("view must have a tag"); &#125; switch(localizedLayoutId) &#123; case LAYOUT_CONTENTMAIN: &#123; if ("layout/content_main_0".equals(tag)) &#123; return new ContentMainBindingImpl(component, view); &#125; throw new IllegalArgumentException("The tag for content_main is invalid. Received: " + tag); &#125; &#125; &#125; return null;&#125; 这个方法的 layoutId 就是 R.layout.content_main （我们使用DataBindingUtil#setContentView传入的值 ）。由于编译器自己生成了一个 Map，这个Map储存了所有需要 DataBinding 处理的 layoutId，layoutId 是key，value 是一个整数值。这里是我没有想通的地方，为啥要对应一个整数值，而不是直接使用 layoutId 呢？？？比如像下面这样写： 12345678switch(layoutId) &#123; case R.layout.content_main: &#123; if ("layout/content_main_0".equals(tag)) &#123; return new ContentMainBindingImpl(component, view); &#125; throw new IllegalArgumentException("The tag for content_main is invalid. Received: " + tag); &#125;&#125; 这个不影响，我们继续往下看，它最后返回了一个对象，叫做 ContentMainBindingImpl。使用过 DataBinding 的都应该会有点眼熟，因为我们使用的对象是 ContentMainBinding，而 ContentMainBindingImpl 看起来是 ContentMainBinding 的一个实现类。看一下他们的关系： 123public abstract class ContentMainBinding extends ViewDataBindingpublic class ContentMainBindingImpl extends ContentMainBinding 也就是说，虽然我们使用的是 ContentMainBinding，但是它实际上是一个 ContentMainBindingImpl 对象。 我们继续，看 ContentMainBindingImpl 的构造方法： com.aprz.databindingdemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(android.databinding.DataBindingComponent, android.view.View) 123public ContentMainBindingImpl(@Nullable android.databinding.DataBindingComponent bindingComponent, @NonNull View root) &#123; this(bindingComponent, root, mapBindings(bindingComponent, root, 5, sIncludes, sViewsWithIds));&#125; 这里调用了一个叫做 mapBindings 的方法，就是它解析了View的 tag ，然后将view存储到了一个数组中，在将这个数组赋值给成员变量，这样我们就不用 findViewById 了，因为它的方法比较长，所以我不贴代码了，就简单的说一下它的工作过程。 androidx.databinding.ViewDataBinding#mapBindings(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[], androidx.databinding.ViewDataBinding.IncludedLayouts, android.util.SparseIntArray, boolean) 1234567891011121314if (isRoot &amp;&amp; tag != null &amp;&amp; tag.startsWith("layout")) &#123; final int underscoreIndex = tag.lastIndexOf('_'); if (underscoreIndex &gt; 0 &amp;&amp; isNumeric(tag, underscoreIndex + 1)) &#123; // 这里的 index 就是 content_main_0 的 0 final int index = parseTagInt(tag, underscoreIndex + 1); if (bindings[index] == null) &#123; bindings[index] = view; &#125; indexInIncludes = includes == null ? -1 : index; isBound = true; &#125; else &#123; indexInIncludes = -1; &#125;&#125; 首先是获取到 tag 以 layout 开头的 View，将这个view 放入到 bindings[0] 中。 123456789&#125; else if (tag != null &amp;&amp; tag.startsWith(BINDING_TAG_PREFIX)) &#123; // 这里的 index 是 binding_1 的 1，当然不只是 1，还有 2，3.... int tagIndex = parseTagInt(tag, BINDING_NUMBER_START); if (bindings[tagIndex] == null) &#123; bindings[tagIndex] = view; &#125; isBound = true; indexInIncludes = includes == null ? -1 : tagIndex;&#125; 然后获取以 tag 为 binding_ 开头的 View，放入到 bindings[1…n] 中。 12345678910if (!isBound) &#123; final int id = view.getId(); if (id &gt; 0) &#123; int index; if (viewsWithIds != null &amp;&amp; (index = viewsWithIds.get(id, -1)) &gt;= 0 &amp;&amp; bindings[index] == null) &#123; bindings[index] = view; &#125; &#125;&#125; 最后，如果控件没有id，但是使用了 @{} 的用法，也会存入 bindings 数组中，这个index也是接着上面 binding_ 的数字，比如，上面最后一个是 binding_5，这里的 index 就是从 6 开始了，这些数值都是编译器生成好了的。我猜想是在处理 xml 的时候，就需要生成对应的类，然后将index对应好。 有了这个数组，显然只需要将它赋值给对应的变量就好了。我们可以生成控件的成员变量，然后以驼峰式命名，将数组的值赋值给对应的变量。 com.aprz.snackbardemo.databinding.ContentMainBindingImpl#ContentMainBindingImpl(androidx.databinding.DataBindingComponent, android.view.View, java.lang.Object[]) 1234567891011121314151617181920212223242526 private ContentMainBindingImpl(androidx.databinding.DataBindingComponent bindingComponent, View root, Object[] bindings) &#123; super(bindingComponent, root, 0 , (android.widget.TextView) bindings[4] , (android.widget.TextView) bindings[1] , (android.widget.TextView) bindings[2] ); this.mboundView0 = (android.widget.LinearLayout) bindings[0]; this.mboundView0.setTag(null); this.mboundView3 = (android.widget.TextView) bindings[3]; this.mboundView3.setTag(null); this.tvName.setTag(null); this.tvSex.setTag(null); setRootTag(root); // listeners invalidateAll(); &#125;---------------------------------------- protected ContentMainBinding(Object _bindingComponent, View _root, int _localFieldCount, TextView tvClassName, TextView tvName, TextView tvSex) &#123; super(_bindingComponent, _root, _localFieldCount); this.tvClassName = tvClassName; this.tvName = tvName; this.tvSex = tvSex; &#125; 从代码里面可以看出，它确实是将bindings赋值给了成员变量。没有id的无法外部使用 ，所以是 ContentMainBindingImpl 的成员变量，内部名字叫做 mboundViewXXX。 说了这么多，只是讲了一下它的如何不用 findViewById 的。但是 DataBinding 还有更重要的作用，就是数据绑定，我们接下来分析分析，它是如何将数据绑定到 UI 的，而且数据更新之后，是如何改变 UI 的！！！ 实现数据绑定，我们需要调用binding.setVariable或者binding.setViewModel，两者效果一样，因为setVariable会间接调用setViewModel方法。 com.aprz.databinding.ContentMainBindingImpl 12345678910111213141516171819202122 // variableId 是生成的BR文件中的一个变量，对应于你在 xml 中设置的变量@Override public boolean setVariable(int variableId, @Nullable Object variable) &#123; boolean variableSet = true; if (BR.viewModel == variableId) &#123; setViewModel((com.aprz.snackbardemo.User) variable); &#125; else &#123; variableSet = false; &#125; return variableSet; &#125; public void setViewModel(@Nullable com.aprz.snackbardemo.User ViewModel) &#123; // 这个方法有个坑，后面会说到 this.mViewModel = ViewModel; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; notifyPropertyChanged(BR.viewModel); super.requestRebind(); &#125; 可以看到实际上主要是调用了一下 notifyPropertyChanged 方法。notifyPropertyChanged 内部就是做了一个回调监听的操作，和我们的观察者模式没有区别，但是这里比较搞笑的就是，此时监听是为 null 的，也就是说没有注册观察者。 它在代码中表现的行为是这样的：我们创建一个对象A，将A通过 binding.setVariable 方法绑定到数据上，是可以正常显示出数据的，但是如果我们改变了对象A的某个属性，这个时候，属性的变化是无法反映到UI上的，我们还需要手动更新UI。 那么当我们改变了对象A的某个属性时，怎么才能自动更新UI 呢？参考官方文档的一个方法是使用 @Bindable 注解，比如我们的对象长这样： com.aprz.aboutme.MyName 12345678910data class MyName(var name: String) : BaseObservable() &#123; @get:Bindable var nickname: String = "aprz" set(value) &#123; field = value notifyPropertyChanged(com.aprz.aboutme.BR.nickname) &#125;&#125; 可以看到，每当 set 方法调用的时候，我们需要手机调用一下 notifyPropertyChanged 方法，这个时候，我们再看生成的文件，查看 setViewModel 方法： com.aprz.databinding.ContentMainBindingImpl#setViewModel 12345678910public void setViewModel(@Nullable com.aprz.snackbardemo.User ViewModel) &#123; // hhh updateRegistration(0, ViewModel); this.mViewModel = ViewModel; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; notifyPropertyChanged(BR.viewModel); super.requestRebind();&#125; 可以看到，第一行多了一行代码：updateRegistration，应该可以猜到，这个方法里面应该就是注册了观察者。为了验证我们的想法，查看一下这个方法： androidx.databinding.ViewDataBinding#updateRegistration(int, androidx.databinding.Observable) 123protected boolean updateRegistration(int localFieldId, Observable observable) &#123; return updateRegistration(localFieldId, observable, CREATE_PROPERTY_LISTENER);&#125; 这里的调用链比较深，我们只关心重要的方法，最后发现调用到了如下方法 androidx.databinding.ViewDataBinding.WeakListener#setTarget 1234567public void setTarget(T object) &#123; unregister(); mTarget = object; if (mTarget != null) &#123; mObservable.addListener(mTarget); &#125;&#125; 这里的 mTarget 是上面的 viewModel 变量，mObservable 是一个叫做 WeakPropertyListener 的类，因为我们省略了中间的调用过程，所以会有点突兀，但是我们把它当作一个 WeakListener 的一个包装类就好了，它持有 WeakListener 的引用而已。 再往下最终，会发现调用到了这里： androidx.databinding.BaseObservable#addOnPropertyChangedCallback 123456789@Overridepublic void addOnPropertyChangedCallback(@NonNull OnPropertyChangedCallback callback) &#123; synchronized (this) &#123; if (mCallbacks == null) &#123; mCallbacks = new PropertyChangeRegistry(); &#125; &#125; mCallbacks.add(callback);&#125; 这里就比较熟悉了吧，就是 notifyPropertyChanged 会触发监听回调，而这个监听就是在这里添加（注册）的。 经过上面的一连串调用，viewModel，WeakPropertyListener ，WeakListener ，就建立这样的一个关系： 因为 ViewModel 继承至 BaseObservable，所以它有一个成员变量：mCallbacks，而 updateRegistration 方法主要是添加了一个观察者。实际上DataBinding的自动更新UI原理还是观察者，但是它的高明之处是编译器自动生成逻辑代码。 好的，说完了观察者的注册，还有一步需要完成，就是通知观察者数据发生了变化。应该还记得，我们的 ViewModel 里面，set 方法都调用了一个方法notifyPropertyChanged： 123456@get:Bindablevar nickname: String = "aprz" set(value) &#123; field = value notifyPropertyChanged(com.aprz.aboutme.BR.nickname) &#125; 这个很显然就是通知观察者，我们的数据发生了变化，我们看看源码吧（其实不看都知道，最终触发了 mCallbacks 的回调）。同样的经过多层调用，到了下面的方法： androidx.databinding.ViewDataBinding#handleFieldChange 123456789101112private void handleFieldChange(int mLocalFieldId, Object object, int fieldId) &#123; if (mInLiveDataRegisterObserver) &#123; // We're in LiveData registration, which always results in a field change // that we can ignore. The value will be read immediately after anyway, so // there is no need to be dirty. return; &#125; boolean result = onFieldChange(mLocalFieldId, object, fieldId); if (result) &#123; requestRebind(); &#125;&#125; 主要是两个方法，先看第一个，看名字就应该是字段发生了变化的处理，该方法会调用到下面的方法： com.aprz.aboutme.databinding.ActivityMainBindingImpl#onChangeMyName 1234567891011121314151617181920212223private boolean onChangeViewModel(com.foxlee.testdatabinding.NewsViewModel ViewModel, int fieldId) &#123; switch (fieldId) &#123; case BR.name: &#123; synchronized(this) &#123; mDirtyFlags |= 0x2L; &#125; return true; &#125; case BR.value1: &#123; synchronized(this) &#123; mDirtyFlags |= 0x4L; &#125; return true; &#125; case BR._all: &#123; synchronized(this) &#123; mDirtyFlags |= 0x1L; &#125; return true; &#125; &#125; return false;&#125; 这里其实啥都没做，就只给 mDirtyFlags 设置了一个标记位，这里就很灵性了，它不是与我们通常的想法一样，给每个字段分别处理，而是只是设置一个标记。 再看 requestRebind，从名字也可以看出来，应该是重新绑定，因为 onChangeMyName 给字段发生了变化的位设置了标记，所以在这个方法里面，应该就是根据标志位来刷新UI了，好，我们看看： androidx.databinding.ViewDataBinding#requestRebind 123456789101112protected void requestRebind() &#123; if (mContainingBinding != null) &#123; mContainingBinding.requestRebind(); &#125; else &#123; ... if (USE_CHOREOGRAPHER) &#123; mChoreographer.postFrameCallback(mFrameCallback); &#125; else &#123; mUIThreadHandler.post(mRebindRunnable); &#125; &#125;&#125; 如果对View的绘制源码有一点了解的，这里应该很好理解，这里就是刷新UI 了。然后继续往下追踪，它会调用到这个方法： com.aprz.aboutme.databinding.ActivityMainBindingImpl#executeBindings 123456789101112131415161718192021222324252627282930if ((dirtyFlags &amp; 0xfL) != 0) &#123; if ((dirtyFlags &amp; 0xbL) != 0) &#123; if (viewModel != null) &#123; // read viewModel.name viewModelName = viewModel.name; &#125; &#125; if ((dirtyFlags &amp; 0xdL) != 0) &#123; if (viewModel != null) &#123; // read viewModel.value1 viewModelValue1 = viewModel.value1; &#125; &#125;&#125;// batch finishedif ((dirtyFlags &amp; 0xdL) != 0) &#123; // api target 1 com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.mboundView3, viewModelValue1); com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.tvValue, viewModelValue1);&#125;if ((dirtyFlags &amp; 0xbL) != 0) &#123; // api target 1 com.foxlee.testdatabinding.NewsViewModel.onTestChange(this.tvName, viewModelName);&#125; 可以看到，这个方法里面就是根据 dirtyFlags 的标志位来更新UI的。这个标志位的算法需要说一下，我们拿 name 的更新举例子： 在 onChangeViewModel 方法中，name字段更新的时候，给 mDirtyFlags 设置的标志位是 mDirtyFlags |= 0x2L;，而在 executeBindings 方法中，判断 name 字段的更新是使用的 dirtyFlags &amp; 0xbL 来判断的，这是为啥呢？ 这里不去深入研究它的计算规则了，只是简单的说一下： 0x1，0x2，0x4，0xb，0xd，0xf，他们转换成二进制是这样的： 123450 00010 00100 01000 10001 0000 看出规律了没有，这些数只有其中一位为1，其余的都为1，按照这个思路，如果某个数的该位为1，那么应该就是需要更新该位对应的属性。有了这个猜想，我们看看下面的数(023， 0x25， 0x29,，0x31)： 123410 001110 0101 10 100111 0001 这些数也是有规律的，他们第一位为1，最后一位为1，中间的数有一位为1。第一位为1，是用来保证更新所有字段的。中间的某位为1是与上面的位对应的，表示某个属性需要更新。第一位我还没搞清楚是用来做什么的（好像是与双向绑定有关系）。 自动刷新UI我们分析完了，还有一个问题，就是UI变化的时候，是如何改变ViewModel的值的呢？ 其实看上面的图，就可以看出一个大概，因为只有 ActitivyMainBindingImpl 有 ViewModel 的引用，所以肯定是它搞得事情。我们打开这个类就会发现这样的一些监听： 1234567891011121314151617181920private android.databinding.InverseBindingListener tvField1androidTextAttrChanged = new android.databinding.InverseBindingListener() &#123; @Override public void onChange() &#123; // Inverse of user.field1 // is user.setField1((java.lang.String) callbackArg_0) java.lang.String callbackArg_0 = android.databinding.adapters.TextViewBindingAdapter.getTextString(tvField1); // localize variables for thread safety // user != null boolean userJavaLangObjectNull = false; // user com.aprz.databindingdemo.User user = mUser; // user.field1 java.lang.String userField1 = null; userJavaLangObjectNull = (user) != (null); if (userJavaLangObjectNull) &#123; user.setField1(((java.lang.String) (callbackArg_0))); &#125; &#125;&#125;; 嗯，这里的逻辑很简单，首先拿到 TextView 的值，然后设置到 user 变量里面。不用想都知道 InverseBindingListener 是用来监听 TextView 的文字变化的。这里是因为在自动生成的代码里面给 TextView 都添加了一个 TextWatcher。所以当它发生变化的时候，就会回调这个方法。 需要注意的是，双向绑定容易引起死循环，因为UI导致 ViewModel 发生变化，ViewModel 变化了，又要去刷新 UI，就会不断的重复这个过程，需要自己处理一下，就是在更新UI的时候，判断一下值是否与当前相同，相同的时候再去更新（通知监听变化了）。 PS： 坑：不支持merge标签。布局根节点必须是 . 同时layout只能包含一个View标签. 不能直接包含&lt;merge&gt;。]]></content>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[0005-使用定时器]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0005-%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[组件的业务逻辑里难免有涉及到定数触发的逻辑，比如倒计时、定时滚动。Tangram 内置了定时器模块，可以全局复用，防止重复开发。以在组件里使用定时器为例： 在 bindView 或者 postBindView 方法里注册定时器。在自定义的 View 中：12345678910@Overridepublic void postBindView(BaseCell cell) &#123; if (cell.serviceManager != null) &#123; TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class); if (timerSupport != null &amp;&amp; !timerSupport.isRegistered(this)) &#123; //第一个参数4是单位秒，第二个参数是接口回调，第三个参数是立即执行 timerSupport.register(4, this, true); &#125; &#125;&#125; 可以看到 TimerSupport 的获取方式有点类似 Android 的 getSystemService。我们看看是怎么做的。 com.tmall.wireless.tangram.BaseTangramEngine 12345678910111213141516private ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt; mServices = new ConcurrentHashMap&lt;&gt;();@Overridepublic &lt;S&gt; void register(@NonNull Class&lt;S&gt; type, @NonNull S service) &#123; Preconditions.checkArgument(type != null, "type is null"); mServices.put(type, type.cast(service));&#125;@Overridepublic &lt;S&gt; S getService(@NonNull Class&lt;S&gt; type) &#123; Object service = mServices.get(type); if (service == null) &#123; return null; &#125; return type.cast(service);&#125; BaseTangramEngine 这个类里面有一个 map，里面储存了各种 service 的实例。我们只需要调用 register 方法将一个实例注册进去，以后就可以通过 getService 方法获取了。而 BaseCell 的 serviceManager 字段又是指向同一个对象，所以这就像是一个单利用来储存与获取数据。 获取到 TimerSupport 之后，就是使用观察者模式来注册监听与解绑监听。 com.tmall.wireless.tangram.support.TimerSupport#register(int, com.tmall.wireless.tangram.support.TimerSupport.OnTickListener, boolean) 123public void register(int interval, @NonNull OnTickListener onTickListener, boolean intermediate) &#123; mDefaultTimer.register(interval, onTickListener, intermediate);&#125; 监听器的实现是 com.tmall.wireless.tangram.support.HandlerTimer类，这个类很简单，一般只要做过倒计时功能的都看的懂，里面是使用 Handler 做了一个循环实现的，所以我就不分析这个类了。 在注册完监听之后，还需要考虑的是，什么时候启动这个循环，什么时候终止这个循环，因为 TimerSupport 是统一管理所有的定时器。比如：当一个观察者解除监听的时候，不能直接停止整个定时器，因为可能还有别的观察者需要使用整个定时器。我们来看看，Tangram 是如何处理的： com.tmall.wireless.tangram.support.HandlerTimer#register 12345@Overridepublic void register(int interval, OnTickListener onTickListener, boolean intermediate) &#123; mListeners.put(onTickListener, new IntervalTickListener(interval, onTickListener, intermediate)); start(false);&#125; 在注册监听的时候，就会启动这个全局定时器。 com.tmall.wireless.tangram.support.HandlerTimer#runTask 1234567891011public void runTask() &#123; mCopyListeners.clear(); mCopyListeners.addAll(mListeners.values()); for (int i = 0, size = mCopyListeners.size(); i &lt; size; i++) &#123; IntervalTickListener listener = mCopyListeners.get(i); listener.onTick(); &#125; if (mListeners.isEmpty()) &#123; stop(); &#125;&#125; 在通知所有观察者的时候会判断，如果没有了观察者，会停止这个全局定时器。 关于定时器的处理，TimerSupport 就是用来统一管理一个全局的定时器的，免得每个 Cell 都开启一个自己的。TimerSupport 里面还有其他的一些方法，可以去看看。 在自定义 View 中实现接口： com.tmall.wireless.tangram.support.TimerSupport.OnTickListener 1234@Overridepublic void onTick() &#123; //处理业务逻辑 &#125; 在 unbindView 或者 postUnbindView 的方法里要记得注销定时器： 123456if (cell.serviceManager != null) &#123; TimerSupport timerSupport = cell.serviceManager.getService(TimerSupport.class); if (timerSupport != null) &#123; timerSupport.unregister(this); &#125;&#125;]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Annotation Processor]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FJava%2FAnnotation%20Processor%2F</url>
    <content type="text"><![CDATA[注解处理在 Java 1.5 的时候就已经发布了，虽然它很老了，但是却是最强大的 API 之一。下面我们会先讨论注解处理，代码自动生成以及使用到这些技术的开源库。什么是注解实际上，我们应该都知道什么是注解。我们经常使用到的：@Override，@Singleton，@StringRes 等等，这些就是注解。 注解是一种可以添加到Java源代码的语法元数据。 我们可以注释类，接口，方法，变量，参数等。 可以从源文件中读取Java注解。 Java注解也可以嵌入和读取编译器生成的类文件。 Java VM可以在运行时保留注解，并通过反射进行读取。 比如： 12345@Retention(RetentionPolicy.SOURCE)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; 创建一个注解需要两部分信息： Retention 和 Target 。 RetentionPolicy 指定了注解应该保留到程序生命周期的什么时候。举个例子：注解可以保留到程序的编译时期或者运行时期。 ElementTypes 指定了注解应该作用于程序的哪一个部分。有3个取值： SOURCE —— 编译时期，不会储存 CLASS —— 储存在 class 文件中，但是不会保留到运行时期 RUNTIME —— 储存在 class 文件中，运行时期可以访问（通过反射） 拿 BindView 注解来说，RetentionPolicy.SOURCE 表示注解只需要在编译时期保存，之后就不需要了。ElementType.FIELD 表示该注解只能修饰字段。 注解处理器介绍编译时期Annotation Processor 实际上是 javac 编译器的一部分，所以注解处理时发生在编译时期，这有许多好处，其中之一就是“在编译其实发生错误比运行时期发生错误要好的多”。 无反射Java 的反射 API 会在运行时抛出许多错误，这实在是有点蛋疼。但是 Annotation Processor 就不一样了，它会直接给我们一个程序的语义结构，我们使用这个语义结构就可以分析注解所处的上下文场景，然后做处理。 生成样板代码Annotation Processor 最大的用处就是用来生成样板代码了，比如著名的 ButterKnife 等开源库。 注意：注解处理器只能生成新的文件，无法更改已经存在的文件。 注解处理器是如何工作的注解处理会执行很多轮。编译器首先会读取java源文件，然后查看文件中是否有使用注解，如果有使用，则调用其对应的注释处理器，这个注解处理器（可能会）生成新的带有注解的java源文件。这些新注解将再次调用其相应的注释处理器，然后再次生成更多的java源文件。就这样一直循环，直到没有新的文件生成。 注册注解处理器java 编译器需要知道所有的注解处理器，所以如果我们想要自定义一个处理器，我们必须要让 java 编译器知道我们创建了一个。 有两种方法来注册一个处理器： 老方法： 创建一个目录： 1&lt;your-annotation-processor-module&gt;/src/main/resources/META-INF/services 然后在services文件夹里面，创建一个名字叫做javax.annotation.processing.Processor的文件。在这个文件中声明你的处理器的权限定名： 1&lt;your-package&gt;.YourProcessor 新方法： 使用谷歌的 AutoService 库。 123456package foo.bar;import javax.annotation.processing.Processor;@AutoService(Processor.class)final class MyProcessor implements Processor &#123; // …&#125; 注意在 gradle 文件中引入依赖。 创建一个注解处理器首先，我们需要继承一个父类： 1234567891011121314151617181920public class Processor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment); // initialize helper/utility classes... &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; // do processing... return true; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; // &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; // &#125;&#125; init() 提供帮助和工具类，如：Filer（生成文件），Messager（用于记录错误，警告等），Elements（用于操作程序元素的工具方法），类型（用于操作类型的工具方法）等。 我们可以使用processingEnvironment 这个变量来获取这些类。 process() 这个方法就是所有处理器处理注解的地方。这里你可以获取到被注解修饰的元素的所有信息。然后你就可以生成新的文件了。 getSupportedAnnotationTypes() 这里返回自定义的注解就好了。它的返回值是 process() 方法的第一个参数。 getSupportedSourceVersion() 返回最新的 java 版本就好了。 新建两个module一个用于创建注解，一个用于创建注解处理器。 为啥需要新建两个module呢？ 因为 processor 需要 annatation 的引用，所以 annotation 需要提出来作为一个 module。 那么可不可以将所有代码都放到 app 里面呢？是可以的，但是由于我们不需要 processor 的代码，只需要它在编译的时候处理我们的代码然后生成新的文件就好了，更不就不需要将 processor 的代码打包到 apk 里面，所以新建 module 是最好的选择。 piri-pricessor 的 build.gradle 需要配置一下： 1implementation project(':piri-annatation') app 的 build.gradle 需要配置一下： 12implementation project(':piri-annatation')annotationProcessor project(':piri-processor') 创建注解1234@Retention(RetentionPolicy.SOURCE)@Target(ElementType.TYPE)public @interface NewIntent &#123;&#125; ElementType.TYPE 表示这个注解可以修饰 类，接口，枚举 等等。 创建注解处理器自定义的注解处理器需要继承至一个指定的父类（AbstractProcessor）： 1234567891011121314public class NewIntentProcessor extends AbstractProcessor &#123; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123;&#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnv) &#123;&#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;&#125; @Override public SourceVersion getSupportedSourceVersion() &#123;&#125;&#125; 开始处理注解首先找到所有的被指定注解修饰元素123456789101112for (Element element : roundEnvironment.getElementsAnnotatedWith(NewIntent.class)) &#123; if (element.getKind() != ElementKind.CLASS) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Can be applied to class."); return true; &#125; TypeElement typeElement = (TypeElement) element; activitiesWithPackage.put( typeElement.getSimpleName().toString(), elements.getPackageOf(typeElement).getQualifiedName().toString());&#125; 我们利用 roundEnvironment.getElementsAnnotatedWith() 这个方法就可以找出所以被指定注解修饰的元素，这个方法返回了一个集合，集合类型是 Element，Element 是所有元素的一个父接口。 然后我们判断一下，注解是否被正确使用了，因为我们在创建注解的时候就指定了该注解只能修饰类，接口，枚举… 如果注解被错误使用了，我们可以使用 message 打印错误信息，反之，被正确使用了，那么我们就可以将它强制转换为 TypeElement。关于这个 TypeElement ，它是 Element 的一个子接口。它通常可以用于类和方法参数。还有一些其他类型的元素： 12345678910111213package com.example; // PackageElementpublic class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () &#123;&#125; // ExecuteableElement public void setA ( // ExecuteableElement int newA // TypeElement ) &#123;&#125;&#125; 之所以要强制转换成 TypeElement，是因为转换之后，我们可以获取到更多的信息。 生成代码1234567891011121314151617TypeSpec.Builder navigatorClass = TypeSpec .classBuilder("Navigator") .addModifiers(Modifier.PUBLIC, Modifier.FINAL);for (Map.Entry&lt;String, String&gt; element : activitiesWithPackage.entrySet()) &#123; String activityName = element.getKey(); String packageName = element.getValue(); ClassName activityClass = ClassName.get(packageName, activityName); MethodSpec intentMethod = MethodSpec .methodBuilder(METHOD_PREFIX + activityName) .addModifiers(Modifier.PUBLIC, Modifier.STATIC) .returns(classIntent) .addParameter(classContext, "context") .addStatement("return new $T($L, $L)", classIntent, "context", activityClass + ".class") .build(); navigatorClass.addMethod(intentMethod);&#125; 这个是 JavaPoet 的使用方法，就不多说了，可以查看 文档 。 最后，将代码写入文件123JavaFile.builder("com.annotationsample", navigatorClass.build()) .build() .writeTo(filer); 生成的文件大概内容如下： 12345public final class Navigator &#123; public static Intent startMainActivity(Context context) &#123; return new Intent(context, com.annotationsample.MainActivity.class); &#125;&#125; 然后，我们就可以在代码中使用生成的代码了： 1234567891011121314@NewIntentpublic class MainActivity extends AppCompatActivity &#123;&#125;----------------------------------------------------------------------------------------public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); Navigator.startMainActivity(this); //generated class, method &#125;&#125; 实例工程AnnotationProcessorDemo 遇到的坑： 新建module的时候要选择 java module，否则找不到 AbstractProcessor 类 我的 AS 一直保持着最新的 gradle 版本，在我写示例项目的时候，是引用的 gradle 版本是 https\://services.gradle.org/distributions/gradle-5.1.1-all.zip，于是我就踩了一个深坑，那就是发现 processor 工程打包除了问题，导致 app 项目引用了无法生成文件。找了一个下午的问题最后发现是 gradle 版本的问题，改成 https\://services.gradle.org/distributions/gradle-4.6-all.zip 就好了。我特么想骂人。 上面的版本问题，已经找到答案，添加一行代码即可： 1annotationProcessor &apos;com.google.auto.service:auto-service:1.0-rc5&apos; 我当时看别人的博客的时候，就很奇怪，为啥不用加 annotationProcessor。 倒推一下 ButterKnife 是怎么做的首先我们先来回忆一下我们是怎么使用 ButterKnife 的。 给控件加上注解： 12@BindView(R.id.title) TextView title; 在 Activity 的 setContentView 后，添加代码： 1ButterKnife.bind(this); 经过这两步，title 就会被自动赋值，然后我们就可以使用了。 这里我们可以猜想一下，ButterKnife 的注解处理器做了什么。 第一步，肯定也是先要获取到被注解修饰的元素。然后接下来该做什么呢？我们转换一下思维，如果我们没有使用 ButterKnife 的话，我们会做什么——我们会在 setContentView 方法后面写一个 initView 方法，然后给变量赋值。这个时候你就应该反应过来了，ButterKnife.bind(this); 这句代码就做了类似的功能。那么它是如何实现的呢？ 我们从这行代码中可以看出，ButterKnife 会持有当前 Activity 的引用，那么我们可不可以利用这个引用，拿到 title 呢？答案是可以的，因为 title 不是私有的，所以我们只需要生成一个类，将这个类放入当前 Activity 所在的 package 中即可。 由于注解的参数就是这个控件的 id，所以我们也可以找到这个控件，调用 findViewById，将这个值赋值给 title。大概是这样： 自动生成的代码 xxx 12activity.title = Utils.findViewById(root, id);这样就完成了赋值。当然实际不可能这么简单，还有很多细节需要处理，这里只是一个倒推，具体的细节还请执行查阅源代码。 后记 文章中已经说过，Annotaion Processor 只能生成新的文件，无法对已有的文件进行修改。如果我们有这方便的需求，那么应该怎么做呢？比如，我们想给某些类（比如Activity 或者 Fragement ）添加 log，手动添加的话，就很蛋疼了，这个时候，如果可以批量处理的话就会轻松很多。那么有什么可以办到呢，就是 Transform API 了，下一篇就写这个东西。 added注解处理器有这么一个蛋疼的地方：它会为每个使用注解的工程生成一个文件，那么问题就来了，有多个module以依赖的形式被app引用，那么就会生成多个相同的类，打包的时候肯定会报错，怎么解决呢？Arouter是生成不同的文件（以模块命名）。 想做一个收集被指定注解修饰的类的功能，但是遇到了很多问题： 首先生成的多个文件只能在module中访问，无法整合成一个类。 就算想别的方法再搞一个类整合这些生成的类，也需要知道这些生成的类的类名，还要能够访问的到这些类（除非你使用反射）。注解处理器的工作方式是每个module分开处理，没法知道别的module生成类的名字（除非像deeplink一样，手动添加）。 后记注解处理器可能会有多次处理过程。一个简单的例子：第一轮处理调用了注解处理器的process()方法，我们生成了对应的文件。由于生成了新文件，它可能会有注解，所以会走下一轮注解处理，然后重复生成文件。就会报错：Attempt to recreate a file for type xxxx解决办法是需要在 process 中将保存的集合清空，在集合为空时，不生成文件。]]></content>
      <categories>
        <category>AnnotationProcessor</category>
      </categories>
      <tags>
        <tag>Java-AnnotationProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-使用组件辅助模块]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0006-%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[每个组件里可能会有一些重复逻辑，特别是采用通用 model 开发组件的时候，组件的 View 之间一般没有继承体系，为了解决这种问题，建议业务也像SimpleClickSupport或者ExposureSupport一样将逻辑模块化，通过 serviceManager 注册到框里提供给组件使用。此外框架里还提供了一个CellSupport，暴露了一些基本接口，业务方需要继承它并注册到 Tangram 里。 假设我们的页面上有一些 Cell 需要做一些比较特殊且复杂的 log 操作，我们将 log 操作封装了起来以方便调用。 现在就有两种方式来使用封装好了的工具，第一种是在自定义 View 的时候，创建这个工具类出来，这显然不太好，或许我们可以将这个工具方法改为静态的，没法改的话，将工具类改为单利。 第二种方法就对该工具类没啥要求，只需要我们写好这个类之后，然后注册到 ServiceManager 里面，然后每个 cell 都可以获取到这个工具类了，如下： 123public class ComplexLogUtil &#123; public void log(View v)&#123;...&#125;&#125; 1engine.register(ComplexLogUtil.class, new ComplexLogUtil()); 123456789@Overridepublic void cellInited(BaseCell cell) &#123; if (cell.serviceManager != null) &#123; ComplexLogUtil complexLogUtil = cell.serviceManager.getService(ComplexLogUtil.class); if (timerSupport != null ) &#123; complexLogUtil.log(this); &#125; &#125;&#125; ServiceManager 就是一个纽带，让每个 Cell 都可以共享同一个东西。 再说 CellSupport，源码里面是这样使用这个类的： com.tmall.wireless.tangram.MVHelper#mountView 123456if (cell.serviceManager != null) &#123; CellSupport cellSupport = cell.serviceManager.getService(CellSupport.class); if (cellSupport != null) &#123; cellSupport.postBindView(cell, view); &#125;&#125; 这就说明了，当我们注册的时候，我们只能使用 CellSupport.class 来注册。比如我们有一个类 MyCellSupport 实现了这个接口，我们注册的时候如下： 1engine.register(CellSupport.class, new MyCellSupport()); 这个玩意就比较像一个切面了，比如我们想对每一个 cell 在 bindView 或者 unBindView 做一些通用的操作，就可以实现这个接口。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-使用布局辅助模块]]></title>
    <url>%2F2019%2F09%2F10%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0007-%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B1%80%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[CardSupport，布局辅助模块，主要处里布局背景加载的回调，让业务方有能力去控制相关逻辑，业务方需要继承它并注册到 Tangram 里。由于这里面的逻辑涉及到 vLayout，而 vLayout 系列准备另起一个系列，所以这里就不说咯。这个类还是挺简单的，里面就几个空方法，Java 8 可以改成接口，用默认实现。 方法的意义也很明了，就是用来处理布局背景的，其他的没有。 还有一个方法是用来设置固定的 view 的出现与消失动画的。 123456789101112public abstract class CardSupport &#123; public FixAreaLayoutHelper.FixViewAnimatorHelper onGetFixViewAppearAnimator(Card card) &#123; return null; &#125; public void onUnbindBackgroundView(View layoutView, Card card) &#123; &#125; public abstract void onBindBackgroundView(View layoutView, Card card);&#125;]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-处理点击与曝光]]></title>
    <url>%2F2019%2F09%2F09%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0003-%E5%A4%84%E7%90%86%E7%82%B9%E5%87%BB%E4%B8%8E%E6%9B%9D%E5%85%89%2F</url>
    <content type="text"><![CDATA[在上一篇，我们在自定义的 View 中的 cellInited 方法里面做了一些初始化的操作，其中就有添加点击事件，代码如下：12345@Overridepublic void cellInited(BaseCell cell) &#123; setOnClickListener(cell); this.cell = cell;&#125; 其中，setOnClickListener 方法的参数是 BaseCell，说明它肯定实现了点击事件的接口： com.tmall.wireless.tangram.structure.BaseCell#onClick 12345678910111213@Overridepublic void onClick(View v) &#123; if (serviceManager != null) &#123; SimpleClickSupport service = serviceManager.getService(SimpleClickSupport.class); if (service != null) &#123; int eventType = this.pos; if (innerClickMap.containsKey(v.hashCode())) &#123; eventType = innerClickMap.get(v.hashCode()).intValue(); &#125; service.onClick(v, this, eventType); &#125; &#125;&#125; 看第 10 行代码，这行代码最终会调用到 com.tmall.wireless.tangram.support.SimpleClickSupport#defaultClick 里面。 SimpleClickSupport 的子类应该要处理这个方法： 123456789101112public class SampleClickSupport extends SimpleClickSupport &#123; public SampleClickSupport() &#123; setOptimizedMode(true); &#125; @Override public void defaultClick(View targetView, BaseCell cell, int eventType) &#123; super.defaultClick(targetView, cell, eventType); Toast.makeText(targetView.getContext(), " 您点击了组件 type:"+cell.type, Toast.LENGTH_SHORT).show(); &#125;&#125; 可以看出来，SimpleClickSupport 是用来统一处理点击事件的。说一下 defaultClick 的 3 个参数： targetView 是 Cell 对应的 View，可能是一个 View，也可能是一个 ViewGroup cell 是View 对应的 cell （感觉有点废话） eventType 是注册点击事件时，传入的 type，如果没有传入该值默认为在 Card 中的位置。 我们可以在自定义 View 中传入 type： 12345@Overridepublic void cellInited(BaseCell cell) &#123; cell.setOnClickListener(this, 4); this.cell = cell;&#125; 这样的话，点击该 cell，eventType 就是 4 了。 使用SimpleClickSupport的时候需要注意： 建议开启优化模式 在路由点击事件的时候，会判断如果开启了优化，会调用到 defaultClick 方法，否则的话会触发反射： 1234567891011public void onClick(View targetView, BaseCell cell, int eventType, Map&lt;String, Object&gt; params) &#123; if (optimizedMode) &#123; defaultClick(targetView, cell, eventType); &#125; else &#123; ... // 使用反射寻找方法 // 方法需要以 onClickXXX 或者 onXXXClick 命名 // 并且参数列表是View targetView, BaseCell cell, int type或者View targetView, BaseCell cell, int type, Map&lt;String, Object&gt; params ... &#125;&#125; 处理曝光Tangram 认为组件曝光的时机就是被 RecyclerView 的 Adapter 绑定数据的那个时候，也就是即将滑动到屏幕范围内。在这个时候业务上可能需要有一些处理，因此提供了接口定义并整合到框架里 —— ExposureSupport。它定义了3个层面的曝光接口，一是曝光布局，二是曝光组件整体区域，三是曝光组件局部区域。业务方实现子类，并针对三个层面的曝光做分别的实现。 文档开头说的还是很清晰的，但是却没有仔细说这 3 个接口是哪 3 个，真的是蛋疼。 布局的整体曝光（这是从文档copy出来的，不知道是布局的曝光还是组件整体的曝光）回调接口是： 1public abstract void onExposure(@NonNull Card card, int offset, int position); 这个方法在com.tmall.wireless.tangram.dataparser.concrete.PojoGroupBasicAdapter#onBindViewHolder中调用。 组件的局部区域曝光接口是： 123public void defaultTrace(@NonNull View targetView, @NonNull BaseCell cell, int type) &#123;&#125; 但是我却没找到哪里调用了这个方法！！！ 还有一个方法： 123public void defaultExposureCell(@NonNull View targetView, @NonNull BaseCell cell, int type) &#123;&#125; 这个方法在 com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder 中调用。 可以看到，onExposure 与 defaultExposureCell 执行的时机差不多在同一时刻，因为 PojoGroupBasicAdapter 是 GroupBasicAdapter 的子类。差别就只有参数了。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-异步加载数据]]></title>
    <url>%2F2019%2F09%2F09%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0004-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[Tangram 的页面的数据无法一次性返回，有些区块布局内的数据需要异步加载、甚至分页加载。Tangram 里内置了封装了异步加载的逻辑，需要各个层面配合完成。数据设置想要实现异步加载，服务器返回的数据需要做如下配置：123456&#123; "id": "Shop", "load": "queryShop", "loadType": "-1", "type": "container-oneColumn"&#125; load 是接口名称，表示这个布局需要执行异步加载的接口。 loadType 是异步加载的方式，-1表示需要异步加载，1表示需要异步加载且有分页。 hasMore 与 loadType 配合，当 loadType = 1 的时候表示分页是否结束。 loadParams 是异步加载接口的常规参数字典，需要在调用接口时透传。 既然规定了 load 是接口名称，我们直接搜一下哪里用到了 “load”这个字符串，果然 Card 里面有一个字段： com.tmall.wireless.tangram.dataparser.concrete.Card#KEY_API_LOAD 1public static final String KEY_API_LOAD = "load"; 继续看用这个字符串搞了啥： com.tmall.wireless.tangram.dataparser.concrete.Card#parseWith(org.json.JSONObject, com.tmall.wireless.tangram.MVHelper, boolean) 12345public void parseWith(@NonNull JSONObject data, @NonNull final MVHelper resolver, boolean isParseCell) &#123; ... load = data.optString(KEY_API_LOAD, null); ...&#125; 从 json 数据里面解析出来接口名字，这个在意料之中。 解析出来之后，框架里面并没有去发起请求，而是使用了接口的方式让外部去做请求，这里只是将接口的一些信息解析出来保存起来。 CardLoadSupport与AsyncLoader，AsyncPageLoader上面说了，请求的处理还是暴露给了外部去处理，那么应该怎么做呢？只需要做一件事，提供一个自定义的 CardLoadSupport 就好了。 这个 CardLoadSupport 需要传入两个参数进去，AsyncLoader和AsyncPageLoader。所以归根结底，还是要自定义两个对象，AsyncLoader 和 AsyncPageLoader。 自定义这两个对象不难，我们看一个例子就明白了： 123456789new AsyncLoader() &#123; @Override public void loadData(Card card, @NonNull final LoadedCallback callback) &#123; Log.w("Load Card", card.load); ... // callback.fail(false); callback.finish(engine.parseComponent(cells)); &#125;&#125; card 参数里面有接口的所有信息了，所以可以发起请求，请求之后可以根据结果来设置相应的回调。 1234567891011121314151617181920212223242526new AsyncPageLoader() &#123; @Override public void loadData(final int page, @NonNull final Card card, @NonNull final LoadedCallback callback) &#123; // cells 是请求回来的数据 List&lt;BaseCell&gt; cs = engine.parseComponent(cells); if (card.page == 1) &#123; GroupBasicAdapter&lt;Card, ?&gt; adapter = engine.getGroupBasicAdapter(); card.setCells(cs); adapter.refreshWithoutNotify(); Range&lt;Integer&gt; range = adapter.getCardRange(card); adapter.notifyItemRemoved(range.getLower()); adapter.notifyItemRangeInserted(range.getLower(), cs.size()); &#125; else &#123; card.addCells(cs); &#125; //mock load 6 pages callback.finish(card.page != 6); card.notifyDataChange(); &#125;&#125;)); 这里是分页请求的处理，与我们平时分页的逻辑并无多大区别。 下面我们来看看源码里面，这两个 loader 做了什么，我们以 AsyncPageLoader 为例。 com.tmall.wireless.tangram.TangramEngine#onScrolled 在 RecyclerView 滚动的时候，就会调用这个方法，当然这方法需要我们主动的调用： 1234567recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); engine.onScrolled(); &#125;&#125;); 下面，我们分析 onScrolled 方法里面的核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// position 是当前屏幕上最后一个 cell 的位置// lastCardIndex 是表示的第几种 type 类型，从 0 开始// 所以 current 是屏幕上最后一个 card// 这里是对屏幕上最后一个卡片进行预加载更多if (pair != null &amp;&amp; position &gt;= pair.first.getUpper() - mPreLoadNumber) &#123; // async load if (!TextUtils.isEmpty(current.load) &amp;&amp; current.loaded) &#123; // page load if (current.loadMore) &#123; loadSupport.loadMore(current); loadSupport.reactiveDoLoadMore(current); &#125; return; &#125;&#125;boolean loadedMore = false;// 这里是处理当前屏幕上的 cardfor (int i = firstCardIndex; i &lt; Math.min(lastCardIndex + mPreLoadNumber, cards.size()); i++) &#123; Card c = cards.get(i); // async load if (!TextUtils.isEmpty(c.load) &amp;&amp; !c.loaded) &#123; // page load if (c.loadMore &amp;&amp; !loadedMore) &#123; // only load one load more card loadSupport.loadMore(c); loadSupport.reactiveDoLoadMore(c); loadedMore = true; &#125; else &#123; loadSupport.doLoad(c); loadSupport.reactiveDoLoad(c); &#125; c.loaded = true; &#125;&#125;// 这里是处理数据源里的最后一个 cardif (mEnableAutoLoadMore &amp;&amp; mGroupBasicAdapter.getItemCount() - position &lt; mPreLoadNumber) &#123; loadMoreCard();&#125; 这里面的主要逻辑分为 3 段，但是很蛋疼的是，这 3 段逻辑又有重复的地方。我们拿数学区间举例：假设第一段区间是 [0, 3]，第二段是 [2, 4]，第三段是 [3, 5]。可以看出区间里面有重复的地方法，就如同上面代码的 3 段逻辑。我们举一个例子来说明逻辑重复导致的影响： Tangram 提供了一个禁止加载更多的方法： com.tmall.wireless.tangram.TangramEngine#enableAutoLoadMore 123public void enableAutoLoadMore(boolean enableAutoLoadMore) &#123; this.mEnableAutoLoadMore = enableAutoLoadMore;&#125; 可以看到，这个字段只用在了第 3 段逻辑里面，按照道理来说，设置了这个之后，我们就不会自动加载更多了，但是实际上上面的两段逻辑也包含加载更多的逻辑，所以即使也将这个字段设置为了 false，你再运行官方demo也没啥区别。 这里我懒得搞清楚它为啥要这样写了，说实话这个框架的是值得一看的，但是代码真的很乱，阅读起来你搞不清楚写的人在想啥。 我们继续我们的分析，从上面的代码中我们可以看到它调用了 CardLoadSupport 的 doLoad 与 loadMore 方法。 CardLoadSupport#doLoad这个方法是用来加载 Card 中的数据的。 com.tmall.wireless.tangram.support.async.CardLoadSupport#doLoad 123456789101112131415161718192021222324252627public void doLoad(final Card card) &#123; if (mAsyncLoader == null) &#123; return; &#125; if (!card.loading &amp;&amp; !card.loaded) &#123; card.loading = true; mAsyncLoader.loadData(card, new AsyncLoader.LoadedCallback() &#123; @Override public void finish() &#123; card.loading = false; card.loaded = true; &#125; @Override public void finish(List&lt;BaseCell&gt; cells) &#123; finish(); card.addCells(cells); card.notifyDataChange(); &#125; public void fail(boolean loaded) &#123; card.loading = false; card.loaded = loaded; &#125; &#125;); &#125;&#125; 在方法中，我们可以看到实际上是使用了 com.tmall.wireless.tangram.support.async.AsyncLoader#loadData 这个方法，而这个方法是我们在创建 AsyncLoader 的时候，需要实现的方法。这样加载 Card 数据的逻辑就串起来了： 监听 RecyclerView 的滚动，在滚动的时候就触发加载加载逻辑。 如果数据没有加载的话，就调用外部实现的 AsyncLoader#loadData 方法来加载数据。 CardLoadSupport#loadMore这个方法是用来处理分页加载的。 com.tmall.wireless.tangram.support.async.CardLoadSupport#loadMore 1234567891011121314151617181920212223242526272829303132333435363738394041public void loadMore(final Card card) &#123; if (mAsyncPageLoader == null) &#123; return; &#125; if (!card.loading &amp;&amp; card.loadMore &amp;&amp; card.hasMore) &#123; card.loading = true; if (!card.loaded) &#123; card.page = sInitialPage; &#125; mAsyncPageLoader.loadData(card.page, card, new AsyncPageLoader.LoadedCallback() &#123; @Override public void finish(boolean hasMore) &#123; card.loaded = true; card.loading = false; card.page++; card.hasMore = hasMore; &#125; @Override public void finish(List&lt;BaseCell&gt; cells, boolean hasMore) &#123; if (card.page == sInitialPage) &#123; card.setCells(cells); &#125; else &#123; card.addCells(cells); &#125; finish(hasMore); card.notifyDataChange(); &#125; @Override public void fail(boolean retry) &#123; card.loaded = true; card.loading = false; card.hasMore = retry; &#125; &#125;); &#125;&#125; 这里的逻辑也很简单，与 doLoad 方法是一样的。我们在实现 AsyncPageLoader.loadData 方法的时候，一定要注意正确的调用 finish 与 fail 方法。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F07%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[直接看官方文档比较好吧： 了解Tangram 基本概念 基础架构 设计原则 后面的文章，都是照着下面链接的目录来的： http://tangram.pingguohe.net/docs/android/access-tangram 主要是记录在看文档的过程中，对相应部分源码的分析与自己的理解。 Tangram 的接入与核心方法这两部分可讲的东西不多，所以我们直接跳过。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-组件开发]]></title>
    <url>%2F2019%2F09%2F07%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FTangram%2F0002-%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在 Tangram 的领域里，我们将一个普通的列表页面结构化成树状结构：分别是页面 - 布局 - 组件。123456789101112131415161718192021222324252627282930页面 | - 布局1 | | | - 组件11 | | | - 组件12 | | | - 组件13 | - 布局2 | | | - 组件21 | | | - 组件22 | - 布局3 | | | - 组件31 | | | - 组件32 | - 组件4 ... | | | - 布局n | - 组件n1 组件分为两层：model 和 View。Tangram 里提供了通用 model 类型 BaseCell，因此开发组件有两个选择： 采用通用 model，开发自定义 View。 采用自定义 model 和自定义 View BaseCell 里面储存了组件的数据信息，又需要的都可以在里面获取到，可以看一下结构树来了解一下里面的方法都有什么，这里就不展开说了，方法名很明了。 通用 Model 开发自定义 View文档提供了两种开发方式，一种是需要实现 ITangramViewLifeCycle 接口，一种是使用注解加反射的方式。 我们先来看第一种，实现结构的方式，以官方的demo为例： com.tmall.wireless.tangram.example.data.SingleImageView 1public class SingleImageView extends LinearLayout implements ITangramViewLifeCycle &#123;...&#125; 自定义的 View 需要实现接口，这个没啥说的。 该接口有 3 个方法需要实现： com.tmall.wireless.tangram.structure.view.ITangramViewLifeCycle 123456789public interface ITangramViewLifeCycle &#123; void cellInited(BaseCell cell); void postBindView(BaseCell cell); void postUnBindView(BaseCell cell);&#125; 第一个方法，就是用来做一些初始化工作的，cell 表示是这个组件的一些信息。上面说过，页面由布局与组件组成，对应的就是 Card 与 Cell。 我们追踪一下，看这个方法在哪里被调用： com.tmall.wireless.tangram.MVHelper#initView com.tmall.wireless.tangram.MVHelper#mountView com.tmall.wireless.tangram.core.adapter.BinderViewHolder#bind com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onBindViewHolder 可以看到，最后到了 GroupBasicAdapter 的 onBindViewHolder方法里面。Tangram 的布局是基于 RecyclerView 的，我们将 GroupBasicAdapter 当作一个超级强的 Adapter 的实现就好了，所以 Cell 的初始化是在 onBindViewHolder 中执行的。 再看接口中的第二个方法，看名字就应该知道也是在 onBindViewHolder 的时候执行的，不过有一个 post 前缀，我们追踪一下就会发现，其实就是比 cellInited 方法晚一点调用而已。 com.tmall.wireless.tangram.MVHelper#mountView 12345678910&#125; else &#123; loadMethod(cell, view); initView(cell, view); renderView(cell, view); renderStyle(cell, view);&#125;if (mvResolver.isCompatibleType(cell.stringType)) &#123; mvResolver.getCellClass(cell.stringType).cast(cell).bindView(view);&#125;postMountView(cell, view); 第 3 行与第 10 行，第 3 行会触发 cellInited 的调用，第 10 行触发了 postBindView。 再看接口中的第三个方法，我们可以思考一下，应该在什么时候触发 postUnBindView 方法？最显然的应该是在滑出屏幕的时候，但是如果对 RecyclerView 的回收机制有一定了解的应该知道，一个 item 滑出屏幕的时候，还没有进入 pool 里面，而是进入到了 cache 里面，是为了防止用户滑出又滑入的情况。所以我们应该在 item 进入 pool 的时候再触发 postUnBindView，而且只有进入了 pool 中的 item 才会重新走 onBindViewHolder，这刚好与 postBindView 是对称的。 我们追踪一下代码，看看它是什么时候调用的： com.tmall.wireless.tangram.core.adapter.GroupBasicAdapter#onViewRecycled 123456@Overridepublic void onViewRecycled(BinderViewHolder&lt;C, ? extends View&gt; holder) &#123; ... holder.unbind(); ...&#125; 与我们思考的一样，是当 item 被回收的时候，触发的。 现在，我们知道了这 3 个方法调用的时机，就知道我们可以在这 3 个方法里面做什么了，下面是一个例子： com.tmall.wireless.tangram.example.data.TestView 12345@Overridepublic void cellInited(BaseCell cell) &#123; setOnClickListener(cell); this.cell = cell;&#125; 这里处理了点击事件。 12345678910111213141516171819@Overridepublic void postBindView(BaseCell cell) &#123; int pos = cell.pos; String parent = ""; if (cell.parent != null) &#123; parent = cell.parent.getClass().getSimpleName(); &#125; textView.setText( cell.id + " pos: " + pos + " " + parent + " " + cell .optParam("msg")); if (pos &gt; 57) &#123; textView.setBackgroundColor(0x66cccf00 + (pos - 50) * 128); &#125; else if (pos % 2 == 0) &#123; textView.setBackgroundColor(0xaaaaff55); &#125; else &#123; textView.setBackgroundColor(0xcceeeeee); &#125;&#125; 这个方法里，就是设置组件了。 postBindView 与 cellInited 的区别在于，postBindView 调用的时候，view 与 style 的渲染准备工作都完成了。 123@Overridepublic void postUnBindView(BaseCell cell) &#123;&#125; 一般情况下，这个方法都不用做什么，除非你有什么需要取消的，比如网络请求，定时器。 自定义 View 还支持注解加反射的方式，原理是一样的，不过一个是直接调用，一个是使用反射来调用，我不太喜欢这种方式，就不介绍了。 自定义 Model 开发组件采用通用的 model 开发组件，只需要写 View 就可以了，然而需要在每次绑定数据的时候都要取原始 json 里解析一下字段。有时候一个业务方会有一些通用的业务字段定义，每个组件里重复解析会让代码显得冗余，因此也提供了注册自定义 model 的兼容模式开发组件。这个时候就需要写自定义 model 和自定义 View 两部分了。 自定义 Model 需要继承 BaseCell，可以实现下面的几个方法： 1234567891011121314/** 解析数据业务数据，可以将解析值缓存到成员变量里 */public void parseWith(JSONObject data)/** 解析数据样式数据，可以将解析值缓存到成员变量里 */public void parseStyle(@Nullable JSONObject data)/** 绑定数据到自定义 View */public void bindView(@NonNull V view)/** 绑定数据到 View 之后，可选实现 */public void postBindView(@NonNull V view)/** 校验原始数据，检查组件的合法性 */public boolean isValid() 其中两个 parse 方法可以理解，但是两个 bind 方法感觉没啥作用啊，有啥通用的 bind 与 unbind 逻辑可以写在这里吗？当成一个切面好理解些。 粒度想一下，Tangram 复用的粒度是 Card 还是 Cell？Card的作用是用来排列 Cell 的，所以它只是起了一个布局的作用，是一个虚拟的概念，在实际的绘制中根本不存在 Card 。所以粒度是 Cell。]]></content>
      <categories>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android源码解析-Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0007-控件]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0007-%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[虚拟控件到底是如何工作的？它是如何直接绘制在 canvas 上的？Tangram 提供的控件分为两类，一类以 Native 开头，表示实际上是基于原生控件实现的。一类以 Virtual 开头，表示这不是一个实际的控件。这里分析两个控件，来加深对虚拟控件的理解。NativeText看它的构造函数，它里面封装了一个原生的控件： com.tmall.wireless.vaf.virtualview.view.text.NativeText 12345678910public class NativeText extends TextBase &#123; protected NativeTextImp mNative; public NativeText(VafContext context, ViewCache viewCache) &#123; super(context, viewCache); mNative = new NativeTextImp(context.forViewConstruction()); &#125;&#125; 这个 NativeTextImp 就是继承至 TextView 的。 Tangram 的控件都是继承至 ViewBase 的，而不是继承至 View。它们没有 view 的 onMeasure，onLayout，onDraw 等方法，而是有自己的一套方法： com.tmall.wireless.vaf.virtualview.core.IView 123void onComMeasure(int widthMeasureSpec, int heightMeasureSpec);void onComLayout(boolean changed, int l, int t, int r, int b); 这两个方法就是自己的一套测量与布局逻辑，对于 Native 开头的控件来说，肯定是直接调用了封装的原生控件的方法： com.tmall.wireless.vaf.virtualview.view.text.NativeText 123456789@Overridepublic void onComMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; mNative.onComMeasure(widthMeasureSpec, heightMeasureSpec);&#125;@Overridepublic void onComLayout(boolean changed, int l, int t, int r, int b) &#123; mNative.onComLayout(changed, l, t, r, b);&#125; 而对于 Virtual 开头的控件来说，它里面没有封装原生控件，所以只能自己实现了，不过我们不用太担心，ViewBase 里有一个内部类 com.tmall.wireless.vaf.virtualview.core.ViewBase.VirtualViewImp，它实现了一些通用的逻辑，一般情况下，我们只需要使用它的方法就好了，看看 VirtualText 是如何做的： com.tmall.wireless.vaf.virtualview.view.text.VirtualText 123456789101112public class VirtualText extends TextBase &#123; protected VirtualViewImp mImp = new VirtualViewImp(); @Override public void onComMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; mImp.onComMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override public void onComLayout(boolean changed, int l, int t, int r, int b) &#123; &#125;&#125; 可以看到，用起来还是很方便的，VirtualText 没有子组件，所以不用实现 onComLayout 方法。 上面说了测量与布局，没有说绘制，是因为绘制有点特殊。还记得在容器添加组件的时候，是怎么做的么？ com.tmall.wireless.vaf.virtualview.container.Container#attachViews(com.tmall.wireless.vaf.virtualview.core.ViewBase, android.view.View) 之前我们没有深入分析这个方法，只是简单的带过了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void attachViews(ViewBase view, View displayViewHolder) &#123; view.setDisplayViewContainer(displayViewHolder); if (view instanceof Layout) &#123; View v = view.getNativeView(); if (null != v) &#123; if (v.getParent() == null) &#123; LayoutParams layoutParams = new LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight); addView(v, layoutParams); &#125; else &#123; LayoutParams layoutParams = v.getLayoutParams(); layoutParams.width = view.getComLayoutParams().mLayoutWidth; layoutParams.height = view.getComLayoutParams().mLayoutHeight; v.setLayoutParams(layoutParams); &#125; if (v instanceof INativeLayoutImpl) &#123; Layout layout = (Layout) view; List&lt;ViewBase&gt; subViews = layout.getSubViews(); if (null != subViews) &#123; for (int i = 0, size = subViews.size(); i &lt; size; i++) &#123; ViewBase com = subViews.get(i); ((INativeLayoutImpl) v).attachViews(com, v); &#125; &#125; &#125; &#125; else &#123; Layout layout = (Layout) view; List&lt;ViewBase&gt; subViews = layout.getSubViews(); if (null != subViews) &#123; for (int i = 0, size = subViews.size(); i &lt; size; i++) &#123; ViewBase com = subViews.get(i); attachViews(com, displayViewHolder); &#125; &#125; &#125; &#125; else &#123; View v = view.getNativeView(); if (null != v) &#123; if (v.getParent() == null) &#123; LayoutParams layoutParams = new LayoutParams(view.getComLayoutParams().mLayoutWidth, view.getComLayoutParams().mLayoutHeight); addView(v, layoutParams); &#125; else &#123; LayoutParams layoutParams = v.getLayoutParams(); layoutParams.width = view.getComLayoutParams().mLayoutWidth; layoutParams.height = view.getComLayoutParams().mLayoutHeight; v.setLayoutParams(layoutParams); &#125; &#125; &#125;&#125; 这个方法看起来很长，但是表达的意思非常的简单： 如果这个组件是以 Native 开头，这将这个组件封装的原生控件添加到容器里面 而对于不是以 Native 开头的，没有添加到容器里面，因为它根本就不是一个 view 这里说的 Native 开头不太准确，但是比较好理解，应该说成是里面封装了一个原生控件的组件。 对于以 Native 开头的，既然添加到了容器里面，那么它的绘制，就都交给 ViewRootImpl 去处理了，不用我们关心。那么这里有一个问题，既然它会被添加到容器里面，我们可不可以不用去实现其测量与布局逻辑呢？反正都是由系统处理。这个肯定是不行的，因为虽然添加到容器中后，走的是系统的布局，但是它与容器中其他虚拟控件的相互位置等等，走的是自定义的那一套逻辑，所以还是要实现自定义的测量与布局。 VirtualText而对于非 Native 开头的，它没有被添加到容器里面，那么它是怎么显示出来的呢？其实就是直接画在容器上的 canvas 上的啦。 com.tmall.wireless.vaf.virtualview.container.Container#onDraw 如果有虚拟控件，需要调用 setWillNotDraw(false);，该方法才会执行 123456@Overrideprotected void onDraw(Canvas canvas) &#123; if (null != mView &amp;&amp; mView.shouldDraw()) &#123; mView.comDraw(canvas); &#125;&#125; 这里的 mView 就是模板文件的根 ViewBase 了。它调用了自己 comDraw 方法，参数是自己的 canvas，我们拿 VHLayout 举例： com.tmall.wireless.vaf.virtualview.core.Layout#comDraw VHLayout 继承 Layout 1234567891011121314151617@Overridepublic void comDraw(Canvas canvas) &#123; super.comDraw(canvas); //FIXME let layout clip virtual children //canvas.save(); //VirtualViewUtils.clipCanvas(canvas, mMeasuredWidth, mMeasuredHeight, mBorderWidth, // mBorderTopLeftRadius, mBorderTopRightRadius, mBorderBottomLeftRadius, mBorderBottomRightRadius); // draw children for (int i = 0, size = mSubViews.size(); i &lt; size; i++) &#123; ViewBase v = mSubViews.get(i); if (v.shouldDraw()) &#123; v.comDraw(canvas); &#125; &#125; //canvas.restore();&#125; 可以看到，它调用了每个子组件的 comDraw 方法。这样一层一层绘制下去，我们拿 VirtualText 举例： com.tmall.wireless.vaf.virtualview.view.text.VirtualText#onComDraw 123456789101112131415161718192021 @Override protected void onComDraw(Canvas canvas) &#123; super.onComDraw(canvas); if (null == mContentRect) &#123; makeContentRect(); &#125; if (null != mContentRect) &#123;... canvas.save(); canvas.clipRect(0, 0, mMeasuredWidth, mMeasuredHeight); canvas.drawText(mDrawText, left, top - mDescent, mPaint); canvas.restore(); ... &#125; else &#123; Log.w(TAG, "skip draw text"); &#125; &#125; 这样 Text 就绘制出来了。 不过在绘制的时候，还有一个需要注意的地方： 子组件的画布需要变化一下，需要将绘制的位置，变换到布局的位置。 看看它是如何做的： com.tmall.wireless.vaf.virtualview.core.ViewBase#comLayout 1234567@Overridepublic void comLayout(int l, int t, int r, int b) &#123; mDrawLeft = l; mDrawTop = t; onComLayout(true, l, t, r, b);&#125; 在子组件布局完成之后，保存了左上角的位置。 com.tmall.wireless.vaf.virtualview.core.ViewBase#comDraw 1234567public void comDraw(Canvas canvas) &#123; canvas.save(); canvas.translate(mDrawLeft, mDrawTop); onComDraw(canvas); canvas.restore(); mIsDrawed = true;&#125; 然后，在绘制的时候，将画布平移了，这样一来，就不用子组件来操心了。 总结： 虚拟控件就是将测量，布局，绘制的逻辑封装在了一个普通的类X中，在依托容器显示的时候，容器中组件的测量，布局，绘制的逻辑，都走X类中的测量，布局，绘制的逻辑。 测量，布局逻辑是为了确定子组件在容器中画布的位置。 其实，把它想象成一个自定义控件就很好理解了。 当我们自定义一个比较复杂的控件时，通常会将这个控件分为好几部分。比如我们要绘制一个日历控件： 我们可以将将年分当作容器，它可以用 RecyclerView 或者 ViewPager 来实现 将月份封装成一个类，它只需要确定当前月有多少天，以及每天的信息应该绘制在哪个位置 （这个玩意就相当于一个布局方法了），以及绘制边框 将天封装成一个类，它绘制每一天的信息 对于月份来说，它不是一个 View，却相当于一个 ViewGroup，用于确定每一天的位置，然后平移画布。 对于天来说，它不是一个 View，却相当于一个 View，用于绘制某天的信息。 我们项目中的日历就是这么实现的，扩展性也不错。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0005-绑定数据]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0005-%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前面一篇文章，对于 preview 方法，我们分析完了第一行代码，现在，我们继续分析设置数据的方法，做了什么：1234IContainer iContainer = (IContainer) mContainer;if (jsonData != null) &#123; iContainer.getVirtualView().setVData(jsonData);&#125; 前面的东西都看懂了的话，就知道这里的 mContainer 实际上是一个 Container 的实例，iContainer.getVirtualView()的值就是 VHLayout。这里设置了 json 数据。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setVData(java.lang.Object, boolean) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768final public void setVData(Object data, boolean isAppend) &#123; if (VERSION.SDK_INT &gt;= 18) &#123; Trace.beginSection("ViewBase.setVData"); &#125; mViewCache.setComponentData(data); if (data instanceof JSONObject) &#123; boolean invalidate = false; if (((JSONObject) data).optBoolean(FLAG_INVALIDATE)) &#123; invalidate = true; &#125; List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView(); if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125; &#125; ((JSONObject) data).remove(FLAG_INVALIDATE); &#125; else if (data instanceof com.alibaba.fastjson.JSONObject) &#123; boolean invalidate = false; if (((com.alibaba.fastjson.JSONObject) data).getBooleanValue(FLAG_INVALIDATE)) &#123; invalidate = true; &#125; List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView(); if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125; &#125; ((com.alibaba.fastjson.JSONObject) data).remove(FLAG_INVALIDATE); &#125; if (VERSION.SDK_INT &gt;= 18) &#123; Trace.endSection(); &#125;&#125; 代码稍微有点长，再仔细看一下，里面有两段逻辑，是差不多的，一段是针对 Android 自带的 JSONObject 处理的，一段是针对 com.alibaba.fastjson.JSONObject 处理的，为啥没有 Gson。 我们只分析其中一段： 1234567891011121314151617181920212223List&lt;ViewBase&gt; cacheView = mViewCache.getCacheView();if (cacheView != null) &#123; for (int i = 0, size = cacheView.size(); i &lt; size; i++) &#123; ViewBase viewBase = cacheView.get(i); List&lt;Item&gt; items = mViewCache.getCacheItem(viewBase); if (null != items) &#123; for (int j = 0, length = items.size(); j &lt; length; j++) &#123; Item item = items.get(j); if (invalidate) &#123; item.invalidate(data.hashCode()); &#125; item.bind(data, isAppend); &#125; viewBase.onParseValueFinished(); if (!viewBase.isRoot() &amp;&amp; viewBase.supportExposure()) &#123; mContext.getEventManager().emitEvent(EventManager.TYPE_Exposure, EventData .obtainData(mContext, viewBase)); &#125; &#125; &#125;&#125; 获取缓存中的所有 ViewBase，然后对每一个 ViewBase 的 Item （也就是封装的属性类），都调用它的 bind 方法。 com.tmall.wireless.vaf.virtualview.core.ViewCache.Item#bind 这个方法有点长，截取一段分析 1234567case TYPE_INT: if (value instanceof Number) &#123; Integer integer = Utils.toInteger(value); if (integer != null) &#123; mView.setAttribute(mKey, integer.intValue()); &#125; &#125; value 的值，是 Parser 解析出来的，里面就是从 json 里面取对应的字段值，懒得看了。拿到值之后，设置给 view。 这样，数据绑定就搞定了。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0006-事件处理]]></title>
    <url>%2F2019%2F09%2F06%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0006-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[组件默认是不会响应事件的。想要组件响应事件，需要做如下类似设置：1flag="flag_exposure|flag_clickable"flag_exposure 表示组件曝光事件，源码中 com.tmall.wireless.vaf.virtualview.event.EventManager#TYPE_Exposure 表示曝光事件，看了调用的位置，一般都在 setData 的时候，有点奇怪。 flag_clickable 就是点击事件了。 当用户触摸了某个位置的时候，会触发下面的代码： com.tmall.wireless.vaf.virtualview.core.ViewBase#click 123public boolean click(int x, int y, boolean isLong) &#123; return clickRoute(mId, isLong);&#125; 或者下面的 layout 的方法： com.tmall.wireless.vaf.virtualview.core.Layout#click 123456789101112131415161718192021222324@Overridepublic boolean click(int x, int y, boolean isLong) &#123; boolean deal = false; for (int i = mSubViews.size() - 1; i &gt;= 0; i--) &#123; ViewBase v = mSubViews.get(i); int l = v.getAbsoluteDrawLeft(); int t = v.getAbsoluteDrawTop(); int w = v.getComMeasuredWidth(); int h = v.getComMeasuredHeight(); if (x &gt;= l &amp;&amp; x &lt; (l + w) &amp;&amp; y &gt;= t &amp;&amp; y &lt;= t + h) &#123; deal = v.click(x, y, isLong); if (deal) &#123; break; &#125; &#125; &#125; if (!deal) &#123; deal = super.click(x, y, isLong); &#125; return deal;&#125; 可以看出，对于 layout 来说，如果 child 没有处理 click 事件的话，会自己处理。类比一下 View 与 ViewGroup 还是很容易理解的。 下面的分析流程走 ViewBase 的 click 方法。 com.tmall.wireless.vaf.virtualview.core.ViewBase#clickRoute 123456789101112protected boolean clickRoute(int id, boolean isLong) &#123; boolean ret; if (isLong) &#123; ret = onLongClick(id); &#125; else &#123; ret = onClick(id); &#125; //if (!ret &amp;&amp; null != mParent) &#123; // ret = mParent.clickRoute(mParent.mId, isLong); //&#125; return ret;&#125; 以 onClick 为例： com.tmall.wireless.vaf.virtualview.core.ViewBase#onClick 123456789101112131415161718192021222324protected boolean onClick(int id) &#123; boolean ret = false; if (null != mBean) &#123; mBean.click(id, false); &#125; if (null != mClickCode) &#123; ExprEngine engine = mContext.getExprEngine(); if (null != engine) &#123; engine.getEngineContext().getDataManager().replaceData( getViewCache().getComponentData()); &#125; if (null != engine &amp;&amp; engine.execute(this, mClickCode)) &#123; &#125; else &#123; Log.e(TAG, "onClick execute failed"); &#125; &#125; // isClickable 会判断是否设置了 flag_clickable 标志位 if (isClickable() &amp;&amp; isVisible()) &#123; ret = mContext.getEventManager().emitEvent(EventManager.TYPE_Click, EventData.obtainData(mContext, this)); &#125; return ret;&#125; 这里发送了一个消息。 点击事件的注册如下： 123456789101112sVafContext.getEventManager().register(EventManager.TYPE_Click, new IEventProcessor() &#123; @Override public boolean process(EventData data) &#123; Log.d(TAG, "TYPE_Click data view:" + data.mView); Log.d(TAG, "TYPE_Click view name:" + data.mVB.getTag("name")); Log.d(TAG, "TYPE_Click view traceId:" + data.mVB.getTag("activityTraceId")); Toast.makeText(PreviewActivity.this, "TYPE_Click view name:" + data.mVB.getTag("name") + "\n traceId:" + data.mVB.getTag("activityTraceId"), Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); 可以看到，这里处理了消息， 只能统一处理。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0004-组件的创建]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0004-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前面我们说了，想要加载一个模板文件，需要调用如下代码：1sViewManager.loadBinBufferSync(TEST.BIN);那么，模板加载进来了之后，该怎么使用呢？用法还算是简单，如下：1234567891011121314151617protected void preview(String templateName, com.alibaba.fastjson.JSONObject jsonData) &#123; mContainer = sVafContext.getContainerService().getContainer(templateName, true); IContainer iContainer = (IContainer) mContainer; if (jsonData != null) &#123; iContainer.getVirtualView().setVData(jsonData); &#125; Layout.Params p = iContainer.getVirtualView().getComLayoutParams(); LinearLayout.LayoutParams marginLayoutParams = new LinearLayout.LayoutParams(p.mLayoutWidth, p.mLayoutHeight); marginLayoutParams.leftMargin = p.mLayoutMarginLeft; marginLayoutParams.topMargin = p.mLayoutMarginTop; marginLayoutParams.rightMargin = p.mLayoutMarginRight; marginLayoutParams.bottomMargin = p.mLayoutMarginBottom; mLinearLayout.removeAllViews(); mLinearLayout.addView(mContainer, marginLayoutParams);&#125; templateName 就是我们模板的名字，不是模板文件的名字，是模板的名字，以我们的例子来说，就是“TEST”。 jsonData 就是模板需要展示的数据，一个例子如下： 123456&#123; "style": &#123; "text-style" : "bold|italic" &#125;, "height": 200&#125; 这里的 style 可以看作是一个对象，它里面有一个 text-style 属性，我们可以这样使用它： 1textStyle="$&#123;style.text-style&#125;" 我们的例子中没有用到 style 这个东西。 ContainerService参数介绍完之后，我们来看看里面的逻辑： 1mContainer = sVafContext.getContainerService().getContainer(templateName, true); 这行代码就是核心内容了，里面就有实例化模板文件中的 view 的所有逻辑。我们点进去看一下： com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, boolean) 1234567public View getContainer(String viewType, boolean createParam) &#123; int type = mComContainerTypeMap.getContainerMap(viewType); if (type &lt;= -1) &#123; type = CONTAINER_TYPE_NORMAL; &#125; return getContainer(viewType, type, createParam);&#125; 因为 Tangram 是支持自定义组件与组件容器的，所以如果你有自定义的组件容器的话，需要注册进去，注册的时候需要传递一个 type 值。由于我们没有自定义的 type 所以这里会返回 -1（也就是说对于自带的容器都是返回 -1），所以我们的 type 值会默认是 CONTAINER_TYPE_NORMAL。 com.tmall.wireless.vaf.framework.cm.ContainerService#getContainer(java.lang.String, int, boolean) 1234567891011121314151617181920212223242526272829303132333435363738394041public View getContainer(String viewType, int containerType, boolean createParam) &#123; IContainer container = null; // 实例化组件是这行代码做的 ViewBase vb = mVM.getView(viewType); if (null == vb) &#123; vb = mVM.getDefaultImage(); vb.setViewType(viewType); &#125; // 如果模板的根布局是 container，不用做什么额外的操作 // 如果模板的根布局不是 container，需要添加一层 container 在外面，container 为 com.tmall.wireless.vaf.virtualview.container.Container 对象 if (vb.isContainer()) &#123; container = (IContainer) vb.getNativeView(); &#125; else &#123; ContainerMrg cm = mContainerMrg.get(containerType); if (null != cm) &#123; container = cm.getContainer(mAppContext); &#125; else &#123; Log.e(TAG, "getContainer type invalidate:" + containerType); &#125; &#125; // 有了容器之后，设置 layoutParams 就完事了 if (null != container) &#123; container.setVirtualView(vb); if (createParam) &#123; Layout.Params p = vb.getComLayoutParams(); MarginLayoutParams marginLayoutParams = new MarginLayoutParams(p.mLayoutWidth, p.mLayoutHeight); marginLayoutParams.leftMargin = p.mLayoutMarginLeft; marginLayoutParams.topMargin = p.mLayoutMarginTop; marginLayoutParams.rightMargin = p.mLayoutMarginRight; marginLayoutParams.bottomMargin = p.mLayoutMarginBottom; ((View)container).setLayoutParams(marginLayoutParams); &#125; // 这里就是将 layout 里面的控件都拿出来，add到容器里里面 container.attachViews(); &#125; return (View)container;&#125; 文档里面说过，因为虚拟控件只是绘制在 canvas 上，所以它依托一个原生容器控件作为宿主容器，必须要有容器才会显示。 我们例子中用的 VHLayout，看起来像一个容器，但是它不是，它里面有自己的测量，布局，绘制逻辑，但是它不是 ViewGroup，也不是 View。它也需要依托在一个容器里面，因为容器是继承了 ViewGroup 的，所以容器才能显示出来。 比如：VHLayout里面竖向排列了3个 NText，我们只拿布局逻辑来说。竖向排列的逻辑放在了 VHLayout 里面，但是容器会将 3个 NText 都拿出来，add 到自己的布局里面，那么这个时候，容器在布局的时候，就需要调用 VHLayout 里面的布局逻辑，来排列 3 个 NText。 这里先有个大致的了解，后面会单独讲解虚拟控件到底是个什么东西。 ViewManager回到代码逻辑，我们深入下去： com.tmall.wireless.vaf.framework.ViewManager#getView 12345678910111213141516171819public ViewBase getView(String type) &#123; ViewBase v; List&lt;ViewBase&gt; vList = mViewCache.get(type); if (null == vList || 0 == vList.size()) &#123; v = mViewFactory.newView(type, mUuidContainers); if (null != v) &#123; if (v.supportDynamic()) &#123; mAppContext.getNativeObjectManager().addView(v); &#125; v.setViewType(type); &#125; else &#123; Log.e(TAG, "new view failed type:" + type); &#125; &#125; else &#123; v = vList.remove(0); &#125; return v;&#125; 这个方法就很简单了，只有第5行是核心代码，就是调用了 ViewFactory 的方法。其他的逻辑都是与缓存相关，因为最终都是基于RecyclerView的，有兴趣的可以自己研究。 ViewFactory com.tmall.wireless.vaf.virtualview.ViewFactory#newView(java.lang.String, android.util.SparseArray&lt;com.tmall.wireless.vaf.virtualview.core.ViewBase&gt;) 这个方法很长，我们一段一段的分析： 12345678910111213public ViewBase newView(String type, SparseArray&lt;ViewBase&gt; uuidContainers) &#123; ViewBase ret = null; if (null != mLoader) &#123; CodeReader cr = null; synchronized (LOCK) &#123; cr = mUiCodeLoader.getCode(type); if (cr == null) &#123; Log.d(TAG, "load " + type + " start when createView "); mTmplWorker.executeTask(type); cr = mUiCodeLoader.getCode(type); &#125; &#125; mUiCodeLoader 是老朋友了，我们可以根据 type 获取到对应的 CodeReader，CodeReader 里面储存的是模板的二进制数据。 mTmplWorker 是用来做异步加载处理的，因为有可能我们启动了异步加载，在实例化模板的时候，模板文件还没有读取完成，所以这里就需要先去加载模板文件。 1234567if (null != cr) &#123; mComArr.clear(); ViewBase curView = null; int tag = cr.readByte(); int state = STATE_continue; ViewCache viewCache = new ViewCache(); mComArr 是一个栈，是用来帮助读取模板的结构的，因为栈的特性很适合处理嵌套的控件层次。 tag 有两个字，一个是表示开始，一个表示结束，其实就是组件的开始与结束标识符，对应着xml 里面的 “&lt;” 与 “/&gt;”。这个没有实际证据，我猜的。 state 是用来表示是否需要跳出循环的，下面是一个死循环： 123456789101112131415161718192021222324252627282930313233while (true) &#123; switch (tag) &#123; case Common.CODE_START_TAG: short comID = cr.readShort(); // 这里就是实例化 viewBase 了，暂时不深入 ViewBase view = createView(mAppContext, comID, viewCache); if (null != view) &#123; Layout.Params p; if (null != curView) &#123; p = ((Layout) curView).generateParams(); mComArr.push(curView); &#125; else &#123; p = new Layout.Params(); &#125; view.setComLayoutParams(p); curView = view; ... case Common.CODE_END_TAG: if (mComArr.size() &gt; 0) &#123; ViewBase c = mComArr.pop(); if (c instanceof Layout) &#123; ((Layout) c).addView(curView); &#125; else &#123; state = STATE_failed; Log.e(TAG, "com can not contain subcomponent"); &#125; curView = c; &#125; else &#123; // can break; state = STATE_successful; &#125; break; 主要说一下 mComArr 的作用： 第一次遇到起始标志，将该 view 赋值给 curView。 再遇到起始标志的时候，就说明遇到了 view 嵌套的情况，这个时候将 curView 放入栈内。 遇到结束标识的时候，将栈顶元素取出来，add 到 curView 中。 这样就搞定了 view 树的解析，还是比较容易理解的，实在绕不清楚的可以回去看看四则运算的中缀转后缀。 接下来，我们看看上面代码中省略的部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 // int byte attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setValue(key, value); --attrCount; &#125; // int RP attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setRPValue(key, value); --attrCount; &#125; // float attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); float value = Float.intBitsToFloat(cr.readInt()); view.setValue(key, value); --attrCount; &#125; // float RP attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); float value = Float.intBitsToFloat(cr.readInt()); view.setRPValue(key, value); --attrCount; &#125; // string code attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setStrValue(key, value); --attrCount; &#125; // expr code attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int key = cr.readInt(); int value = cr.readInt(); view.setValue(key, mExprCodeLoader.get(value)); --attrCount; &#125; // user var attrCount = cr.readByte(); while (attrCount &gt; 0) &#123; int varType = cr.readByte(); int nameId = cr.readInt(); int value = cr.readInt(); view.addUserVar(varType, nameId, value); --attrCount; &#125; int uuid = view.getUuid(); if (uuid &gt; 0 &amp;&amp; null != uuidContainers) &#123; uuidContainers.put(uuid, view); &#125; List&lt;Item&gt; pendingItems = viewCache.getCacheItem(view); if (pendingItems == null || pendingItems.isEmpty()) &#123; view.onParseValueFinished(); &#125;&#125; else &#123; state = STATE_failed; Log.e(TAG, "can not find view id:" + comID);&#125;break; 这里的大部分代码都是在读取二进制文件中储存的属性键值对。 属性的 key 是一个 int 值，在 com.libra.virtualview.common.StringBase 中。 属性的 value 分为好几类： int int RP float flot RP string expr user var int 是整数，int RP 是什么呢？RP 表示的是百分比。不是说我们要写 20%w 这样的东西，而是说，如果UI妹妹给我们的切图是 720 * 1080 的，其中有个 button 的宽度为 100px，那么我们不用换算成dp，可以直接使用 100，然后调用 com.libra.Utils#setUedScreenWidth 设置一下就好了，在创建 view 的时候，会自动帮我们按百分比换算的。 我们拿我们的 xml 来说，有一个属性键值对是 textSize=&quot;12&quot;，那么 key 就是 final public static int STR_ID_textSize = -1003668786;，value 就是 12。这些属性键值对都是在组件区的组件数里面。 ViewBase当我们解析出来了组件的属性键值对之后，就可以设置给实例化出来的 view 了。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setValue(int, int) 1234567891011final public boolean setValue(int key, int value) &#123; // set self value boolean ret = this.setAttribute(key, value); // set layout param value if (!ret &amp;&amp; null != mParams) &#123; ret = mParams.setAttribute(key, value); &#125; return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, int) 12345678protected boolean setAttribute(int key, int value) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_paddingLeft: mPaddingLeft = Utils.dp2px(value); isPaddingLeftSet = true; break; com.tmall.wireless.vaf.virtualview.core.Layout.Params#setAttribute(int, int) 1234567891011public boolean setAttribute(int key, int value) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_layoutWidth: if (value &gt; 0) &#123; mLayoutWidth = Utils.dp2px(value); &#125; else &#123; mLayoutWidth = value; &#125; break; setValue 的思路还是很清楚的，先看 ViewBase 能不能处理这个属性，不能就给 Params 处理。看里面的逻辑都是将属性值给储存起来了，随后在测量，布局，绘制的时候就会用到这些属性值。 上面是对 int 类型的处理，对 String 类型的处理有点不一样。 com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrValue 123456789final public boolean setStrValue(int key, int value) &#123; boolean ret = this.setStrAttribute(key, value); if (!ret &amp;&amp; null != mParams) &#123; ret = mParams.setStrAttribute(key, value); &#125; return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setStrAttribute 1234567protected boolean setStrAttribute(int key, int value) &#123; StringLoader sm = mContext.getStringLoader(); // 注意这里 String stringValue = sm.getString(value); boolean ret = setAttribute(key, stringValue); return ret;&#125; com.tmall.wireless.vaf.virtualview.core.ViewBase#setAttribute(int, java.lang.String) 1234567protected boolean setAttribute(int key, String stringValue) &#123; boolean ret = true; switch (key) &#123; case StringBase.STR_ID_layoutWidth: mViewCache.put(this, StringBase.STR_ID_layoutWidth, stringValue, Item.TYPE_FLOAT); this.mParams.mLayoutWidth = LayoutCommon.WRAP_CONTENT; break; com.tmall.wireless.vaf.virtualview.core.Layout.Params#setStrAttribute 1234public boolean setStrAttribute(int key, int value) &#123; //TODO return false;&#125; ViewBase 的 setStrAttribute 方法，需要注意的是 value 并不是属性值。还记得我们前面讲 StringLoader 的时候，会给字符串生成一个唯一的 id 么？这里的 value 就是生成的id。根据这个 id， 我们可以获取到对应的字符串值。 在设置字符串属性值的时候，需要特殊处理，因为如果是按照 layoutHeight=&quot;${height}&quot;这样的使用方式，我们这个时候是拿不到对应的值的，我们只能将 “${height}”给储存起来，等到设置了 json 数据的时候，在从里面取对应的值，然后再设置属性。 具体的方式就是：将属性键值对封装成一个类。 com.tmall.wireless.vaf.virtualview.core.ViewCache.Item 123456public Item(ViewBase v, int key, String attrEL, int valueType) &#123; mView = v; mKey = key; mAttrEL = attrEL; mValueType = valueType;&#125; v 就是属性所属的 view，key 就是属性的 id，attrEl 就是属性字符串值，valueType 是属性值的类型。attrEl 可能还需要进行解析才能使用，比如将 “${height}”解析为 “height”，具体看 com.tmall.wireless.vaf.virtualview.core.ViewCache.Parser 源码。 然后，等到设置了数据之后，就可以调用 item.bind 方法，给 view 设置属性了，后面细说。 其他的属性解析都是类似的，就不说了。再回到 view 实例化的代码处，具体说一下实例化过程。 1ViewBase view = createView(mAppContext, comID, viewCache); com.tmall.wireless.vaf.virtualview.ViewFactory#createView 1234567private ViewBase createView(VafContext context, int comID, ViewCache viewCache) &#123; ViewBase.IBuilder builder = mBuilders.get(comID); if (null != builder) &#123; return builder.build(context, viewCache); &#125; return null;&#125; 实际上就是调用了 build 方法。mBuilders 集合是在构造方法里com.tmall.wireless.vaf.virtualview.ViewFactory#ViewFactory初始化的： 12345...mBuilders.put(Common.VIEW_ID_FrameLayout, new FrameLayout.Builder());mBuilders.put(Common.VIEW_ID_GridLayout, new GridLayout.Builder());mBuilders.put(Common.VIEW_ID_VHLayout, new VHLayout.Builder());... 可以看出来，每个控件都需要提供一个 Builder 类，用来实例化该控件。可以看一下 VHLayout 的 Builder 类： 123456public static class Builder implements ViewBase.IBuilder &#123; @Override public ViewBase build(VafContext context, ViewCache viewCache) &#123; return new VHLayout(context, viewCache); &#125;&#125; 这样的话，整个模板的实例化逻辑就理清楚了。 总结： 从模板里面解析出 view 树。 解析 view 树的时候，使用 builder 创建 view，然后给 view 设置对应的属性。 如果是 @{height}这样的属性值的话，不能直接给属性赋值，需要储存起来，等到设置数据的时候在设置值。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0002-数据模板]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0002-%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[这一段本来应该是介绍 Tangram 才说的，但是为了说明模板的作用，这里还是需要简要的说明一下 Tangram 是做什么的。首先，作为一个商城类应用，其首页的变动是非常频繁的，特别是在一些特殊的节日。按照一般的开发逻辑，在节日之前肯定是要发新版的，而且节日过了之后，又需要将界面改回来。如果一直发新版本的话，就效率太低了，更新频繁的话也很容易找骂。 一种解决方案就是使用 H5，但是性能会有问题。下面的片段来源于文档： 最初我们看重动态性，在HTML框架和发布工具上做了大量的文章。我们可以快速开发出一张HTML页面，并推送到端上，而且通过Hybrid接口还能与Native进行交互。然而在大规模（双11）应用的过程中我们很快发现了问题——性能。当时我们认为WebView的性能是HTML页面的瓶颈，现在还不是大规模推广HTML的时候，我们需要一套替代方案。 H5 暂时不可行，那么还是只能在原生页面上想办法了（下面的内容，还是来源于文档，建议去看官方文档）。 从业务的角度来说，带界面的业务基本分三种： 临时性业务——比如活动，几张页面生命周期可能2周，1周，甚至一两天。数量多，需求频繁，有可沉淀的东西，但变化更多。对极致性能不敏感。 常规业务——比如频道，生命周期长，需要长期维护。数量有限，需求稳定，沉淀性好。对极致性能相当敏感。 基础业务——跟常规业务相比需求稳定性更高，对性能和稳定性有极高的要求。 对于第1型，我们认为未来一定属于HTML，随着WebView性能的提升和Mobile开发框架与开发技能日趋成熟，现阶段HTML体现出的劣势终将荡然无存。 而第2型和第3型是值得我们去思考的，结合我们团队所负责的业务形态，我们结合多年在业务上的经验制定了以粗粒度组件化+灵活布局容器为基本理念的界面解决方案。 以 Tangram View 作为根节点，具备滚动能力；页面的子节点为布局容器，每行一个容器，向下单行排列；布局容器中按照各自的布局规则，在其内对任意组件进行排列。 这里说的比较抽象，我举一个例子： 我们写一个 MainActivity，其布局长这样： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/container" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 可以看出，这里布局里面其实什么都没有，那么这个时候，我想要让界面显示出东西出来，怎么办呢？有两种方法： 动态的创建控件 动态的加载布局 动态的创建控件显然难度太高了，特别是复杂的布局，很是蛋疼。动态的加载布局，是可以的，但是解析 XML 太慢了，可以优化一下不？这里参照了 Google 的思路，Android Studio 在打包 APK 的时候，会将 XML 文件编译为二进制文件，它不仅仅减小了体积，而且在解析文件的时候，会更加快速。 这样思考的话，一个可以动态更改布局的方法就有了雏形：将布局文件编译为二进制文件，上传到服务器，客户端下载，界面启动的时候，动态加载最新版本的布局。 理解了上面的话，我们再来看看 Tangram 的模板是什么东西。 模板是什么模板其实就是上面说说的二进制布局文件，不过这个二进制文件不是 Android Studio 编译 xml 文件之后生成的，而是 alibaba 有自己的一套工具，用来生成二进制文件。 这个二进制文件有自己的格式，具体可以参考官方文档，这里只贴一个图，后面的源码部分会经常用到这个图： 创建模板文件我们刚开始接触 Android 的时候，也需要学习如何编写一个界面，需要熟悉每个控件是做什么的。对于 Tangram 也是如此，它有一套自己的控件（虽然也是使用的原生控件实现的），所以我们也需要先熟悉一下这些控件，控件的介绍在： http://tangram.pingguohe.net/docs/virtualview/atom-elements http://tangram.pingguohe.net/docs/virtualview/container-elements 这里举一个简单的例子： TextTest.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 可以看出来，与 Android XML 布局的差别不大，还很简洁。其中使用到的属性的意思也很明了，有不清楚的可以参考文档： http://tangram.pingguohe.net/docs/virtualview/elements 模板编译工具的使用模板写好了之后，我们就可以编译该模板文件为二进制文件了。 首先需要下载编译工具，工具下载地址在：https://github.com/alibaba/virtualview_tools 使用 git clone 下来之后： 切到 virtualview_tools\compiler-tools\TemplateWorkSpace 目录下 在 template 目录下，创建 TextTest.xml 模板文件 打开 templatelist.properties，增加一行 TextTest=Test,1 说一下格式 123456789格式 xmlFileName=outFileName,Version[,platform]xmlFileName 标识 template 目录下需要编译的 xml 文件名建议不带 .xml 后缀，目前做了兼容outFileName 输出到 build 目录下的 .out 文件名，这个 outFileName 会编译到二进制文件中，需要是唯一的，可以理解为模板的 IDVersion 表示 xml 编译后的版本号，看上面的模板文件结构图，模板文件可以有主版本号，次版本号，修订版本号，经过测试这个版本号表示 的是修订版本号，从源码上来看主版本号与次版本号似乎是固定的platform 同时兼容 iOS 和 android 时不写，可填的值为 android 和iphone 打开 git bash，执行 sh buildTemplate.sh 命令 就会在 build 目录下生成相应的文件了 项目地址里面有中文文档，虽然不是非常的详细，但是也大致看的懂。 编译工具还提供了实时预览的效果，由于我只是想看源码，所以并没有尝试这个效果，有兴趣的可以自己试试实时预览，写复杂的布局肯定需要用到。 查看说明文档，还会发现，编译器支持增加自定义属性，我没试过就不说了，但是我大致知道它是如何工作的，我们后面会说源码，所以如果你都能看懂，这个自定义属性也就自然懂了 。 执行完 buildTemplate 命令之后，我们进入 build 目录，里面有几个目录需要关注： out目录：XML 模板编译成二进制数据的文件，其他内容都是以此为基础生成，上传到 cdn，通过模板管理后台下发的也是这里的文件； java目录：XML 模板编译成二进制数据之后的 Java 字节数组形式，可以直接拷贝到 Android 开发工程里使用，作为打底数据； sign目录：out 格式文件的 md5 码，供模板管理平台下发模板给客户端校验使用； txt目录：XML 模板编译成二进制数据之后的十六进制字符串形式，转换成二进制数据就是 java 目录下的字节数组 我们打开 build\java 目录，找到生成的 TEST.java 文件，打开后如下： 12345public class TEST&#123;public static final byte[] BIN = new byte[] &#123;65, 76, 73, 86, 86, 0, 1, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 122, 0, 0, 0, -87, 0, 0, 0, 32, 0, 0, 0, -51, 0, 0, 0, 0, 0, 0, 0, -47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 4, 84, 101, 115, 116, 0, 110, 0, 0, 2, 4, -86, 50, -11, -48, 0, 0, 0, 0, 0, 47, -1, 108, 0, 0, 0, 48, 92, -43, -16, -15, -1, -1, -1, -1, 119, 112, -84, -68, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, -60, 45, 58, -50, 0, 0, 0, 12, 0, 47, -1, 108, 0, 0, 0, 48, -80, -104, 85, 46, -1, 0, -120, -103, 119, 112, -84, -68, -1, -1, -1, -1, -64, -101, 46, 54, -1, 51, 51, 51, 0, 0, 0, 2, 92, -43, -16, -15, -14, -87, -65, 127, 0, 54, 69, 45, 82, -14, -15, -117, 0, 0, 1, 1, 0, 0, 0, 2, 82, -14, -15, -117, 0, 11, 84, 105, 116, 108, 101, 58, 32, 116, 101, 120, 116, -14, -87, -65, 127, 0, 9, 36, 123, 104, 101, 105, 103, 104, 116, 125, 0, 0, 0, 0, &#125;;&#125; 里面就只有一个 byte 数组，里面个每个数都表示一个字节。 我们再打开 build\out 目录，找到生成的 TEST.out 文件，用十六进制编辑器查看，如下： 看前面5个字节，表示的就是 ALIVV，这个就是模板文件结构表的固定开头。将图中的十六进制换成数字，就是与 TEST.java 文件中的字节数组是一一对应的。 看了这些东西，总结出一句话，那就是这个二进制数组就表示的是一个布局，所以这个文件叫做模板文件。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0003-模板编译与解析]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0003-%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[PS： 为了方便记录，将编译与解析合并 官方文档的这一篇叫做“组件编译”，我看了文档，发现这里的组件的意思应该是“控件”。为了阅读的流畅性，所以这里我就改名为模板编译，其实最终还是编译的一个一个的布局控件。既然要将一个xml文件编译成二进制文件，最后还要能够解析出来，那么我们需要解决一些问题，还是拿之前的 xml 文件来说： TextTest.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 首先，VHLayout 这些控件的名字怎么储存？ 然后属性名怎么储存？ 属性值怎么储存？ 属性值分为多种，一般的颜色、数值子类的简单，可以字节作为整数存起来，但是像 text 属性，一般是一个字符串，该怎么储存呢？ 还有像 layoutWidth 这样的，可以写 200 这样的数值，也可以写 match_parent，这个又该如何处理？ 模板还支持逻辑表达式，这个表达式又该怎么储存？ 我们先来看官方文档的说明，然后一个一个来对照源码进行解析。 颜色：转换成4字节整型颜色值，格式 AARRGGBB； 枚举：按照预定义的整数转换，比如 gravity 的类型，orientation 的类型… 基础组件的类型：按照预定义的整数转换，内置基础组件的类型从 1 开始分配，自定义组件建议从 1000 开始分配，后续可能语义化成字符串类型定义，对用户隐藏这些细节； 字符串：以 hashCode 值作为它的序列化后整数，并在字符串资源区建立以 hashCode 为索引的列表，在解析的时候从中获取原始的字符串值； 逻辑表达式：与字符串的处理类似； 上面说，对于颜色值，是字节储存的，因为颜色值也是 4 个字节组成的，转成二进制都不用改的。在上面的例子种，我们设置的颜色值是 #008899，前面的“#”，我们不需要，只需要后面的“008899”，直接放入二进制文件中。为了验证猜想，我们查看二进制文件，看看有没有 00 88 99 3个直接是挨着的。 肯定是有的。 我们再来看源码，是如何解析这个值的。 加载模板文件一个模板编译好了之后，我们可以直接使用，也可以让服务器下发。这里介绍直接使用的方式。按照官方文档的实例，是在 Application 中加载的模板文件，应该也是可以在别的地方加载的。代码如下： com.aprz.virtualviewdemo.MyApp#onCreate 1sViewManager.loadBinBufferSync(TEST.BIN); 这里传入的参数，就是模板文件的二进制数据数组了。既然加载了数组，肯定需要解析出来使用，我们可以顺着这里路径点击去，最后就到了下面的代码： com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean) 这坨方法，还是非常长的，但是不难，我们一点一点分析啊。 如果你能对着模板文件结构图来看这段代码，简直不要太简单了。 1234567891011public int loadFromBuffer(byte[] buf, boolean override) &#123; int ret = -1; if (null != buf) &#123; mDepPageIds = null; if (buf.length &gt; 27) &#123; // check tag byte[] tagArray = Arrays.copyOfRange(buf, 0, Common.TAG.length()); if (Arrays.equals(Common.TAG.getBytes(), tagArray)) &#123; ... Common.TAG 就是 “ALIVV”，这个固定标识是用来验证是否是模板文件的。总不能随便给一个二进制文件，就开始解析吧。最后的 if 判断就是用来判断前 5 个字节是否为 “ALIVV”表示的字节。 12345678910CodeReader reader = new CodeReader();reader.setCode(buf);reader.seekBy(Common.TAG.length());// check versionint majorVersion = reader.readShort();int minorVersion = reader.readShort();int patchVersion = reader.readShort();reader.setPatchVersion(patchVersion); 这一段，逻辑也很清晰，跳过固定标识，依次读取 主版本号，次版本号，修订版本号。 123456789101112if ((Common.MAJOR_VERSION == majorVersion) &amp;&amp; (Common.MINOR_VERSION == minorVersion)) &#123; int uiStartPos = reader.readInt(); reader.seekBy(4); int strStartPos = reader.readInt(); reader.seekBy(4); int exprCodeStartPos = reader.readInt(); reader.seekBy(4); int extraStartPos = reader.readInt(); reader.seekBy(4); 当主版本号为1，并且次版本号为0的时候，才会走里面的逻辑。这里就可以看出来，主版本号与次版本号不是我们可以更改的，应该是编译的时候生成的固定值。我们只能设置修订版本号。 123456789int pageId = reader.readShort();int depPageCount = reader.readShort();if (depPageCount &gt; 0) &#123; mDepPageIds = new int[depPageCount]; for (int i = 0; i &lt; depPageCount; ++i) &#123; mDepPageIds[i] = reader.readShort(); &#125;&#125; 这里是记录该模板的依赖，没搞懂，而且源码里面标记为过时了，查看源码也没有用到的地方，就当做没有这几行代码吧。 12345678if (reader.seek(uiStartPos)) &#123; // parse ui codes boolean result = false; if (!override) &#123; result = mUiCodeLoader.loadFromBuffer(reader, pageId, patchVersion); &#125; else &#123; result = mUiCodeLoader.forceLoadFromBuffer(reader, pageId, patchVersion); &#125; 定位到组件区的起始位置（不明白的回去查看模板文件二进制格式图）。然后就可以开始读取组件（控件）信息了。UiCodeLoader 里面的逻辑咱们不深入了，留到下面说，这里先把外面的逻辑走完，有个大致的理解。可以猜想一下，UiCodeLoader 肯定是解析控件信息了，将解析控件的代码封装为了一个类。 123456789101112// parse stringif (reader.getPos() == strStartPos) &#123; if (null != mStringLoader) &#123; result = mStringLoader.loadFromBuffer(reader, pageId); &#125; else &#123; Log.e(TAG, "mStringManager is null"); &#125;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "string pos error:" + strStartPos + " read pos:" + reader.getPos()); &#125;&#125; 根据模板文件二进制格式图可以看出来，组件解析完了之后，就是字符串区了，这里就是解析字符串了。 1234567891011121314151617181920// parse exprif (reader.getPos() == exprCodeStartPos) &#123; if (null != mExprCodeLoader) &#123; result = mExprCodeLoader.loadFromBuffer(reader, pageId); &#125; else &#123; Log.e(TAG, "mExprCodeStore is null"); &#125;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "expr pos error:" + exprCodeStartPos + " read pos:" + reader.getPos()); &#125;&#125;// load extra dataif (reader.getPos() == extraStartPos) &#123;&#125; else &#123; if (BuildConfig.DEBUG) &#123; Log.e(TAG, "extra pos error:" + extraStartPos + " read pos:" + reader.getPos()); &#125;&#125; 解析表达式，与解析额外数据，但是这里没有对额外数据做处理，也没有提供可覆盖的方法，有点奇怪。 总结一下，com.tmall.wireless.vaf.virtualview.loader.BinaryLoader#loadFromBuffer(byte[], boolean)这个方法就是照着模板二进制文件解析出来了里面的所有详细，为实例化出控件做准备。 UiCodeLoader前面，我们没有深入控件解析的逻辑，这里就仔细说说。上面我们分析到了： com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBuffer 123456789101112131415161718192021public boolean loadFromBuffer(CodeReader reader, int pageId, int patchVersion) &#123; boolean ret = true; int count = reader.readInt(); //count should be 1 short nameSize = reader.readShort(); String name = new String(reader.getCode(), reader.getPos(), nameSize, Charset.forName("UTF-8")); CodeReader oldCodeReader = mTypeToCodeReader.get(name); if (oldCodeReader != null) &#123; int oldPatchVersion = oldCodeReader.getPatchVersion(); if (patchVersion &lt;= oldPatchVersion) &#123; //avoid loading code repeat Log.w(TAG, "load view name " + name + " should not override from " + patchVersion + " to " + patchVersion); ret = false; return ret; &#125; &#125; ret = loadFromBufferInternally(reader, nameSize, name); return ret;&#125; 说一下，只要是 loader 里面的逻辑，基本都是在解析二进制文件，搞各种 readInt ，readShort 之类的，所以一定要对着二进制结构图看。 它先读取了一个 count，但是它没有用到这个值，额，牛逼，只是加了一句注释，count应该为1 。我们看结构图，发现这个count值表示的是组件的个数，也就是说这个组件个数应该为1 。那么应该代表的是根布局，如果我写两个会怎么样呢？比如： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;VHLayout flag="flag_exposure|flag_clickable" layoutHeight="match_parent" layoutWidth="match_parent" orientation="V"&gt; &lt;NText background="#008899" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt;&lt;VHLayoutflag="flag_exposure|flag_clickable"layoutHeight="match_parent"layoutWidth="match_parent"orientation="V"&gt; &lt;NText background="#002299" flag="flag_exposure|flag_clickable" layoutHeight="$&#123;height&#125;" layoutWidth="match_parent" text="Title: text-------------------------" textColor="#333333" textSize="12" /&gt;&lt;/VHLayout&gt; 实际上，还是只显示了第一个 VHLayout，而且编译之后的二进制文件里面 count 依然是 1 。猜想是编译器只处理了第一个根节点。 继续往下分析，读取了模板的 name，就是我们在 templatelist.properties 里面设置的值。以我们的例子来说，这个 name 就是 “TEST”。 再接着就是判断补丁值，根据逻辑可以知道，修订版本值不能降低，否则就会忽略。继续深入代码调用： com.tmall.wireless.vaf.virtualview.loader.UiCodeLoader#loadFromBufferInternally 1234567891011121314private boolean loadFromBufferInternally(CodeReader reader, short nameSize, String name) &#123; boolean ret = true; mTypeToCodeReader.put(name, reader); reader.seekBy(nameSize); short uiCodeSize = reader.readShort(); mTypeToPos.put(name, reader.getPos()); if (!reader.seekBy(uiCodeSize) ) &#123; ret = false; Log.e(TAG, "seekBy error:" + uiCodeSize); &#125; return ret;&#125; 将 name 与 reader 对应着储存起来，以后需要的时候可以直接获取，避免重复创建。将 name 与 pos 对应着储存起来，这个表示 reader 读取到了什么位置。这个 pos 非常的重要，这个 pos 表示的是组件区的组件数据开始的位置，组件数据里面都是储存的组件的属性值。 就没有其他的逻辑了，总结一下，UiCodeLoader 做了这些事情： 读取了每个模板的 name，为每个模板都保存了对应的 CodeReader 实例（根据 name 获取），还记录了 CodeReader 读取到了哪个位置。 StringLoader上面处理完了组件区，接着就该字符串区了。看如下代码： com.tmall.wireless.vaf.virtualview.loader.StringLoader#loadFromBuffer 12345678910111213141516171819202122232425262728293031public boolean loadFromBuffer(CodeReader reader, int pageId) &#123; boolean ret = true; // pageId 是页面编码 mCurPage = pageId; int totalSize = reader.getMaxSize(); // 字符串的个数 int count = reader.readInt(); for (int i = 0; i &lt; count; ++i) &#123; // 字符串索引 int id = reader.readInt(); // 字符串长度 int len = reader.readShort(); int pos = reader.getPos(); if (pos + len &lt;= totalSize) &#123; // 解析出字符串 String str = new String(reader.getCode(), reader.getPos(), len); // 与id对应储存起来，可以根据id拿到string，也可以根据string拿到id mIndex2String.put(id, str); mString2Index.put(str, id); reader.seekBy(len); &#125; else &#123; Log.e(TAG, "read string over"); ret = false; break; &#125; &#125; return ret;&#125; 上面的代码里面，其逻辑注释说的很详细了。 需要注意的是，id 表示字符串的唯一标识，这个唯一标识，很重要，应该是编译的时候自动生成的一个数，先记住这个唯一标识。 上面我们说过，像 title=“Hello”这样的属性值，“Hello”就是作为字符串储存的，所以这里就可以将“Hello”给提取出来，id 就是 3556653。 总结一下： StringLoader 就是将字符串区的字符串读取出来了，然后储存了id与string。 ExprCodeLoader这个 loader，我还没深入的去看，暂时就不说了。 说一个我发现的东西，例子中，我们使用了数据绑定： 1layoutHeight="$&#123;height&#125;" 这个 “${height}” 是储存在字符串区的。 说了这么多 loader，其实最核心的东西还没有涉及到，不是不愿意讲，而是这部分代码的逻辑在实例化控件的位置，我们下篇再讲。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0027-栈的应用之四则表达式]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0027-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E5%9B%9B%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[四则表达式大家应该都知道如何取计算，有个口诀： 先乘除，后加减，从左算到右，先括号内再括号外。 看下面的这个表达式：19 + (3 - 1) * 3 + 10 / 2这个表达式，让我们来算，非常的简单。但是让计算机来计算呢，就比较麻烦了。因为计算机不会口诀，它不知道应该先计算括号里面的。那么如何才能让计算机计算四则表达式呢？在 20 世纪 50 年代，一个波兰逻辑学家（名字太长，就不打了）发明了一种后缀表达式（逆波兰表达式）。这种后缀表达式是一种全新的显示方式，非常巧妙的解决了程序实现四则运算的问题。 对于上面的那个四则表达式，它的后缀表达式如下： 1234四则表达式9 + (3 - 1) * 3 + 10 / 2后缀表达式：9 3 1 - 3 * + 10 2 / + 之所以叫后缀表达式，是因为符号在要运算数字的后面出现。 后缀表达式的计算有了后缀表达式，我们需要理解它是如何工作的，先来说一段规则： 从左到右遍历表达式的每个数字与符号，遇到数字就进栈，遇到符号，就出栈两个数字，然后进行运算，将运算的结果进栈，一直遍历完毕，最后栈内的就是计算结果。 看下面的这个例子： 12后缀表达式：9 3 1 - 3 * + 10 2 / + 创建一个空栈，遍历表达式，前3个都是数字，直接进栈： 接下来遇到了 “-”，从栈里面取两个运算数字，第一个是减数，第二个是被减数，即（3 - 1），然后将结果 2 进栈: 接着是数字 3 进栈 接着是遇到了 “*”，同样从栈里面取出两个数字，计算（2 * 3），将结果 6 放入栈中，然后，又遇到了 “+”，从栈里面取出两个数字，计算（9 + 6），将结果 15 放入栈中： 接着是，10 与 2 进栈，然后是遇到 “/”，计算（10 / 2），将 5 进栈。最后遇到 “+”，计算 （15 + 5），将 20 进栈。20 就是计算结果。 中缀表达式转后缀表达式前面我们说了，后缀表达式对于程序来说，很好描述，但是如果没有一个方法很容易的将中缀表达式转成后缀表达式的话，后缀表达式毫无意义。 所以这里介绍中缀表达式转后缀表达式的规则： 从左到右遍历中缀表达式 遇到数字直接输出 遇到左括号进栈 遇到右括号，需要将栈内元素出栈，直到左括号出栈 遇到符号需要对于栈顶元素 如果栈为空，进栈 如果栈顶为左括号，进栈 将栈顶元素依次出栈，直到遇到比该符号的优先级低的符号。 还是上面的例子【9 + (3 - 1) * 3 + 10 / 2】，用图来描述一遍： 初始化一个空栈，开始遍历，第一个是数字 9 ，直接输出，然后是符号 “+”，进栈 此时表达式为：9 左括号未配对，直接进栈，3直接输出，“-”进栈，1直接输出，遇到右括号需要将栈里面的元素输出，直到左括号出栈 此时表达式为：9 3 1 - 遇到 “*” 号，比栈顶元素的优先级高，进栈，输出 3 此时表达式为：9 3 1 - 3 遇到 “+”号，将 “*”出栈，将“+”出栈，将这个“+”号进栈，输出表达式为 ：，然后是输出 10，将“/”进栈， 此时表达式为：9 3 1 - 3 * + 10 输出 “2”，将 “/”，“+” 出栈 此时表达式为：9 3 1 - 3 * + 10 2 / + 代码实现先定义操作符数据结构，因为涉及到优先级比较： 123456789101112131415161718192021222324252627enum Operator &#123; PLUS("+", 1), MINUS("-", 1), MUl("*", 2), DIV("/", 2), LEFT_BRACKET("(", 3), RIGHT_BRACKET(")", 3); String symbol; int priority; Operator(String s, int priority) &#123; this.symbol = s; this.priority = priority; &#125; public boolean lessOrEqual(Operator operator) &#123; return this.priority &lt;= operator.priority; &#125; public static Operator get(String s) &#123; Operator[] values = Operator.values(); for (Operator operator : values) &#123; if (operator.symbol.equals(s)) &#123; return operator; &#125; &#125; return null; &#125;&#125; 然后开始想法子计算表达式，分为几个步骤。 将字符串表达式分解开 1234567891011121314151617181920212223242526272829303132333435363738private static String[] splitExpr(String expr) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); expr = expr.replaceAll(" ", ""); int length = expr.length(); // 用来储存数字 StringBuilder builder = null; for (int i = 0; i &lt; length; i++) &#123; String c = expr.substring(i, i + 1); // 遇到符号，需要先判断将 builder 里面储存的数字添加到集合，然后将符号添加到集合 if (isSymbol(c)) &#123; if (builder != null) &#123; result.add(builder.toString()); builder = null; &#125; result.add(c); &#125; else if (isNumber(c)) &#123; // 遇到数字就将数字添加到 builder，避免多位数字问题 if (builder == null) &#123; builder = new StringBuilder(); &#125; builder.append(c); &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; if (builder != null) &#123; result.add(builder.toString()); &#125; return result.toArray(new String[0]);&#125; 将表达式分解之后，可以执行中缀转后缀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static String[] midToEnd(String expr) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 先将表达式分解出来 String[] array = splitExpr(expr); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); String pop; for (int i = 0; i &lt; array.length; i++) &#123; String s = array[i]; if (isNumber(s)) &#123; // 数字直接输出 result.add(s); &#125; else if (isOperator(s)) &#123; // 符号将栈顶优先级高于或等于的依次出栈 Operator operator; Operator top; while (!stack.isEmpty() &amp;&amp; isOperator(stack.peek())) &#123; operator = Operator.get(s); top = Operator.get(stack.peek()); if (operator.lessOrEqual(top)) &#123; result.add(stack.pop()); &#125; else &#123; break; &#125; &#125; // 将自己进栈 stack.push(s); &#125; else if (s.equals(Operator.LEFT_BRACKET.symbol)) &#123; // 左括号进栈 stack.push(s); &#125; else if (s.equals(Operator.RIGHT_BRACKET.symbol)) &#123; // 右括号需要匹配左括号 while (!stack.empty()) &#123; pop = stack.pop(); if (pop.equals(Operator.LEFT_BRACKET.symbol)) &#123; break; &#125; result.add(pop); &#125; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; while (!stack.isEmpty()) &#123; result.add(stack.pop()); &#125; return result.toArray(new String[0]);&#125; 然后计算后缀表达式 12345678910111213141516171819202122232425262728293031323334353637private static double cal(String expr) &#123; String[] temp = midToEnd(expr); Stack&lt;Double&gt; number = new Stack&lt;&gt;(); for (String s : temp) &#123; if (isNumber(s)) &#123; // 数字直接进栈 number.push(Double.parseDouble(s)); &#125; else if (isOperator(s)) &#123; // 运算符则弹出两个数字，计算结果，将结果进栈 if (number.size() &gt;= 2) &#123; Double opr = number.pop(); Double opl = number.pop(); number.push(func(opl, opr, s)); &#125; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125; &#125; return number.pop(); &#125; private static Double func(Double opl, Double opr, String op) &#123; if (Operator.PLUS.symbol.equals(op)) &#123; return opl + opr; &#125; else if (Operator.MINUS.symbol.equals(op)) &#123; return opl - opr; &#125; else if (Operator.MUl.symbol.equals(op)) &#123; return opl * opr; &#125; else if (Operator.DIV.symbol.equals(op)) &#123; return opl / opr; &#125; else &#123; throw new IllegalArgumentException("表达式有问题"); &#125;&#125; 这里我为了简单，只处理了运算数为整形的情况，分解表达式字符串用的是正则，如下： 1234567891011121314private static boolean isNumber(String s) &#123; String numberRegex = "\\d+"; return s.matches(numberRegex);&#125; private static boolean isSymbol(String s) &#123; String regex = "[\\+\\-\\*\\/()]"; return s.matches(regex);&#125; private static boolean isOperator(String s) &#123; String regex = "[\\+\\-\\*\\/]"; return s.matches(regex);&#125;]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0001-前言]]></title>
    <url>%2F2019%2F09%2F04%2Fblog_bak%2FBlog%2FAndroid-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2FVirtualview%2F0001-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[本来按照顺序是应该先写 VLayout，再写 Tangram，最后才是 Virtualview。这是一个循序渐进的过程。由于我本身对 VLayout 有了一定的了解，所以我就直接看了 Tangram，发现源码阅读起来不算太难，就是写代码的风格看着有点蛋疼（我们装了阿里的 Java 规约插件，然后发现源码里全是警告线，这特么自己开发的内部都不用的吗）。当我根据文档一点一点的阅读完源码之后，本来以为就要结束的时候，才发现里面说的“虚拟控件”才是比较值得咀嚼的。 于是我又花了3天左右来啃这个东西，其中的艰辛…，唉，我太难了。 根据官方文档，对照源码，阅读完里面的核心内容之后，发现虚拟控件并没有那么的神奇，而且它有一些不足。 本系列就是将我在阅读的过程中，理解的，记录的，思考的东西整理出来。]]></content>
      <categories>
        <category>Virtualview</category>
      </categories>
      <tags>
        <tag>Android-源码解析-Virtualview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0023-栈的顺序储存结构及实现]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0023-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本篇我们使用数组来实现栈。在之前我们需要思考一个简单的问题，因为栈只能从一端进行删除，那么我们使用数组的哪一端来进行插入与删除呢？根据出栈与入栈的特性，我们知道栈底一般是不变的，显然用数组的下标为 0 的一段作为栈底比较好。接下来我们还要使用一个变量来记录栈顶元素的位置，如下图：当入栈与出栈的时候，只需要改变top的值就好了。当 top = 0 的时候，表示栈内只有一个值，所以我们规定 top = -1 的时候，栈为空。 数据结构123456789public class MyStack&lt;T&gt; &#123; private static final int SIZE = 100; private Object[] table = new Object[SIZE]; private int top = -1; &#125; 入栈将一个元素压入栈中，分为两步： 将 top 的值加一 将元素赋值给 top 指向的位置 代码如下： 123456789public int push(T value) &#123; if (isFull()) &#123; return -1; &#125; table[++top] = value; return 0;&#125; 嗯，非常的简单，没啥说的，返回值 -1 表示失败， 0 表示成功。如下图： 出栈将一个元素删除，分为三步： 返回 top 指向的元素 将 top 减一 代码如下： 12345678910@SuppressWarnings("unchecked")public T pop() &#123; if (top == -1) &#123; return null; &#125; T result = (T) table[top]; top--; return result;&#125; 这里 pop 返回了出栈的值，这里的返回值还是经常会用到的。图的话，将入栈的图反过来看就好了。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0024-两个栈共享空间]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0024-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[首先需要说的是，两个栈共享空间的意思是一个数组里面有两个栈。那么什么情况下会设计出这么奇怪的数据结构呢？有时候我们需要两个栈，而且这两个栈的变化是相反的，当一个栈的元素增加的时候，另一个栈的元素就应该减少，这个时候就可以使用两个栈共享空间了。之所以要让两个栈共享空间而不是直接写两个栈，主要是在顺序储存的情况下，太浪费空间了，因为我们只能预估一个大概的最大值作为栈的储存空间。当两个栈共享空间的话，就可以节约一部分内存了。 看下面的这个设计图： 我们让两个栈的栈底分别在数组的两端，两个栈的栈顶是对着的（就像两个饮料瓶的瓶口相互对着一样，假设瓶口是栈顶）。当我们像栈内放入元素的时候，两个栈顶就会相互靠拢，直到两个栈顶挨着了，这个时候就说明，两个栈都满了。 数据结构12345678910public class MyStack2&lt;T&gt; &#123; private static final int SIZE = 100; private Object[] table = new Object[SIZE]; private int top = -1; private int top2 = SIZE; &#125; top 表示栈1 的栈顶，栈1 没有元素的时候 top = -1，top2 表示栈2 的栈顶，栈2 没有元素的时候 top = SIZE。 插入元素插入元素的时候需要指定插入哪一个栈，就没啥其他的了。 1234567891011121314public int push(T value, int which) &#123; // 栈满了 if (top + 1 == top2) &#123; return -1; &#125; if (which == 1) &#123; table[++top] = value; &#125; else &#123; table[--top2] = value; &#125; return 0;&#125; 删除元素123456789101112131415161718@SuppressWarnings("unchecked")public T pop(int which) &#123; T result; if (which == 1) &#123; if (top == -1) &#123; return null; &#125; result = (T) table[top--]; &#125; else &#123; if (top2 == SIZE) &#123; return null; &#125; result = (T) table[top2++]; &#125; return result;&#125; 插入与删除就是分为两个栈来处理，与单个栈的插入与删除是一样的。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0021-栈的定义]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0021-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在我们的软件应用中，栈的应用是非常普通的。 拿一个文本编辑器来举例，我们经常使用 Ctrl + Z 的快捷键来回退到上一步，这个动作就用到了栈。 栈是一种只能够在一端进行插入与删除的数据结构，如下图： 栈的插入操作叫做入栈，删除操作叫做出栈。 我们玩的游戏《汉诺塔》，就是一种典型的入栈出栈操作。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0025-栈的链式储存结构及实现]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0025-%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[使用数组来实现线性表总是有很大的局限性，因为大小无法决定，如果增加扩容功能的话，赋值元素也很浪费性能，所以下面我们用链式储存来实现栈。使用链式储存结构，必然要增加一个指向下一个元素的指针，所以这里相比顺序储存增加了使用空间。思考一下，使用链式存储的时候，头指针应该指向哪里，是指向栈底还是栈顶比较好？因为我们经常需要对栈顶进行操作，所以头指针指向栈顶比较合适，不然每次操作都要从栈底遍历一下。如下图： 数据结构123456789public class Node &#123; T value; Node next;&#125;public class Stack &#123; Node head; int count;&#125; 入栈操作12345678910111213public int push(T value) &#123; if (count == SIZE) &#123; return - 1; &#125; Node node = new Node(); node.value = value; node.next = head; head = node; count++; return 0;&#125; 如下图： 出栈操作123456789101112public T pop() &#123; if (count == 0) &#123; return null; &#125; T result = head.value; Node p = head; head = head.next; free(p); count--; return result;&#125; 如下图： 如果前面的链表都理解的话，这些入栈出栈的代码还是很简单的。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0026-栈的应用之递归]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0026-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归是个啥就不说了，是非常基础的东西了。将两面镜子对着，你就明白啥是递归了。下面我们讲一个数列：斐波那契数列。用这个数列来讲解递归。斐波那契数列 如果兔子在出生的第二个月，就有了繁殖能力，一对兔子每个月可以生一对兔子。问一年后有多少对兔子？ 这里我们假设第 x 个月，兔子有 f(x) 对，则 第 x-1 个月，有 f(x-1) 对，第 x-2 个月，有 f(x-2) 对。这看起来像是废话，但是仔细想一想，因为兔子在出生的第2个月才有繁殖能力。所以在 x-1 个月的时候，只有 f(x-2) 对兔子才有繁殖能力，有因为每一对兔子可以生一对兔子，所以 : f(x) = f(x-1) + f(x-2) 其中，f(x-1) 表示第 x-1 个月的兔子数，f(x-2) 表示所有兔子中可以繁殖的兔子数。 所以这个数列为：1，1，2，3，5，8，13，21，34，55，89，144。即一年后有 144 对兔子。 循环实现12345678910111213141516public static int f(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; int p = 1; int c = 1; int q = 0; for (int i = 2; i &lt; n; i++) &#123; q = p + c; p = c; c = q; &#125; return q;&#125; 递归实现123456int f(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; return f(n-1) + f(n-2);&#125; 明显可以看出，递归的逻辑更加清晰。但是需要注意的是，函数的每次调用都将其变量，返回值，参数值都放入了调用栈之中，如果递归的层次太深，会报栈溢出的错误，因为栈的容量是有大小限制的，不会无穷大。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0022-进栈出栈变化形式]]></title>
    <url>%2F2019%2F09%2F01%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0022-%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考一个问题：有 [1, 2, 3, 4, … ，n] 一共 n 个整数，他们按顺序入栈，问一共有多少种出栈顺序（提示：1 入栈之后可以立即出栈）？首先，我们设f(n)代表序列个数为n的出栈序列种数。同时，我们假定第一个出栈的序数是k。第一个出栈的序数k将1~ n的序列分成两个序列： 其中一个是1~ k-1，序列个数为k-1； 另外一个是k+1~n，序列个数是n-k。 那么对于一个给定的值 k 来说，f(k) 就表示前 k 个数的出栈顺序，f(n-k) 就表示后 n-k 个数的出栈顺序。 f(n)的问题就等价于序列个数为k-1的出栈序列种数乘以序列个数为n - k的出栈序列种数，即选择k这个序数的出栈组合为f(k-1)×f(n-k)，又因为第一个出栈的数可以是 1 ~ n 中的任意一个数，所以 k 可以取值 1 ~ n。 所以：f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0) 12f(0) = 1;f(1) = 1; 如果，我们知道卡特兰数，那么这个公式可以转换为 $C^n_{2n}-C^{n+1}_{2n}$ 。 可以看出最后转换成了排列组合公式，那么下面我们从排列组合的角度来思考一下这个问题。 我们先不管数的顺序是怎么样的，对于每一个数来说，总是要先入栈一次，然后再出栈一次。这里就假设入栈记为1，出栈记为0，那么就会产生一个 2n 个数的序列。这个序列由 n 个 1 与 n 个 0 组成。 使用排列组合的思想，在 2n 个位置里面选 n 个位置放入 1，其余的位置放入 0，一共有 $C^n_{2n}$ 种可能。 然后再思考一下，按照上面的排列方式，有一些序列是不符合要求的，比如 0001... 这种序列，因为 0 表示出栈，前面都没有入栈，哪里来的出栈呢？ 所以我们需要找出在某个位置上，它前面的0的个数大于1的个数的所有序列。 我们假设在某个位置上（只能是奇数位置，不可能是偶数位置），0的个数刚好比1的个数多一个，设这个位置为 2m+1。 那么，这个位置前就有 m+1 个 0 和 m 个 1。后面有 n-m-1 个 0， n -m 个 1。 这里我们要做一个骚操作： 将 2m+1 位置后面的 0 与 1 互换，则该位置后面就变成了 n-m-1 个 1， n -m 个 0。所以整个序列变成了由 n+1 个 0， n-1 个 1 组成的序列。 我们将所有不符合要求的集合记作 B。 将由 n+1 个 0， n-1 个 1 组成的序列集合记作 A，A 的个数为 $C^{n+1}_{2n}%$。 B 集合中的每一个元素都对应着 A 中的一个元素。 则 A 集合包含 B 集合。 再反过来思考，任何一个由 n+1 个 0 和 n-1 个 1 组成的 2n 个数的序列，由于 0 的个数比 1 的个数多 2 个，2n为偶数，故必在某一个奇数位上 0 的个数刚好比 1 的个数多一个。同样在后面部分0和1互换，就成为了由 n 个 0 和 n 个 1 组成的 2n 个数的序列，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。 同样的，转换为集合来思考，即集合 B 包含集合 A。 最终，我们得到，集合A = 集合B。 所以，不符合要求的集合数为 $C^{n+1}_{2n}$。 最后得到 $C^n_{2n}-C^{n+1}_{2n}$ 。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0020-双向链表]]></title>
    <url>%2F2019%2F08%2F28%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0020-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[双向链表很好理解，就是既可以往后遍历也可以往前遍历。就好比你做地铁，工作人员告诉你只能从 A 到 B，无法从 B 到 A，那你肯定觉得这个人有病。单向链表与循环链表虽然都很有用，但是有各自的局限性，有局限就会有可以完善的地方，双向链表就是来补充他们的不足的。前面的例子中，我们的节点类都是这样设计的：123456public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next;&#125; 双向链表的话，就还需要加一个东西，加一个指向前面节点的指针： 1234567public class Node&lt;T&gt; &#123; T t; Node&lt;T&gt; next; Node&lt;T&gt; pre;&#125; next 指针就是用来向后遍历的，pre 指针是用来向前遍历的。 头节点就应该是这样（不要搞错了头指针与头节点）： 一开始让他们都指向自己就好了。 一个有数据的双向链表长这样： 插入元素这里就不写完成的代码了，只说一下核心逻辑，其他的与单项链表差不多。 先理清思路： 找到要插入的位置，拿到该位置的前后两个节点（P, N） 用两个变量保存起来 再执行单链表的插入操作（执行两次） 1234567Node p, e;Node insert;p.next = insert;insert.next = e;e.pre = insert;insert.pre = p; 这样写就不用记顺序，如果只使用两个变量，也可以做出来，但是有点蛋疼。 如下图： 1234s.pre = p;s.next = p.next;p.next.pre = sp.next = s; 删除元素这个还是比较简单的：就是将单链表的删除操作，执行两次。 12p.pre.next = p.next;p.next.pre = p.pre; 这两个语句顺序没啥关系，因为将链表反过来，再删除的话，也是一样的。 双向链表相对于单链表来说，更加复杂一点，但是在操作某个节点的前后节点的时候会更加方便。这就是一个典型的使用空间换时间的操作。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0019-循环链表]]></title>
    <url>%2F2019%2F08%2F27%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0019-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前面我们说的链表都是单链表，因为链表中的节点只储存了指向后一个节点的指针，所以我们无法向前遍历，只能向后遍历。如果我们想要遍历前面的节点，那么该怎么做呢？原来的单链表结构是无法做到了，所以需要改进一下。第一中改进方案就是这一章需要讲的，循环链表。顾名思义，就是将链表的头和尾连起来，串成一个圆环，就是循环链表了。 同样是只能向后遍历，因为头和尾连起来了，所以最后总能遍历到前面的节点。有点不撞南墙不回头的意思。 虽然只是将头与尾连起来了，但是在使用这个数据结构的时候，还是有几个需要注意的地方。 循环链表的初始化为了与单链表保持一致，循环链表也有一个头节点，但是在初始化这个头节点的时候，需要注意一下，因为刚开始的链表是没有数据的，所以这个时候头节点需要指向自己，如下图： 当有数据的时候，循环链表如下图： 可以看出，其实这种循环链表与单链表的差别不大，只不过循环链表的遍历条件变成了：node.next != headNode。 我们想访问一个节点的时候，时间复杂度仍然为 O(n). 有些时候，我们需要访问到链表的最后一个元素，按照上面的循环链表的结构，我们需要 O(n) 的时间，那么有没有快捷一点的方法呢？ 显然是有点，比如说我们加一个尾指针，指向最后一个节点，这样就可以以 O(1) 的时间访问尾节点了。再仔细想一下，有了尾指针，头指针还需要吗？ 因为是循环链表，所以尾指针指向的就是头节点，所以可以不需要头指针了。如下图： 举一个尾指针的用处，合并两个链表，如下图： 要想将它们合并，还是很简单的，先理清思路： 将 A 链表的头尾节点引用断开（由于断开后就找不到了，所以需要保存一下头节点的引用） 将 A 链表的尾指针指向 B 链表的第一个节点 将 B 链表的尾指针指向 A 链表的第一个节点 代码如下： 1234567Node temp = rearA.next;rearA.next = rearB.next.next;// 因为 java 会自动释放节点，所以就没写// 可以加上// Node headB = rearB.next;// free(headB);rearB.next = temp; 有了尾节点之后，代码会简单很多，因为合并链表涉及到头与尾两个节点，所以使用尾节点比较方便。]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0025-非阻塞算法]]></title>
    <url>%2F2019%2F08%2F26%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0025-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇文章，真的是很有意思，讲的都是概念性的东西，但是越读越有味道，最好多读几遍。 在并发上下文中，非阻塞算法是一种不阻塞访问共享状态（或以其他方式协作或通信）的线程的算法。更一般地说，如果一个线程的挂起不会导致算法中涉及的其他线程的挂起，则这个算法是非阻塞的。为了更好的理解阻塞算法和非阻塞算法之间的区别，我会先讲解阻塞算法然后再讲解非阻塞算法。 阻塞算法很多算法和并发数据结构都是阻塞的。例如，java.util.concurrent.BlockingQueue的不同实现都是阻塞数据结构。如果一个线程要往一个阻塞队列中插入一个元素，队列中没有足够的空间，执行插入操作的线程就会阻塞直到队列中有了可以存放插入元素的空间。 下图演示了一个阻塞算法是如何保证一个共享数据结构的行为的： 线程 A 执行请求的操作 线程 B 会一直阻塞直到可以安全地执行操作（线程A的操作执行完） 非阻塞算法Java也包含几个非阻塞数据结构。AtomicBoolean, AtomicInteger, AtomicLong, AtomicReference都是非阻塞数据结构的例子。 下图演示了一个非阻塞算法保证一个共享数据结构的行为： 线程 B 执行请求的操作 线程 A 访问的时候，发现无法访问会直接返回，可以去做一些别的操作。 非阻塞算法 vs 阻塞算法阻塞算法和非阻塞算法的主要不同在于当请求操作不能够执行时阻塞算法和非阻塞算法会怎么做。 阻塞算法会阻塞线程直到请求操作可以被执行。非阻塞算法会通知请求线程操作不能够被执行，并返回。 阻塞算法的问题：如果一个线程 T1 往一个已经满了的阻塞队列里插入一个元素，这个线程就会阻塞，直到其他线程从这个阻塞队列中取走了一些元素。如果由于某些原因，从阻塞队列中取元素的线程 T2 被阻塞在了程序的某处，那么，T1 要么一直阻塞下去，要么直到 T2 从阻塞队列中取走了一个元素。 并发数据结构在一个多线程系统中，线程间通常通过一些数据结构“交流”。可以是任何的数据结构，从变量到更加高级的数据结构（队列，栈等）。为了便于多线程对数据结构的正确并发访问，必须通过某些并发算法来保护数据结构。这些并发算法让这些数据结构成为并发数据结构。 如果某个算法确保一个并发数据结构是阻塞的，它就被称为是一个阻塞算法。这个数据结构也被称为是一个阻塞，并发数据结构。 如果某个算法确保一个并发数据结构是非阻塞的，它就被称为是一个非阻塞算法。这个数据结构也被称为是一个非阻塞，并发数据结构。 单个写线程的情景在一些场景下，你仅有唯一的一个线程在向一个共享变量写，多个线程在读这个变量。当仅有一个线程在更新一个变量，不管有多少个线程在读这个变量，都不会发生竞态条件。因此，无论时候当仅有一个线程在写一个共享变量时，你可以把这个变量声明为volatile。 当多个线程在一个共享变量上执行一个 read-update-write 的顺序操作时才会发生竞态条件。如果你只有一个线程在执行一个 raed-update-write 的顺序操作，其他线程都在执行读操作，将不会发生竞态条件。 下面是一个单个写线程的例子，它没有采取同步手段但任然是多线程安全的： 123456789101112131415161718192021public class SingleWriterCounter &#123; private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions. */ public void inc() &#123; this.count++; &#125; /** * Many reading threads may call this method * @return */ public long count() &#123; return this.count; &#125;&#125; 上面的例子中，多个线程时可以访问 SingleWriterCounter 的同一个实例的，只要只有一个线程调用 inc() 方法（不是指某一时刻一个线程，而是只有一个线程）。count()方法可以被多个线程调用。这样的场景将不会发生任何竞态条件。 下图，说明了线程是如何访问count这个volatile变量的。 基于volatile变量的更高级的数据结构使用多个volatile变量去创建数据结构是可以的，构建出的数据结构中每一个volatile变量仅被一个单个的线程写，被多个线程读。每个volatile变量可能被一个不同的线程写（但仅有一个）。使用像这样的数据结构多个线程可以使用这些volatile变量以一个非阻塞的方法彼此发送信息。 下面是一个简单的例子： 123456789101112131415161718192021222324252627282930public class DoubleWriterCounter &#123; private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions. */ public void incA() &#123; this.countA++; &#125; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions. */ public void incB() &#123; this.countB++; &#125; /** * Many reading threads may call this method */ public long countA() &#123; return this.countA; &#125; /** * Many reading threads may call this method */ public long countB() &#123; return this.countB; &#125;&#125; 只有一个线程调用 incA()，也只有一个线程调用 incB()，countA()和countB()可以被多个线程调用。这个例子实际上是两个 SingleWriterCounter 合在一起了。 下图，展示了两个线程通过类似于上面的一个数据结构进行通信的： CAS 与乐观锁如果你确实需要多个线程写同一个共享变量，使用volatile变量是不合适的。你需要独占对这个变量的访问权限（排他）。下面代码演示了Java中的同步块是如何进行排他访问的： 123456789101112131415public class SynchronizedCounter &#123; long count = 0; public void inc() &#123; synchronized(this) &#123; count++; &#125; &#125; public long count() &#123; synchronized(this) &#123; return this.count; &#125; &#125;&#125; inc() 与 count() 都有一个同步块，而同步块与 wait() - notify() 却是我们想避免的。 我们可以使用原子变量来代替这两个同步块。在这个例子中是AtomicLong。下面是SynchronizedCounter类的AtomicLong实现版本。 1234567891011121314151617import java.util.concurrent.atomic.AtomicLong;public class AtomicCounter &#123; private AtomicLong count = new AtomicLong(0); public void inc() &#123; boolean updated = false; while(!updated)&#123; long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); &#125; &#125; public long count() &#123; return this.count.get(); &#125;&#125; 这个版本是上一个版本的线程安全版本。在这一版中，我们感兴趣的是inc()方法的实现。inc()方法中不再含有一个同步块。而是被下面这些代码替代： 12345boolean updated = false;while(!updated)&#123; long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1);&#125; 上面这些代码并不是一个原子操作。也就是说，可能会有两个不同的线程调用 inc() 方法。但是这里却没有包含竟态条件。 秘密就在于while循环里的第二行代码。compareAndSet()方法调用是一个原子操作。它用一个期望值和AtomicLong 内部的值去比较，如果这两个值相等，就把AtomicLong内部值替换为一个新值。compareAndSet()通常被CPU中的compare-and-swap指令直接支持。因此，不需要去同步，也不需要去挂起线程。 假设，这个AtomicLong的内部值是20。然后，两个线程去读这个值，都尝试调用compareAndSet(20, 20 + 1)。尽管compareAndSet()是一个原子操作，这个方法也会被这两个线程相继执行（某一个时刻只有一个）。 第一个线程会使用期望值20（这个计数器的上一个值）与AtomicLong的内部值进行比较。由于两个值是相等的，AtomicLong会更新它的内部值至21（20 + 1 ）。变量updated被修改为true，while循环结束。 现在，第二个线程调用compareAndSet(20, 20 + 1)。由于AtomicLong的内部值不再是20，这个调用将不会成功。AtomicLong的值不会再被修改为21。变量，updated被修改为false，线程将会再次在while循环外自旋。这段时间，它会读到值21并企图把值更新为22。如果在此期间没有其它线程调用inc()。第二次迭代将会成功更新AtomicLong的内部值到22。 上一部分展现的代码被称为乐观锁（optimistic locking）。乐观锁区别于传统的锁（有时也被称为悲观锁）。传统的锁会使用同步块或其他类型的锁阻塞对临界区域的访问。一个同步块或锁可能会导致线程挂起。 乐观锁允许所有的线程在不发生阻塞的情况下创建一份共享内存的拷贝。这些线程接下来可能会对它们的拷贝进行修改，并企图把它们修改后的版本写回到共享内存中。如果没有其它线程对共享内存做任何修改， CAS操作就允许线程将它的变化写回到共享内存中去。如果，另一个线程已经修改了共享内存，这个线程将不得不再次获得一个新的拷贝，在新的拷贝上做出修改，并尝试再次把它们写回到共享内存中去。 称之为“乐观锁”的原因就是：线程会乐观的认为，其他线程在此期间（线程获得了他们想要更改的数据的副本并应用他们的更改）不会对共享内存进行更改。当这个乐观假设成立时，这个线程仅仅在无锁的情况下完成共享内存的更新。当这个假设不成立时，线程所做的工作就会被丢弃，但仍然不使用锁。 乐观锁适用于共享内存竞用不是非常高的情况。如果共享内存上的内容非常多，仅仅因为更新共享内存失败，就用浪费大量的CPU周期用在拷贝和修改上。 不可替换的数据结构一般的，在数据结构不是很复杂的情况下，我们可以使用 CAS 来更新一个数据结构：将数据拷贝一份，做出修改，然后将旧的替换为新的引用。 然而，一个大的数据结构可能会需要大量的内存和CPU周期来复制。这会使你的程序占用大量的内存和浪费大量的时间在拷贝操作上，导致你的程序的性能降低，特别是在这个数据结构的竞争非常高情况下。 一个线程花费在拷贝和修改这个数据结构上的时间越长，其它线程在此期间修改这个数据结构的可能性就越大。如果一个线程修改了这个数据结构，其它所有的线程都不等不再次执行 拷贝-修改 操作。这将会增大性能影响和内存浪费。 接下来的部分将会讲解一种实现非阻塞数据结构的方法，这种数据结构可以被并发修改，而不仅仅是拷贝和修改。 共同修改我们可以不用每次复制原来的数据结构，而是让多个线程同时修改这个数据结构。这里的多线程同时修改并不是真正意义上的同时修改，而是说某一个线程提交自己的修改时，别的线程依然无法访问，但是如果该线程在提交自己的修改之后阻塞了，别的线程可以继续完成该线程提交的修改操作。 大致的过程如下： 检查另一个线程是否已经对这个数据结构提交了修改 如果没有其他线程提交了修改，创建一个修改对象，然后向这个数据结构提交这次修改 执行对共享数据结构的修改 移除对这个修改的引用，向其它线程发送信号，告诉它们这个修改已经被执行 第二步可以阻塞其他线程提交一个修改。因此，第二步实际的工作是作为这个数据结构的一个锁。如果一个线程已经成功提交了一个修改，其他线程就不可以再提交一个修改直到第一个修改执行完毕。 如果一个线程提交了一个修改，然后做一些其它的工作时发生阻塞，这时候，这个共享数据结构实际上是被锁住的。其它线程检测到它们不能够提交修改，这个时候我们就休要做一些特殊的操作（为了避免一个已经提交的修改锁住共享数据结构，这个修改对象必须包含足够的信息让其他线程来完成这次修改），我们让别的线程来帮助完成这次修改。 下面是一个蓝图： 可以看到，上面的图中有两次检查。 第一次检查，是某个线程 T1 想要对数据结构提交一个修改，发现已经有别的线程 T0 提交过修改了，但是 T0 却没有完成自己提交的修改，所以 T1 需要先帮 T0 完成它提交的修改，然后再复制数据结构，创建自己的修改。 等到 T1 创建完自己的修改之后，由于不可抗力，T1 也阻塞了，这个时候 T2 又来了，所以 T2 也需要再次完成未完成的修改。这里就是第二次检查的作用了。 一个非阻塞算法的模板在非阻塞算法方面，我（博客原作者 Jakob Jenkov ）并不是一位专家，所以，下面的模板可能错误。不要基于我提供的模板实现自己的非阻塞算法。这个模板意在告诉你一个关于非阻塞算法大致是什么样子的。如果，你想实现自己的非阻塞算法，首先学习一些实际的工业水平的非阻塞算法，然后在实践中学习更多关于非阻塞算法实现的知识。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicStampedReference;public class NonblockingTemplate &#123; public static class IntendedModification &#123; public AtomicBoolean completed = new AtomicBoolean(false); &#125; private AtomicStampedReference&lt;IntendedModification&gt; ongoingMod = new AtomicStampedReference&lt;IntendedModification&gt;(null, 0); //declare the state of the data structure here. public void modify() &#123; while(!attemptModifyASR()); &#125; public boolean attemptModifyASR()&#123; boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null)&#123; //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted)&#123; //complete modification via a series of compare-and-swap operations. //note: other threads may assist in completing the compare-and-swap // operations, so some CAS may fail modified = true; &#125; &#125; else &#123; //attempt to complete ongoing modification, so the data structure is freed up //to allow access from this thread. modified = false; &#125; return modified; &#125;&#125; 说实话，这里有个地方我有点疑问（上面代码中的 45-50行）： 123456&#125; else &#123; //attempt to complete ongoing modification, so the data structure is freed up //to allow access from this thread. modified = false;&#125; 这里别的线程帮助完成提交的修改的时，应该怎么做才能不导致阻塞？ 如果使用 CAS，那岂不是还是要走 copy 数据结构的套路？那就还是回到了原来的问题啊，copy 复杂的数据结构可能会导致更激烈的竞争。 或者将两个修改合并？？但是虽然这样不会 copy 数据，但是合并的操作怎么保证不阻塞？合并的时候完全使用 CAS 操作，这样就只 copy 了提交对象。 非阻塞算法是不容易实现的正确的设计和实现非阻塞算法是不容易的。在尝试设计你的非阻塞算法之前，看一看是否已经有人设计了一种非阻塞算法正满足你的需求。 Java已经提供了一些非阻塞实现（比如 ConcurrentLinkedQueue），相信在Java未来的版本中会带来更多的非阻塞算法的实现。 除了Java内置非阻塞数据结构还有很多开源的非阻塞数据结构可以使用。 选择非阻塞算法的第一个好处是，给了线程一个选择，当它们请求的动作不能够被执行时做些什么。不再是被阻塞在那。在这种情况下，它可以选择阻塞或自我等待，像这样把CPU的使用权让给其它的任务。 没有死锁非阻塞算法的第二个好处是，一个线程的挂起不会导致其它线程挂起。这也意味着不会发生死锁。非阻塞算法任然可能产生活锁（live lock），两个线程一直请求一些动作，但一直被告知不能够被执行（由于相互影响）。 没有线程挂起挂起和恢复一个线程的代价是昂贵的。 无论什么时候，一个线程阻塞，就会被挂起。由于使用非阻塞算法线程不会被挂起，这种过载就不会发生。这就意味着CPU有可能花更多时间在执行实际的业务逻辑上而不是上下文切换。 降低线程延迟在这里我们提到的延迟指的是一个请求产生到线程实际的执行它之间的时间。因为在非阻塞算法中线程不会被挂起，它们就没有线程切换成本。这就意味着当一个请求执行时可以得到更快的响应，减少它们的响应延迟。 非阻塞算法通常忙等待直到请求动作可以被执行来降低延迟。当然，在一个非阻塞数据数据结构有着很高的线程争用的系统中，CPU可能在它们忙等待期间消耗大量的CPU周期。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0021-阻塞队列]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0021-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[阻塞队列与普通队列的区别在于：当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来（如从队列中移除一个或者多个元素，或者完全清空队列）。 下图展示了如何通过阻塞队列来合作： 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素 从5.0开始，JDK在java.util.concurrent包里提供了阻塞队列的官方实现。尽管JDK中已经包含了阻塞队列的官方实现，但是熟悉其背后的原理还是很有帮助的。 阻塞队列的简单实现阻塞队列的实现类似于带上限的Semaphore的实现。下面是阻塞队列的一个简单实现： 12345678910111213141516171819202122232425262728293031323334public class BlockingQueue &#123; private List queue = new LinkedList(); private int limit = 10; public BlockingQueue(int limit)&#123; this.limit = limit; &#125; public synchronized void enqueue(Object item) throws InterruptedException &#123; while(this.queue.size() == this.limit) &#123; wait(); &#125; if(this.queue.size() == 0) &#123; notifyAll(); &#125; this.queue.add(item); &#125; public synchronized Object dequeue() throws InterruptedException&#123; while(this.queue.size() == 0)&#123; wait(); &#125; if(this.queue.size() == this.limit)&#123; notifyAll(); &#125; return this.queue.remove(0); &#125;&#125; 可以看到这个例子与上一篇的带上界的信号量很像，不过就是多了一步操作（往 list 里面添加或删除元素）。 每当 list 满的时候，enqueue 线程就会进入 wait 方法，然后阻塞。当 list 从满变为非满的时候，阻塞的线程就会被唤醒。 当 list 为空的时候，dequeue 线程会进入 wait 方法，然后阻塞。当 list 从空变为非空的时候，阻塞的线程就会被唤醒。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0022-线程池]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0022-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[线程池（Thread Pool）对于限制应用程序中同一时刻运行的线程数很有用。因为每启动一个新线程都会有相应的性能开销，每个线程都需要给栈分配一些内存等等。我们可以把并发执行的任务传递给一个线程池，来替代为每个并发执行的任务都启动一个新的线程。只要池里有空闲的线程，任务就会分配给一个线程执行。在线程池的内部，任务被插入一个阻塞队列，线程池里的线程会去取这个队列里的任务。当一个新任务插入队列时，一个空闲线程就会成功的从队列中取出任务并且执行它。 Java 5 在 java.util.concurrent 包中自带了内置的线程池，所以你不用非得实现自己的线程池。不过无论如何，知道一点关于线程池实现的知识总是有用的。 下面我们来实现一个简易版的线程池。 一个线程池需要存放两部分的东西：线程、任务。 1234567891011121314151617181920212223242526272829303132public class ThreadPool &#123; private BlockingQueue taskQueue = null; private List&lt;PoolThread&gt; threads = new ArrayList&lt;PoolThread&gt;(); private boolean isStopped = false; public ThreadPool(int noOfThreads, int maxNoOfTasks) &#123; taskQueue = new BlockingQueue(maxNoOfTasks); for (int i=0; i&lt;noOfThreads; i++) &#123; threads.add(new PoolThread(taskQueue)); &#125; for (PoolThread thread : threads) &#123; thread.start(); &#125; &#125; public void synchronized execute(Runnable task) &#123; if(this.isStopped) throw new IllegalStateException("ThreadPool is stopped"); this.taskQueue.enqueue(task); &#125; public synchronized boolean stop() &#123; this.isStopped = true; for (PoolThread thread : threads) &#123; thread.toStop(); &#125; &#125;&#125; 我们在构造函数中，一开始就创建出多个线程，并启动它们，以供后面的任务使用，当然这里是为了简化，完全可以做到任务到来了之后再去创建线程。 execute 方法就很简单了，我们啥都不用做，将任务放入队列即可（就像银行排队一样，就算前面没有人，你也要先取号）。 stop 方法就是用来停止线程池里面所有线程的。 我们再来看 PoolThread 的实现： 123456789101112131415161718192021222324252627282930public class PoolThread extends Thread &#123; private BlockingQueue&lt;Runnable&gt; taskQueue = null; private boolean isStopped = false; public PoolThread(BlockingQueue&lt;Runnable&gt; queue) &#123; taskQueue = queue; &#125; public void run() &#123; while (!isStopped()) &#123; try &#123; Runnable runnable =taskQueue.take(); runnable.run(); &#125; catch(Exception e) &#123; // 写日志或者报告异常, // 但保持线程池运行. &#125; &#125; &#125; public synchronized void toStop() &#123; isStopped = true; this.interrupt(); // 打断池中线程的 dequeue() 调用. &#125; public synchronized boolean isStopped() &#123; return isStopped; &#125;&#125; 这个类就是一个增强版，线程执行 run 方法的时候，只能去队列里面取。队列没有东西，就阻塞着。处理异常一定要捕获。如果线程有中断标识按需退出，例子中没有处理，官方包中线程池也是不会中断，一定会执行完当前任务。 然后一个隐藏的点：子线程会在完成当前执行的任务后阻塞。注意 PoolThread.stop() 方法中调用了 this.interrupt()。它确保阻塞在 taskQueue.dequeue() 里的 wait() 调用的线程能够跳出 wait() 调用（因为执行了中断interrupt，它能够打断这个调用），并且抛出一个 InterruptedException 异常离开 dequeue() 方法。这个异常在 PoolThread.run() 方法中被截获、报告，然后再检查 isStopped 变量。由于 isStopped 的值是 true, 因此 PoolThread.run() 方法退出，子线程终止。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0023-CAS]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0023-CAS%2F</url>
    <content type="text"><![CDATA[在说 CAS 之前先说一下乐观锁的定义： 乐观锁总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，所以在每次操作数据的时候都不会给数据加锁，即在线程对数据进行操作的时候，别的线程不会阻塞仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。 CAS是乐观锁的一种实现，说起来很抽象，其实还是很简单的，因为实际上它都不算是锁，更像是一种策略。 CAS（Compare and swap），是设计并发算法时用到的一种技术。简单来说，CAS 是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术。 在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。下面是一个简单的示例： 123456789101112class MyLock &#123; private boolean locked = false; public boolean lock() &#123; if(!locked) &#123; locked = true; return true; &#125; return false; &#125;&#125; 上面这段代码，如果用在多线程的程序会出现很多错误。 为了在一个多线程程序中良好的工作，“check then act” 操作必须是原子的。原子就是说“check”操作和“act”被当做一个原子代码块执行。不存在多个线程同时执行原子块。 下面是一个代码示例，把之前的lock()方法用synchronized关键字重构成一个原子块。 123456789101112class MyLock &#123; private boolean locked = false; public synchronized boolean lock() &#123; if(!locked) &#123; locked = true; return true; &#125; return false; &#125;&#125; 现在lock()方法是同步的，所以，在某一时刻只能有一个线程在同一个 MyLock 实例上执行它。 原子的lock方法实际上是一个“compare and swap”的例子。 现在的 CPU 自身就支持 CAS 操作。Java 5 中，我们可以使用 java.util.concurrent.atomic 包中的原子类来使用CPU中的这些功能。 下面是一个使用AtomicBoolean类实现lock()方法的例子： 12345678public static class MyLock &#123; private AtomicBoolean locked = new AtomicBoolean(false); public boolean lock() &#123; return locked.compareAndSet(false, true); &#125;&#125; locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。如果值被替换了，compareAndSet()返回true，否则，返回false。 使用 Java5+ 提供的CAS特性而不是使用自己实现的的好处是 Java5+ 中内置的CAS特性可以让你利用底层的你的程序所运行机器的CPU的CAS特性。这会使代码运行更快。 在使用 CAS 的时候，还需要注意 ABA 问题。 ABA 问题就是：如果某个线程将变量的值改变了，然后又改回原来的值，所以 CAS 仍然会认为值没有别的线程改变过。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0024-剖析同步器]]></title>
    <url>%2F2019%2F08%2F23%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0024-%E5%89%96%E6%9E%90%E5%90%8C%E6%AD%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前面，我们设计了简易版的信号量、锁等，它们虽然功能不一样，但是内部的差距却差不多。换句话说，它们内部的的基础部分是相同（或相似）的。了解这些基础部件能在设计同步器的时候给我们大大的帮助。这就是本文要细说的内容。大部分同步器都是用来保护某个区域（临界区）的代码，这些代码可能会被多线程并发访问。要实现这个目标，同步器一般要支持下列功能： 状态 访问条件 状态变化 通知策略 Test-and-Set 方法 Set 方法 并不是所有同步器都包含上述部分，也有些并不完全遵照上面的内容。但通常你会看到一或多个类似的功能。 状态同步器中的状态是用来确定某个线程是否有访问权限。 下面是Lock和BoundedSemaphore中的两个代码片段。 123456789101112public class Lock&#123;+ //state is kept here+ private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; ...&#125; 123456789101112131415public class BoundedSemaphore &#123;+ //state is kept here+ private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait(); this.signal++; this.notify(); &#125; ...&#125; 访问条件访问条件决定调用test-and-set方法（下文会说到）的线程是否可以对状态进行设置。访问条件一般是基于同步器状态的。通常是放在一个while循环里，以避免虚假唤醒问题。访问条件的计算结果要么是true要么是false。 这里有两个来自Lock和BoundedSemaphore的代码片段，它们都有访问条件。注意观察条件是怎样在while循环中检查的。 123456789101112public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123;+ //access condition+ while(isLocked)&#123; wait(); &#125; isLocked = true; &#125; ...&#125; 状态变化一旦一个线程获得了临界区的访问权限，它得改变同步器的状态，让其它线程阻塞，防止它们进入临界区。换而言之，这个状态表示正有一个线程在执行临界区的代码。其它线程想要访问临界区的时候，该状态应该影响到访问条件的结果。 这里有两个状态变化的代码片段： 12345678910111213141516171819public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125;+ //state change+ isLocked = true; &#125; public synchronized void unlock()&#123;+ //state change+ isLocked = false; notify(); &#125;&#125; 12345678910111213141516171819202122public class BoundedSemaphore &#123; private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait();+ //state change+ this.signals++; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait();+ //state change+ this.signals--; this.notify(); &#125;&#125; 通知策略一旦某个线程改变了同步器的状态，可能需要通知其它等待的线程状态已经变了。因为也许这个状态的变化会让其它线程的访问条件变为true。 通知策略通常分为三种： 通知所有等待的线程 通知所有等待的线程非常简单。所有等待的线程都调用的同一个对象上的wait()方法，某个线程想要通知它们只需在这个对象上调用notifyAll()方法。 通知N个等待线程中的任意一个 通知等待线程中的任意一个也很简单，只需将notifyAll()调用换成notify()即可。调用notify方法没办法确定唤醒的是哪一个线程，也就是“等待线程中的任意一个”。 通知N个等待线程中的某个指定的线程 有时候可能需要通知指定的线程而非任意一个等待的线程。例如，如果你想保证线程被通知的顺序与它们进入同步块的顺序一致，或按某种优先级的顺序来通知。想要实现这种需求，每个等待的线程必须在其自有的对象上调用wait()。当通知线程想要通知某个特定的等待线程时，调用该线程自有对象的notify()方法即可。 下面是通知策略的一个例子（通知任意一个等待线程）： 123456789101112131415161718public class Lock&#123; private boolean isLocked = false; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; //wait strategy - related to notification strategy wait(); &#125; isLocked = true; &#125; public synchronized void unlock()&#123; isLocked = false;+ notify(); //notification strategy &#125;&#125; Test-and-Set方法test-and-set其实就是包括了访问条件与状态变化。 同步器中最常见的有两种类型的方法，test-and-set是第一种（set是另一种）。Test-and-set的意思是，调用这个方法的线程检查访问条件，如若满足，该线程设置同步器的内部状态来表示它已经获得了访问权限。 状态的改变通常使其它试图获取访问权限的线程计算条件状态时得到false的结果，但并不一定总是如此。例如，在读写锁中，获取读锁的线程会更新读写锁的状态来表示它获取到了读锁，但是，只要没有线程请求写锁，其它请求读锁的线程也能成功。 test-and-set很有必要是原子的，也就是说在某个线程检查和设置状态期间，不允许有其它线程在test-and-set方法中执行。 test-and-set方法的程序流通常遵照下面的顺序： 如有必要，在检查前先设置状态 检查访问条件 如果访问条件不满足，则等待 如果访问条件满足，设置状态，如有必要还要通知等待线程 下面的ReadWriteLock类的lockWrite()方法展示了test-and-set方法。调用lockWrite()的线程在检查之前先设置状态(writeRequests++)。然后检查canGrantWriteAccess()中的访问条件，如果检查通过，在退出方法之前再次设置内部状态。这个方法中没有去通知等待线程。 1234567891011121314151617181920212223public class ReadWriteLock&#123; private Map&lt;Thread, Integer&gt; readingThreads = new HashMap&lt;Thread, Integer&gt;(); private int writeAccesses = 0; private int writeRequests = 0; private Thread writingThread = null; ... public synchronized void lockWrite() throws InterruptedException&#123; writeRequests++; Thread callingThread = Thread.currentThread(); while(! canGrantWriteAccess(callingThread))&#123; wait(); &#125; writeRequests--; writeAccesses++; writingThread = callingThread; &#125; ...&#125; set方法set方法是同步器中常见的第二种方法。set方法仅是设置同步器的内部状态，而不先做检查。set方法的一个典型例子是Lock类中的unlock()方法。持有锁的某个线程总是能够成功解锁，而不需要检查该锁是否处于解锁状态。 set方法的程序流通常如下： 设置内部状态 通知等待的线程 这里是unlock()方法的一个例子： 12345678public class Lock&#123; private boolean isLocked = false; public synchronized void unlock()&#123; isLocked = false; notify(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0019-锁的可重入性]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0019-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%2F</url>
    <content type="text"><![CDATA[synchronized 就是可重入的，看下面的实例代码：12345678910111213public class Counter &#123; private int count = 0; public synchronized int inc() &#123; return ++count; &#125; public synchronized int dec() &#123; inc(); return --count; &#125;&#125; 这个例子没什么意义，我们可以不用在意。 但是注意一下它的 dec 方法，在这个方法里面它又调用了 inc 方法，而 inc 与 dec 方法都有 synchronized 修饰。如果 synchronized 不可重入的话，线程在执行 dec 方法的时候，会阻塞在对 inc 方法的调用上。但是实际情况是没有的，所以 synchronized 肯定是可重入的。 再回想一下我们前面写的例子，Lock 与 FairLock 这两个锁是可重入的吗？ 先看 Lock 例子： 123456789101112131415161718192021222324252627public class Lock&#123; private boolean isLocked = false; private Thread lockingThread = null; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; lockingThread = Thread.currentThread(); &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; notify(); &#125; &#125; 当一个线程 T 进入 lock 方法之后，会将 isLocked 置为 true，如果这个时候，再次调用 lock 方法的话，会发生什么呢？ 1234// 连续调用调用 lock 方法myLock.lock();// do somethingmyLock.lock(); 在第二次调用 lock 方法的时候，由于 isLocked 已经变为 true 了，所以会进入 wait 方法，导致该线程休眠了，这就不是一个可重入的锁，正常情况下它不应该休眠。 那么应该如何解决这个问题呢？ 我们想想，发现如果是同一个线程多次获取锁的话，就不应该进入 wait 方法。所以我们需要特殊处理一下，而且，获取锁多少次还应该释放锁多少次。 看看改进之后的代码： 1234567891011121314151617181920212223242526272829public class Lock&#123; boolean isLocked = false; Thread lockedBy = null; int lockedCount = 0; public synchronized void lock() throws InterruptedException&#123; Thread callingThread = Thread.currentThread(); while(isLocked &amp;&amp; lockedBy != callingThread)&#123; wait(); &#125; isLocked = true; lockedCount++; lockedBy = callingThread; &#125; public synchronized void unlock()&#123; if(Thread.curentThread() == this.lockedBy)&#123; lockedCount--; if(lockedCount == 0)&#123; isLocked = false; notify(); &#125; &#125; &#125;&#125; 先看 lock 方法： 在进入 wait 之前，先判断了当前线程是不是获取了锁的线程，如果是则不需要 wait。然后记录了获取锁的次数。 在看 unlock 方法： 首先就判断了当前线程是不是获取了锁的线程，不是的话，就不用走下面的逻辑了，是的话就notify，减少获取锁的次数。 这样，我们就实现了一个可重入锁了，其实还是蛮简单的，就是记录了一下锁的获取次数以及判断一下当前线程是不是获取了锁的线程。 有一个需要注意的地方：在finally语句中调用unlock() 如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例： 1234567lock.lock();try&#123; //do critical section code, //which may throw exception&#125; finally &#123; lock.unlock();&#125; 这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。 FairLock 与 Lock 的核心代码其实是差不多的，所以就不讲了。 synchronized 不用这样是因为，java文件在被编译为 class 文件的时候就已经做了这些操作。比如，我们查看一个 class 文件的字节码： 1234563: monitorenter //进入同步方法//..........省略其他 15: monitorexit //退出同步方法16: goto 24//省略其他.......21: monitorexit //退出同步方法 发现，有两个 monitorexit，第二个 monitorexit 就是用来处理发生异常的情况的。再看第一个 monitorexit 后面有一个 goto，说明如果不出现异常是不会走第二个 monitorexit 的。]]></content>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0017-嵌套监视器锁死]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0017-%E5%B5%8C%E5%A5%97%E7%9B%91%E8%A7%86%E5%99%A8%E9%94%81%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前面我们说到过死锁产生的4个条件，其中前3个是可以说是由于锁的特性导致的，一般我们不可改变，只有第4个原因是人为导致的，即获取锁的顺序不一致导致的。但是在某些情况下，即使获取锁的顺序一致，也有可能会导致类似死锁的情况，相互等待。举个例子：12345678910111213141516171819202122232425//lock implementation with nested monitor lockout problempublic class Lock&#123; protected MonitorObject monitorObject = new MonitorObject(); protected boolean isLocked = false; public void lock() throws InterruptedException&#123; synchronized(this)&#123; while(isLocked)&#123; synchronized(this.monitorObject)&#123; this.monitorObject.wait(); &#125; &#125; isLocked = true; &#125; &#125; public void unlock()&#123; synchronized(this)&#123; this.isLocked = false; synchronized(this.monitorObject)&#123; this.monitorObject.notify(); &#125; &#125; &#125;&#125; 看上面的代码，lock 与 unlock 方法都顺序获取两个锁，一个是 lock 对象本身，一个是 monitorObject 对象。 看上去没什么问题，但是注意一下，monitorObject 同步块下面的代码是一个相互唤醒的代码，这会导致下面的情况发生： 某一时刻，isLocked 为 true，这个时候，T1 获取到了 lock 对象的锁，然后接下来获取到了 monitorObjet 的锁，但是由于该 lock 锁已经被别人使用了，所以会进入 wait 方法，释放 monitorObject 锁。所以 T1 只持有 lock 对象的锁，然后等待别的线程唤醒。 然后切换到另一个线程 T2，这个线程是获取了 lock 锁（将 isLocked 置为 true）的线程，它执行完自己的代码之后，需要调用 unLock 方法了，然后发现 lock 对象被 T1 持有了，它无法进入 synchronized 里面，唤醒 T1 线程。 这样，T1 等待 T2 唤醒，但是 T2 又无法唤醒 T1（T1 持有 T2 需要的锁），这就与死锁比较类似，不过死锁都是阻塞在获取锁这里，而嵌套监视器锁定是一个线程阻塞在获取锁这里，另一个线程一直在 wait。 最后，由于 lock 锁被 T1 持有了，而后所有调用 lock 与 unlock 方法的线程都会被阻塞。另外，从这里也可以看出来，wait 只会释放对象上的锁。 看完上面的解释后，你可能会想，确实会有这样的情况，但是本公子天纵奇才，怎么可能会写这么搓的代码。那我们接下来看个不那么简化的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Fair Lock implementation with nested monitor lockout problempublic class FairLock &#123; private boolean isLocked = false; private Thread lockingThread = null; private List waitingThreads = new ArrayList(); public void lock() throws InterruptedException&#123; QueueObject queueObject = new QueueObject(); synchronized(this)&#123; waitingThreads.add(queueObject); while(isLocked || waitingThreads.get(0) != queueObject)&#123; synchronized(queueObject)&#123; try&#123; queueObject.wait(); &#125;catch(InterruptedException e)&#123; waitingThreads.remove(queueObject); throw e; &#125; &#125; &#125; waitingThreads.remove(queueObject); isLocked = true; lockingThread = Thread.currentThread(); &#125; &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; if(waitingThreads.size() &gt; 0)&#123; QueueObject queueObject = waitingThread.get(0); synchronized(queueObject)&#123; queueObject.notify(); &#125; &#125; &#125;&#125; 这个例子基本上是与前面“饥饿与公平”的最后一个例子一样。但是不同的地方在于，“饥饿与公平”的例子中，lock 方法的 synchronized 里面没有嵌套 synchronized(queueObject)，而在这个例子中，显然是一个监视器嵌套的情况。 与之前的例子仅仅又一步之差，但是却引发出一个重大的bug。 嵌套监视器锁死 VS 死锁嵌套监视器锁死与死锁很像：都是线程最后被一直阻塞着互相等待。 但是两者又不完全相同。在死锁中我们已经对死锁有了个大概的解释，死锁通常是因为两个线程获取锁的顺序不一致造成的，线程1锁住A，等待获取B，线程2已经获取了B，再等待获取A。如死锁避免中所说的，死锁可以通过总是以相同的顺序获取锁来避免。 发生嵌套管程锁死时锁获取的顺序是一致的。线程1获得A和B，然后释放B，等待线程2的信号。线程2需要同时获得A和B，才能向线程1发送信号。所以，一个线程在等待唤醒，另一个线程在等待想要的锁被释放。 不同点归纳如下： 123死锁中，二个线程都在等待对方释放锁。嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0018-失效的数据]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0018-%E5%A4%B1%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[原文叫做 “Slipped Conditions”，这个不太好翻译，所以我就借用一下《Java并发编程实战》的一节的标题了，讲的东西差不多。直接看一个例子：123456789101112131415161718192021222324public class Lock &#123; private boolean isLocked = true; public void lock()&#123; synchronized(this)&#123; while(isLocked)&#123; try&#123; this.wait(); &#125; catch(InterruptedException e)&#123; //do nothing, keep waiting &#125; &#125; &#125; synchronized(this)&#123; isLocked = true; &#125; &#125; public synchronized void unlock()&#123; isLocked = false; this.notify(); &#125;&#125; 看 lock 方法，里面有两个同步代码块，第一个同步代码块里面使用 isLocked 作为条件判断，却在第二个同步代码块里面更新了 isLocked 这个值。 这样的写就会很容易产生问题： 当一个线程 T1 执行完第一个同步代码块之后，可能就失去了CPU时间片执行的机会，然后另外一个线程 T2 就可以若无其事的也进入到 lock 方法里面，并且由于第一个线程 T1 没有更新 isLocke 的值，所以 T2 进入第一个同步代码块之后不会进入 wait 方法，这样就相当于有两个线程同时获取了 lock 锁。 这个场景就是“slipped conditions”的例子。 当 T1 进入第一个同步代码块后，从它使用 isLocked 这个值开始，一直到它更新 isLocke 值后，这个期间应该是不允许别的线程访问的，其他线程访问了就是使用了失效的数据。 所以我们应该让使用条件与更新条件这两个地方为原子的。也就是说，在第一个线程检查和设置条件期间，不会有其它线程使用这个条件。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0020-信号量]]></title>
    <url>%2F2019%2F08%2F22%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0020-%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Semaphore（信号量） 是一个线程同步结构，用于在线程间传递信号，以避免出现信号丢失，或者像锁一样用于保护一个关键区域。自从5.0开始，jdk在java.util.concurrent包里提供了Semaphore 的官方实现，因此大家不需要自己去实现Semaphore。但是还是很有必要去熟悉如何使用Semaphore及其背后的原理。 之前就在实现公平锁的时候就实现了一个类似信号量的东西。 123456789101112131415public class Semaphore &#123; private boolean signal = false; public synchronized void take() &#123; this.signal = true; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(!this.signal) wait(); this.signal = false; &#125;&#125; 这里的逻辑前面已经解释过多次了，所以这里就不再赘述了。 唯一需要注意的是，这里的 take 与 release 的意思与我们理解的意思是相反的。take 表示产生了一个信号，release 表示消耗了一个信号。在这里例子中显得很反常，但是在本文的最后一个例子中就会发现很合理。 上面的例子是一个简单的信号量，那么它可以做什么呢？ 可以在两个线程之间通信 如下例子： 1234567891011121314151617181920212223242526272829303132333435Semaphore semaphore = new Semaphore();SendingThread sender = new SendingThread(semaphore)；ReceivingThread receiver = new ReceivingThread(semaphore);receiver.start();sender.start();public class SendingThread &#123; Semaphore semaphore = null; public SendingThread(Semaphore semaphore)&#123; this.semaphore = semaphore; &#125; public void run()&#123; //do something, then signal this.semaphore.take(); &#125;&#125;public class RecevingThread &#123; Semaphore semaphore = null; public ReceivingThread(Semaphore semaphore)&#123; this.semaphore = semaphore; &#125; public void run()&#123; this.semaphore.release(); //receive signal, then do something... &#125;&#125; SendingThread 线程执行到 this.semaphore.take(); 的时候会阻塞，然后等待 RecevingThread 执行到 this.semaphore.release(); 才会醒过来，继续执行自己的代码。 信号量可以用在线程需要配合的地方。 下面我们对信号量进行增强。 可计数的信号量123456789101112131415public class CountingSemaphore &#123; private int signals = 0; public synchronized void take() &#123; this.signals++; this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait(); this.signals--; &#125;&#125; 这个可计数的也没啥意义，我们再增加一下功能。 带上界的信号量12345678910111213141516171819202122232425public class BoundedSemaphore &#123; private int signals = 0; private int bound = 0; public BoundedSemaphore(int upperBound)&#123; this.bound = upperBound; &#125; public synchronized void take() throws InterruptedException&#123; while(this.signals == bound) wait(); this.signals++; // 这里调用 notify，是用来唤醒 release 导致的阻塞的线程 this.notify(); &#125; public synchronized void release() throws InterruptedException&#123; while(this.signals == 0) wait(); this.signals--; this.notify(); &#125;&#125; 当已经产生的信号数量达到了上限，take方法将阻塞新的信号产生请求，直到某个线程调用release方法后，被阻塞于take方法的线程才能传递自己的信号。 BoundedSemaphore 其实可以当作锁来使用： 12345678BoundedSemaphore semaphore = new BoundedSemaphore(1);...semaphore.take();try&#123; //critical section&#125; finally &#123; semaphore.release();&#125; 在前面的例子中，Semaphore被用来在多个线程之间传递信号，这种情况下，take和release分别被不同的线程调用。 但是在锁这个例子中，take和release方法将被同一线程调用，因为只允许一个线程来获取信号（允许进入关键区域的信号），其它调用take方法获取信号的线程将被阻塞，直到第一个调用take方法的线程调用release方法来释放信号。对release方法的调用永远不会被阻塞，这是因为任何一个线程都是先调用take方法，然后再调用release。 通过有上限的Semaphore可以限制进入某代码块的线程数量。设想一下，在上面的例子中，如果BoundedSemaphore 上限设为5将会发生什么？意味着允许5个线程同时访问关键区域，但是你必须保证，这个5个线程不会互相冲突。否则你的应用程序将不能正常运行。 必须注意，release方法应当在finally块中被执行。这样可以保在关键区域的代码抛出异常的情况下，信号也一定会被释放。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0016-饥饿与公平]]></title>
    <url>%2F2019%2F08%2F21%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0016-%E9%A5%A5%E9%A5%BF%E4%B8%8E%E5%85%AC%E5%B9%B3%2F</url>
    <content type="text"><![CDATA[在多线程程序中，有可能出现这样的情况：某个线程由于得不到CPU的时间片，导致这个线程永远无法执行。这种情况就叫做“饥饿”。解决“饥饿”的方案叫“公平性”，即让每个线程都有机会获得CPU得运行机会。“饥饿”的原因先来说一下导致“饥饿”得几个原因： 高优先级线程吞噬低优先级线程的CPU时间 你可以为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。对大多数应用来说，你最好是不要改变其优先级值。 线程被一直因为获取不到锁而阻塞，因为 synchronized 是非公平锁，所以有可能线程永远得不到锁。 Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。 线程一直处于 wait 状态，因为 notify 总是随机唤醒一个，所以有可能线程永远不会被唤醒。 如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。 实现“公平性”文章原文说了这样的一句话： While it is not possible to implement 100% fairness in Java we can still implement our synchronization constructs to increase fairness between threads. 我也不知道为啥不能100%实现。暂且放过。 下面，我们来自己实现一个锁，不要方，很简单的。 12345678public class Synchronizer&#123; Lock lock = new Lock(); public void doSynchronized() throws InterruptedException&#123; this.lock.lock(); //critical section, do a lot of work which takes a long time this.lock.unlock(); &#125;&#125; 这个例子里面所使用的 Lock 就是我们需要实现的锁了。实现代码如下： 12345678910111213141516171819202122232425262728293031public class Lock&#123; private boolean isLocked = false; private Thread lockingThread = null; public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; wait(); &#125; isLocked = true; lockingThread = Thread.currentThread(); &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; notify(); &#125;&#125; lock 方法：多个线程访问该方法的时候，只有第一个获得 synchronized 锁的线程才能进入 lock 方法，然后将 isLocked 置为true，其余的线程获得 synchronized 锁之后，只能进入 wait 方法。 unlock 方法：该方法重新将 isLocked 置为 false，这样其他线程才能跳出 wait 所在的循环。调用 notify 之后，由于多个线程使用的是同一个锁，所以将随机唤醒一个线程。 我们仔细想一下，lock 方法也是一个同步代码块，但是线程基本不会在同步代码块上阻塞（同步代码块很短），而是都阻塞到了 wait 方法上。 虽然，notify 唤醒的时候，是随机唤醒一个阻塞在同一个对象上的线程。但是这里就是我们可以优化的点了！！！因为如果我们让每个线程都阻塞在不同对象的 wait 方法上，这样我们只需要公平的调用这些对象的 notify 方法就可以实现公平性了。 为了实现公平性，我们还需要一个队列，用来存储线程到来的顺序，按照到来的顺序来唤醒线程，实现公平性。 看下面的代码，一个简易的公平锁： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FairLock &#123; private boolean isLocked = false; private Thread lockingThread = null; private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;(); public void lock() throws InterruptedException &#123; QueueObject queueObject = new QueueObject(); boolean isLockForThisThread = true; synchronized (this) &#123; waitingThreads.add(queueObject); &#125; while (isLockForThisThread) &#123; synchronized (this) &#123; isLockForThisThread = !isLocked &amp;&amp; waitingThreads.get(0) == queueObject; if (isLockForThisThread) &#123; isLocked = true; waitingThreads.remove(queueObject); lockingThread = Thread.currentThread(); return; &#125; &#125; try &#123; queueObject.doWait(); &#125; catch (InterruptedException e) &#123; synchronized (this) &#123; waitingThreads.remove(queueObject); &#125; throw e; &#125; &#125; &#125; public synchronized void unlock() &#123; if (this.lockingThread != Thread.currentThread()) &#123; throw new IllegalMonitorStateException( "Calling thread has not locked this lock"); &#125; isLocked = false; lockingThread = null; if (waitingThreads.size() &gt; 0) &#123; waitingThreads.get(0).doNotify(); &#125; &#125;&#125; 12345678910111213141516171819202122public class QueueObject &#123; private boolean isNotified = false; public synchronized void doWait() throws InterruptedException &#123; while(!isNotified)&#123; this.wait(); &#125; this.isNotified = false; &#125; public synchronized void doNotify() &#123; this.isNotified = true; this.notify(); &#125; public boolean equals(Object o) &#123; return this == o; &#125;&#125; 我们先说 QueueObject 类，它其实就是一个信号量。doWait 方法里面使用了循环，避免假唤醒。同时也储存了唤醒信号，避免信号丢失。这个类还是很好理解的，就是将 Object 的 wait 与 notify 增强了一下。 再来看 FairLock 类。别看代码有点复杂，但是逻辑基本没变。比如 lock 方法： 首先为每个线程都创建一个锁对象，然后放入队列里面。 接下来仍然是一个 while 循环，只不过这个循环的变量需要注意一下，原先只要判断是否已经有线程把锁拿走了，现在还需要在这个基础上判断，是否当前线程是队列里面的第一个线程（只有第一个有资格运行，这样才公平）。然后仍然是调用 wait 方法。 再来仔细的对比一下，FairLock 与 Lock 的区别： lock()方法不再声明为synchronized，取而代之的是只对必需同步的代码进行同步。 调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程（头部的）获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。 queueObject.doWait()调用放置在synchronized(this)块之外，以避免监视器嵌套锁死的情况（下一篇会讲）。 最后，注意到queueObject.doWait()的try – catch块，在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。 性能考虑如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。 这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。 究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0013-ThreadLocal]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0013-ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal类创建的变量会给每个线程都分配一份，虽然每个线程都持有的是执行同一个ThreadLocal对象的引用，但是获取的（调用 get 方法）确实不同的对象。创建 ThreadLocal 对象1private ThreadLocal myThreadLocal = new ThreadLocal(); 这个好理解，与普通Java类一样使用即可。 储存值当创建好了 ThreadLocal 之后，我们就可以往里面储存值了，就像 ThreadLocal 是一个容器一样。 123456// ThreadLocal 支持泛型private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;String&gt;();// 储存一个 string 对象myThreadLocal1.set("Hello ThreadLocal");String threadLocalValues = myThreadLocal.get(); 嗯，获取用 String 来当作例子有点不恰当，没法看出它是不是同一个对象，我们稍微改变一下： 1234567// ThreadLocal 支持泛型private ThreadLocal myThreadLocal1 = new ThreadLocal&lt;Object&gt;();// 储存一个 string 对象myThreadLocal1.set(new Object());Object o = myThreadLocal.get();System.out.println(o.hashcode()) 在不同的线程里面执行，打印 hashCode 会发现是不同的值，即不同的线程 set 与 get 获取的都是属于自己的那一份，无法获取别的线程的，别的线程也获取不到自己的。 初始值ThreadLocal 还可以指定一个初始值，即当没有执行 set 方法的时候，get 方法也能取出初始值来。 1private ThreadLocal&lt;Object&gt; threadLocal = ThreadLocal.withInitial(Object::new); 这个初始值也是每个线程都有一份，每个线程获取的也是不同的对象，而不是同一个对象。 示例12345678910111213141516171819202122232425262728293031323334public class ThreadLocalExample &#123; public static class MyRunnable implements Runnable &#123; private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); @Override public void run() &#123; threadLocal.set( (int) (Math.random() * 100D) ); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(threadLocal.get()); &#125; &#125; public static void main(String[] args) &#123; MyRunnable sharedRunnableInstance = new MyRunnable(); Thread thread1 = new Thread(sharedRunnableInstance); Thread thread2 = new Thread(sharedRunnableInstance); thread1.start(); thread2.start(); thread1.join(); //wait for thread 1 to terminate thread2.join(); //wait for thread 2 to terminate &#125;&#125; 上面创建了两个线程共享一个MyRunnable实例。 每个线程执行run()方法的时候，会给同一个ThreadLocal实例设置不同的值。 如果不使用ThreadLocal对象，那么第二个线程将会覆盖第一个线程所设置的值。 然而，由于是ThreadLocal对象，所以两个线程无法看到彼此的值。因此，可以设置或者获取不同的值。 InheritableThreadLocalInheritableThreadLocal类是ThreadLocal的子类。 为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。 需要注意的地方ThreadLocal 实际上是将要存放的对象放入到了 Thread 的 localValues 变量中。 java.lang.Thread 1234/** * Normal thread local values. */ThreadLocal.Values localValues; 使用 set 方法的时候，是将 ThreadLocal 本身的弱引用做为 key，将要储存的对象做为 value。 java.lang.ThreadLocal#set 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 看起来传递的是 this，其实真正put的时候，使用的是弱引用。如下： java.lang.ThreadLocal.ThreadLocalMap.Entry 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 可以看到，Entry 是继承至 WeakReference 的，而 Entry 就是要 put 进去的 key 与 value 的封装。 所以，网上多说，会有内存泄露的可能。是因为如果 ThreadLocal 本身如果没有再使用了，而当前线程迟迟不结束的话，会导致 Thread 的 localValues 变量里存的 key 被回收，values 却无法被回收（引用找不到了，但是却存在于 threa 的成员变量里面）。 这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value造成内存泄漏，当然线程结束就好了。 所以，使用 ThreadLocal 推荐写成 private static 的。用完也应该 remove。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0014-volatile关键字]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0014-volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Java 的 volatile 关键字表示修饰的这个变量的 值储存在主存 中，这里不要理解错了，并不是说 volatile 修饰的变量就直接在主内存中操作（这是不可能的），而是说： 修改volatile变量时会强制将修改后的值刷新的主内存中。 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，需要重新读取主内存中的值。 说的通俗一点，就是每次读取 volatile 变量都会从主存中读取，每次写入 volatile 变量都是写入到主存中。 前面我们说过可见性问题，而 volatile 关键字就是用来保证线程之间变量的可见性。可能还是有点抽象，那就再说一遍。 volatile 对可见性的保证现在的 CPU 为了性能，会将内存中的数据拷贝到 CPU 的高速缓存中。如果有多个 CPU 的话，每个线程会运行在不同的 CPU 上，即每个线程都会拷贝一个数据到高速缓存中。如下图： 对于非 volatile 的变量，在多线程的程序中，就会出现可见性问题，当一个线程更新了值之后，而另一个线程却看不到，就会导致程序错误： 12345public class SharedObject &#123; public int counter = 0;&#125; 假设，线程 1 会更新计数器的值， 线程 2 会时时的读取这个计数器的值。由于 counter 不是 volatile 的，所以在线程 1 更新其值之后，不一定会将值刷新到主存中，当线程 2 读取的时候，读取的还是未更新的值： 使用 volatile 之后，就不一样了。volatile 就是用来解决这个问题的，我们给 counter 加上关键字： 12345public class SharedObject &#123; public volatile int counter = 0;&#125; 当线程1更新 counter 的值后， 线程2就能读到最新值了。 但是如果 线程1 与 线程2 都更新 counter 的值的话，仅仅加上 volatile 关键字还是不够的，后面会说。 volatile 对重排序的影响volatile 可见性不仅会影响到它优化的变量，还会对重排序有一定影响。看下面这个例子： 12345678//x、y为非volatile变量//flag为volatile变量x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且 volatile 关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 volatile 与 Happens-Before再来看一个例子： 123456789101112131415161718192021public class MyClass &#123; private int years; private int months private volatile int days; public int totalDays() &#123; int total = this.days; total += months * 30; total += years * 365; return total; &#125; public void update(int years, int months, int days)&#123; // 1 this.years = years; // 2 this.months = months; // 3 this.days = days; &#125;&#125; update 方法写了3个变量，只有 days 是 volatile 的。但是实际上在将 days 的值刷入主内存的时候，会将 years 与 months 的值也刷入主内存。 totalDays 方法读取了3个变量的值，当从主内存读取 days 的值的时候，也会从主内存读取 months 与 years 的值。 起初，我是无法理解的，于是去 stackOverFlow 上问了一下，很快就有了答案： 这个是由于 “Happens-Before” 原则引发的： 由于 days 被 volatile 修饰，所以代码 1 2 处 Happens-Before 代码 3，即代码 1 2 的结果对代码 3 是可见的。 同样，volatile 变量的写 Happens-Before volatile 变量的读。 在根据 Happens-Before 的传递性，所以某一个线程想要读取 days 的值的时候，months 与 years 的值也是最新的。 volatile 使用注意前面，我们说的多个线程更新 counter 的值，尽管 counter 是 volatile 的，但是还是会出问题，现在就来解释一下。 1counter++; 就拿这个举例，假设某个时刻，counter 的值为 4。 123456789线程1从主内存中读取值为4，准备执行加一的指令，然后线程1被阻塞，切换到线程2线程2从主内存中读取值为4，准备执行加一的指令，然后线程2被阻塞，切换到线程1线程1执行加一的指令，最后将自增后的值赋值给counter，counter的值成了5，写入回了主内存。线程1阻塞，切换到线程2.线程2执行加一的指令（将4加一的过程中不需要对counter进行读写，所以自增之后的值还是5），然后将 5 赋值给 counter，并写入回了主内存。最后，counter 的结果还是 5. 看一张图： 在读取一个变量与给这个变量赋值之间是有一段间隔的，这段间隔表示它们不是一个原子操作，不是原子操作就会产生竟态条件。两个线程同时读取值之后，一个线程即使更新了值，也不管用了，因为读取操作已经完成了，后面的写操作不需要再次读取该值，也就看不到最新的值。 所以，volatile 应该用在不需要依赖变量的当前值的地方。反过来说： 运算结果并不依赖变量的当前值（即结果对产生中间结果不依赖），或者能够确保只有单一的线程修改变量的值 比如，用来更新标识变量，直接给标识赋值，flag = true 或者 flag = false，不需要依赖当前的值，像 flag = !flag 就不行。 最后，由于 volatile 每次写操作将最新值刷入主存，每次读操作要从主存重新读取，所以效率不高，而且它还禁止了指令优化，所以一定要在确实需要的时候才使用。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0015-死锁]]></title>
    <url>%2F2019%2F08%2F20%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0015-%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。死锁的产生死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。举个例子：123如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。 上面的例子可能的代码如下： 1234567891011121314151617181920212223242526public class TreeNode &#123; TreeNode parent = null; List children = new ArrayList(); public synchronized void addChild(TreeNode child)&#123; if(!this.children.contains(child)) &#123; this.children.add(child); child.setParentOnly(this); &#125; &#125; public synchronized void addChildOnly(TreeNode child)&#123; if(!this.children.contains(child)&#123; this.children.add(child); &#125; &#125; public synchronized void setParent(TreeNode parent)&#123; this.parent = parent; parent.addChildOnly(this); &#125; public synchronized void setParentOnly(TreeNode parent)&#123; this.parent = parent; &#125;&#125; 如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程： 12345Thread 1: parent.addChild(child); //locks parent --&gt; child.setParentOnly(parent);Thread 2: child.setParent(parent); //locks child --&gt; parent.addChildOnly() 首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。 然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。 现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。 上面的例子说的是比较简单的死锁，还有更加复杂的死锁（死锁可能不止包含2个线程）。下面是4个线程发生死锁的例子： 1234Thread 1 locks A, waits for BThread 2 locks B, waits for CThread 3 locks C, waits for DThread 4 locks D, waits for A 还有数据库也可能发生死锁（这个与线程的死锁是一样的道理）。 当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁。 死锁预防先来说一下死锁产生的必要条件，知道了条件之后，就可以采取对应的措施。 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 通过前面死锁的产生篇章，我们知道了循环等待的条件的形成是由于线程请求锁的顺序不一致导致的。那么如果我们让线程请求锁的顺序有序的话，那就不会形成循环等待条件，这样形成死锁的条件就打破了。看下面这个例子： 123456789101112Thread 1: lock A lock BThread 2: wait for A lock C (when A locked)Thread 3: wait for A wait for B wait for C 如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。 线程2和线程3只有在获取了锁A之后才能尝试获取锁C。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。 按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。 还有一种方式，就是加上超时机制。一个线程在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。看下面的例子： 12345678910111213Thread 1 locks AThread 2 locks BThread 1 attempts to lock B but is blockedThread 2 attempts to lock A but is blockedThread 1's lock attempt on B times outThread 1 backs up and releases A as wellThread 1 waits randomly (e.g. 257 millis) before retrying.Thread 2's lock attempt on A times outThread 2 backs up and releases B as wellThread 2 waits randomly (e.g. 43 millis) before retrying. 在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁。 需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁，也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。 此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相同的重试时间的概率就高的多。 还有一种避免死锁的算法（银行家算法），不过需要预先知道所有的线程，资源。 死锁检测死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。 每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。 当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。 当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。先判断B是否有A所要的锁，没有则查看线程B等待的线程C，看C是否持有A说要的锁，就这样递进的检查下去。 下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。 那么当检测出死锁时，这些线程该做些什么呢？ 一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0018-静态链表]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2F%E7%AE%97%E6%B3%95%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F0018-%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[在一些早期的语言中，是没有指针这个东西的，那么就没办法实现链表了。但是我们的前辈们想出了一个办法：用数组来实现链表，是真的牛逼。我们来看看是如何实现的吧。首先，同样是定义一个Node类，然后创建一个Node数组，为了方便插入数据，会把这个数组定义的大一些，以免溢出（这里就不考虑扩容了）。注意这里我们储存的是下一个节点的位置，而不是下一个节点的引用，因为早期的语言没有引用。 1234class Node &#123; Object value; int nextPos;&#125; 然后我们再来思考，用数组怎么链式储存数据。 首先头指针怎么存？ 新插入一个节点的时候，怎么插入？肯定不能一个个往后移动 删除节点的时候，怎么标记这个位置是空的？ 直接给出答案吧，看下图： 这样储存的就解决了上面的3个问题。 头节点放在最后一个位置。 第一个位置用来放备用链表，啥叫备用链表呢，就是把数组里面所有为空的位置串起来的链表。有了备用链表，想要插入的话，从备用链表里面拿第一个节点就好了。想要删除的话，将删除的节点放入备用链表就好了。 静态链表的初始化其实静态链表的初始化就是要做3件事： 头节点 备用链表头节点 备用链表 12345678910public void initList() &#123; for(int i=0; i&lt;SIZE; i++) &#123; // 这里初始化了备用链表的头节点与备用链表 // 原本我想的是将静态链表的头节点放在第一个位置，后来想了一下 // 放在最后一个位置会更简单一些，虽然放在第一个位置也能实现，但是就显得麻烦了 nodes[i].nextPos = i+1; &#125; // 这里初始化了静态链表的头节点 nodes[SIZE - 1].nextPos = 0;&#125; 其实就是将整个数组串起来，最后将头尾连起来，形成一个闭环。 这个闭环里面其实是有两条链表，一个备用链表，一个存放数据的链表。 上面的代码中，将数据链表一开始指向了 0 位置，其实一开始指不指向 0 无所谓，只要它后来指向第一个存放数据的位置就好了。 插入一个元素第一个插入的元素，肯定是存放在1位置的（因为备用链表初始化的时候，第一个节点是1位置），接下来插入的数据依次往后摆。 假设静态链表已经存放进去了一些数据，如下图所示： 要想插入一个数据，需要分为这几步： 拿出备用链表的头节点 H 更新备用链表的头节点 将 H 节点插入到数据链表中 我们先从备用链表里面拿到其头节点，代码如下： 123456789101112private int getStandByHeadNode() &#123; // 获取备用链表头节点的位置 int pos = table[0].nextPos; // 我们指定，备用链表的头节点为0，表示链表已经满了 if (pos != 0) &#123; // 更新备用链表的头节点 table[0].nextPos = table[pos].nextPos; &#125; return pos;&#125; 然后再插入数据，这里的插入数据与之前的不一样，因为我们储存了下一个节点的位置，所以我们只需要更新一下下一个节点的位置就好了： 1234567891011121314151617181920public void insertNode(int index, Object value) &#123; // 保证 index 在 0 与 数据链表的长度之间 checkIndex(index); int pos = getStandByHeadNode(); if (pos == 0) &#123; return; &#125; table[pos].value = value; // 寻找插入位置 int dataNextPos = SIZE - 1; for (int i = 0; i &lt; index; i++) &#123; dataNextPos = table[dataNextPos].nextPos; &#125; // 在第i个节点后面添加一个节点 table[pos].nextPos = table[dataNextPos].nextPos; table[dataNextPos].nextPos = pos;&#125; 插入后数据如下图： 删除一个元素同样的，先来理思路： 找到需要删除的元素 D 的前一个元素H（因为需要更改 H 元素的cur值） 将 H 的cur 值改为 D 的 cur 值 将 D 元素放入备用链表 代码如下： 1234567891011121314151617181920212223242526public void deleteNode(int index) &#123; // 保证链表长度大于1 checkLength(); // 保证 index 在 0 与 数据链表的长度之间 checkIndex(index); // 找到需要删除的节点的前一个节点 int dataNextPos = SIZE - 1; for (int i = 0; i &lt; index; i++) &#123; dataNextPos = table[dataNextPos].nextPos; &#125; // 前一个节点 Node p = table[dataNextPos]; // 需要删除的节点 Node d = table[p.nextPos]; // 删除节点 p.nextPos = d.nextPos; // 将 d 放入备用链表 d.nextPos = table[0].nextPos; table[0].nextPos = p.nextPos; // 释放节点空间 d.nextPos = 0; d.value = null;&#125; 静态链表的优缺点优点： 增删时只需要修改游标，不需要移动元素 缺点： 没有解决长度问题（长度无法确定，只能取一个估计值），失去了随机存储的特性]]></content>
      <categories>
        <category>大话数据结构</category>
      </categories>
      <tags>
        <tag>算法-大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0012-线程间通信]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0012-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程之间的通信通常是为了协调这些线程的工作。线程之间的通信会涉及到下面几个内容的东西： 通过共享对象通信 忙等待 wait、notify、notifyAll 丢失的信号 假唤醒 不要对常量以及全局对象调用 wait 通过共享对象通信这个是最容易想到的方法：创建一个对象，在这个对象里面存放一个标识，提供更新标识的方法。然后每个线程持有这个对象的引用，即可进行通信。 12345678910111213public class MySignal&#123; protected boolean hasDataToProcess = false; public synchronized boolean hasDataToProcess()&#123; return this.hasDataToProcess; &#125; public synchronized void setHasDataToProcess(boolean hasData)&#123; this.hasDataToProcess = hasData; &#125;&#125; 线程A和B获得指向同一个MySignal实例的引用，就可以进行通信。 忙等待由于线程运行的先后顺序不固定，所以我们需要保证B线程在 hasDataToProcess 的值变为 true 之前，一直等待，否则就会出错。 1234567protected MySignal sharedSignal = ......while(!sharedSignal.hasDataToProcess())&#123; //do nothing... busy waiting&#125; 于是，我们可以这样写，这种等待的方式就叫做忙等待。 ##wait、notify、notifyAll 忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。 Java 里面内置了3个方法允许线程在等待信号的时候变为非运行状态。 java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。 一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify： 123456789101112131415161718192021public class MonitorObject&#123;&#125;public class MyWaitNotify&#123; MonitorObject myMonitorObject = new MonitorObject(); public void doWait()&#123; synchronized(myMonitorObject)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; myMonitorObject.notify(); &#125; &#125;&#125; 当一个线程调用 notify 方法之后，将会从所有等待的线程中随机唤醒一个。 一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()，否则，会抛出IllegalMonitorStateException异常。 不知道你看到上面的话之后，有没有什么想法，如果你是刚接触这方面的内容的话，这里是有个说不通的地方的。 上面说，wait 必须要在同步代码块里面调用，那么它调用完之后，锁还是自己持有，别的线程也没法干啥啊 所以，为了不出现这种bug，wait方法会释放锁。 但是 notify 就不一样的，notify 不会释放锁，需要等待同步代码块执行完才会释放锁。一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。说白了，就是线程被唤醒之后，还需要等待一段时间（等notify的同步代码块执行完）才能退出 wait 方法。 如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。 ##丢失的信号 假如一个线程还没有进入 wait 方法，另一个线程就调用了 nofity 方法，那么就会导致这个线程错失了唤醒的机会。有些时候这没啥，但是在某些情况下，只会唤醒一次，这样这个线程就永远不会醒了。 为了避免这种情况，我们可以将信号保存起来： 123456789101112131415161718192021222324public class MyWaitNotify2&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; if(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 这样就不会错失信号了，即使信号在 wait 前发出来。 假唤醒由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups），无端端地醒过来了，这个是属于底层的问题。 如果上面的例子中出现了假唤醒，那么程序就会出问题，所以我们不能使用 if 判断，而是需要使用 while 来防止假唤醒： 123456789101112131415161718192021222324public class MyWaitNotify3&#123; MonitorObject myMonitorObject = new MonitorObject(); boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 将 wait 写在 while 循环体里面，这样即使发生了假唤醒，由于 wasSignalled 没有更新，所以它仍然会继续进入 wait 状态。 ##不要对常量以及全局对象调用 wait 看下面的例子： 123456789101112131415161718192021222324public class MyWaitNotify&#123; String myMonitorObject = ""; boolean wasSignalled = false; public void doWait()&#123; synchronized(myMonitorObject)&#123; while(!wasSignalled)&#123; try&#123; myMonitorObject.wait(); &#125; catch(InterruptedException e)&#123;...&#125; &#125; //clear signal and continue running. wasSignalled = false; &#125; &#125; public void doNotify()&#123; synchronized(myMonitorObject)&#123; wasSignalled = true; myMonitorObject.notify(); &#125; &#125;&#125; 这个例子的问题在于：JVM/编译器内部会把常量字符串转换成同一个对象。 这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。 那么，这会发生什么问题呢？ 首先，即使创建了多个MyWaitNotify实例，它们的锁都是同一把，导致不同实例上的所有的线程竞争同一个锁，这个问题我们就不说了。我们说另外一个问题。 假设，线程B调用了 notify 方法，本来应该是线程A被唤醒，但是由于多个实例使用了同一个锁，所有可能是线程C被唤醒，由于线程C检查了信号的状态，发现它没有被更新，所以对线程C来说，这相当于一次假唤醒。但是对于线程A来说，是信号丢失了。 有的同学说，可以使用 notifyAll 来解决这个问题，但是这对性能不好。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。 所以：在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0011-synchronized同步代码块]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0011-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[同步代码块就像一个锁一样，将代码给锁起来，线程需要执行同步块中的代码时需要先获取锁才能执行。一次只能有一个线程获得锁。Java中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在同一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。 有四种不同的同步块： 实例方法 静态方法 实例方法中的同步块 静态方法中的同步块 实例同步方法123public synchronized void add(int value)&#123; this.count += value;&#125; 这个方法是同步在这个方法所属的对象上的。如果有多个线程执行该对象的 add 方法，就会出现阻塞，只有获取了锁的线程才能执行。但是如果是执行的不同对象上的 add 方法，因为获取的是不同的锁，所以不会阻塞。 静态同步方法123public static synchronized void add(int value)&#123; this.count += value;&#125; 与实例同步方法一样。不过它同步的不是实例对象，而是类对象（XXX.class）。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。 实例方法中的同步块有时你不需要同步整个方法，而是同步方法中的一部分。 1234567public void add(int value)&#123; synchronized(this)&#123; this.count += value; &#125; &#125; 注意到，这里我们传递了this，说明同步代码块是作用在 this 这个对象上的，它的作用与实例同步方法一样。（在同步构造器中用括号括起来的对象叫做监视器对象） 我们出了传递 this，还可以传递别的对象，只要是你想让代码块作用在这个对象上就行。 静态方法中的同步块12345678910111213public class MyClass &#123; public static synchronized void log1(String msg1, String msg2)&#123; log.writeln(msg1); log.writeln(msg2); &#125; public static void log2(String msg1, String msg2)&#123; synchronized(MyClass.class)&#123; log.writeln(msg1); log.writeln(msg2); &#125; &#125;&#125; log2 与 log1 是等价的，当然静态方法中的同步块我们也可以传递别的类的 class。 示例在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。 1234567891011121314151617181920212223242526272829303132public class Counter&#123; long count = 0; public synchronized void add(long value)&#123; this.count += value; &#125;&#125;public class CounterThread extends Thread&#123; protected Counter counter = null; public CounterThread(Counter counter)&#123; this.counter = counter; &#125; public void run() &#123; for(int i=0; i&lt;10; i++)&#123; counter.add(i); &#125; &#125;&#125;public class Example &#123; public static void main(String[] args)&#123; Counter counter = new Counter(); Thread threadA = new CounterThread(counter); Thread threadB = new CounterThread(counter); threadA.start(); threadB.start(); &#125;&#125; 这里创建了两个线程。他们的构造器引用同一个Counter实例。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。 如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示： 123456789101112public class Example &#123; public static void main(String[] args)&#123; Counter counterA = new Counter(); Counter counterB = new Counter(); Thread threadA = new CounterThread(counterA); Thread threadB = new CounterThread(counterB); threadA.start(); threadB.start(); &#125;&#125; 注意这两个线程，threadA和threadB不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0010-内存模型]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0010-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在说内存模型之前，我们先来说下一CPU，对CPU有一定了解之后，再来说为何要有内存模型。CPU缓存一致性我们知道CPU是用来执行计算机指令的，而指令中包含的数据是从主存（内存）当中读取的，它将读取的数据放入自己的寄存器中，然后执行操作，这个是因为CPU在寄存器上执行操作的速度远大于在主存上执行的速度。 虽然CPU访问寄存器的速度很快，但是每次执行新的指令的时候，又要重新从主存中读取数据。那么这就会产生一个问题：随着CPU技术的发展，CPU的运行速度越来越快，而内存的技术没有啥太大的改变，这就导致了CPU与内存的运行速度差距越来越大。换成人类时间举个例子，一个主频2.6G的CPU执行一个指令只需要1s，它从内存读取数据大概需要4分钟（这还假设它没有触发缺页异常）。 可以看到如果CPU只能从内存中读取数据的话，那么CPU技术发展的再快也没有用。那么有没有什么办法解决呢？显然是有的，不然我们的个人计算机也不会发展的那么迅速了。 就是给CPU加一个高速缓存，这样由于局部性原理，CPU只需要将部分数据保存在高速缓存中，就可以极大的缓解数据读取慢的问题（从高速缓存中读取数据与执行指令的速度在同一个数量级）。于是CPU工作方式如下： 当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 现在的CPU有的还会有多级缓存：L1，L2，L3。工作方式与普通的缓存一样，L1中找不到找L2，L2中找不到找L3。但是每一级缓存的速度相差比较大，L1与L2的速度就不在同一个数量级。我们只需要知道CPU有一个高速缓存就好了。 高速缓存解决了数据访问慢的问题，但是引入了新的问题：每个CPU有自己的缓存，每个缓存中的数据都是主存中的一份拷贝。如果多个CPU都同时从主存中读取了一样的数据，都更改了这个数据，那么当CPU将缓存中的数据写回主存会发生什么呢？具体会发生啥我也不知道，反正肯定会乱成一锅粥就对了。这种问题叫做缓存一致性问题。 这里说一个小知识：我们经常说的 4核8线程是什么意思？ 4核显然是4个CPU核心，但是8线程是什么呢？难道一个CPU可以同时运行两个线程？ 8线程指的是通过超线程技术，用一个物理核模拟两个虚拟核，在CPU核心没有满负荷运载时，其剩余用量可以模拟成虚拟的核心。 除了缓存一致性问题，还有别的导致多CPU运算出错（不符合我们的预期）的问题。比如：CPU指令优化导致的问题。比如，一个32位的系统读取 double 与 long 值的时候会分两次读，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值。 内存模型为了保证共享内存的正确性，内存模型定义了共享内存系统中多线程程序读写操作行为的规范。主要是抽象出了3个概念：可见性、有序性、原子性。 这3个概念就是前人们总结出来的3个前置条件，我们要想在编写出一个符合期望的多线程程序，那么内存模型就需要提供一套解决方案来实现这3个条件。 Java内存模型Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。 Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问。 线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量。 工作内存中存储着主内存中的变量副本拷贝。 下面举几个例子来说明哪些变量储存在主内存，哪些变量储存在工作内存。注意不要把主内存，工作内存与堆栈搞混了。 原始类型的本地变量是储存在栈（在工作内存中）。 对象类型的本地变量储存在堆中（在主内存中），但是该类型的引用储存在栈中（在工作内存中）。 对象的成员变量（不管这个变量是基本类型还是对象类型）是放在堆中（在主内存中）。 static变量以及类本身相关信息将会存储在方法区（在主内存中）。 JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。 在上面的图中，Object3对象肯定不是在 methodOne() 中创建的，所以它们指向同一个对象。 Object1 与 Object5 才是在 methodTwo() 中创建的，所以每个线程都创建了自己的对象。 Java内存模型与实际内存的关系对于硬件内存来说只有寄存器、缓存内存、主内存的概念，并没有工作内存(线程私有数据区域)和主内存(堆内存)之分。 JMM只是一种抽象的概念，是一组规则，并不实际存在，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中或者CPU缓存或者寄存器中。 Java内存模型保证了原子性、可见性、有序性JMM主要是靠happens-before 原则，sychronized等同步锁， volatile 等关键字来保证原子性、可见性以及有序性。 下面是happens-before原则规则： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作； volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C； 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始； 这些东西读起来像是很理所当然的东西，但是却是并发编程的基石。就像高等数学学起来很费劲，1+1却是理所当然一样。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0009-线程安全及不可变性]]></title>
    <url>%2F2019%2F08%2F19%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0009-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%2F</url>
    <content type="text"><![CDATA[当一个以上的线程对同一个资源进行写操作的时候，就会产生竟态条件。多个线程同时读不会产生竟态条件。不可变对象如果我们让共享资源不可变的话，不提供修改方法，那就没有线程安全问题了。如下：1234567891011public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125;&#125; 这里我们只在构造函数里面传递值进去来实例化一个对象，该对象实例化完成之后，就无法更改里面的值了。所以这个对象是线程安全的，是不可变的。即不可变的对象是线程安全的。 需要区分“不可变”与“只读”。 一个变量只读，不代表这个变量不可变。 举一个例子：一个人的年龄是只读的，因为无法随便更改一个人的年龄，但是随着时间的变化，这个人的年龄是可以增加的，所以年龄这个变量是只读的，但是是可变的。一个人的出生年月是不可变的。 上面的不可变例子由于没有提供任何的修改方法，所以它是不可变的，但是需要用到这种不可变对象的需求毕竟非常少，如果有需要修改这个对象，那么有没有什么方法能保证线程安全呢？看看下面的例子： 123456789101112131415public class ImmutableValue&#123; private int value = 0; public ImmutableValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; public ImmutableValue add(int valueToAdd)&#123; return new ImmutableValue(this.value + valueToAdd); &#125;&#125; 我们给这个不可变对象提供了一个 add 方法，但是注意，我们返回了一个新的对象。这就是一种比较常用的方法，为了保证线程的安全性，我们通常不会改变原来的对象，而是创建一个新的对象并返回。 使用不可变对象不代表线程安全看下面这个例子： 123456789101112131415public void Calculator&#123; private ImmutableValue currentValue = null; public ImmutableValue getValue()&#123; return currentValue; &#125; public void setValue(ImmutableValue newValue)&#123; this.currentValue = newValue; &#125; public void add(int newValue)&#123; this.currentValue = this.currentValue.add(newValue); &#125;&#125; Calculator类持有一个指向ImmutableValue实例的引用。注意，通过setValue()方法和add()方法可能会改变这个引用。因此，即使Calculator类内部使用了一个不可变对象，但Calculator类本身还是可变的，因此Calculator类不是线程安全的。 换句话说：ImmutableValue类是线程安全的，但使用它的类不是。当尝试通过不可变性去获得线程安全时，这点是需要牢记的。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0008-线程安全与共享资源]]></title>
    <url>%2F2019%2F08%2F18%2Fblog_bak%2FBlog%2FJava%2F%E5%B9%B6%E5%8F%91%2F0008-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[我们知道竟态条件指的是多个线程访问共享资源需要依赖线程的执行顺序，说白了就是计算的结果依赖线程的执行顺序，线程顺序OK才能到正确的结果。一份代码到底是否线程安全，需要看它是否有共享资源。那么线程会共享哪些资源呢？通常，我们的资源一般都是 文件，数据库，图片等，或许还有其他的，但是不管他们都是什么，在Java里面都是用一个变量表示。即我们只需要分析代码里面有哪些共享变量就好了。 变量分为局部变量与成员变量。 局部变量局部变量存储在线程自己的栈中。 局部变量也有两种：基本类型与类类型。 基本类型基础类型的局部变量是线程安全的。下面是基础类型的局部变量的一个例子： 123456public void someMethod()&#123; long threadSafeInt = 0; threadSafeInt++;&#125; 类类型对象的局部引用与基本类型不一样。它虽然本身没有被共享，但引用所指的对象并没有存储在线程的栈内，而是在共享堆中。 其实，只要别的线程获取不到这个类类型，它也是线程安全的。 下面是一个线程安全的局部引用样例： 12345678910public void someMethod()&#123; LocalObject localObject = new LocalObject(); localObject.callMethod(); method2(localObject);&#125;public void method2(LocalObject localObject)&#123; localObject.setValue("value");&#125; 样例中LocalObject对象没有被方法返回，也没有被传递给someMethod()方法外的对象。 每个执行someMethod()的线程都会创建自己的LocalObject对象，并赋值给localObject引用。 因此，这里的LocalObject是线程安全的。事实上，整个someMethod()都是线程安全的。 即使将LocalObject作为参数传给同一个类的其它方法或其它类的方法时，它仍然是线程安全的。 当然，如果LocalObject通过某些方法被传给了别的线程，那它就不再是线程安全的了，但是它在 someMethod 这个方法中还是线程安全的。 成员变量对象成员存储在堆上。如果两个线程同时更新同一个对象的同一个成员，那这个代码就不是线程安全的。下面是一个样例： 1234567public class NotThreadSafe&#123; StringBuilder builder = new StringBuilder(); public add(String text)&#123; this.builder.append(text); &#125; &#125; 如果两个线程同时调用同一个NotThreadSafe实例上的add()方法，就会有竞态条件问题。例如： 12345678910111213141516NotThreadSafe sharedInstance = new NotThreadSafe();new Thread(new MyRunnable(sharedInstance)).start();new Thread(new MyRunnable(sharedInstance)).start();public class MyRunnable implements Runnable&#123; NotThreadSafe instance = null; public MyRunnable(NotThreadSafe instance)&#123; this.instance = instance; &#125; public void run()&#123; this.instance.add("some text"); &#125;&#125; 注意两个MyRunnable共享了同一个NotThreadSafe对象。因此，当它们调用add()方法时会造成竞态条件。 当然，如果这两个线程在不同的NotThreadSafe实例上调用call()方法，就不会导致竞态条件。下面是稍微修改后的例子： 12new Thread(new MyRunnable(new NotThreadSafe())).start();new Thread(new MyRunnable(new NotThreadSafe())).start(); 现在两个线程都有自己单独的NotThreadSafe对象，调用add()方法时就会互不干扰，再也不会有竞态条件问题了。所以非线程安全的对象仍可以通过某种方式来消除竞态条件。 线程控制逃逸规则根据我们上面所说的，如果我们把一个变量控制在线程之内，让别的线程无法访问，那么就不会有多线程问题了。 那么我们如何判断这个变量是否是被控制在线程之内的？下面就说一下判断规则。 12如果一个资源的创建，使用，销毁都在同一个线程内完成，且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。 即使对象本身线程安全，但如果该对象中包含其他资源（文件，数据库连接），整个应用也许就不再是线程安全的了。 比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的（这里其实就是违反了上面的规则–没有在线程内创建资源，我们只是持有了这个资源的引用）。比如，2个线程执行如下代码： 1检查记录X是否存在，如果不存在，插入X 如果两个线程同时执行，而且碰巧检查的是同一个记录，那么两个线程最终可能都插入了记录： 1234线程1检查记录X是否存在。检查结果：不存在线程2检查记录X是否存在。检查结果：不存在线程1插入记录X线程2插入记录X 同样的问题也会发生在文件或其他共享资源上。因此，区分某个线程控制的对象是资源本身，还是仅仅到某个资源的引用很重要。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java-并发</tag>
      </tags>
  </entry>
</search>
