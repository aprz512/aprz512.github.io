

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.svg">
  <link rel="icon" href="/img/logo.svg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="aprz512">
  <meta name="keywords" content="">
  
  <title>这学JNI，多是一件美事啊 - 二手程序员</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lyldalek.top","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"oWSVw2w2LW7MdhWmyHAsgyH6-MdYXbMMI","app_key":"FllNdPfQPCLcrJVVXHGyakPQ","server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>二手程序员</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" 
         style="background: url('/cover/top.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="这学JNI，多是一件美事啊">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-02 00:00" pubdate>
        2022年1月2日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      大约 
      29
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">这学JNI，多是一件美事啊</h1>
            
            <div class="markdown-body">
              <h3 id="JNI的定义"><a href="#JNI的定义" class="headerlink" title="JNI的定义"></a>JNI的定义</h3><p>JNI全称：Java Native Interface</p>
<p>它是Java本身的一种特性，用来在Java里面调用C/C++代码的。</p>
<p>看下面的一个程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    PrintStream ps = <span class="hljs-keyword">new</span> PrintStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;work&quot;</span>));<br>    System.setOut(ps);<br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序比较简单，就是将输出流重定向了一下。但是，我们看一下 System 这个类的 out 字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PrintStream out = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>

<p>这是一个 final 字段，那么 setOut 方法是如何改变这个 out 的值的呢？</p>
<p>是因为它调用了一个 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOut0</span><span class="hljs-params">(PrintStream out)</span></span>;<br></code></pre></td></tr></table></figure>

<p>在native层就可以绕过限制，改变一个final字段的值。</p>
<h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>下面，看一个native版的 hello world 的例子：</p>
<p>先写一个 java 类，里面调用一个 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> HelloWorld().print();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// String path = System.getProperty(&quot;java.library.path&quot;);</span><br>        <span class="hljs-comment">// System.out.println(path);</span><br>        System.loadLibrary(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>print 是一个 native 方法，它会输出 hello world。接下来我们实现这个 native 类。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Apache">/* <span class="hljs-attribute">DO</span> NOT EDIT THIS FILE - it is machine generated */<br><span class="hljs-comment">#include &lt;jni.h&gt;</span><br>/* <span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> for class HelloWorld */<br><br><span class="hljs-comment">#ifndef _Included_HelloWorld</span><br><span class="hljs-comment">#define _Included_HelloWorld</span><br><span class="hljs-comment">#ifdef __cplusplus</span><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-comment">#endif</span><br>/*<br> * <span class="hljs-attribute">Class</span>:     HelloWorld<br> * <span class="hljs-attribute">Method</span>:    print<br> * <span class="hljs-attribute">Signature</span>: ()V<br> */<br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL Java_HelloWorld_print<br>  (<span class="hljs-attribute">JNIEnv</span> *, jobject);<br><br><span class="hljs-comment">#ifdef __cplusplus</span><br>&#125;<br><span class="hljs-comment">#endif</span><br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure>

<p>这个文件是使用javah -jni生成的。 </p>
<p>头文件里面定义了一个方法，只不过这个方法的名称有点奇特，其实就是由对应的 java 方法的包名+方法名组成。不过如果涉及到特殊字符或者重载，还会有更多变化，具体的可以看 JNI 规范文档。</p>
<p>先忽略JNIEXPORT和JNICALL宏。你可能有注意到本地方法的C实现接受两个参数。但是HelloWorld.java中定义的 print 方法却没有接受任何参数。</p>
<p>每一个本地方法实现的第一个参数是一个JNIEnv接口指针。第二个参数是HelloWorld对象本身，类似于this指针。如果是一个静态方法，那么第二个参数是类对象本身，类似 Class 对象。</p>
<p>extern “C” {} 的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按c语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
<p>JNIECXPORT 的作用是将函数导出，可以被其他库调用。</p>
<p>JNICALL 的作用暂时不清楚，linux 平台似乎是空定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JNIEXPORT  __attribute__ ((visibility (<span class="hljs-meta-string">&quot;default&quot;</span>)))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> JNICALL</span><br></code></pre></td></tr></table></figure>



<p>接下来，我们来实现上面的这个方法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-comment">#include &lt;jni.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &quot;HelloWorld.h&quot;</span><br><br><br>// <span class="hljs-attribute">mac</span> 上 loadLibary 方法会找以 .dylib 或者 .jnilib 结尾的库<br>// 编译命令  <span class="hljs-attribute">cc</span> -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -I. -fPIC -shared HelloWorld.c -o libHelloWorld.dylib<br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL Java_HelloWorld_print<br>  (<span class="hljs-attribute">JNIEnv</span> *env, jobject obj)<br>&#123;<br>    <span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-attribute">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现非常的简单，就是调用了一下 printf 方法，输出了 hello world。</p>
<p>再下面，就是生成 so 文件，不过需要注意的是，不同的平台，System.loadLibrary 方法加载的库文件的规则不一样。在 mac 上默认加载以 .dylib 或者 .jnilib 结尾的库，所以如果你生成了一个 libHelloWorld.so 的文件，是加载不了的，除非使用 load 方法加载绝对路径。</p>
<p>编译命令： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">cc -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin -I. -fPIC -shared HelloWorld.c -o libHelloWorld.dylib<br></code></pre></td></tr></table></figure>

<p>然后使用 javac 生成 class 文件，最后运行 class 文件，就能输出 hello world 了！！！</p>
<h3 id="JavaVM-JNIEnv"><a href="#JavaVM-JNIEnv" class="headerlink" title="JavaVM / JNIEnv"></a>JavaVM / JNIEnv</h3><p>一个JNIEnv指针仅在其相关联的线程中有效。不能将这个指针从一个线程中传递给另一个线程，或者在多线程中缓存和使用它。</p>
<p>Java虚拟机在同一个线程传递给本地方法相同的JNIEnv指针，但是从不同线程中调用本地方法时传递的是不同的JNIEnv指针。但是这些JNIEnv 指针的方法都是同一份。</p>
<p>获取 JNIEnv 有几种方式：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">JNIEnv</span> *env;<br>(*<span class="hljs-attribute">jvm</span>)-&gt;AttachCurrentThread(jvm, (void **)&amp;env, NULL); <br><br><br>(*<span class="hljs-attribute">jvm</span>)-&gt;GetEnv((void **) env, JNI_VERSION_<span class="hljs-number">1</span>_<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure>

<p>写到这一节的时候，多少有点随意，因为这一节的知识大家都知道，但是突然想了一下，为啥JNIEnv无法被线程共享呢？暂时没有找到阐述的很清楚的文章，翻了源码也没有思路，猜测一下，可能JNIEnv 的某些变量就是放在线程相关的缓冲区中的。不深究了。</p>
<h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><p>上面花了一节来写一个demo，其实主要是想说 JNI 是java的东西，跟 android 关系不大，刚开始接触android的时候，我一直是将JNI当作android的特性来理解的，而且我看了一些 java 相关的书籍中，似乎都没有介绍 JNI 相关的。</p>
<p>我理解的 NDK 是google官方实现了很多API，提供给开发者来使用，只不过是通过JNI来实现的。</p>
<h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_Prompt_getLine</span><span class="hljs-params">(JNIEnv *env, jobject obj, jstring prompt)</span> </span>&#123;<br>    <span class="hljs-comment">/* ERROR: incorrect use of jstring as a char* pointer */</span> <br>    printf(<span class="hljs-string">&quot;%s&quot;</span>, prompt); <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当从 java 层传递一个字符串过来之后，它的类型是 jstring。完整的类型映射表如下：</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMyMWM1MDU3ODBlOWJmOTVhOGM3OWQwMWQ1NzVjZTNfdUxvdFRZYkZKakdLd21OMXlTQTFiV2VTdkdmWTA3TGtfVG9rZW46Ym94Y251amVyVmdGaHdQazF5S2dZOHdZNkpoXzE2NDExMzYwODY6MTY0MTEzOTY4Nl9WNA" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果，我们想打印一下这个字符串，那么可以使用 GetStringUTFChars 这个函数，它会返回一个 const char * 类型（编码是 MUTF 类型，具体看参考文档 JNI TIPS），我们就可以使用 printf 来打印它了。为啥要是 const 的呢？是因为java中的string是不可变的，不允许更改。</p>
<p>还有一个 GetStringChars 函数，它返回 jchar* 类型，我们不能直接打印。Java 中的字符都是 Unicode 编码，显然这个 jchar * 指向的是 unicode 编码的字符串。</p>
<p>有一个需要注意的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> x ;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *chars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(hello, &amp;x);<br><br><span class="hljs-keyword">if</span>(x)<br></code></pre></td></tr></table></figure>

<p>我们经常会用到这个方法，但是第二个参数经常会让我疑惑，查了一些文档后，终于弄明白了：</p>
<p>这个方法会返回字符串的utf形式，由于虚拟机内部以及本地内存的一些原因，在调用这个方法的时候，有可能会将字符串拷贝一遍。如果返回的字符串是原来的 java.lang.String 的一份拷贝， 在方法返回之后，isCopy指向的内存地址将会被设置为JNI_TRUE。而如果返回的字符串指针直接指向原来的java.lang.String对象，则该地址会被设置为JNI_FALSE。如果返回了JNI_FALSE, 则原生代码将不能改变返回的字符串，因为改变了这个字符串，原来的java字符串也会被修改，这违背了java.lang.String实例不可改变的原则。通常你可以直接传递NULL给isCopy来告诉Java虚拟机你不在乎返回的字符串是否拷贝了。</p>
<p>同样的，基于上面的原因，在调用完这个方法之后，就需要调用一个对应的ReleaseStringUTFChars 方法，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">str = (*env)-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(env, prompt, <span class="hljs-literal">NULL</span>);<br>(*env)-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(env, prompt, str);<br></code></pre></td></tr></table></figure>

<p>否则会造成内存泄漏。</p>
<p>ReleaseStringUTFChars 的实现比较有意思：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReleaseStringUTFChars</span><span class="hljs-params">(JNIEnv*, jstring, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* chars)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span>[] chars;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看 GetStringUTFChars 的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">GetStringUTFChars</span><span class="hljs-params">(JNIEnv* env, jstring java_string, jboolean* is_copy)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (java_string == <span class="hljs-literal">nullptr</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span> (is_copy != <span class="hljs-literal">nullptr</span>) &#123;<br>     *is_copy = JNI_TRUE;<br>   &#125;<br><br>   <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>   ObjPtr&lt;mirror::String&gt; s = soa.Decode&lt;mirror::String&gt;(java_string);<br>   <span class="hljs-keyword">size_t</span> length = s-&gt;<span class="hljs-built_in">GetLength</span>();<br>   <span class="hljs-keyword">size_t</span> byte_count =<br>       s-&gt;<span class="hljs-built_in">IsCompressed</span>() ? length : <span class="hljs-built_in">GetUncompressedStringUTFLength</span>(s-&gt;<span class="hljs-built_in">GetValue</span>(), length);<br>   <span class="hljs-keyword">char</span>* bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[byte_count + <span class="hljs-number">1</span>];<br>   <span class="hljs-built_in">CHECK</span>(bytes != <span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// bionic aborts anyway.</span><br>   <span class="hljs-keyword">if</span> (s-&gt;<span class="hljs-built_in">IsCompressed</span>()) &#123;<br>     <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* src = s-&gt;<span class="hljs-built_in">GetValueCompressed</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; byte_count; ++i) &#123;<br>       bytes[i] = src[i];<br>     &#125;<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">char</span>* end = <span class="hljs-built_in">GetUncompressedStringUTFChars</span>(s-&gt;<span class="hljs-built_in">GetValue</span>(), length, bytes);<br>     <span class="hljs-built_in">DCHECK_EQ</span>(byte_count, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">size_t</span>&gt;(end - bytes));<br>   &#125;<br>   bytes[byte_count] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>   <span class="hljs-keyword">return</span> bytes;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>看第6行，是必定会执行拷贝的，所以 JNI 在 ART里面的实现，是一定会拷贝。</p>
<p>对于字符串的创建还有一对函数：NewStringUTF/NewString ，这个是类似的，不说了，看文档吧。</p>
<p>还有一点要提一下，Get/ReleaseStringCritical 这对函数我没有用过，但是有了 Get/ReleaseStringChars  为啥还要这对玩意呢？而且这对函数使用起来条件比较苛刻，他们之间的本地代码不能调用会引起阻塞的方法以及创建新对象，否则虚拟机可能会引起死锁。</p>
<p><img src="https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY1MjBiZDAxN2I4YzAwZjhlNGVmMDMwNWMzNmMwMzdfbWVpZFVVdGNMdEhYVnQ5QjJqM1J0Nmt3V2U0SkZiVTZfVG9rZW46Ym94Y25VTmZBWE1sdFhLNnZTNk55R0gzbTBnXzE2NDExMzYwODY6MTY0MTEzOTY4Nl9WNA" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>根据上面的文档，只能猜测他们的性能要稍微好点？？</p>
<h3 id="JNI-访问-java-字段与方法"><a href="#JNI-访问-java-字段与方法" class="headerlink" title="JNI 访问 java 字段与方法"></a>JNI 访问 java 字段与方法</h3><p>JNIEnv  提供了一个 FindClass 方法来寻找某一个类，这个里面的逻辑其实就是 ClassLoader 的逻辑。</p>
<p>这一套方法有点像 Java 里面的反射的使用方式。</p>
<p>上面拿到的是 jclass 对象，按照反射的逻辑，我们接下来就该获取对应的字段或者方法了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">jmethodID mid;<br>jclass runnableIntf =(*env)-&gt;FindClass(env, <span class="hljs-string">&quot;java/lang/Runnable&quot;</span>); <br>mid = (*env)-&gt;GetMethodID(env, runnableIntf, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <br></code></pre></td></tr></table></figure>

<p>GetMethodID 的第3个参数需要解释一下，看例子：</p>
<p>“(I)V”表明该方法有一个类型为int的参数并且返回类型为void。</p>
<p>“()D”表明该方法不需要参数并且返回一个double值。</p>
<p>调用静态方法，使用 GetStaticMethod ID。</p>
<p>访问字段/构造方法也是类似的，一看就懂。</p>
<p>那么这里就有一个问题，既然，能使用构造方法，来为啥不直接用 String 的构造方法来创建字符串，而是要为 String 创建专门的使用函数呢？</p>
<p>答案还是因为性能问题，字符串是编程语言中使用最频繁的了，必须得特别支持。</p>
<p>由于，FindClass/GetMethodID/GetFieldID 这些都会有性能问题，所以有一个小技巧就是将这些结果缓存起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">jmethodID MID_InstanceMethodCall_callback; <br><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_InstanceMethodCall_initIDs</span><span class="hljs-params">(JNIEnv *env, jclass cls)</span> </span>&#123;<br>    MID_InstanceMethodCall_callback = (*env)-&gt;GetMethodID(env, cls, <span class="hljs-string">&quot;callback&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>后面，直接使用缓存的字段就好了。</p>
<p>使用JNI访问字段和调用方法的性能特性如何？</p>
<p>一个典型的虚拟机实现执行Java/native调用比执行Java/Java调用大概慢两到三倍。</p>
<p>有了 method id 与 field id 就可以尝试访问方法与字段了，常用的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">CallVoidMethod<br>CallVoidMethodV<br>CallVoidMethodA<br></code></pre></td></tr></table></figure>

<p>那这3个方法有啥区别呢？</p>
<p>从文档上看不出来什么东西，但是从源码里面可以看出来，前面两个内部调用的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">InvokeVirtualOrInterfaceWithVarArgs<br></code></pre></td></tr></table></figure>

<p>后面一个内部调用的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">InvokeVirtualOrInterfaceWithJValues<br></code></pre></td></tr></table></figure>

<p>那这两个内部又有啥区别呢？</p>
<p>这要说到两种类型，一种是 va_list，一种是 jvalue。va_list 就是可变长参数，我们使用 va_arg(变长参数, 类型)，就可以取出参数的值。jvalue 是一个联合类型，它里面储存的是真正的参数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">jvalue</span> &#123;</span><br>    jboolean    z;<br>    jbyte       b;<br>    jchar       c;<br>    jshort      s;<br>    jint        i;<br>    jlong       j;<br>    jfloat      f;<br>    jdouble     d;<br>    jobject     l;<br>&#125; jvalue;<br></code></pre></td></tr></table></figure>

<p>其实，<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/reflection.h;drc=master;l=94">InvokeVirtualOrInterfaceWithVarArgs</a> 这个方法内部是将可变参数一个一个的取出来，然后转为 jvalue 类型，再处理，可以理解为上面的两个方法殊途同归。所以，最终的参数都是 jvalue 类型。但是使用起来还是 CallVoidMethod 最方便，它只需要我们传递 java 对应的类型就好了，比如需要一个 String，我们就传递一个 jstring。</p>
<h3 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h3><p>上面说到，将计算出来的 class/method/field 缓存起来可以提高运行性能，但是有一点需要注意。</p>
<p>FindClass 返回的是一个局部引用，而局部引用在函数返回后会被JVM自动回收。</p>
<p>查了一些资料以及经过自己的测试，发现 FindClass 返回的是局部引用，GetMethodID/GetFieldID 返回的是弱全局引用。</p>
<p>我写了这样的一个Demo：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jclass</span> cache_class;<br><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL<br><span class="hljs-attribute">Java_com_aprz_mytestdemo_jni_RefActivity_cache</span>(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">if</span> (cache_class == nullptr) &#123;<br>        <span class="hljs-attribute">cache_class</span> = env-&gt;FindClass(<span class="hljs-string">&quot;com/aprz/mytestdemo/jni/RefActivity&quot;</span>);<br>    &#125;<br>    <span class="hljs-attribute">LOGE</span>(<span class="hljs-string">&quot;cache_class = %p&quot;</span>, cache_class);<br>    <span class="hljs-attribute">jmethodID</span> just_print = env-&gt;GetMethodID(cache_class, <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-attribute">if</span> (just_print) &#123;<br>        <span class="hljs-attribute">env</span>-&gt;CallVoidMethodA(thiz, just_print, &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码想缓存一个 RefActivity 的引用以便后续使用，但是却有一个逻辑问题，cache_class 它是一个指针，第一次被赋值后，指向 RefActivity 的 class 的一个局部引用，这个引用在方法结束之后会被回收，但是 cache_class 的值仍然指向那个局部引用的地址（地址里面没有东西了），所以导致 cache_class 成了一个野指针。</p>
<p>该方法第一次执行时没有问题，第二次执行时就会报错：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">36.466</span> <span class="hljs-number">6683</span><span class="hljs-literal">-6683</span>/? A/DEBUG: signal <span class="hljs-number">6</span> (SIGABRT), code <span class="hljs-literal">-1</span> (SI_QUEUE), fault addr --------<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">36.466</span> <span class="hljs-number">6683</span><span class="hljs-literal">-6683</span>/? A/DEBUG: Abort message: <span class="hljs-string">&#x27;JNI DETECTED ERROR IN APPLICATION: use of deleted local reference 0x75</span><br><span class="hljs-string">        from void com.aprz.mytestdemo.jni.RefActivity.cache()&#x27;</span><br></code></pre></td></tr></table></figure>

<p>同样的方式缓存 method id ：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jmethodID</span> cache_method_id;<br><br><span class="hljs-attribute">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-attribute">JNIEXPORT</span> void JNICALL<br><span class="hljs-attribute">Java_com_aprz_mytestdemo_jni_RefActivity_cacheMethod</span>(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">if</span> (cache_method_id == nullptr) &#123;<br>        <span class="hljs-attribute">cache_method_id</span> = env-&gt;GetMethodID(env-&gt;GetObjectClass(thiz), <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    &#125;<br>    <span class="hljs-attribute">if</span> (cache_method_id) &#123;<br>        <span class="hljs-attribute">env</span>-&gt;CallVoidMethodA(thiz, cache_method_id, &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于 GetMethodID 返回的是弱全局引用，那么只要有别的地方引用它，它就不会被回收，所以这样使用没有问题。多次运行是ok的。</p>
<p>还有一个问题，JNIEnv 提供了一个 DeleteLocalRef 方法用来删除局部引用，那么就有人要问了，既然局部引用在方法执行完之后会被回收，为啥还要提供这个方法，让它自己会被回收不香吗？</p>
<p>是基于两个原因，第一个是在某些版本的 android 里面，JNI的局部引用表是有限制的，比如 512。既然有限制，那么就有可能超过这个限制，比如，你方法里面有循环，又比如，你写了一个调用链巨长的方法。所以，我们应该在以下这些情况主动删除局部引用：</p>
<ol>
<li><p>本地代码遍历一个特别大的字符串数组，每遍历一个元素，都会创建一个局部引用，当对使用完这个元素的局部引用时，就应该马上手动释放它。</p>
</li>
<li><p>局部引用会阻止所引用的对象被 GC 回收。比如你写的一个本地函数中刚开始需要访问一个大对象，因此一开始就创建了一个对这个对象的引用，但在函数返回前会有一个大量的非常复杂的计算过程，而在这个计算过程当中是不需要前面创建的那个大对象的引用的。但是，在计算的过程当中，如果这个大对象的引用还没有被释放的话，会阻止 GC 回收这个对象，内存一直占用着，造成资源的浪费。所以这种情况下，在进行复杂计算之前就应该把引用给释放了，以免不必要的资源浪费。</p>
</li>
<li><p>编写工具函数时，要当心不要在函数的调用轨迹上遗漏任何的局部引用，因为工具函数被调用的场合和次数是不确定的，一量被大量调用，就很有可能造成内存溢出。</p>
</li>
</ol>
<p>反正，核心就是，能够删除的就立即删除。</p>
<p>比如，我写了一个工具方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tools</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>    jmethodID x = env-&gt;GetMethodID(env-&gt;GetObjectClass(thiz), <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它泄漏了一个局部引用，当我在一个 while(true) 里面调用这个方法的时候，就会报错：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>] JNI ERROR (app bug): local reference table overflow (max=<span class="hljs-number">8388608</span>)<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>] local reference table dump:<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]   Last <span class="hljs-number">10</span> entries (of <span class="hljs-number">8388608</span>):<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388607</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388606</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br><span class="hljs-number">2021</span><span class="hljs-literal">-12</span><span class="hljs-literal">-21</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">13.373</span> <span class="hljs-number">10249</span><span class="hljs-literal">-10249</span>/com.aprz.mytestdemo A/aprz.mytestdem: jni_env_ext<span class="hljs-literal">-inl</span>.h:<span class="hljs-number">32</span>]     <span class="hljs-number">8388605</span>: <span class="hljs-number">0</span>x1387b518 java.lang.Class&lt;com.aprz.mytestdemo.jni.RefActivity&gt;<br></code></pre></td></tr></table></figure>

<p>错误提示很明显，是局部引用表溢出了，800多万个，几秒就耗光了！！下面有表里面储存的对象的 dump，全是 RefActivity 的 class 对象，看我们上面的代码，是 env-&gt;GetObjectClass(thiz) 这行代码有问题，它返回了一个局部引用，每次调用这个方法，都会累加一次。所以造成溢出，应该将它删除。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">void</span> tools(JNIEnv *env, jobject thiz) &#123;<br>    <span class="hljs-attribute">jclass</span> tmp_class = env-&gt;GetObjectClass(thiz);<br>    <span class="hljs-attribute">jmethodID</span> tmp_method = env-&gt;GetMethodID(tmp_class, <span class="hljs-string">&quot;justPrint&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-attribute">env</span>-&gt;DeleteLocalRef(tmp_class);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样写就没问题了，注意，tmp_method 不能 delete，会报错，突然发现好像也没有一个文档来说明那些应该删除，那些不能删除。</p>
<p>上面的这个例子有一点没能想通，就是 GetObjectClass 返回的是一个局部引用，循环体里面的方法执行完之后就释放了才对，为啥还会导致引用溢出，猜测与编译器优化，变量分配有关。</p>
<p>看了一下 android 11 的源码，local table 的大小为 512，上面测试的手机是我刷的android10的镜像，不知道为啥这么大。看注释可知，是故意设置这么小的，强制开发者注意随时释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Number of local references in the indirect reference table. </span><br><span class="hljs-comment">// The value is arbitrary but low enough that it forces sanity checks.</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> kLocalsInitial = <span class="hljs-number">512</span>;<br></code></pre></td></tr></table></figure>



<p>同样的，全局引用与弱全局引用也有对应的删除方法：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">env</span>-&gt;DeleteGlobalRef()<br><span class="hljs-attribute">env</span>-&gt;DeleteWeakGlobalRef()<br></code></pre></td></tr></table></figure>



<p>还有一个知识点是引用的比较：给定两个引用（不管是全局、局部还是弱全局引用），我们只需要调用 IsSameObject 来判断它们两个是否指向相同的对象。</p>
<p>例如：<code>（*``env``)-&gt;IsSameObject(env, obj1, obj2)</code></p>
<p>如果 obj1 和 obj2 指向相同的对象，则返回 JNI_TRUE（或者 1），否则返回 JNI_FALSE（或者 0）。这个方法还可以用于空指针的比较。如果 obj 是一个局部或全局引用，可以用来判断 obj 是否指向一个 null 对象。但需要注意的是，如果比较的是弱全局引用，那么true表示的是该引用被回收了。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>当JNI调用 java 方法时，java 方法有可能会出现异常，那么我们需要做对应的处理，因为出了异常之后，不像在 java 里面，后面的流程会中断，而是会继续执行，看下面的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_aprz_mytestdemo_jni_ExceptionActivity_toNative</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>    jclass exception_activity_class = env-&gt;GetObjectClass(thiz);<br>    jmethodID do_something_method_id = env-&gt;GetMethodID(exception_activity_class, <span class="hljs-string">&quot;doSomething&quot;</span>,<br>                                                        <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-keyword">if</span> (do_something_method_id) &#123;<br>        <span class="hljs-comment">// 这里出了异常</span><br>        env-&gt;CallVoidMethod(thiz, do_something_method_id);<br>    &#125;<br><br>    LOGE(<span class="hljs-string">&quot;i will print even exception occurred!!!!&quot;</span>);<br><br>    env-&gt;DeleteLocalRef(exception_activity_class);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>doSomething 是一个 java 方法，它会抛出一个空指针异常。按照我们对 java 的理解，LOGE 这行代码应该执行不到才对，但是实际上它打印出来了。所以我们需要一种手段来检测异常是否出现，从而做对应的处理。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">exc</span> = (*env)-&gt;ExceptionOccurred(env); <br><span class="hljs-attribute">if</span> (exc) &#123;<br>    (*<span class="hljs-attribute">env</span>)-&gt;ExceptionDescribe(env); <br>    (*<span class="hljs-attribute">env</span>)-&gt;ExceptionClear(env); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>ExceptionOccurred会检测到这个异常。</p>
<p>ExceptionDescribe会输出一个关于这个异常的描述性信息。</p>
<p>ExceptionClear方法清除这个异常。</p>
<p>还有一个 ExceptionCheck 方法，它的功能与 ExceptionOccurred 类似，但是它不会产生一个局部引用，所以使用起来比较方便。</p>
<p>异常检查的代码写起来很麻烦，但是确实是必要的，特别是你申请了资源的时候，出了异常必须要释放才行。</p>
<h3 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h3><p>当 Sytem.loadlibrary 加载一个 so 的时候，虚拟机会找到该 so 中的 JNI_OnLoad 方法，并调用它。</p>
<p>简单的追一下调用链：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell">java.lang.System<span class="hljs-comment">#loadLibrary</span><br>java.lang.Runtime<span class="hljs-comment">#nativeLoad(java.lang.String, java.lang.ClassLoader, java.lang.Class&lt;?&gt;)</span><br>// 下面的是 android<span class="hljs-literal">-11</span>.<span class="hljs-number">0.0</span>—r3 代码<br>Runtime_nativeLoad  -&gt;<br>JVM_NativeLoad -&gt;<br>JavaVMExt::LoadNativeLibrary<br></code></pre></td></tr></table></figure>

<p>LoadNativeLibrary 这个方法里面做了两件非常重要的事情：</p>
<ol>
<li><p>void* <strong><a target="_blank" rel="noopener" href="http://source.bytedance.net/android/s?refs=handle&project=android-11.0.0_r3">handle</a></strong> = <a target="_blank" rel="noopener" href="http://source.bytedance.net/android/s?defs=android&project=android-11.0.0_r3">android</a>::<a target="_blank" rel="noopener" href="http://source.bytedance.net/android/s?defs=OpenNativeLibrary&project=android-11.0.0_r3">OpenNativeLibrary</a></p>
<ol>
<li><p> 将 so 加载进来，使用的是 android_dlopen_ext 方法。</p>
</li>
<li><p> 创建一个 SharedLibrary 对象：new  SharedLibrary(…, handle, …)</p>
</li>
</ol>
</li>
<li><p>找到 JNI_OnLoad 函数的地址，执行这个函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">void</span>* sym = library-&gt;<span class="hljs-built_in">FindSymbol</span>(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, <span class="hljs-literal">nullptr</span>);<br>...<br><span class="hljs-keyword">using</span> JNI_OnLoadFn = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(JavaVM*, <span class="hljs-keyword">void</span>*);<br>JNI_OnLoadFn jni_on_load = <span class="hljs-keyword">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);<br><span class="hljs-keyword">int</span> version = (*jni_on_load)(<span class="hljs-keyword">this</span>, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure>

<p>从这里，我们可以看出，该方法的第二个参数没什么卵用，是用来兼容以后的版本的。</p>
<p>JNI 提供了注册函数的两种方式，一种是静态注册，就是我们第一个例子使用的方式，第二种是动态注册（RegisterNatives），动态注册的时机通常就是在 JNI_OnLoad 中，动态注册相比较于静态注册的好处就是可以批量注册，而且还不会暴露出注册的函数。</p>
<p>看了一下源码流程，其实静态注册也是走的动态注册的流程。当一个类被加载的时候，会去设置</p>
<h3 id="C、C-使用-JNIEnv-的不同之处"><a href="#C、C-使用-JNIEnv-的不同之处" class="headerlink" title="C、C++ 使用 JNIEnv 的不同之处"></a>C、C++ 使用 JNIEnv 的不同之处</h3><p>c 中的 JNIEnv：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">typedef</span> const struct JNINativeInterface* JNIEnv;<br></code></pre></td></tr></table></figure>

<p>env 是一个 JNINativeInterface** c++ 中的 JNIEnv：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> _JNIEnv JNIEnv;<br></code></pre></td></tr></table></figure>

<p>_JNIEnv 又是 const struct JNINativeInterface* functions; 所以 env 是一个 JNINativeInterface** 类型都是一样的，但是使用方式不一样，是因为 JNINativeInterface 对C++做了封装。 看下面一段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">JNIEnv</span> &#123;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">JNINativeInterface</span>* <span class="hljs-title">functions</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__cplusplus)</span><br><br><span class="hljs-function">jint <span class="hljs-title">GetVersion</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> functions-&gt;<span class="hljs-built_in">GetVersion</span>(<span class="hljs-keyword">this</span>); &#125;<br></code></pre></td></tr></table></figure>

<p>_JNIEnv 除了直接引用了 JNINativeInterface* 之外，还将里面的接口重新定义了一遍，然后将 this 参数替我们传递了。</p>
<p>所以在cpp文件里面，使用 env 非常简单，而在 c 文件里面使用 env 比较麻烦。</p>
<h3 id="FindClass-GetMethodID-CallVoidMethod-内部逻辑"><a href="#FindClass-GetMethodID-CallVoidMethod-内部逻辑" class="headerlink" title="FindClass / GetMethodID / CallVoidMethod 内部逻辑"></a>FindClass / GetMethodID / CallVoidMethod 内部逻辑</h3><p>首先说 FindClass 的逻辑，这是看的 <a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/39533503">Android运行时ART加载类和方法的过程分析</a> 这篇文章，是分析的 4.4 的代码，很老了，但是大致逻辑应该差不过，理解了这个，可以再去看最新的代码。</p>
<p>上面提到过，FindClass 走的也是 classLoader 加载类的流程，我们知道，每个 classLoader 都会指定 path 用来加载 dex 文件，那么有了类的描述符之后，就会挨个的去找，从而获取对应的 DexFile 文件。如果 classLoader 为 null 的话，就会去系统启动路径去找。</p>
<p>找到 DexFile 之后，会创建一个 kclass 对象，就是 native 层的 Class。然后设置各种信息：类索引号，静态成员变量和实例成员变量，函数索引号等。</p>
<p>创建 class 的时候，会加载类的各个成员，比如类方法，这个时候，就会创建 ArtField 与 ArtMethod 等。对于 ArtMethod，会去 LinkCode，这个顾名思义，就是链接该方法对应的指令了。如果这个方法是一个 native 方法，就会去注册这个方法，就像动态注册一样，其实就是设置了  <a target="_blank" rel="noopener" href="http://source.bytedance.net/android/s?defs=entry_point_from_jni_&project=android-5.0.1_r1">entry_point_from_jni_</a> 的值，只不过它设置的是一个 stub，等到真正调用的时候才会去 dlsym  查询 so 的函数地址，然后替换成真的，这种模式很常用。</p>
<p>所以，FindClass 其实就是加载了一个类，创建了对应 Class 对象，以及为每个类方法创建了 “Stub” 对象，方法真正被调用的时候才会创建真的。</p>
<p>那么 GetMethodID 的逻辑就更简单了，该方法需要一个 jclass 参数，而这个参数其实就是 Class 对象的一个指针，所以我们只需要拿到 Class 对象里面 ArtMethod 数组，一个一个对比就好了，不过有点麻烦的是，要考虑接口，父类等问题。</p>
<p>CallVoidMethod 的逻辑其实也不难，但是需要对 ArtMethod 的结构有一定的了解，我们看下面：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">class</span> ArtMethod &#123;<br>…………<br><span class="hljs-attribute">protect</span>:<br><span class="hljs-attribute">HeapReference</span> declaring_class_;<br><span class="hljs-attribute">HeapReference</span>&gt; dex_cache_resolved_methods_;<br><span class="hljs-attribute">HeapReference</span>&gt; dex_cache_resolved_types_;<br><span class="hljs-attribute">uint32_t</span> access_flags_;<br><span class="hljs-attribute">uint32_t</span> dex_code_item_offset_;<br><span class="hljs-attribute">uint32_t</span> dex_method_index_;<br><span class="hljs-attribute">uint32_t</span> method_index_;<br><span class="hljs-attribute">struct</span> PACKED(<span class="hljs-number">4</span>) PtrSizedFields &#123;<br><span class="hljs-attribute">void</span>* entry_point_from_interpreter_;<br><span class="hljs-attribute">void</span>* entry_point_from_jni_;<br><span class="hljs-attribute">void</span>* entry_point_from_quick_compiled_code_;<br><span class="hljs-comment">#if defined(ART_USE_PORTABLE_COMPILER)</span><br><span class="hljs-attribute">void</span>* entry_point_from_portable_compiled_code_;<br><span class="hljs-comment">#endif</span><br>&#125; <span class="hljs-attribute">ptr_sized_fields_</span>;<br><span class="hljs-attribute">static</span> GcRoot java_lang_reflect_ArtMethod_;<br>｝<br>……<br></code></pre></td></tr></table></figure>

<p>这是 5.0 的代码，这个时候，还存在entry_point_from_jni_，entry_point_from_interpreter_ 这些字段，这些字段其实就是方法的指令入口地址：</p>
<p>entry_point_from_jni_ ：如果该方法是一个 native 方法，那么这个地址就是加载进来的 so 中的方法的地址。</p>
<p>entry_point_from_interpreter_：这个是使用解释器执行时，指令的地址。</p>
<p>entry_point_from_quick_compiled_code_：这个是非解释器执行时的指令地址（就是 aot 模式）。</p>
<p>还有一个 entry_point_from_portable_compiled_code_，这个似乎没有打开过。它与 entry_point_from_quick_compiled_code_ 类似，只不过是这两种模式生成的 oat 文件不一样，</p>
<p>通过Portable后端和Quick后端生成的OAT文件的本质区别在于，前者使用标准的动态链接器加载，而后者使用自定义的加载器加载。</p>
<p> 标准动态链接器在加载SO文件（这里是OAT文件）的时候，会自动处理重定位问题。也就是说，在生成的本地机器指令中，如果有依赖其它的SO导出的函数，那么标准动态链接器就会将被依赖的SO也加载进来，并且从里面找到被引用的函数的地址，用来重定位引用了该函数的符号。</p>
<p>自定义加载器的做法就不一样了。它在加载OAT文件时，并不需要做上述的重定位操作。因为Quick后端生成的本地机器指令需要调用一些外部库提供的函数时，是通过一个函数跳转表来实现的。由于在加载过程中不需要执行重定位，因此加载过程就会更快，Quick的名字就是这样得来的。</p>
<p>了解了上面的知识，我们再来看 CallVoidMethod，有了 method id，就相当于有了 ArtMethod，而 ArtMethod 里面又有方法对应的指令入口，直接跳转过去执行就好了，当然不像我说的这么简单，还要处理参数，栈帧等。</p>
<h3 id="hook-jni-调用"><a href="#hook-jni-调用" class="headerlink" title="hook jni 调用"></a>hook jni 调用</h3><p>上面说到，java 方法对应的 jni 函数的地址在 entry_point_from_jni_ 这个里面，那么我们只需要替换这个值为我们写的方法的地址，就可以监控方法的执行了。</p>
<p>实现这个功能的难点在于，如何找到 ArtMethod 里面的 entry_point_from_jni_ 这个字段。</p>
<p>因为每个版本，每个rom都可能不一样，所以有一种取巧的方式是写两个相邻的 native method：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">external fun <span class="hljs-title">x1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">external fun <span class="hljs-title">x2</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>然后，获取到他们的 jmethodid：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Apache"><span class="hljs-attribute">jclass</span> entry_point_activity = env-&gt;GetObjectClass(thiz);<br><br><span class="hljs-attribute">jmethodID</span> x<span class="hljs-number">1</span> = env-&gt;GetMethodID(entry_point_activity, <span class="hljs-string">&quot;x1&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br><span class="hljs-attribute">jmethodID</span> x<span class="hljs-number">2</span> = env-&gt;GetMethodID(entry_point_activity, <span class="hljs-string">&quot;x2&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>因为，jmethodID 实际上就是 ArtMethod 的指针，所以，我们就获取到了这两个对象的地址。</p>
<p>对象里面储存的是各个字段，我们只需要从对象的地址开始往后遍历，总能走到 entry_point_from_jni_ 这个字段，然后跟我们声明的 JNI 函数比较一下即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">intptr_t</span> offsetToFind =<br>        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">intptr_t</span> &gt;(x1) - <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">intptr_t</span> &gt;(x2);<br><br><br><span class="hljs-keyword">if</span> (offsetToFind &lt; <span class="hljs-number">0</span>) &#123;<br>    offsetToFind = -offsetToFind;<br>&#125;<br><span class="hljs-keyword">if</span> (offsetToFind &gt; <span class="hljs-number">128</span>) &#123;<br>    offsetToFind = <span class="hljs-number">128</span>;<br>&#125;<br><br><br><span class="hljs-keyword">uintptr_t</span> jni_entry_point_offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uintptr_t</span> curOffset = <span class="hljs-number">0</span>; curOffset &lt; offsetToFind; curOffset += <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">void</span> *)) &#123;<br>    <span class="hljs-keyword">uintptr_t</span> curAddr = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">uintptr_t</span> &gt;(x1) + curOffset;<br>    <span class="hljs-keyword">if</span> ((*<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span> **&gt;(curAddr)) ==<br>        Java_com_aprz_mytestdemo_jni_EntryPointsActivity_x1) &#123;<br>        jni_entry_point_offset = curOffset;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里是限制了最大往后遍历128位。其中有一点不太明白，就是为什么步长是  sizeof（void *），因为我们不确定rom会放什么字段。</p>
<p>经过测试发现，对象中的字段会对齐，按照字段占用最大值对齐，比如有一个 char，一个 void *，会将结构的占用的内存，扩展为最大值的倍数，于是char 扩展成 4/8 字节。</p>
<p>计算出了地址，hook 就只需要将你创建的替换函数的地址替换上去就好了，记得签名一致。</p>
<p>需要注意的是，这种ArtMethod计算方法只在11以下管用，11及以上ArtMethod的获取需要使用其他的方式，这个可以去翻翻源码来解决！</p>
<p>我看了5.x里面的逻辑，ArtMethod 的 entry_point_from_jni_ 字段，默认会设置为 Stub（<a target="_blank" rel="noopener" href="http://source.bytedance.net/android/s?defs=art_jni_dlsym_lookup_stub&project=android-5.0.1_r1">art_jni_dlsym_lookup_stub</a>） 的地址，在 Stub 执行的时候，会在 so 里面找真实的方法地址，找到了之后 entry_point_from_jni_ 才会替换为真实的！！那如果这个方法之前没有被调用过不是找不到地址了吗？</p>
<p>所以想要找到entry_point_from_jni_的地址，必须要先调用一下这两个native方法，才能正确计算。计算完成之后，想要调用原来的方法，就需要去符号表里面寻找原函数并调用了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a target="_blank" rel="noopener" href="https://developer.android.com/training/articles/perf-jni#utf-8-and-utf-16-strings">JNI</a><a target="_blank" rel="noopener" href="https://developer.android.com/training/articles/perf-jni#utf-8-and-utf-16-strings"> TIPS</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">JNI</a><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html"> SPEC</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54848337">ArtMethod结构与相关技术介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://blog4jimmy.com/category/the_java_native_interface_programmer_guide_and_specificationjni">JNI</a><a target="_blank" rel="noopener" href="https://blog4jimmy.com/category/the_java_native_interface_programmer_guide_and_specificationjni">编程指南与规范</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94ec55eb54fd">so 加载</a><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/94ec55eb54fd">https://www.jianshu.com/p/94ec55eb54fd</a>)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C++</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/22/blog_bak/Blog/%E6%8A%98%E8%85%BE/%E7%8A%B6%E6%80%81%E9%97%AE%E9%A2%98/">
                        <span class="hidden-mobile">状态问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"oWSVw2w2LW7MdhWmyHAsgyH6-MdYXbMMI","appKey":"FllNdPfQPCLcrJVVXHGyakPQ","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[],"appid":"oWSVw2w2LW7MdhWmyHAsgyH6-MdYXbMMI","appkey":"FllNdPfQPCLcrJVVXHGyakPQ"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
