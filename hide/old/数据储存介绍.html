<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="使用共享首选项SharedPreferences 类提供了一个通用框架，以便您能够保存和检索原始数据类型的永久性键值对。 您可以使用 SharedPreferences 来保存任何原始数据：布尔值、浮点值、整型值、长整型和字符串。 此数据将跨多个用户会话永久保留（即使您的应用已终止亦如此）。">
<meta property="og:type" content="website">
<meta property="og:title" content="数据储存介绍">
<meta property="og:url" content="http://aprz512.github.io/hide/old/数据储存介绍.html">
<meta property="og:site_name" content="二手程序员">
<meta property="og:description" content="使用共享首选项SharedPreferences 类提供了一个通用框架，以便您能够保存和检索原始数据类型的永久性键值对。 您可以使用 SharedPreferences 来保存任何原始数据：布尔值、浮点值、整型值、长整型和字符串。 此数据将跨多个用户会话永久保留（即使您的应用已终止亦如此）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-08-01T04:16:19.011Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据储存介绍">
<meta name="twitter:description" content="使用共享首选项SharedPreferences 类提供了一个通用框架，以便您能够保存和检索原始数据类型的永久性键值对。 您可以使用 SharedPreferences 来保存任何原始数据：布尔值、浮点值、整型值、长整型和字符串。 此数据将跨多个用户会话永久保留（即使您的应用已终止亦如此）。">
  <link rel="canonical" href="http://aprz512.github.io/hide/old/数据储存介绍">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>数据储存介绍 | 二手程序员</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二手程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">22</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">10</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">164</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">数据储存介绍

</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>数据储存介绍</li>
          
        
      
    
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
        
          <h2 id="使用共享首选项"><a href="#使用共享首选项" class="headerlink" title="使用共享首选项"></a>使用共享首选项</h2><p><code>SharedPreferences</code> 类提供了一个通用框架，以便您能够保存和检索原始数据类型的永久性键值对。 您可以使用 <code>SharedPreferences</code> 来保存任何原始数据：布尔值、浮点值、整型值、长整型和字符串。 此数据将跨多个用户会话永久保留（即使您的应用已终止亦如此）。</p>
<a id="more"></a>

<p>要获取应用的 <code>SharedPreferences</code> 对象，请使用以下两个方法之一：</p>
<ul>
<li><code>getSharedPreferences()</code> - 如果您需要多个按名称（使用第一个参数指定）识别的首选项文件，请使用此方法。</li>
<li><code>getPreferences()</code> - 如果您只需要一个用于 Activity 的首选项文件，请使用此方法。 由于这将是用于 Activity 的唯一首选项文件，因此无需提供名称。</li>
</ul>
<p>查看<code>getPreferences()</code>源码，内部实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> SharedPreferences <span class="title">getPreferences</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getSharedPreferences(getLocalClassName(), mode);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法返回activity的类名，不带包名</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLocalClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String pkg = getPackageName();</span><br><span class="line">       <span class="keyword">final</span> String cls = mComponent.getClassName();</span><br><span class="line">       <span class="keyword">int</span> packageLen = pkg.length();</span><br><span class="line">       <span class="keyword">if</span> (!cls.startsWith(pkg) || cls.length() &lt;= packageLen</span><br><span class="line">               || cls.charAt(packageLen) != <span class="string">'.'</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> cls;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cls.substring(packageLen+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>要写入值：</p>
<ol>
<li>调用 <code>edit()</code> 以获取 <code>SharedPreferences.Editor</code>。</li>
<li>使用 <code>putBoolean()</code> 和 <code>putString()</code> 等方法添加值。</li>
<li>使用 <code>commit()</code> 提交新值</li>
</ol>
<p>要读取值，请使用 <code>getBoolean()</code> 和 <code>getString()</code> 等 <code>SharedPreferences</code> 方法。</p>
<p>以下是在计算器中保存静音按键模式首选项的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFS_NAME = <span class="string">"MyPrefsFile"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span></span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(state);</span><br><span class="line">       . . .</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Restore preferences</span></span><br><span class="line">       SharedPreferences settings = getSharedPreferences(PREFS_NAME, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">boolean</span> silent = settings.getBoolean(<span class="string">"silentMode"</span>, <span class="keyword">false</span>);</span><br><span class="line">       setSilent(silent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onStop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We need an Editor object to make preference changes.</span></span><br><span class="line">      <span class="comment">// All objects are from android.context.Context</span></span><br><span class="line">      SharedPreferences settings = getSharedPreferences(PREFS_NAME, <span class="number">0</span>);</span><br><span class="line">      SharedPreferences.Editor editor = settings.edit();</span><br><span class="line">      editor.putBoolean(<span class="string">"silentMode"</span>, mSilentMode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Commit the edits!</span></span><br><span class="line">      editor.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS: </p>
<ol>
<li><p>如果有多进程的需求，最好先做调研。</p>
</li>
<li><p><code>SharedPreferences</code>创建文件的位置在，需要root才可以查看：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/YOUR_PACKAGE_NAME/shared_prefs/YOUR_PREFS_NAME.xml</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用内部存储"><a href="#使用内部存储" class="headerlink" title="使用内部存储"></a>使用内部存储</h2><p>您可以直接在设备的内部存储中保存文件。默认情况下，保存到内部存储的文件是应用的私有文件，其他应用（和用户）不能访问这些文件。 当用户卸载您的应用时，这些文件也会被移除。</p>
<p>要创建私有文件并写入到内部存储：</p>
<ol>
<li>使用文件名称和操作模式调用 <code>openFileOutput()</code>。 这将返回一个 <code>FileOutputStream</code>。</li>
<li>使用 <code>write()</code> 写入到文件。</li>
<li>使用 <code>close()</code> 关闭流式传输。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String FILENAME = <span class="string">"hello_file"</span>;</span><br><span class="line">String string = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);</span><br><span class="line">fos.write(string.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<p><code>MODE_PRIVATE</code> 将会创建文件（或替换具有相同名称的文件），并将其设为应用的私有文件。 其他可用模式包括：<code>MODE_APPEND</code>、<code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITEABLE</code>。</p>
<p><strong>注意</strong>：自 API 级别 17 以来，常量 <code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITEABLE</code> 已被弃用。从 Android N 开始，使用这些常量将会导致引发 <code>SecurityException</code>。这意味着，面向 Android N 和更高版本的应用无法按名称共享私有文件，尝试共享“file://”URI 将会导致引发<code>FileUriExposedException</code>。 如果您的应用需要与其他应用共享私有文件，则可以将 <code>FileProvider</code> 与 <code>FLAG_GRANT_READ_URI_PERMISSION</code>配合使用。另请参阅<a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="noopener">共享文件</a> 。</p>
<p>要从内部存储读取文件：</p>
<ol>
<li>调用 <code>openFileInput()</code> 并向其传递要读取的文件名称。 这将返回一个 <code>FileInputStream</code>。</li>
<li>使用 <code>read()</code> 读取文件字节。</li>
<li>然后使用 <code>close()</code> 关闭流式传输。</li>
</ol>
<p><strong>提示</strong>：如果在编译时想要保存应用中的静态文件，请在项目的 <code>res/raw/</code> 目录中保存该文件。 可以使用 <code>openRawResource()</code> 打开该资源并传递 <code>R.raw.*&lt;filename&gt;*</code> 资源 ID。 此方法将返回一个 <code>InputStream</code>，您可以使用该流式传输读取文件（但不能写入到原始文件）。</p>
<p>文件创建的位置在：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/YOUR_PACKAGE_NAME/files/YOUR_FILE</span><br></pre></td></tr></table></figure>

<h3 id="保存缓存文件"><a href="#保存缓存文件" class="headerlink" title="保存缓存文件"></a>保存缓存文件</h3><p>如果您想要缓存一些数据，而不是永久存储这些数据，应该使用 <code>getCacheDir()</code> 来打开一个 <code>File</code>，它表示您的应用应该将临时缓存文件保存到的内部目录。</p>
<p>当设备的内部存储空间不足时，Android 可能会删除这些缓存文件以回收空间。 但您不应该依赖系统来为您清理这些文件， 而应该始终自行维护缓存文件，使其占用的空间保持在合理的限制范围内（例如 1 MB）。 当用户卸载您的应用时，这些文件也会被移除。</p>
<p>文件创建的位置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/data/data/YOUR_PACKAGE_NAME/cache/YOUR_FILE</span><br><span class="line"></span><br><span class="line">在API24下出现：/data/user/0/YOUR_PACKAGE_NAME/cache/YOUR_FILE</span><br><span class="line">查了一下，比较合理的解释是：</span><br><span class="line">6.0 支持多用户 </span><br><span class="line">如果新建一个用户，就可能返回 </span><br><span class="line">/data/user/1/package/files </span><br><span class="line">然后当前用户 n 可能无法访问 /data/user/n/以外的目录。</span><br><span class="line"></span><br><span class="line">所以在6.0之前，data/data 就相当于 /data/user/0</span><br></pre></td></tr></table></figure>

<h3 id="其他实用方法"><a href="#其他实用方法" class="headerlink" title="其他实用方法"></a>其他实用方法</h3><ul>
<li><p><code>getFilesDir()</code></p>
<p>获取在其中存储内部文件的文件系统目录的绝对路径。</p>
<p>这个同<code>getCacheDir()</code></p>
</li>
<li><p><code>getDir()</code></p>
<p>在您的内部存储空间内创建（或打开现有的）目录。</p>
<p>这个方法在 files 的同级目录创建目录：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/user/0/YOUR_PACKAGE_NAME/YOUR_DIR</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>deleteFile()</code></p>
<p>删除保存在内部存储的文件。</p>
<p>删除files下指定名称的文件。</p>
</li>
<li><p><code>fileList()</code></p>
<p>返回您的应用当前保存的一系列文件。</p>
<p>返回files下所有的文件名，返回的是String[]对象。</p>
</li>
</ul>
<h2 id="使用外部存储"><a href="#使用外部存储" class="headerlink" title="使用外部存储"></a>使用外部存储</h2><p>每个兼容 Android 的设备都支持可用于保存文件的共享“外部存储”。 该存储可能是可移除的存储介质（例如 SD 卡）或内部（不可移除）存储。 保存到外部存储的文件是全局可读取文件，而且，在计算机上启用 USB 大容量存储以传输文件后，可由用户修改这些文件。</p>
<p><strong>注意</strong>：如果用户在计算机上装载了外部存储或移除了介质，则外部存储可能变为不可用状态，并且在您保存到外部存储的文件上没有实施任何安全性。 所有应用都能读取和写入放置在外部存储上的文件，并且用户可以移除这些文件。</p>
<h3 id="使用作用域目录访问"><a href="#使用作用域目录访问" class="headerlink" title="使用作用域目录访问"></a>使用作用域目录访问</h3><p>在 Android 7.0 或更高版本中，如果您需要访问外部存储上的特定目录，请使用作用域目录访问。 作用域目录访问可简化您的应用访问标准外部存储目录（例如 Pictures目录）的方式，并提供简单的权限 UI，清楚地详细介绍应用正在请求访问的目录。有关作用域目录访问的更多详情，请参阅<a href="https://developer.android.com/training/articles/scoped-directory-access.html。" target="_blank" rel="noopener">https://developer.android.com/training/articles/scoped-directory-access.html。</a></p>
<h3 id="获取外部存储的访问权限"><a href="#获取外部存储的访问权限" class="headerlink" title="获取外部存储的访问权限"></a>获取外部存储的访问权限</h3><p>要读取或写入外部存储上的文件，您的应用必须获取 <code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 系统权限。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>如果您同时需要读取和写入文件，则只需请求 <code>WRITE_EXTERNAL_STORAGE</code> 权限，因为此权限也隐含了读取权限要求。</p>
<p><strong>注</strong>：从 Android 4.4 开始，如果您仅仅读取或写入应用的私有文件，则不需要这些权限。 如需了解更多信息，请参阅下面有关<a href="https://developer.android.com/guide/topics/data/data-storage.html#AccessingExtFiles" target="_blank" rel="noopener">保存应用私有文件</a>的部分。</p>
<h3 id="检查介质可用性"><a href="#检查介质可用性" class="headerlink" title="检查介质可用性"></a>检查介质可用性</h3><p>在使用外部存储执行任何工作之前，应始终调用 <code>getExternalStorageState()</code> 以检查介质是否可用。介质可能已装载到计算机，处于缺失、只读或其他某种状态。 例如，以下是可用于检查可用性的几种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* Checks if external storage is available for read and write */</span><br><span class="line">public boolean isExternalStorageWritable() &#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    if (Environment.MEDIA_MOUNTED.equals(state)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Checks if external storage is available to at least read */</span><br><span class="line">public boolean isExternalStorageReadable() &#123;</span><br><span class="line">    String state = Environment.getExternalStorageState();</span><br><span class="line">    if (Environment.MEDIA_MOUNTED.equals(state) ||</span><br><span class="line">        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getExternalStorageState()</code> 方法将返回您可能需要检查的其他状态（例如介质是否处于共享 [连接到计算]、完全缺失、错误移除等状态）。 当您的应用需要访问介质时，您可以使用这些状态向用户通知更多信息。</p>
<h3 id="保存可与其他应用共享的文件"><a href="#保存可与其他应用共享的文件" class="headerlink" title="保存可与其他应用共享的文件"></a>保存可与其他应用共享的文件</h3><p>一般而言，应该将用户可通过您的应用获取的新文件保存到设备上的“公共”位置，以便其他应用能够在其中访问这些文件，并且用户也能轻松地从该设备复制这些文件。 执行此操作时，应使用共享的公共目录之一，例如 <code>Music/</code>、<code>Pictures/</code> 和 <code>Ringtones/</code> 等。</p>
<p>要获取表示相应的公共目录的 <code>File</code>，请调用 <code>getExternalStoragePublicDirectory()</code>，向其传递您需要的目录类型，例如 <code>DIRECTORY_MUSIC</code>、<code>DIRECTORY_PICTURES</code>、 <code>DIRECTORY_RINGTONES</code> 或其他类型。通过将您的文件保存到相应的媒体类型目录，系统的媒体扫描程序可以在系统中正确地归类您的文件（例如铃声在系统设置中显示为铃声而不是音乐）。</p>
<p>例如，以下方法在公共图片目录中创建了一个用于新相册的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public File getAlbumStorageDir(String albumName) &#123;</span><br><span class="line">    // Get the directory for the user&apos;s public pictures directory.</span><br><span class="line">    File file = new File(Environment.getExternalStoragePublicDirectory(</span><br><span class="line">            Environment.DIRECTORY_PICTURES), albumName);</span><br><span class="line">    if (!file.mkdirs()) &#123;</span><br><span class="line">        Log.e(LOG_TAG, &quot;Directory not created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在媒体扫描程序中隐藏您的文件"><a href="#在媒体扫描程序中隐藏您的文件" class="headerlink" title="在媒体扫描程序中隐藏您的文件"></a>在媒体扫描程序中隐藏您的文件</h4><p>在您的外部文件目录中包含名为 <code>.nomedia</code> 的空文件（注意文件名中的点前缀）。 这将阻止媒体扫描程序读取您的媒体文件，并通过 <code>MediaStore</code>内容提供程序将其提供给其他应用。 但如果您的文件真正是应用的私有文件，则应该<a href="https://developer.android.com/guide/topics/data/data-storage.html#AccessingExtFiles" target="_blank" rel="noopener">将其保存在应用私有的目录中</a>。</p>
<h3 id="保存应用私有文件"><a href="#保存应用私有文件" class="headerlink" title="保存应用私有文件"></a>保存应用私有文件</h3><p>如果您正在处理的文件不适合其他应用使用（例如仅供您的应用使用的图形纹理或音效），则应该通过调用 <code>getExternalFilesDir()</code> 来使用外部存储上的私有存储目录。此方法还会采用 <code>type</code> 参数指定子目录的类型（例如 <code>DIRECTORY_MOVIES</code>）。 如果您不需要特定的媒体目录，请传递 <code>null</code> 以接收应用私有目录的根目录。</p>
<p>从 Android 4.4 开始，读取或写入应用私有目录中的文件不再需要 <code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 权限。 因此，您可以通过添加 <a href="https://developer.android.com/guide/topics/manifest/uses-permission-element.html#maxSdk" target="_blank" rel="noopener"><code>maxSdkVersion</code></a> 属性来声明，只能在较低版本的 Android 中请求该权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span><br><span class="line">                     android:maxSdkVersion=&quot;18&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：当用户卸载您的应用时，此目录及其内容将被删除。此外，系统媒体扫描程序不会读取这些目录中的文件，因此不能从 <code>MediaStore</code> 内容提供程序访问这些文件。 同样，<strong>不应将这些目录</strong>用于最终属于用户的媒体，例如使用您的应用拍摄或编辑的照片或用户使用您的应用购买的音乐等 — 这些文件应<a href="https://developer.android.com/guide/topics/data/data-storage.html#SavingSharedFiles" target="_blank" rel="noopener">保存在公共目录中</a>。</p>
<p>有时，已分配某个内部存储器分区用作外部存储的设备可能还提供了 SD 卡槽。在使用运行 Android 4.3 和更低版本的这类设备时，<code>getExternalFilesDir()</code> 方法将仅提供内部分区的访问权限，而您的应用无法读取或写入 SD 卡。不过，从 Android 4.4 开始，可通过调用<code>getExternalFilesDirs()</code> 来同时访问两个位置，该方法将会返回包含各个位置条目的 <code>File</code> 数组。 数组中的第一个条目被视为外部主存储；除非该位置已满或不可用，否则应该使用该位置。 如果您希望在支持 Android 4.3 和更低版本的同时访问两个可能的位置，请使用<a href="https://developer.android.com/tools/support-library/index.html" target="_blank" rel="noopener">支持库</a>中的静态方法 <code>ContextCompat.getExternalFilesDirs()</code>。 在 Android 4.3 和更低版本中，此方法也会返回一个 <code>File</code> 数组，但其中始终仅包含一个条目。</p>
<p><strong>注意</strong> 尽管 <code>MediaStore</code> 内容提供程序不能访问 <code>getExternalFilesDir()</code> 和 <code>getExternalFilesDirs()</code> 所提供的目录，但其他具有 <code>READ_EXTERNAL_STORAGE</code> 权限的应用仍可访问外部存储上的所有文件，包括上述文件。 如果您需要完全限制您的文件的访问权限，则应该转而将您的文件写入到<a href="https://developer.android.com/guide/topics/data/data-storage.html#filesInternal" target="_blank" rel="noopener">内部存储</a>。</p>
<h3 id="保存缓存文件-1"><a href="#保存缓存文件-1" class="headerlink" title="保存缓存文件"></a>保存缓存文件</h3><p>要打开表示应该将缓存文件保存到的外部存储目录的 <code>File</code>，请调用 <code>getExternalCacheDir()</code>。 如果用户卸载您的应用，这些文件也会被自动删除。</p>
<p>与前述 <code>ContextCompat.getExternalFilesDirs()</code> 相似，您也可以通过调用 <code>ContextCompat.getExternalCacheDirs()</code> 来访问辅助外部存储（如果可用）上的缓存目录。</p>
<p><strong>提示</strong>：为节省文件空间并保持应用性能，您应该在应用的整个生命周期内仔细管理您的缓存文件并移除其中不再需要的文件，这一点非常重要。</p>
<h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><p>Android 提供了对 <a href="http://www.sqlite.org/" target="_blank" rel="noopener">SQLite</a> 数据库的完全支持。应用中的任何类（不包括应用外部的类）均可按名称访问您所创建的任何数据库。</p>
<p>创建新 SQLite 数据库的推荐方法是创建 <code>SQLiteOpenHelper</code> 的子类并覆盖 <code>onCreate()</code> 方法，在此方法中，您可以执行 SQLite 命令以创建数据库中的表。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class DictionaryOpenHelper extends SQLiteOpenHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static final int DATABASE_VERSION = 2;</span><br><span class="line">    private static final String DICTIONARY_TABLE_NAME = &quot;dictionary&quot;;</span><br><span class="line">    private static final String DICTIONARY_TABLE_CREATE =</span><br><span class="line">                &quot;CREATE TABLE &quot; + DICTIONARY_TABLE_NAME + &quot; (&quot; +</span><br><span class="line">                KEY_WORD + &quot; TEXT, &quot; +</span><br><span class="line">                KEY_DEFINITION + &quot; TEXT);&quot;;</span><br><span class="line"></span><br><span class="line">    DictionaryOpenHelper(Context context) &#123;</span><br><span class="line">        super(context, DATABASE_NAME, null, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">        db.execSQL(DICTIONARY_TABLE_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后您可以使用已定义的构造函数获取 <code>SQLiteOpenHelper</code> 实现的实例。 要从数据库执行写入和读取操作，请分别调用 <code>getWritableDatabase()</code> 和 <code>getReadableDatabase()</code>。二者都会返回一个表示数据库的 <code>SQLiteDatabase</code> 对象，并提供用于 SQLite 操作的方法。</p>
<p>Android 没有实施标准 SQLite 概念之外的任何限制。我们推荐包含一个可用作唯一 ID 的自动增量值关键字段，以便快速查找记录。 私有数据不要求这样做，但如果您实现了一个<a href="https://developer.android.com/guide/topics/providers/content-providers.html" target="_blank" rel="noopener">内容提供程序</a>，则必须包含使用 <code>BaseColumns._ID</code> 常量的唯一 ID。</p>
<p>您可以使用 <code>SQLiteDatabase</code> <code>query()</code> 方法来执行 SQLite 查询，这些方法可接受各种查询参数，例如要查询的表、投影、选择、列、分组和其他参数。 对于复杂的查询，例如需要列别名的查询，应该使用<code>SQLiteQueryBuilder</code>，它将提供多种便捷的方法来构建查询。</p>
<p>每个 SQLite 查询都会返回一个指向该查询找到的所有行的 <code>Cursor</code>。 您始终可以使用 <code>Cursor</code> 机制来浏览数据库查询结果，以及读取行和列。</p>
<p>如需演示 Android 中的 SQLite 数据库使用方法的示例应用，请参阅 <a href="https://developer.android.com/resources/samples/NotePad/index.html" target="_blank" rel="noopener">记事本</a>和 <a href="https://developer.android.com/resources/samples/SearchableDictionary/index.html" target="_blank" rel="noopener">可搜索字典</a>应用。</p>
<p>顺便介绍一下 作用域目录 的访问</p>
<h1 id="使用作用域目录访问-1"><a href="#使用作用域目录访问-1" class="headerlink" title="使用作用域目录访问"></a>使用作用域目录访问</h1><p>应用（如照片应用）通常只需要访问外部存储中的特定目录，例如 <code>Pictures</code> 目录。现有的外部存储访问方法未经专门设计，无法轻松地为这些类型的应用提供定向目录访问。例如：</p>
<ul>
<li>在您的清单中请求 <code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 将允许访问外部存储上的所有公共目录，这可能导致访问的内容超出应用需要的内容。</li>
<li>使用<a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架</a>通常会让您的用户通过一个系统 UI 选取目录，如果应用始终访问同一个外部目录，则该操作没有任何必要。</li>
</ul>
<p>Android 7.0 提供简化的 API 来访问常见的外部存储目录。</p>
<h2 id="访问外部存储目录"><a href="#访问外部存储目录" class="headerlink" title="访问外部存储目录"></a>访问外部存储目录</h2><p>使用 <code>StorageManager</code> 类获取适当的 <code>StorageVolume</code> 实例。然后，通过调用该实例的 <code>StorageVolume.createAccessIntent()</code> 方法创建一个 intent。使用此 intent 访问外部存储目录。要获取所有可用卷的列表，包括可移动介质卷，请使用 <code>StorageManager.getStorageVolumes()</code>。</p>
<p>如果您有关于特定文件的信息，请使用 <code>StorageManager.getStorageVolume(File)</code> 获取包含该文件的 <code>StorageVolume</code>。调用此 <code>StorageVolume</code>上的 <code>createAccessIntent()</code> 以访问文件的外部存储目录。</p>
<p>在次要卷（例如外部 SD 卡）上，调用 <code>createAccessIntent()</code> 以请求访问整个卷而不是特定目录时将传入“null”。如果您向主要卷传入“null”，或者如果您传入无效的目录名，<code>createAccessIntent()</code> 将返回“null”。</p>
<p>以下代码段展示了如何在主要共享存储中打开 <code>Pictures</code> 目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StorageManager sm = (StorageManager)getSystemService(Context.STORAGE_SERVICE);</span><br><span class="line">StorageVolume volume = sm.getPrimaryStorageVolume();</span><br><span class="line">Intent intent = volume.createAccessIntent(Environment.DIRECTORY_PICTURES);</span><br><span class="line">startActivityForResult(intent, request_code);</span><br></pre></td></tr></table></figure>

<p>系统尝试授予对外部目录的访问权限，并使用一个简化的 UI 向用户确认访问权限（如果需要）：</p>
<p><strong>图 1.</strong> 一个请求访问 Pictures 目录的应用。</p>


<p>如果用户授予访问权限，系统会调用 <code>onActivityResult()</code> 替换方法（结果代码为 <code>RESULT_OK</code>），以及包含 URI 的 intent 数据。使用提供的 URI 访问目录信息，与使用<a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架</a>返回的 URI 类似。</p>
<p>如果用户不授予访问权限，系统将调用<code>onActivityResult()</code> 替换方法（结果代码为 <code>RESULT_CANCELED</code>），以及空 intent 数据。</p>
<p>获得特定外部目录的访问权限也会获得该目录中子目录的访问权限。</p>
<h2 id="访问可移动介质上的目录"><a href="#访问可移动介质上的目录" class="headerlink" title="访问可移动介质上的目录"></a>访问可移动介质上的目录</h2><p>要使用作用域目录访问来访问可移动介质上的目录，首先请添加一个用于侦听 <code>MEDIA_MOUNTED</code> 通知的 <code>BroadcastReceiver</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=&quot;.MediaMountedReceiver&quot;</span><br><span class="line">    android:enabled=&quot;true&quot;</span><br><span class="line">    android:exported=&quot;true&quot; &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MEDIA_MOUNTED&quot; /&gt;</span><br><span class="line">        &lt;data android:scheme=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>

<p>当用户装载可移动介质（如 SD 卡）时，系统将发送一则 <code>MEDIA_MOUNTED</code> 通知。此通知会在 intent 数据中提供一个 <code>StorageVolume</code> 对象，您可以使用此对象访问可移动介质上的目录。以下示例可以访问可移动介质上的 <code>Pictures</code> 目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// BroadcastReceiver has already cached the MEDIA_MOUNTED</span><br><span class="line">// notification Intent in mediaMountedIntent</span><br><span class="line">StorageVolume volume = (StorageVolume)</span><br><span class="line">    mediaMountedIntent.getParcelableExtra(StorageVolume.EXTRA_STORAGE_VOLUME);</span><br><span class="line">volume.createAccessIntent(Environment.DIRECTORY_PICTURES);</span><br><span class="line">startActivityForResult(intent, request_code);</span><br></pre></td></tr></table></figure>

<h2 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h2><p>如果可能，请保留外部目录访问 URI，这样就不必重复要求用户授予访问权限。在用户授予访问权限后，调用 <code>getContentResolver()</code>，在返回 <code>ContentResolver</code> 后，使用目录访问 URI 调用 <code>takePersistableUriPermission()</code>。系统将保留此 URI，后续的访问请求将返回 <code>RESULT_OK</code>，且不会向用户显示确认 UI。</p>
<p>如果用户拒绝授予外部目录访问权限，请勿立即再次请求访问权限。反复不停地请求访问权限会导致糟糕的用户体验。如果用户拒绝了一项请求，而应用再次请求访问权限，UI 会显示一个 <strong>Don’t ask again</strong> 复选框：</p>
<p><strong>图 1.</strong> 应用第二次请求访问可移动介质。</p>


<p>如果用户选择 <strong>Don’t ask again</strong> 并拒绝请求，您的应用向给定目录提出的所有未来请求都将被自动拒绝，并且将不会有请求 UI 呈现给用户。</p>

        
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>数据储存介绍</li>
          
        
      
    
  </ul>

    
    
    
  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用共享首选项"><span class="nav-number">1.</span> <span class="nav-text">使用共享首选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用内部存储"><span class="nav-number">2.</span> <span class="nav-text">使用内部存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保存缓存文件"><span class="nav-number">2.1.</span> <span class="nav-text">保存缓存文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他实用方法"><span class="nav-number">2.2.</span> <span class="nav-text">其他实用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用外部存储"><span class="nav-number">3.</span> <span class="nav-text">使用外部存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用作用域目录访问"><span class="nav-number">3.1.</span> <span class="nav-text">使用作用域目录访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取外部存储的访问权限"><span class="nav-number">3.2.</span> <span class="nav-text">获取外部存储的访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查介质可用性"><span class="nav-number">3.3.</span> <span class="nav-text">检查介质可用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存可与其他应用共享的文件"><span class="nav-number">3.4.</span> <span class="nav-text">保存可与其他应用共享的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在媒体扫描程序中隐藏您的文件"><span class="nav-number">3.4.1.</span> <span class="nav-text">在媒体扫描程序中隐藏您的文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存应用私有文件"><span class="nav-number">3.5.</span> <span class="nav-text">保存应用私有文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存缓存文件-1"><span class="nav-number">3.6.</span> <span class="nav-text">保存缓存文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用数据库"><span class="nav-number">4.</span> <span class="nav-text">使用数据库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用作用域目录访问-1"><span class="nav-number"></span> <span class="nav-text">使用作用域目录访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#访问外部存储目录"><span class="nav-number">1.</span> <span class="nav-text">访问外部存储目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问可移动介质上的目录"><span class="nav-number">2.</span> <span class="nav-text">访问可移动介质上的目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最佳做法"><span class="nav-number">3.</span> <span class="nav-text">最佳做法</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">613k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">9:17</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
