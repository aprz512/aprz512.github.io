<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="这里主要研究一下 Hot Observable 与 Cold  Observable 的区别。先看一下定义：1Cold observables start running upon subscription, i.e., the observable sequence only starts pushing values to the observers when Subscribe is cal">
<meta property="og:type" content="website">
<meta property="og:title" content="RxJava_HOT_COLD_Observable测试">
<meta property="og:url" content="http://aprz512.github.io/hide/old/RxJava-HOT-COLD-Observable测试.html">
<meta property="og:site_name" content="六根不净堂">
<meta property="og:description" content="这里主要研究一下 Hot Observable 与 Cold  Observable 的区别。先看一下定义：1Cold observables start running upon subscription, i.e., the observable sequence only starts pushing values to the observers when Subscribe is cal">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-01-15T07:50:14.003Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava_HOT_COLD_Observable测试">
<meta name="twitter:description" content="这里主要研究一下 Hot Observable 与 Cold  Observable 的区别。先看一下定义：1Cold observables start running upon subscription, i.e., the observable sequence only starts pushing values to the observers when Subscribe is cal">
  <link rel="canonical" href="http://aprz512.github.io/hide/old/RxJava-HOT-COLD-Observable测试">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>RxJava_HOT_COLD_Observable测试 | 六根不净堂</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">六根不净堂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">15</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">5</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">108</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">RxJava_HOT_COLD_Observable测试

</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>RXJAVA-HOT-COLD-OBSERVABLE测试</li>
          
        
      
    
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
        
          <p>这里主要研究一下 Hot Observable 与 Cold  Observable 的区别。</p><p>先看一下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cold observables start running upon subscription, i.e., the observable sequence only starts pushing values to the observers when Subscribe is called. (…) This is different from hot observables such as mouse move events or stock tickers which are already producing values even before a subscription is active.</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>下面开始进行验证。</p>
<p>先创建一个 Cold Observable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mCold = Observable</span><br><span class="line">        .interval(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread());</span><br></pre></td></tr></table></figure>

<p>再创建两个 Observer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mObserver1 = <span class="keyword">new</span> DisposableObserver&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(mDesc1.getText());</span><br><span class="line">        stringBuilder.append(<span class="string">","</span>);</span><br><span class="line">        stringBuilder.append(aLong);</span><br><span class="line">        mDesc1.setText(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mObserver2 = <span class="keyword">new</span> DisposableObserver&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(mDesc2.getText());</span><br><span class="line">        stringBuilder.append(<span class="string">","</span>);</span><br><span class="line">        stringBuilder.append(aLong);</span><br><span class="line">        mDesc2.setText(stringBuilder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们分别点击两个按钮，触发 Cold Observable 的 subscribe 方法的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClick</span>(R.id.bs1)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSubsribe1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCold.subscribe(mObserver1);</span><br><span class="line">    mCompositeDisposable.add(mObserver1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnClick</span>(R.id.bs2)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSubsribe2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCold.subscribe(mObserver2);</span><br><span class="line">    mCompositeDisposable.add(mObserver2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看演示画面：</p>


<p>无论我们什么时候点击这两个按钮，两个 TextView 显示的都是从 0 开始。这种特性就是 Cold Observable 的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">那么这里提出一个问题，如果都是在主线程发射数据，那么结果是怎么样的呢？</span><br><span class="line"></span><br><span class="line">其实是没什么影响的，哈哈哈哈。不过如果你在主线程 sleep 的话会影响 TextView 的显示，因为 VSYNC 信号来的时候，主线程正在睡觉，毕竟 onNext 执行的太快了。</span><br></pre></td></tr></table></figure>

<p>接下来，我们将 Cold Observable 变为 Hot Observable，再次观察 TextView 的显示。</p>
<p>创建一个 Hot Observable，使用 publish 方法，就可以将 Cold Observable 变为 Hot Observable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mHot = Observable</span><br><span class="line">        .interval(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">        .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .publish()</span><br><span class="line">        .autoConnect();</span><br></pre></td></tr></table></figure>

<p>再次点击按钮，会有如下画面：</p>


<p>第 2 个 Observer 来到的时候，获取的数据并不是从 0 开始的，而是从中间开始，要看你订阅的时间。这就是 Hot Observable 的特性。</p>
<p>下面，试试从源码角度来看看为啥会这样？</p>
<p>看看 interval 方法，它肯定是创建了一个 Observable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interval(period, period, unit, Schedulers.computation());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    ObjectHelper.requireNonNull(unit, <span class="string">"unit is null"</span>);</span><br><span class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableInterval(Math.max(<span class="number">0L</span>, initialDelay), Math.max(<span class="number">0L</span>, period), unit, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里使用的线程是 Schedulers.computation()，我们测试的时候打印的线程日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-1</span><br><span class="line">RxComputationThreadPool-2</span><br></pre></td></tr></table></figure>

<p>是对应的。然后看 ObservableInterval 这个类吧。根据我们之前的源码分析经验，看一个方法就够了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Long&gt; s)</span> </span>&#123;</span><br><span class="line">    IntervalObserver is = <span class="keyword">new</span> IntervalObserver(s);</span><br><span class="line">    s.onSubscribe(is);</span><br><span class="line"></span><br><span class="line">    Scheduler sch = scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sch <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        Worker worker = sch.createWorker();</span><br><span class="line">        is.setResource(worker);</span><br><span class="line">        worker.schedulePeriodically(is, initialDelay, period, unit);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);</span><br><span class="line">        is.setResource(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>schedulePeriodicallyDirect 就是让线程完成定时器的工作。 既然用到了线程，肯定要有 Runnable，IntervalObserver 就是一个 Runnable，看他的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (get() != DisposableHelper.DISPOSED) &#123;</span><br><span class="line">        actual.onNext(count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ohyeah，count 从 0 开始，所以这就是定时器的核心代码。</p>
<p>到这里，好像忘记了原来的初衷，我们是来分析 Cold Observable 的行为的，也就是为什么每有一个新的 Observer 发送的数据都会从新开始？其实上面也能看出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntervalObserver is = <span class="keyword">new</span> IntervalObserver(s);</span><br></pre></td></tr></table></figure>

<p>就是这一句代码，每次 subscribe 都会触发 subscribeActual，subscribeActual 会新创建一个实例对象，所以 onNext 的时候就会重新开始，并且由于线程池的管理，使用的线程也是不一样的（只要另外的线程还在工作，是不可能重用的）。</p>
<p>那么我们再来看看 Hot Observable 的源码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ConnectableObservable&lt;T&gt; <span class="title">publish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ObservablePublish.create(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservablePublish</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ConnectableObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">HasUpstreamObservableSource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectableObservable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>他们的族谱大概是这个样子的。</p>
<p>既然是继承至 Observable，那么看 subscribeActual 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    onSubscribe.subscribe(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就能看到与 Cold Observable 的区别的，Cold Observable 的 subscribeActual 方法中每次都新创建一个 Observable，但是这里没有，它使用的是成员变量。所以只要调用这个类的 subscribe 方法，那么走的都是同一个对象的方法。看看 onSubscribe 是谁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ObservablePublish</span><span class="params">(ObservableSource&lt;T&gt; onSubscribe, ObservableSource&lt;T&gt; source,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> AtomicReference&lt;PublishObserver&lt;T&gt;&gt; current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onSubscribe = onSubscribe;</span><br><span class="line">    <span class="keyword">this</span>.source = source;</span><br><span class="line">    <span class="keyword">this</span>.current = current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ConnectableObservable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableSource&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the current connection to source needs to be shared between the operator and its onSubscribe call</span></span><br><span class="line">    <span class="keyword">final</span> AtomicReference&lt;PublishObserver&lt;T&gt;&gt; curr = <span class="keyword">new</span> AtomicReference&lt;PublishObserver&lt;T&gt;&gt;();</span><br><span class="line">    ObservableSource&lt;T&gt; onSubscribe = <span class="keyword">new</span> PublishSource&lt;T&gt;(curr);</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservablePublish&lt;T&gt;(onSubscribe, source, curr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 onSubscribe 是 PublishSource 对象。</p>
<p>So，我们继续查看这个类的 subscribeActual 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; child)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create the backpressure-managing producer for this child</span></span><br><span class="line">    InnerDisposable&lt;T&gt; inner = <span class="keyword">new</span> InnerDisposable&lt;T&gt;(child);</span><br><span class="line">    child.onSubscribe(inner);</span><br><span class="line">    <span class="comment">// concurrent connection/disconnection may change the state,</span></span><br><span class="line">    <span class="comment">// we loop to be atomic while the child subscribes</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// get the current subscriber-to-source</span></span><br><span class="line">        PublishObserver&lt;T&gt; r = curr.get();</span><br><span class="line">        <span class="comment">// if there isn't one or it is disposed</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.isDisposed()) &#123;</span><br><span class="line">            <span class="comment">// create a new subscriber to source</span></span><br><span class="line">            PublishObserver&lt;T&gt; u = <span class="keyword">new</span> PublishObserver&lt;T&gt;(curr);</span><br><span class="line">            <span class="comment">// let's try setting it as the current subscriber-to-source</span></span><br><span class="line">            <span class="keyword">if</span> (!curr.compareAndSet(r, u)) &#123;</span><br><span class="line">                <span class="comment">// didn't work, maybe someone else did it or the current subscriber</span></span><br><span class="line">                <span class="comment">// to source has just finished</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// we won, let's use it going onwards</span></span><br><span class="line">            r = u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try adding it to the current subscriber-to-source, add is atomic in respect</span></span><br><span class="line"><span class="comment">         * to other adds and the termination of the subscriber-to-source.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (r.add(inner)) &#123;</span><br><span class="line">            inner.setParent(r);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// NOPMD</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The current PublishObserver has been terminated, try with a newer one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note: although technically correct, concurrent disconnects can cause</span></span><br><span class="line"><span class="comment">         * unexpected behavior such as child observers never receiving anything</span></span><br><span class="line"><span class="comment">         * (unless connected again). An alternative approach, similar to</span></span><br><span class="line"><span class="comment">         * PublishSubject would be to immediately terminate such child</span></span><br><span class="line"><span class="comment">         * observers as well:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Object term = r.terminalEvent;</span></span><br><span class="line"><span class="comment">         * if (r.nl.isCompleted(term)) &#123;</span></span><br><span class="line"><span class="comment">         *     child.onComplete();</span></span><br><span class="line"><span class="comment">         * &#125; else &#123;</span></span><br><span class="line"><span class="comment">         *     child.onError(r.nl.getError(term));</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         * return;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The original concurrent behavior was non-deterministic in this regard as well.</span></span><br><span class="line"><span class="comment">         * Allowing this behavior, however, may introduce another unexpected behavior:</span></span><br><span class="line"><span class="comment">         * after disconnecting a previous connection, one might not be able to prepare</span></span><br><span class="line"><span class="comment">         * a new connection right after a previous termination by subscribing new child</span></span><br><span class="line"><span class="comment">         * observers asynchronously before a connect call.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码还是很简单的，都是注释。主要做的事情就是先创建一个 PublishObserver 对象（如果没有或者 dispose 了），创建了之后将 inner 添加到这个对象中。PublishObserver 里面有个集合存的都是 Observer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Tracks the subscribed observers. */</span></span><br><span class="line"><span class="keyword">final</span> AtomicReference&lt;InnerDisposable&lt;T&gt;[]&gt; observers;</span><br></pre></td></tr></table></figure>

<p>与 Cold Observable 比较一下，它没有触发 onNext 的流程，这也是为什么我们必须要调用 connect 方法的原因。那么接下来就来分析一下 autoConnect 方法是怎么做到 subscribe 时自动触发 onNext 方法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">autoConnect</span><span class="params">(<span class="keyword">int</span> numberOfSubscribers, @NonNull Consumer&lt;? <span class="keyword">super</span> Disposable&gt; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numberOfSubscribers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.connect(connection);</span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableAutoConnect&lt;T&gt;(<span class="keyword">this</span>, numberOfSubscribers, connection));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了新的 Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; child)</span> </span>&#123;</span><br><span class="line">    source.subscribe(child);</span><br><span class="line">    <span class="keyword">if</span> (clients.incrementAndGet() == numberOfObservers) &#123;</span><br><span class="line">        source.connect(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里我们就明白了，是 subscribe 的时候判断一下，如果 Observer 的数量达到要求了，那么就调用一下 connect 方法。这里我们看一下这个 source 对象，按照逻辑 source 指的是上一个创建的 Observable，也就是 ObservablePublish 对象。</p>
<p>看看这个 connect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Disposable&gt; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doConnect;</span><br><span class="line">    PublishObserver&lt;T&gt; ps;</span><br><span class="line">    <span class="comment">// we loop because concurrent connect/disconnect and termination may change the state</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// retrieve the current subscriber-to-source instance</span></span><br><span class="line">        ps = current.get();</span><br><span class="line">        <span class="comment">// if there is none yet or the current has been disposed</span></span><br><span class="line">        <span class="keyword">if</span> (ps == <span class="keyword">null</span> || ps.isDisposed()) &#123;</span><br><span class="line">            <span class="comment">// create a new subscriber-to-source</span></span><br><span class="line">            PublishObserver&lt;T&gt; u = <span class="keyword">new</span> PublishObserver&lt;T&gt;(current);</span><br><span class="line">            <span class="comment">// try setting it as the current subscriber-to-source</span></span><br><span class="line">            <span class="keyword">if</span> (!current.compareAndSet(ps, u)) &#123;</span><br><span class="line">                <span class="comment">// did not work, perhaps a new subscriber arrived</span></span><br><span class="line">                <span class="comment">// and created a new subscriber-to-source as well, retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ps = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if connect() was called concurrently, only one of them should actually</span></span><br><span class="line">        <span class="comment">// connect to the source</span></span><br><span class="line">        doConnect = !ps.shouldConnect.get() &amp;&amp; ps.shouldConnect.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// NOPMD</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Notify the callback that we have a (new) connection which it can dispose</span></span><br><span class="line"><span class="comment">     * but since ps is unique to a connection, multiple calls to connect() will return the</span></span><br><span class="line"><span class="comment">     * same Disposable and even if there was a connect-disconnect-connect pair, the older</span></span><br><span class="line"><span class="comment">     * references won't disconnect the newer connection.</span></span><br><span class="line"><span class="comment">     * Synchronous source consumers have the opportunity to disconnect via dispose on the</span></span><br><span class="line"><span class="comment">     * Disposable as subscribe() may never return in its own.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note however, that asynchronously disconnecting a running source might leave</span></span><br><span class="line"><span class="comment">     * child observers without any terminal event; PublishSubject does not have this</span></span><br><span class="line"><span class="comment">     * issue because the dispose() was always triggered by the child observers</span></span><br><span class="line"><span class="comment">     * themselves.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.accept(ps);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        <span class="keyword">throw</span> ExceptionHelper.wrapOrThrow(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (doConnect) &#123;</span><br><span class="line">        source.subscribe(ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法和上面分析的一个方法很像，代码很少，注释很多。其实只需要注意一下最后一句代码就行了。我们看到了 source.subscribe(ps)，既然看到了这行代码，那么后面的流程其实就是和 Cold Observable 一样了。最终会触发到 PublishObserver 的 onNext 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (InnerDisposable&lt;T&gt; inner : observers.get()) &#123;</span><br><span class="line">        inner.child.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它将我们之前 subscribe 的时候 add 的 Observer 全部遍历了一遍，然后调用其 onNext 方法，所以 Hot Observable 的每个 Observer 收到了 item 都是同步的。这个才比较像真正意义上的观察者模式。</p>
<p>总结一下，Hot Observable 的流程：</p>
<ol>
<li>publish 方法返回了一个 ObservablePublish 对象。</li>
<li>由于 ObservablePublish 的 subscribeActual 方法里面使用的是 onSubscribe 成员变量，所以接下来创建 PublishObserver 的时候，只会创建一个该对象。</li>
<li>onSubscribe 成员变量的 subscribeActual 方法创建了 PublishObserver 用来储存 subscribe 方法添加的 Observer。</li>
<li>调用 connect 方法之后会触发 source 的 subscribeActual。</li>
<li>source 的 subscribeActual 方法会执行之后和 Cold Observer 一样的流程，最后触发 PublishObserver 的 onNext 方法，由于 PublishObserver 只有一个，所以发射的数据必然是同步的。</li>
<li>PublishObserver 的 onNext 方法内部遍历了每个 subscribe 时添加的 Observer。</li>
</ol>

        
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>RXJAVA-HOT-COLD-OBSERVABLE测试</li>
          
        
      
    
  </ul>

    
    
    
  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数"></span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长"></span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
