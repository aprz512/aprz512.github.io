<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="原文地址 请通过以下方式下载本系列文章的Github示例代码： 1git clone https://github.com/davenkin/gradle-learning.git">
<meta property="og:type" content="website">
<meta property="og:title" content="Gradle学习">
<meta property="og:url" content="http://aprz512.github.io/hide/old/Gradle学习.html">
<meta property="og:site_name" content="二手程序员">
<meta property="og:description" content="原文地址 请通过以下方式下载本系列文章的Github示例代码： 1git clone https://github.com/davenkin/gradle-learning.git">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-08-18T08:56:55.968Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gradle学习">
<meta name="twitter:description" content="原文地址 请通过以下方式下载本系列文章的Github示例代码： 1git clone https://github.com/davenkin/gradle-learning.git">
  <link rel="canonical" href="http://aprz512.github.io/hide/old/Gradle学习">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>Gradle学习 | 二手程序员</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二手程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">22</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">12</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">187</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">Gradle学习

</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>GRADLE学习</li>
          
        
      
    
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
        
          <p><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">原文地址</a></p>
<p>请通过以下方式下载本系列文章的Github示例代码：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/davenkin/gradle-learning.git</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="Gradle快速入门"><a href="#Gradle快速入门" class="headerlink" title="Gradle快速入门"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">Gradle快速入门</a></h1><p>让我们来看一个最简单的Task，创建一个build.gradle文件，内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task helloWorld &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">"Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;&lt;</code>表示向<code>helloWorld</code>中加入执行代码——其实就是<code>groovy</code>代码。<code>Gradle</code>向我们提供了一整套DSL，所以在很多时候我们写的代码似乎已经脱离了<code>groovy</code>，但是在底层依然是执行的<code>groovy</code>。比如上面的<code>task</code>关键字，其实就是一个<code>groovy</code>中的方法，而大括号之间的内容则表示传递给<code>task()</code>方法的一个闭包。除了<code>&lt;&lt;</code>之外，我们还很多种方式可以定义一个Task，我们将在本系列后续的文章中讲到。</p>
<p>在与build.gradle相同的目录下执行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle helloWorld</span><br></pre></td></tr></table></figure>

<p>命令行输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$ gradle helloworld</span><br><span class="line">:helloWorld</span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.018 secs</span><br><span class="line"></span><br><span class="line">This build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.10/userguide/gradle_daemon.html</span><br></pre></td></tr></table></figure>

<p>关于Gradle的安装，直接在命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt get install gradle</span><br></pre></td></tr></table></figure>

<p>安装完成之后，切换到当前工作目录就可以运行gradle了。</p>
<p>在默认情况下，Gradle将当前目录下的<code>build.gradle</code>文件作为项目的构建文件。在上面的例子中，我们创建了一个名为helloWorld的Task，在执行gradle命令时，我们指定执行这个helloWorld Task。这里的helloWorld是一个DefaultTask类型的对象，这也是定义一个Task时的默认类型，当然我们也可以显式地声明Task的类型，甚至可以自定义一个Task类型（我们将在本系列的后续文章中讲到）。</p>
<p>比如，我们可以定义一个用于文件拷贝的Task：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task copyFile(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">   from <span class="string">'xml'</span></span><br><span class="line">   into <span class="string">'destination'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上copyFile将<strong>xml文件夹</strong>中的所有内容拷贝到<strong>destination文件夹</strong>中。这里的两个文件夹都是相对于当前Project而言的，即build.gradle文件所在的目录。</p>
<p>Task之间可以存在依赖关系，比如taskA依赖于taskB，那么在执行taskA时，Gradle会先执行taskB，然后再执行taskA。声明Task依赖关系的一种方式是在定义一个Task的时候：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task taskA(<span class="string">dependsOn:</span> taskB) &#123;</span><br><span class="line">   <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gradle在默认情况下为我们提供了几个常用的Task，比如查看Project的Properties、显示当前Project中定义的所有Task等。可以通过一下命令查看Project中所有的Task：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle tasks</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$ gradle tasks</span><br><span class="line">:tasks</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build. [incubating]</span><br><span class="line">wrapper - Generates Gradle wrapper files. [incubating]</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &apos;1-gradle-first-try&apos;.</span><br><span class="line">components - Displays the components produced by root project &apos;1-gradle-first-try&apos;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &apos;1-gradle-first-try&apos;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &apos;1-gradle-first-try&apos;.</span><br><span class="line">help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &apos;1-gradle-first-try&apos;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &apos;1-gradle-first-try&apos;.</span><br><span class="line">properties - Displays the properties of root project &apos;1-gradle-first-try&apos;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &apos;1-gradle-first-try&apos;.</span><br><span class="line"></span><br><span class="line">Other tasks</span><br><span class="line">-----------</span><br><span class="line">copyFile</span><br><span class="line">helloWorld</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradle tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle help --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.012 secs</span><br><span class="line"></span><br><span class="line">This build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.10/userguide/gradle_daemon.html</span><br></pre></td></tr></table></figure>

<p>可以看到，除了我们自己定义的<code>copyFile</code>和<code>helloWorld</code>之外，Gradle还默认为我们提供了dependencies、projects和properties等Task。dependencies用于显示Project的依赖信息，projects用于显示所有Project，包括根Project和子Project，而properties则用于显示一个Project所包含的所有Property。</p>
<p>在默认情况下，Gradle已经为Project添加了很多Property，我们可以调用以下命令进行查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle properties</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$ gradle properties</span><br><span class="line">:properties</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">allprojects: [root project &apos;1-gradle-first-try&apos;]</span><br><span class="line">ant: org.gradle.api.internal.project.DefaultAntBuilder@99407c2</span><br><span class="line">antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@6c796cc1</span><br><span class="line">artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@226eba67</span><br><span class="line">asDynamicObject: org.gradle.api.internal.ExtensibleDynamicObject@1cb7936c</span><br><span class="line">baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@35342d2f</span><br><span class="line">buildDir: /home/aprz/workspace/AndroidStudioProjects/gradle-learning/1-gradle-first-try/build</span><br><span class="line">buildFile: /home/aprz/workspace/AndroidStudioProjects/gradle-learning/1-gradle-first-try/build.gradle</span><br><span class="line">buildScriptSource: org.gradle.groovy.scripts.UriScriptSource@128c502c</span><br><span class="line">buildscript: org.gradle.api.internal.initialization.DefaultScriptHandler@45667d98</span><br><span class="line">childProjects: &#123;&#125;</span><br><span class="line">class: class org.gradle.api.internal.project.DefaultProject_Decorated</span><br><span class="line">classLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@65eabaab</span><br><span class="line">components: []</span><br><span class="line">configurationActions: org.gradle.configuration.project.DefaultProjectConfigurationActionContainer@7123be6c</span><br><span class="line">configurations: []</span><br><span class="line">convention: org.gradle.api.internal.plugins.DefaultConvention@1de9d54</span><br><span class="line">copyFile: task &apos;:copyFile&apos;</span><br><span class="line">defaultTasks: []</span><br><span class="line">deferredProjectConfiguration: org.gradle.api.internal.project.DeferredProjectConfiguration@77a2aa4a</span><br><span class="line">dependencies: org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler_Decorated@47ad69f7</span><br><span class="line">depth: 0</span><br><span class="line">description: null</span><br><span class="line">ext: org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension@2b917fb0</span><br><span class="line">extensions: org.gradle.api.internal.plugins.DefaultConvention@1de9d54</span><br><span class="line">fileOperations: org.gradle.api.internal.file.DefaultFileOperations@5e5073ab</span><br><span class="line">fileResolver: org.gradle.api.internal.file.BaseDirFileResolver@3c4262d1</span><br><span class="line">gradle: build &apos;1-gradle-first-try&apos;</span><br><span class="line">group: </span><br><span class="line">helloWorld: task &apos;:helloWorld&apos;</span><br><span class="line">inheritedScope: org.gradle.api.internal.ExtensibleDynamicObject$InheritedDynamicObject@100c567f</span><br><span class="line">logger: org.gradle.logging.internal.slf4j.OutputEventListenerBackedLogger@30c0d731</span><br><span class="line">logging: org.gradle.logging.internal.DefaultLoggingManager@6d5037a9</span><br><span class="line">modelRegistry: org.gradle.model.internal.registry.DefaultModelRegistry@422b8438</span><br><span class="line">modelSchemaStore: org.gradle.model.internal.manage.schema.extract.DefaultModelSchemaStore@30669dac</span><br><span class="line">module: org.gradle.api.internal.artifacts.ProjectBackedModule@6e0d4a8</span><br><span class="line">name: 1-gradle-first-try</span><br><span class="line">parent: null</span><br><span class="line">parentIdentifier: null</span><br><span class="line">path: :</span><br><span class="line">pluginManager: org.gradle.api.internal.plugins.DefaultPluginManager_Decorated@629adce</span><br><span class="line">plugins: [org.gradle.api.plugins.HelpTasksPlugin@5a4ed68f]</span><br><span class="line">processOperations: org.gradle.api.internal.file.DefaultFileOperations@5e5073ab</span><br><span class="line">project: root project &apos;1-gradle-first-try&apos;</span><br><span class="line">projectDir: /home/aprz/workspace/AndroidStudioProjects/gradle-learning/1-gradle-first-try</span><br><span class="line">projectEvaluationBroadcaster: ProjectEvaluationListener broadcast</span><br><span class="line">projectEvaluator: org.gradle.configuration.project.LifecycleProjectEvaluator@6a282fdd</span><br><span class="line">projectRegistry: org.gradle.api.internal.project.DefaultProjectRegistry@743c6ce4</span><br><span class="line">properties: &#123;...&#125;</span><br><span class="line">repositories: []</span><br><span class="line">resources: org.gradle.api.internal.resources.DefaultResourceHandler@70331432</span><br><span class="line">rootDir: /home/aprz/workspace/AndroidStudioProjects/gradle-learning/1-gradle-first-try</span><br><span class="line">rootProject: root project &apos;1-gradle-first-try&apos;</span><br><span class="line">scriptHandlerFactory: org.gradle.api.internal.initialization.DefaultScriptHandlerFactory@3bbf9027</span><br><span class="line">scriptPluginFactory: org.gradle.configuration.DefaultScriptPluginFactory@10c2064a</span><br><span class="line">serviceRegistryFactory: org.gradle.internal.service.scopes.ProjectScopeServices$4@70e13fa</span><br><span class="line">services: ProjectScopeServices</span><br><span class="line">standardOutputCapture: org.gradle.logging.internal.DefaultLoggingManager@6d5037a9</span><br><span class="line">state: project state &apos;EXECUTED&apos;</span><br><span class="line">status: release</span><br><span class="line">subprojects: []</span><br><span class="line">tasks: [task &apos;:copyFile&apos;, task &apos;:helloWorld&apos;, task &apos;:properties&apos;]</span><br><span class="line">version: unspecified</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.266 secs</span><br><span class="line"></span><br><span class="line">This build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.10/userguide/gradle_daemon.html</span><br></pre></td></tr></table></figure>

<p>在以上Property中，allprojects表示所有的Project，这里只包含一个根Project，在多项目构建中，它将包含多个Project；buildDir表示构建结果的输出目录；我们自己定义的helloWorld和copyFile也成为了Project中的Property。另外，Project还包括用于执行Ant命令的DefaultAntBuilder（Property名为ant）和Project的描述属性description。</p>
<h1 id="创建Task的多种方法"><a href="#创建Task的多种方法" class="headerlink" title="创建Task的多种方法"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-2.html" target="_blank" rel="noopener">创建Task的多种方法</a></h1><p>Gradle的Project从本质上说只是含有多个Task的容器，一个Task与Ant的Target相似，表示一个逻辑上的执行单元。我们可以通过很多种方式定义Task，所有的Task都存放在Project的TaskContainer中。</p>
<p><strong>调用Project的task()方法创建Task</strong></p>
<p>在使用Gradle时，创建Task最常见的方式便是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello1 &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">'hello1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的“&lt;&lt;”表示追加的意思，即向hello中加入执行过程。我们还可以使用doLast来达到同样的效果：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello2 &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">      println <span class="string">'hello2'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果需要向Task的最前面加入执行过程，我们可以使用doFirst：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello3 &#123;</span><br><span class="line">   doFirst &#123;</span><br><span class="line">      println <span class="string">'hello3'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的3个例子中，Gradle的DSL向我们展示了一种非常自然的风格来创建Task，而事实上这些都只是一种内部DSL，也即必须符合groovy的语法要求。上面的task关键字实际上是一个方法调用，该方法属于Project。Project中存在多个重载的task()方法。和Ruby等动态语言一样，在调用groovy方法时，我们不用将参数放在括号里面。</p>
<p>以上我们自定义的3个Task都位于TaskContainer中，Project中的tasks属性即表示该TaskContainer。为此，我们可以新建一个Task来显示这些信息：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task showTasks &#123;</span><br><span class="line">   println tasks.<span class="keyword">class</span></span><br><span class="line">   println tasks.size()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将以上4个Task放在同一个build.gradle中，再执行gradle showTasks，命令行输出如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="number">-4.3</span>$ gradle showTasks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">gradle</span>.<span class="title">api</span>.<span class="title">internal</span>.<span class="title">tasks</span>.<span class="title">DefaultTaskContainer_Decorated</span></span></span><br><span class="line"><span class="class">4</span></span><br><span class="line">:showTasks UP-TO-DATE</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total <span class="string">time:</span> <span class="number">2.161</span> secs</span><br></pre></td></tr></table></figure>

<p>上面的DefaultTaskContainer_Decorated表示tasks类型，而4表示该TaskContainer中包含有4个自定义的Task——包括showTasks本身。</p>
<p><strong>通过TaskContainer的create()方法创建Task</strong></p>
<p>在上文中我们讲到，通过task()方法创建的Task都被存放在了TaskContainer中，而Project又维护了一个TaskContainer类型的属性tasks，那么我们完全可以直接向TaskContainer里面添加Task。查查TaskContainer的API文档可以发现，TaskContainer向我们提供了大量重载的create()方法用于添加Task。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.create(<span class="string">name:</span> <span class="string">'hello4'</span>) &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">'hello4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明Task之间的依赖关系</strong></p>
<p>Task之间是可以存在依赖关系，比如TaskA依赖TaskB，那么在执行TaskA时，Gradle会先执行TaskB，再执行TaskA。我们可以在定义一个Task的同时声明它的依赖关系：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello5(<span class="string">dependsOn:</span>hello4) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'hello5'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以在定义Task之后再声明依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello6 &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">'hello6'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello6.dependsOn hello5</span><br></pre></td></tr></table></figure>

<p><strong>配置Task</strong></p>
<p>一个Task除了执行操作之外，还可以包含多个Property，其中有Gradle为每个Task默认定义的Property，比如description，logger等。另外，每一个特定的Task类型还可以含有特定的Property，比如Copy的from和to等。当然，我们还可以动态地向Task中加入额外的Property。在执行一个Task之前，我们通常都需要先设定Property的值，Gradle提供了多种方法设置Task的Property值。</p>
<p>首先，我们可以在定义Task的时候对Property进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task hello7 &lt;&lt; &#123;</span><br><span class="line">   description = <span class="string">"this is hello7"</span> </span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以通过闭包的方式来配置一个已有的Task：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task hello8 &lt;&lt; &#123;</span><br><span class="line">	println description</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello8 &#123;</span><br><span class="line">	description = <span class="string">"this is hello8"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，对hello8的description设置发生在创建该Task之后，在执行“gradle hello8”时，命令行依然可以打印出正确的“this is hello8”，这是因为Gradle在执行Task时分为两个阶段，首先是配置阶段，然后才是实际执行阶段。所以在执行hello8之前，Gradle会扫描整个build.gradle文档，将hello8的description设置为“this is hello8”，然后执行hello8，此时hello8的description已经包含了设置后的值。</p>
<p>我们还可以通过调用Task的configure()方法完成Property的设置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task hello9 &lt;&lt; &#123;</span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello9.configure &#123;</span><br><span class="line">   description = <span class="string">"this is hello9"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，通过闭包的方式配置Task在内部也是通过调用Task的configure()方法完成的，对此我们将在后续的文章中详细地讲到。</p>
<h1 id="读懂Gradle语法"><a href="#读懂Gradle语法" class="headerlink" title="读懂Gradle语法"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-3.html" target="_blank" rel="noopener">读懂Gradle语法</a></h1><p>Gradle是一种声明式的构建工具。在执行时，Gradle并不会一开始便顺序执行build.gradle文件中的内容，而是分为两个阶段，第一个阶段是配置阶段，然后才是实际的执行阶段。在配置阶段，Gradle将读取所有build.gradle文件的所有内容来配置Project和Task等，比如设置Project和Task的Property，处理Task之间的依赖关系等。</p>
<p>虽然很多时候我们只需要照着网上的例子写自己的DSL语句就行了，但是此时我们所知道的也就只有这么多了。如果我们能够了解Gradle DSL的内部工作机制，那么我们便可以达到举一反三的效果。在前面的文章中我们讲到，Gradle的DSL只是Groovy语言的内部DSL，也即必须遵循Groovy的语法规则。现在，让我们先来看看以下非常简单的Task：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">task showDescription1 &lt;&lt; &#123;</span><br><span class="line">   description = <span class="string">'this is task showDescription'</span></span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task showDescription2 &lt;&lt; &#123;</span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br><span class="line">showDescription2.description = <span class="string">'this is task showDescription'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task showDescription3 &lt;&lt; &#123;</span><br><span class="line">   println description</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDescription3 &#123;</span><br><span class="line">   description = <span class="string">'this is task showDescription'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上3个Task完成的功能均相同，即先设置Task的description属性，在将其输出到命令行。但是，他们对description的设置方式是不同的。对于showDescription1，我们在定义一个Task的同时便设置description；对于showDescription2，其本身便是Project的一个Property；而对于showDescription3，我们是在一个和它同名的方法中设置description。</p>
<p><strong>事实上，对于每一个Task，Gradle都会在Project中创建一个同名的Property，所以我们可以将该Task当作Property来访问，showDescription2便是这种情况。另外，Gradle还会创建一个同名的方法，该方法接受一个闭包，我们可以使用该方法来配置Task，showDescription3便是这种情况。</strong></p>
<p>要读懂Gradle，我们首先需要了解Groovy语言中的两个概念，一个Groovy中的<code>Bean</code>概念，一个是<code>Groovy闭包的delegate机制</code>。</p>
<p>Groovy中的Bean和Java中的Bean有一个很大的不同，即Groovy为每一个字段都会自动生成getter和setter，并且我们可以通过像访问字段本身一样调用getter和setter，比如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroovyBeanExample</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> bean = <span class="keyword">new</span> GroovyBeanExample()</span><br><span class="line">bean.name = <span class="string">'this is name'</span></span><br><span class="line">println bean.name</span><br></pre></td></tr></table></figure>

<p>我们看到，GroovyBeanExample只定义了一个私有的name属性，并没有getter和setter。但是在使用时，我们可以直接对name进行访问，无论时读还是写。事实上，我们并不是在直接访问name属性，当我们执行”bean.name = ‘this is name’”时，我们实际调用的是”bean.setName(‘this is name’)”，而在调用”println bean.name”时，我们实际调用的是”println bean.getName()”。这里的原因在于，Groovy动态地为name创建了getter和setter，采用像直接访问的方式的目的是为了增加代码的可读性，使它更加自然，而在内部，Groovy依然是在调用setter和getter方法。这样，我们便可以理解上面对showDescription2的description设置原理。</p>
<p>另外，Gradle大量地使用了Groovy闭包的delegate机制。简单来说，delegate机制可以使我们将一个闭包中的执行代码的作用对象设置成任意其他对象。比如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line">   Child child = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> configChild(Closure c) &#123;</span><br><span class="line">      c.delegate = child</span><br><span class="line">      c.setResolveStrategy Closure.DELEGATE_FIRST</span><br><span class="line">      c()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> parent = <span class="keyword">new</span> Parent()</span><br><span class="line">parent.configChild &#123;</span><br><span class="line">	name = <span class="string">"child name"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println parent.child.name</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，当我们调用configChild()方法时，我们并没有指出name属性是属于Child的，但是它的确是在设置Child的name属性。事实上光从该方法的调用中，我们根本不知道name是属于哪个对象的，你可能会认为它是属于Parent的。真实情况是，在默认情况下，name的确被认为是属于Parent的，但是我们在configChild()方法的定义中做了手脚，使其不再访问Parent中的name（Parent也没有name属性），而是Child的name。在configChild()方法中，我们将该方法接受的闭包的delegate设置成了child，然后将该闭包的ResolveStrategy设置成了DELEGATE_FIRST。这样，在调用configChild()时，所跟闭包中代码被代理到了child上，即这些代码实际上是在child上执行的。此外，闭包的ResolveStrategy在默认情况下是OWNER_FIRST，即它会先查找闭包的owner（这里即parent），如果owner存在，则在owner上执行闭包中的代码。这里我们将其设置成了DELEGATE_FIRST，即该闭包会首先查找delegate（本例中即child），如果找到，该闭包便会在delegate上执行。对于上面的showDescription3，便是这种情况。当然，实际情况会稍微复杂一点，比如showDescription3()方法会在内部调用showDescription3的configure()方法，再在configure()方法中执行闭包中的代码。</p>
<p>你可能会发现，在使用Gradle时，我们并没有像上面的parent.configChild()一样指明方法调用的对象，而是在build.gradle文件中直接调用task()，apply()和configuration()方法等，这是因为在没有说明调用对象的情况下，Gradle会自动将调用对象设置成当前Project。比如调用apply()方法和调用project.apply()方法的效果是一样的。查查Gradle的Project文档，你会发现这些方法都是Project类的方法。</p>
<p>另外举个例子，对于configurations()方法（它的作用我们将在后面的文章中讲到），该方法实际上会将所跟闭包的delegate设置成ConfigurationContainer，然后在该ConfigurationContainer上执行闭包中的代码。再比如，dependencies()方法，该方法会将所跟闭包的delegate设置成DependencyHandler。</p>
<p>还有，Project还定义了configure(Object object,Closure configureClosure)方法，该方法是专门用来配置对象的（比如Task），它会将configureClosure的delegate设置成object，之后configureClosure中的执行代码其实是在object上执行的。和Groovy Bean一样，delegate机制的一个好处是可以增加所创建DSL的可读性。</p>
<h1 id="增量式构建"><a href="#增量式构建" class="headerlink" title="增量式构建"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-4.html" target="_blank" rel="noopener">增量式构建</a></h1><p>如果我们将Gradle的Task看作一个黑盒子，那么我们便可以抽象出输入和输出的概念，一个Task对输入进行操作，然后产生输出。比如，在使用java插件编译源代码时，输入即为Java源文件，输出则为class文件。如果多次执行一个Task时的输入和输出是一样的，那么我们便可以认为这样的Task是没有必要重复执行的。此时，反复执行相同的Task是冗余的，并且是耗时的。</p>
<p>为了解决这样的问题，Gradle引入了增量式构建的概念。在增量式构建中，我们为每个Task定义输入（inputs）和输入（outputs），如果在执行一个Task时，如果它的输入和输出与前一次执行时没有发生变化，那么Gradle便会认为该Task是最新的（UP-TO-DATE），因此Gradle将不予执行。一个Task的inputs和outputs可以是一个或多个文件，可以是文件夹，还可以是Project的某个Property，甚至可以是某个闭包所定义的条件。</p>
<p>每个Task都拥有inputs和outputs属性，他们的类型分别为TaskInputs和TaskOutputs。在下面的例子中，我们展示了这么一种场景：名为combineFileContent的Task从sourceDir目录中读取所有的文件，然后将每个文件的内容合并到destination.txt文件中。让我们先来看看没有定义Task输入和输出的情况：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task combineFileContentNonIncremental &#123;</span><br><span class="line">   <span class="keyword">def</span> sources = fileTree(<span class="string">'sourceDir'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> destination = file(<span class="string">'destination.txt'</span>)</span><br><span class="line"></span><br><span class="line">   doLast &#123;</span><br><span class="line">      destination.withPrintWriter &#123; writer -&gt;</span><br><span class="line">         sources.each &#123;source -&gt;</span><br><span class="line">            writer.println source.text</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次执行“gradle combineFileContentNonIncremental”时，整个Task都会反复执行，即便在第一次执行后我们已经得到了所需的结果。如果该combineFileContentNonIncremental是一个繁重的Task，那么多次重复执行势必造成没必要的时间耗费。</p>
<p>这时，我们可以将sources声明为该Task的inputs，而将destination声明为outputs，重新创建一个Task如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task combineFileContentIncremental &#123;</span><br><span class="line">   <span class="keyword">def</span> sources = fileTree(<span class="string">'sourceDir'</span>)</span><br><span class="line">   <span class="keyword">def</span> destination = file(<span class="string">'destination.txt'</span>)</span><br><span class="line"></span><br><span class="line">   inputs.dir sources</span><br><span class="line">   outputs.file destination</span><br><span class="line"></span><br><span class="line">   doLast &#123;</span><br><span class="line">      destination.withPrintWriter &#123; writer -&gt;</span><br><span class="line">         sources.each &#123;source -&gt;</span><br><span class="line">            writer.println source.text</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下，后一个Task只比前一个Task多了两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputs.dir sources</span><br><span class="line">outputs.file destination</span><br></pre></td></tr></table></figure>

<p>当首次执行combineFileContentIncremental时，Gradle会完整地执行该Task。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$ gradle combineFileContentIncremental</span><br><span class="line">:combineFileContentIncremental</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.286 secs</span><br></pre></td></tr></table></figure>

<p>但是紧接着再执行一次，命令行显示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="number">-4.3</span>$ gradle combineFileContentIncremental</span><br><span class="line">:combineFileContentIncremental UP-TO-DATE</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total <span class="string">time:</span> <span class="number">1.872</span> secs</span><br></pre></td></tr></table></figure>

<p>我们发现，combineFileContentIncremental被标记为UP-TO-DATE，表示该Task是最新的，Gradle将不予执行。在实际应用中，你将遇到很多这样的情况，因为Gradle的很多插件都引入了增量式构建机制。</p>
<p>如果我们修改了inputs（即sourceDir文件夹）中的任何一个文件或删除掉了destination.txt，当调用“gradle combineFileContentIncremental”时，Gradle又会重新执行，因为此时的Task已经不再是最新的了。对于outputs，我们还可以使用upToDateWhen()方法来决定一个Task的outputs是否为最新的，该方法接受一个闭包作为检查条件，感兴趣的读者可以自行了解。</p>
<h1 id="自定义Property"><a href="#自定义Property" class="headerlink" title="自定义Property"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-5.html" target="_blank" rel="noopener">自定义Property</a></h1><p>在前面的文章中我们讲到，设置和读取Project的Property是使用Gradle的一个很重要的方面。比如，很多Plugin都会向Project中加入额外的Property，在使用这些Plugin时，我们需要对这些Property进行赋值。</p>
<p>Gradle在默认情况下已经为Project定义了很多Property，其中比较常用的有：</p>
<ul>
<li>project：Project本身</li>
<li>name：Project的名字</li>
<li>path：Project的绝对路径</li>
<li>description：Project的描述信息</li>
<li>buildDir：Project构建结果存放目录</li>
<li>version：Project的版本号</li>
</ul>
<p>以下，我们首先设置Project的version和description属性，再定义showProjectProperties以打印这些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version = &apos;this is the project version&apos;</span><br><span class="line">description = &apos;this is the project description&apos;</span><br><span class="line"></span><br><span class="line">task showProjectProperties &lt;&lt; &#123;</span><br><span class="line">   println version</span><br><span class="line">   println project.description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在打印description时，我们使用了project.description，而不是直接使用description。原因在于，Project和Task都拥有description属性，而定义Task的闭包将delegate设置成了当前的Task，故如果直接使用description，此时打印的是showProjectProperties的description，而不是Project的，所以我们需要显式地指明project。</p>
<p>Gradle还为我们提供了多种方法来自定义Project的Property。</p>
<p><strong>在build.gradle文件中定义Property</strong></p>
<p>在build.gradle文件中向Project添加额外的Property时，我们并不能直接定义，而是应该通过ext来定义。如果要添加一个名为property1的Property，我们应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext.property1 = &quot;this is property1&quot;</span><br></pre></td></tr></table></figure>

<p>另外，我们也可以通过闭包的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">   property2 = &quot;this is property2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在定义了Property后，使用这些Property时我们则不需要ext，而是可以直接访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task showProperties &lt;&lt; &#123;</span><br><span class="line">   println property1</span><br><span class="line">   println property2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 事实上，任何实现了ExtensionAware接口的Gradle对象都可以通过这种方式来添加额外的Property，比如Task也实现了该接口。</p>
<p><strong>通过命令行参数定义Property</strong></p>
<p>Gradle还提供了-P命令行参数来设置Property，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task showCommandLieProperties &lt;&lt; &#123;</span><br><span class="line">   println property3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行“gradle showCommandLieProperties”时，终端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:showCommandLieProperties&apos;.</span><br><span class="line">&gt; Could not find property &apos;property3&apos; on task &apos;:showCommandLieProperties&apos;.</span><br></pre></td></tr></table></figure>

<p>表示property3并没有被定义，在调用gradle命令时，通过-P参数传入该Property：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -Pproperty3=&quot;this is property3&quot; showCommandLieProperties</span><br></pre></td></tr></table></figure>

<p>此时终端显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:showCommandLieProperties</span><br><span class="line">this is property3</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>

<p> <strong>通过JVM系统参数定义Property</strong>　　</p>
<p>我们知道，在java中，我们可以通过-D参数定义JVM的系统参数，然后在代码中可以可以通过System.getProperty()进行获取。在Gradle中，我们也可以通过-D的方式向Project传入Property，只是此时我们需要遵循一些约定：每一个通过-D方式声明的Property都需要以“org.gradle.project”为前缀，对于上面的showCommandLieProperties，我们也可以通过以下方式设置property3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -D org.gradle.project.property3=&quot;this is another property3&quot; showCommandLieProperties</span><br></pre></td></tr></table></figure>

<p><strong>通过环境变量设置Property</strong><br>我们还可以通过设置环境变量的方式设置Project的Property。这种方式和（3）一样，需要我们遵循一些约定：在定义环境变量时，每一个Property都需要以“ORG_GRADLE_PROJECT_”为前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ORG_GRADLE_PROJECT_property3=&quot;this is yet another property3&quot;</span><br></pre></td></tr></table></figure>

<p>在调用showCommandLieProperties时，我们便不需要传入命令行参数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle showCommandLieProperties</span><br></pre></td></tr></table></figure>

<p>在原作者所工作的项目中，我们的持续集成服务器便是通过这种方式为Gradle设置Property的。 </p>
<h1 id="使用Java-Plugin"><a href="#使用Java-Plugin" class="headerlink" title="使用Java Plugin"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-6.html" target="_blank" rel="noopener">使用Java Plugin</a></h1><p>Gradle最常用的Plugin便是java Plugin了。和其他Plugin一样，java Plugin并没有什么特别的地方，只是向Project中引入了多个Task和Property。当然，java Plugin也有比较与众不同的地方，其中之一便是它在项目中引入了构建生命周期的概念，就像Maven一样。但是，和Maven不同的是，Gradle的项目构建生命周期并不是Gradle的内建机制，而是由Plugin自己引入的。</p>
<p><strong>java Plugin引入的主要Task</strong></p>
<p>执行“gradle build”，我们已经可以看到java Plugin所引入的主要Task：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:compileJava</span><br><span class="line">:processResources</span><br><span class="line">:classes</span><br><span class="line">:jar</span><br><span class="line">:assemble</span><br><span class="line">:compileTestJava</span><br><span class="line">:processTestResources</span><br><span class="line">:testClasses</span><br><span class="line">:test</span><br><span class="line">:check</span><br><span class="line">:build</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 4.813 secs</span><br></pre></td></tr></table></figure>

<p>build也是java Plugin所引入的一个Task，它依赖于其他Task，其他Task又依赖于另外的Task，所以有了以上Task执行列表。以上Task执行列表基本上描述了java Plugin向项目中所引入的构建生命周期概念。</p>
<p>除了定义众多的Task外，java Plugin还向Project中加入了一些额外的Property。比如，sourceCompatibility用于指定在编译Java源文件时所使用的Java版本，archivesBaseName用于指定打包成Jar文件时的文件名称。</p>
<p><strong>Java项目的目录结构</strong></p>
<p>在默认情况下，Gradle采用了与Maven相同的Java项目目录结构：</p>


<p><strong>配置已有source set</strong>　</p>
<p>Gradle在采用了Maven目录结构的同时，还融入了自己的一些概念，即source set。对于上图中的目录结构，Gradle实际上为我们创建了2个source set，一个名为main，一个名为test。　　</p>
<p>　　请注意，这里的source set的名字main与上图目录结构中的main文件夹并无必然的联系，只是在默认情况下，Gradle为了source set概念到文件系统目录结构的映射方便，才采用了相同的名字。对于test， 也是如此。我们完全可以在build.gradle文件中重新配置这些source set所对应的目录结构，同时，我们还可以创建新的source set。</p>
<p>　　从本质上讲，Gradle的每个source set都包含有一个名字，并且包含有一个名为java的Property和一个名为resources的Property，他们分别用于表示该source set所包含的Java源文件集合和资源文件集合。在实际应用时，我们可以将他们设置成任何目录值。比如，我们可以重新设置main的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">   main &#123;</span><br><span class="line">      java &#123;</span><br><span class="line">         srcDir &apos;java-sources&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      resources &#123;</span><br><span class="line">         srcDir &apos;resources&apos;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时所对应的项目目录结构如下：</p>


<p>我们重新设置了main的目录结构，而对于test，我们保留了Gradle默认的目录结构。</p>
<p><strong>创建新的source set</strong></p>
<p>要创建一个新的source set也是非常简单的，比如，我们可以创建一个名为api的source set来存放程序中的接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">   api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上配置也可以与main放在一起。在默认情况下，该api所对应的Java源文件目录被Gradle设置为<code>${path-to-project}/src/api/java</code>，而资源文件目录则被设置成了<code>${path-to-project}/src/api/resources</code>。我们也可以像上面的main一样重新对api的目录结构进行配置。</p>
<p>Gradle会自动地为每一个新创建的source set创建相应的Task，创建规律为：对于名为mySourceSet的source set，Gradle将为其创建<code>compile&lt;mySourceSet&gt;Java</code>、<code>process&lt;mySourceSet&gt;Resources</code>和`<mysourceset>Classes这3个Task。对于这里api而言，Gradle会为其创建名为compileApiJava、processApiResource和apiClasses Task。我们可以在命令行中执行”gradle apiClasses”。</mysourceset></p>
<p>你可能会注意到，对于main而言，Gradle并没有相应的compileMainJava，原因在于：由于main是Gradle默认创建的source set，并且又是及其重要的source set，Gradle便省略掉了其中的“Main”，而是直接使用了compileJava作为main的编译Task。对于test来说，Gradle依然采用了compileTestJava。</p>
<p>通常的情况是，我们自己创建的名为api的source set会被其他source set所依赖，比如main中的类需要实现api中的某个接口等。此时我们需要做两件事情。第一，我们需要在编译main之前对api进行编译，即编译main中Java源文件的Task应该依赖于api中的Task：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classes.dependsOn apiClasses</span><br></pre></td></tr></table></figure>

<p>第二，在编译main时，我们需要将api编译生成的class文件放在main的classpath下。此时，我们可以对main和test做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">   main &#123;</span><br><span class="line">      compileClasspath = compileClasspath + files(api.output.classesDir)</span><br><span class="line">   &#125;</span><br><span class="line">   test &#123;</span><br><span class="line">      runtimeClasspath = runtimeClasspath + files(api.output.classesDir)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以需要对test的runtimeClasspath进行设置，是因为在运行测试时我们也需要加载api中的类。</p>
<h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-7.html" target="_blank" rel="noopener">依赖管理</a></h1><p>一个Java项目总会依赖于第三方，要么是一个第三方类库，比如Apache commons；要么是你自己开发的另外一个Java项目，比如你的web项目依赖于另一个核心的业务项目。通常来说，这种依赖的表示形式都是将第三方的Jar文件放在自己项目的classpath下，要么是编译时的classpath，要么是运行时的classpath。</p>
<p>在声明对第三方类库的依赖时，我们需要告诉Gradle在什么地方去获取这些依赖，即配置Gradle的Repository。在配置好依赖之后，Gradle会自动地下载这些依赖到本地。Gradle可以使用Maven和Ivy的Repository，同时它还可以使用本地文件系统作为Repository。</p>
<p>在本文中，我们将以Maven的Repository为例进行讲解，要配置Maven的Repository是非常简单的，我们只需要在build.gradle文件中加入以下代码即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">   mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Gradle将对依赖进行分组，比如编译Java时使用的是这组依赖，运行Java时又可以使用另一组依赖。每一组依赖称为一个Configuration，在声明依赖时，我们实际上是在设置不同的Configuration。值得一提的是，将依赖称为Configuration并不是一个好的名字，更好的应该叫作诸如“DependencyGroup”之类的。但是，习惯了就好的。</p>
<p>要定义一个Configuration，我们可以通过以下方式完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">   myDependency</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上只是定义了一个名为myDependency的Configuration，我们并未向其中加入依赖。我们可以通过dependencies()方法向myDependency中加入实际的依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   myDependency &apos;org.apache.commons:commons-lang3:3.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 以上，我们将Apache的commons加入了myDependency中。之后，如果有Task需要将Apache commons加入到classpath中，我们可以通过以下方式进行获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task showMyDependency &lt;&lt; &#123;</span><br><span class="line">   println configurations.myDependency.asPath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行“gradle showMyDependency”命令，在笔者的电脑上终端将显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$ gradle showMyDependency</span><br><span class="line">:showMyDependency</span><br><span class="line">Download https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.0/commons-lang3-3.0.pom</span><br><span class="line">Download https://repo1.maven.org/maven2/org/apache/commons/commons-parent/21/commons-parent-21.pom</span><br><span class="line">Download https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.0/commons-lang3-3.0.jar</span><br><span class="line">/home/aprz/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-lang3/3.0/8873bd0bb5cb9ee37f1b04578eb7e26fcdd44cb0/commons-lang3-3.0.jar</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 10.152 secs</span><br></pre></td></tr></table></figure>

<p>在实际应用时，比如我们需要调用Ant的某个target，而该target在执行时需要设置classpath，那么我们便可以通过以上方式进行设置。</p>
<p>下面，我们来看一个Java项目，该项目依赖于SLF4J，而在测试时依赖于Junit。在声明依赖时，我们可以通过以下方式进行设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile &apos;org.slf4j:slf4j-log4j12:1.7.2&apos;</span><br><span class="line">   testCompile &apos;junit:junit:4.8.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们并没有定义名为compile和testCompile的Configuration，这是这么回事呢？原因在于，java Plugin会自动定义compile和testCompile，分别用于编译Java源文件和编译Java测试源文件。　　另外，java Plugin还定义了runtime和testRuntime这两个Configuration，分别用于在程序运行和测试运行时加入所配置的依赖。</p>
<p>再举个来自Gradle官网的例子：在Gradle中调用Ant，首先我们通过Configuration声明一组依赖，然后在Ant定义中将该Configuration所表示的classpath传给Ant：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">   pmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">   pmd group: &apos;pmd&apos;, name: &apos;pmd&apos;, version: &apos;4.2.5&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task check &lt;&lt; &#123;</span><br><span class="line">   ant.taskdef(name: &apos;pmd&apos;, classname: &apos;net.sourceforge.pmd.ant.PMDTask&apos;, classpath: configurations.pmd.asPath)</span><br><span class="line">   ant.pmd(shortFilenames: &apos;true&apos;, failonruleviolation: &apos;true&apos;, rulesetfiles: file(&apos;pmd-rules.xml&apos;).toURI().toString()) &#123;</span><br><span class="line">      formatter(type: &apos;text&apos;, toConsole: &apos;true&apos;)</span><br><span class="line">      fileset(dir: &apos;src&apos;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在依赖冲突，在默认情况下，Gradle会选择最新版本，这和Maven是不同的，Maven会选择离依赖树最近的版本。当然，我们可以通过设置Configuration的resolutionStrategy来重新设置依赖冲突的处理规则，对此本文将不予讲解。</p>
<p>除了可以加入Maven和Ivy的Repository中的依赖之外，Gradle还允许我们声明对其他Project或者文件系统的依赖。比如，如果ProjectA的compileJava依赖于ProjectB，那么可以在ProjectA中声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile project(&apos;:ProjectB&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 另外，对于本地文件系统中的Jar文件，我们可以通过以下方式声明对其的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">   compile files(&apos;spring-core.jar&apos;, &apos;spring-aap.jar&apos;)</span><br><span class="line">   compile fileTree(dir: &apos;deps&apos;, include: &apos;*.jar&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建多个Project"><a href="#构建多个Project" class="headerlink" title="构建多个Project"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-8.html" target="_blank" rel="noopener">构建多个Project</a></h1><p>Gradle为每个build.gradle都会创建一个相应的Project领域对象，在编写Gradle脚本时，我们实际上是在操作诸如Project这样的Gradle领域对象。在多Project的项目中，我们会操作多个Project领域对象。Gradle提供了强大的多Project构建支持。</p>
<p>要创建多Project的Gradle项目，我们首先需要在根（Root）Project中加入名为settings.gradle的配置文件，该文件应该包含各个子Project的名称。比如，我们有一个根Project名为root-project，它包含有两个子Project，名字分别为sub-project1和sub-project2，此时对应的文件目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root-project/</span><br><span class="line">   sub-project1/</span><br><span class="line">      build.gradle</span><br><span class="line">   sub-project2/</span><br><span class="line">      build.gradle</span><br><span class="line">build.gradle</span><br><span class="line">settings.gradle</span><br></pre></td></tr></table></figure>

<p>root-project本身也有自己的build.gradle文件，同时它还拥有settings.gradle文件位于和build.gradle相同的目录下。此外，两个子Project也拥有他们自己的build.gradle文件。</p>
<p>要将sub-project1和sub-project2加入到root-project的子Project中，我们需要在settings.gradle中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &apos;sub-project1&apos;, &apos;sub-project2&apos;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来定义一个Task用于显示每个Project各自的名称。我们可以在每个build.gradle进行定义，但是这却是一种比较笨的方法，此时我们也完全没有享受到Gradle的多Project构建功能所带来的好处。在Gradle中，我们可以通过根Project的allprojects()方法将配置一次性地应用于所有的Project，当然也包括定义Task。比如，在root-project的build.gradle中，我们可以做以下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">   apply plugin: &apos;idea&apos;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   task allTask &lt;&lt; &#123;</span><br><span class="line">      println project.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上Gradle脚本将闭包中的代码应用在所有的Project中，包括root-project本身。我们首先将应用了idea Plugin用于生成IntelliJ工程，其次我们定义了名为allTask的Task，该Task应用于每个Project，作用是输出各个Project的名称。执行“gradle allTask”，命令行输出如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:allTask</span><br><span class="line">root-project</span><br><span class="line">:sub-<span class="string">project1:</span>allTask</span><br><span class="line">sub-project1</span><br><span class="line">:sub-<span class="string">project2:</span>allTask</span><br><span class="line">sub-project2</span><br></pre></td></tr></table></figure>

<p>我们看到，该allTask对于每个Project都执行了一次，在执行时输出了当前Project的名称。</p>
<p>除了allprojects()之外，Project还提供了subprojects()方法用于配置所有的子Project（不包含根Project）。比如，我们可以定义Task来只输出各个子Project的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">   task subTask &lt;&lt; &#123;</span><br><span class="line">      println project.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行“gradle subTask”，命令行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sub-project1:subTask</span><br><span class="line">sub-project1</span><br><span class="line">:sub-project2:subTask</span><br><span class="line">sub-project2</span><br></pre></td></tr></table></figure>

<p>此时的输出中不再包含root-project的名字。</p>
<p>上文中已经提到，在Gradle脚本中，我们实际上是在操作一些领域对象，因此我们可以将groovy的所有语言特性用在Gradle的领域对象上，比如我们可以对Project进行过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure(allprojects.findAll &#123; it.name.startsWith(&apos;sub&apos;) &#125;) &#123;</span><br><span class="line">   subTask &lt;&lt; &#123;</span><br><span class="line">      println &apos;this is a sub project&apos;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们先找到所有Project中名字以“sub”开头的Project，然后再对这些Project进行配置，在配置中，我们向这些Project的subTask中加入了一条额外的打印语句。</p>
<p>此时如果再执行“gradle subTask”，命令行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:sub-project1:subTask</span><br><span class="line">sub-project1</span><br><span class="line">this is a sub project</span><br><span class="line">:sub-project2:subTask</span><br><span class="line">sub-project2</span><br><span class="line">this is a sub project</span><br></pre></td></tr></table></figure>

<p>到此为止，我们所有的Task定义工作都是在root-project中进行的，而sub-project1和sub-project2中的build.gradle文件依然什么都没有。事实上，我们可以将所有对子Project的配置均放在根Project中进行。在上面的例子中，我们通过allprojects()和subprojects()将所有的子Project都包含在了配置之内，其实我们还可以对单个Project进行单独配置。比如，在root-project的build.gradle中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project(&apos;:sub-project1&apos;) &#123;</span><br><span class="line">   task forProject1 &lt;&lt; &#123;</span><br><span class="line">      println &apos;for project 1&apos;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 以上脚本向sub-project1中加入了名为forProject1的Task，在执行“gradle forProject1”时，终端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:sub-project1:forProject1</span><br><span class="line">for project 1</span><br></pre></td></tr></table></figure>

<p> 这里有一个问题：我们是在root-project下执行的命令，因此照理说Gradle会认为forProject1是定义在所有的Project上，而此时只有sub-project1才拥有该Task，Gradle应该抛出异常指示在root-project和sub-project2上找不到该Task才对，为什么它还是执行成功了呢？原因在于：只有当一个Task没有在任何Project中定义时，Gradle才会将其当做异常。否则，Gradle会在所有拥有该Task的Project上执行该Task。</p>
<p>一旦有了多个Project，他们之间便会存在着依赖关系。Gradle的Project之间的依赖关系是基于Task的，而不是整个Project的。</p>
<p>现在，让我们来看一个Project依赖的例子。比如sub-project1中有taskA和taskB，taskA依赖于taskB：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task taskA &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">'this is taskA from project 1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task taskB &lt;&lt; &#123;</span><br><span class="line">   println <span class="string">'this is taskB from project 1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taskA.dependsOn taskB</span><br></pre></td></tr></table></figure>

<p>在执行“gradle taskA”时，终端输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sub-project1:taskB</span><br><span class="line">this is taskB from project 1</span><br><span class="line">:sub-project1:taskA</span><br><span class="line">this is taskA from project 1</span><br></pre></td></tr></table></figure>

<p> 这个很容易理解，两个Task都是属于sub-project1的。但是，让我们再向其中加入一些复杂性。我们在sub-project2中定义taskC和taskD，然后使taskA再依赖于taskC，又使taskB依赖于taskD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//sub-project1:</span><br><span class="line">taskA.dependsOn &apos;:sub-project2:taskC&apos;</span><br><span class="line">taskB.dependsOn &apos;:sub-project2:taskD&apos;</span><br><span class="line"></span><br><span class="line">//sub-project2:</span><br><span class="line">task taskC &lt;&lt; &#123;</span><br><span class="line">   println &apos;this is taskC from project 2&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task taskD &lt;&lt; &#123;</span><br><span class="line">   println &apos;this is taskD from project 2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再执行“gradle taskA”，终端输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:sub-project2:taskD</span><br><span class="line">this is taskD from project 2</span><br><span class="line">:sub-project1:taskB</span><br><span class="line">this is taskB from project 1</span><br><span class="line">:sub-project2:taskC</span><br><span class="line">this is taskC from project 2</span><br><span class="line">:sub-project1:taskA</span><br><span class="line">this is taskA from project 1</span><br></pre></td></tr></table></figure>

<p>分析一下：taskA依赖于taskB，而taskB又依赖于taskD，所以sub-project1的taskD首先得到了执行，然后再执行sub-project1的taskB。之后，又由于taskA依赖于taskC，故Gradle再次转向sub-project1执行taskC，最后才执行taskA。</p>
<h1 id="自定义Task类型"><a href="#自定义Task类型" class="headerlink" title="自定义Task类型"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-9.html" target="_blank" rel="noopener">自定义Task类型</a></h1><p>在前面的文章中我们讲到，Gradle本身只是一个架子，真正起作用的是Task和Plugin。要真正了解Task和Plugin的工作机制并熟练运用，学会自定义Task类型和Plugin是大有裨益的。</p>
<p>Gradle中的Task要么是由不同的Plugin引入的，要么是我们自己在build.gradle文件中直接创建的。在默认情况下，我们所创建的Task是DefaultTask类型，该类型是一个非常通用的Task类型，而在有些时候，我们希望创建一些具有特定功能的Task，比如Copy和Jar等。还有时候，我们希望定义自己创建的Task类型，在本文中，我们以定义一个简单的HelloWorldTask为例，讲解如何自定义一个Task类型，并且如何对其进行配置。</p>
<p>在Gradle中，我们有3种方法可以自定义Task类型。</p>
<p><strong>在build.gradle文件中直接定义</strong></p>
<p>我们知道，Gradle其实就是groovy代码，所以在build.gradle文件中，我们便可以定义Task类。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">    <span class="meta">@Optional</span></span><br><span class="line">    String message = <span class="string">'I am davenkin'</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">def</span> hello()&#123;</span><br><span class="line">        println <span class="string">"hello world $message"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task hello(<span class="string">type:</span>HelloWorldTask)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task hello1(<span class="string">type:</span>HelloWorldTask)&#123;</span><br><span class="line">   message =<span class="string">"I am a programmer"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上例中，我们定义了一个名为HelloWorldTask的Task，它需要继承自DefaultTask，它的作用是向命令行输出一个字符串。@TaskAction表示该Task要执行的动作，即在调用该Task时，hello()方法将被执行。另外，message被标记为@Optional，表示在配置该Task时，message是可选的。在定义好HelloWorldTask后，我们创建了两个Task实例，第一个hello使用了默认的message值，而第二个hello1在创建时重新设置了message的值。</p>
<p>在执行hello时，命令行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:hello</span><br><span class="line">hello world I am davenkin</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.139 secs</span><br></pre></td></tr></table></figure>

<p>在执行hello1时，命令行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:hello1</span><br><span class="line">hello world I am a programmer</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>

<p> <strong>在当前工程中定义Task类型</strong></p>
<p>在（一）中，我们在build.gradle中直接定义了Task的类型，这样将Task的定义和使用混在一起。在需要定义的Task类型不多时，我们可以采用这种方法，但是在项目中存在大量的自定义Task类型时，这就不见得是中好的做法了。一种改进方法是在另外的一个gradle文件中定义这些Task，然后再apply到build.gradle文件中。这里，我们将使用另一种方法：在buildSrc目录下定义Task类型，Gradle在执行时，会自动地查找该目录下所定义的Task类型，并首先编译该目录下的groovy代码以供build.gradle文件使用。</p>
<p>在当前工程的buildSrc/src/main/groovy/davenkin目录下创建HelloWorldTask.groovy文件，将（1）中对HelloWorldTask的定义转移到该文件中：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> davenkin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.*</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.tasks.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">    <span class="meta">@Optional</span></span><br><span class="line">    String message = <span class="string">'I am davenkin'</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="keyword">def</span> hello()&#123;</span><br><span class="line">        println <span class="string">"hello world $message"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们将HelloWorldTask定义在了davenkin包下，因此在build.gradle文件中引用该Task时，我们需要它的全名称：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task hello(<span class="string">type:</span>davenkin.HelloWorldTask)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task hello1(<span class="string">type:</span>davenkin.HelloWorldTask)&#123;</span><br><span class="line">    message =<span class="string">"I am a programmer"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的hello和hello1与（1）中的hello和hello1完成的功能相同。</p>
<p><strong>在单独的项目中定义Task类型</strong></p>
<p>虽然（2）中的Task定义与build.gradle分离开了，但是它依然只能应用在当前工程中。如果我们希望所定义的Task能够用在另外的项目中，那么（2）中的方法便不可行的，此时我们可以将Task的定义放在单独的工程中，然后在所有使用Task的工程中通过声明依赖的方式引入这些Task。</p>
<p>创建另外一个项目，将（2）中buildSrc目录下的内容考到新建项目中，由于该项目定义Task的文件是用groovy写的，因此我们需要在该项目的build.gradle文件中引入groovy Plugin。另外，由于该项目的输出需要被其他项目所使用，因此我们还需要将其上传到repository中，在本例中，我们将该项目生成的包含了Task定义的jar文件上传到了本地的文件系统中。最终的build.gradle文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">version = &apos;1.0&apos;</span><br><span class="line">group = &apos;davenkin&apos;</span><br><span class="line">archivesBaseName = &apos;hellotask&apos;</span><br><span class="line"></span><br><span class="line">repositories.mavenCentral()</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    groovy localGroovy()</span><br><span class="line">&#125;</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(url: &apos;file:../lib&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行“gradle uploadArchives”，所生成的jar文件将被上传到上级目录的lib(../lib)文件夹中。</p>
<p>在使用该HelloWorldTask时，客户端的build.gradle文件可以做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;file:../lib&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath group: &apos;davenkin&apos;, name: &apos;hellotask&apos;, version: &apos;1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task hello(type: davenkin.HelloWorldTask)</span><br></pre></td></tr></table></figure>

<p>首先，我们需要告诉Gradle到何处去取得依赖，即配置repository。另外，我们需要声明对HelloWorldTask的依赖，该依赖用于当前build文件。之后，对hello的创建与（2）中一样。</p>
<h1 id="自定义Plugin（本系列完）"><a href="#自定义Plugin（本系列完）" class="headerlink" title="自定义Plugin（本系列完）"></a><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-10.html" target="_blank" rel="noopener">自定义Plugin（本系列完）</a></h1><p>在Plugin中，我们可以向Project中加入新的Task，定义configurations和property等。我们3种方法可以自定义Plugin，这些方法和自定义Task类型的3种方法相似。在接下来的例子中，我们将分别通过这3种方法来创建一个DateAndTimePlugin，该Plugin定义了2个Task，分别用于输出系统当前的日期和时间，另外，我们可以配置日期和时间的输出格式。</p>
<p><strong>（一）在build.gradle文件中直接定义Plugin</strong></p>
<p>和在build.gradle文件中定义Task类型一样，我们可以将对Plugin的定义直接写在build.gradle中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: DateAndTimePlugin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dateAndTime &#123;</span><br><span class="line">    timeFormat = &apos;HH:mm:ss.SSS&apos;</span><br><span class="line">    dateFormat = &apos;MM/dd/yyyy&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DateAndTimePlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        project.extensions.create(&quot;dateAndTime&quot;, DateAndTimePluginExtension)</span><br><span class="line"></span><br><span class="line">        project.task(&apos;showTime&apos;) &lt;&lt; &#123;</span><br><span class="line">            println &quot;Current time is &quot; + new Date().format(project.dateAndTime.timeFormat)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        project.tasks.create(&apos;showDate&apos;) &lt;&lt; &#123;</span><br><span class="line">            println &quot;Current date is &quot; + new Date().format(project.dateAndTime.dateFormat)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DateAndTimePluginExtension &#123;</span><br><span class="line">    String timeFormat = &quot;MM/dd/yyyyHH:mm:ss.SSS&quot;</span><br><span class="line">    String dateFormat = &quot;yyyy-MM-dd&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个自定义的Plugin都需要实现Plugin<t>接口，事实上，除了给Project编写Plugin之外，我们还可以为其他Gradle类编写Plugin。该接口定义了一个apply()方法，在该方法中，我们可以操作Project，比如向其中加入Task，定义额外的Property等。</t></p>
<p>在上例中，我们在DateAndTimePlugin中向Project添加了2个Task，一个名为showTime，一个名为showDate。请注意创建这2个Task所使用的不同方法，更多的创建Task的方法，请参考本系列<a href="http://www.cnblogs.com/davenkin/p/gradle-learning-2.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>每个Gradle的Project都维护了一个ExtenionContainer，我们可以通过project.extentions进行访问，比如读取额外的Property和定义额外的Property等。在DateAndTimePlugin中，我们向Project中定义了一个名为dateAndTime的extension，并向其中加入了2个Property，分别为timeFormat和dateFormat，他们又分别用于showTime和showDate。在使用该Plugin时，我们可以通过以下方式对这两个Property进行重新配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dateAndTime &#123;</span><br><span class="line">    timeFormat = <span class="string">'HH:mm:ss.SSS'</span></span><br><span class="line">    dateFormat = <span class="string">'MM/dd/yyyy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（二）在当前工程中定义Plugin</strong></p>
<p>在当前工程中的buildSrc/src/main/groovy/davenkin目录下创建DateAndTimePlugin.groovy文件，将build.gradle中定义DateAndTimePlugin的代码提取到给文件中，但是除去对DateAndTimePluginExtension的定义，因为我们将在另外一个单独的文件中定义DateAndTimePluginExtension。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> davenkin</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateAndTimePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        project.extensions.create(<span class="string">"dateAndTime"</span>, DateAndTimePluginExtension)</span><br><span class="line"></span><br><span class="line">        project.task(<span class="string">'showTime'</span>) &lt;&lt; &#123;</span><br><span class="line">            println <span class="string">"Current time is "</span> + <span class="keyword">new</span> Date().format(project.dateAndTime.timeFormat)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        project.tasks.create(<span class="string">'showDate'</span>) &lt;&lt; &#123;</span><br><span class="line">            println <span class="string">"Current date is "</span> + <span class="keyword">new</span> Date().format(project.dateAndTime.dateFormat)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建DateAndTimePluginExtension.groovy：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> davenkin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateAndTimePluginExtension</span> &#123;</span></span><br><span class="line">    String timeFormat = <span class="string">"MM/dd/yyyyHH:mm:ss.SSS"</span></span><br><span class="line">    String dateFormat = <span class="string">"yyyy-MM-dd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们将2个类文件都放在了davenkin包下。Gradle在执行时，会自动扫描buildSrc目录，并会在执行Task之前构建该目录下的内容。在build.gradle文件中，在apply该Plugin时，我们需要声明对该Plugin的全名称，即包含报名：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> davenkin.DateAndTimePlugin</span><br><span class="line"></span><br><span class="line">dateAndTime &#123;</span><br><span class="line">    timeFormat = <span class="string">'HH:mm:ss.SSS'</span></span><br><span class="line">    dateFormat = <span class="string">'MM/dd/yyyy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行“gradle showTime”，命令行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">:buildSrc:compileJava UP-TO-DATE</span><br><span class="line">:buildSrc:compileGroovy UP-TO-DATE</span><br><span class="line">:buildSrc:processResources UP-TO-DATE</span><br><span class="line">:buildSrc:classes UP-TO-DATE</span><br><span class="line">:buildSrc:jar UP-TO-DATE</span><br><span class="line">:buildSrc:assemble UP-TO-DATE</span><br><span class="line">:buildSrc:compileTestJava UP-TO-DATE</span><br><span class="line">:buildSrc:compileTestGroovy UP-TO-DATE</span><br><span class="line">:buildSrc:processTestResources UP-TO-DATE</span><br><span class="line">:buildSrc:testClasses UP-TO-DATE</span><br><span class="line">:buildSrc:test UP-TO-DATE</span><br><span class="line">:buildSrc:check UP-TO-DATE</span><br><span class="line">:buildSrc:build UP-TO-DATE</span><br><span class="line">:showTime</span><br><span class="line">Current time is 19:08:35.489</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 2.995 secs</span><br></pre></td></tr></table></figure>

<p>可以看到，Gradle会首先构建buildSrc目录，然后才执行showTime（红色部分）。</p>
<p><strong>（三）在单独的项目中创建Plugin</strong></p>
<p>新建一个项目，将（二）中buildSrc目录下的内容拷贝到该项目下，定义该项目的build.gradle文件如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'groovy'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br><span class="line"></span><br><span class="line">version = <span class="number">1.0</span></span><br><span class="line">group = <span class="string">'davenkin'</span></span><br><span class="line">archivesBaseName = <span class="string">'datetimeplugin'</span></span><br><span class="line">repositories.mavenCentral()</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    groovy localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories.mavenDeployer &#123;</span><br><span class="line">        repository(<span class="string">url:</span> <span class="string">'file:../lib'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，我们还可以为该Plugin重新命名，如果我们希望将该Plugin命名为time，那么我们需要在src/main/resources/META-INF/gradle-plugins目录下创建名为time.properties的文件，内容如下： </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span> = <span class="title">davenkin</span>.<span class="title">DateAndTimePlugin</span></span></span><br></pre></td></tr></table></figure>

<p>在执行“gradle uploadArchives”时，Gradle会将该Plugin打包成jar文件，然后将其上传到上级目录下的lib目录中（../lib）。之后，在客户端的build.gradle文件中，我们需要做如下定义：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">'file:../lib'</span></span><br><span class="line">        &#125; &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">group:</span> <span class="string">'davenkin'</span>, <span class="string">name:</span> <span class="string">'datetimeplugin'</span>,</span><br><span class="line"><span class="symbol">                version:</span> <span class="string">'1.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'time'</span></span><br><span class="line"></span><br><span class="line">dateAndTime &#123;</span><br><span class="line">    timeFormat = <span class="string">'HH:mm:ss.SSS'</span></span><br><span class="line">    dateFormat = <span class="string">'MM/dd/yyyy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们配置repository以执行lib目录，然后声明对DateAndTimePlugin的依赖，再apply该Plugin，此时我们应该使用“time”作为该Plugin的名称，最后对该Plugin进行配置。</p>

        
      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
      
      
        
          
            
          
          
            <li><a href="/hide/">HIDE</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li><a href="/hide/old/">OLD</a></li>
          
        
      
    
      
      
        
          
            
          
          
            <li>GRADLE学习</li>
          
        
      
    
  </ul>

    
    
    
  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">187</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Gradle快速入门"><span class="nav-number">1.</span> <span class="nav-text">Gradle快速入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建Task的多种方法"><span class="nav-number">2.</span> <span class="nav-text">创建Task的多种方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读懂Gradle语法"><span class="nav-number">3.</span> <span class="nav-text">读懂Gradle语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#增量式构建"><span class="nav-number">4.</span> <span class="nav-text">增量式构建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义Property"><span class="nav-number">5.</span> <span class="nav-text">自定义Property</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Java-Plugin"><span class="nav-number">6.</span> <span class="nav-text">使用Java Plugin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#依赖管理"><span class="nav-number">7.</span> <span class="nav-text">依赖管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构建多个Project"><span class="nav-number">8.</span> <span class="nav-text">构建多个Project</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义Task类型"><span class="nav-number">9.</span> <span class="nav-text">自定义Task类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义Plugin（本系列完）"><span class="nav-number">10.</span> <span class="nav-text">自定义Plugin（本系列完）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">770k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">11:40</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
