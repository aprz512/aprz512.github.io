<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="java中==和equals和hashCode的区别？12345678== 比较的是变量内存地址equals 默认也是比较的内存地址，但是我们可以复写该方法，根据业务逻辑来实现比较两个对象是否相等hashCode 是当对象需要放入集合中时，起到区别的作用，比如 hashMap 等Object.hashCode的通用约定：hashCode 相等的，对象不一定相等。对象相等，那么 hashCode 一">
<meta property="og:type" content="website">
<meta property="og:title" content="java面试题">
<meta property="og:url" content="http://aprz512.github.io/hide/java面试题.html">
<meta property="og:site_name" content="六根不净堂">
<meta property="og:description" content="java中==和equals和hashCode的区别？12345678== 比较的是变量内存地址equals 默认也是比较的内存地址，但是我们可以复写该方法，根据业务逻辑来实现比较两个对象是否相等hashCode 是当对象需要放入集合中时，起到区别的作用，比如 hashMap 等Object.hashCode的通用约定：hashCode 相等的，对象不一定相等。对象相等，那么 hashCode 一">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-08T06:06:07.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java面试题">
<meta name="twitter:description" content="java中==和equals和hashCode的区别？12345678== 比较的是变量内存地址equals 默认也是比较的内存地址，但是我们可以复写该方法，根据业务逻辑来实现比较两个对象是否相等hashCode 是当对象需要放入集合中时，起到区别的作用，比如 hashMap 等Object.hashCode的通用约定：hashCode 相等的，对象不一定相等。对象相等，那么 hashCode 一">
  <link rel="canonical" href="http://aprz512.github.io/hide/java面试题">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>java面试题 | 六根不净堂</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">六根不净堂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">19</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">9</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">128</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">java面试题

</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
        
          <p><strong>java中==和equals和hashCode的区别？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">== 比较的是变量内存地址</span><br><span class="line">equals 默认也是比较的内存地址，但是我们可以复写该方法，根据业务逻辑来实现比较两个对象是否相等</span><br><span class="line">hashCode 是当对象需要放入集合中时，起到区别的作用，比如 hashMap 等</span><br><span class="line"></span><br><span class="line">Object.hashCode的通用约定：</span><br><span class="line">hashCode 相等的，对象不一定相等。</span><br><span class="line">对象相等，那么 hashCode 一定相等。</span><br><span class="line">所以，复写 equals 方法的时候，必须复写 hashCode 方法。</span><br></pre></td></tr></table></figure><a id="more"></a>


<p><strong>int、char、long各占多少字节数？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 4个</span><br><span class="line">char 2个</span><br><span class="line">long 8个</span><br></pre></td></tr></table></figure>

<p><strong>int与integer的区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 是基本类型</span><br><span class="line">Integer 是类类型</span><br><span class="line">类类型与基本类型的区别：默认值，创建等</span><br></pre></td></tr></table></figure>

<p><strong>谈谈对java多态的理解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在代码中的表现就是：父类的引用指向子类。</span><br><span class="line">由于子类之间的实现不相同，代码执行的时候，所表现出来的行为也不用。</span><br><span class="line">多态的三要素：继承 重写 父类引用指向子类对象。</span><br></pre></td></tr></table></figure>

<p><strong>String、StringBuffer、StringBuilder区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String 是不可变类，每次操作都会生成一个新的 String 对象。</span><br><span class="line">StringBuffer 是可变的，也是线程安全的。</span><br><span class="line">StringBuilder 是可变的，但是是非线程安全的。</span><br><span class="line">在单线程中改变字符串使用 StringBuilder 是效率最高的，也是最节省内存的。</span><br></pre></td></tr></table></figure>

<p><strong>什么是内部类？内部类的作用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部类就是在类的内部还可以声明别的类。</span><br><span class="line">作用：</span><br><span class="line">内部类可以无条件的访问外部类的成员。</span><br><span class="line">方便编写代码，比如：事件监听，工作线程。</span><br><span class="line">将某些逻辑合在一起，顺便可以做到隐藏，比如：viewHolder</span><br></pre></td></tr></table></figure>

<p><strong>抽象类和接口区别？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。</span><br><span class="line">接口：定义一系列的行为规范，让实现类来实现。如：网络回调接口 等。</span><br><span class="line">抽象：子类有通用的功能，有时候，我们还可以编写默认实现。如：BaseActivity 等。</span><br><span class="line"></span><br><span class="line">PS：接口可以多继承。</span><br></pre></td></tr></table></figure>

<p><strong>抽象类的意义？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">封装子类中的通用功能。</span><br><span class="line">规定子类必须要实现的方法，以便提供某种功能。</span><br></pre></td></tr></table></figure>

<p><strong>抽象类与接口的应用场景？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如我们要构建一个动物相关的小游戏，那么我们需要构建很多个动物相关的类：dog，cat 等。</span><br><span class="line">在编写代码之前，我们可以想到，dog，cat 他们的行为有很多共同之处，比如：吃，睡，发出声音等。</span><br><span class="line">那么我们就可以抽象出一个类 animal，这个类里面有所有动物共同的行为，那么这个 Animal 就是抽象类。</span><br><span class="line"></span><br><span class="line">后来，我们的游戏要进行扩展，要添加玩具类，同样我们可以抽象出 Toys 作为抽象类。之前我们的动物类中有 bird，它可以飞，其他的动物都不能飞，那么要需要有一个单独的方法 fly 来实现。而 toys 的子类有个一遥控玩具也可以飞，那么它也需要实现 fly 方法。这个时候问题就来了，fly 是一个行为，无法抽象成一个类，这个时候就只能使用接口了。我们定义一个 FlyBehaivor 接口，让具有飞行行为的类都实现这个接口，就好了。</span><br></pre></td></tr></table></figure>

<p><strong>抽象类是否可以没有方法和属性？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以，但是没啥意义</span><br></pre></td></tr></table></figure>

<p><strong>接口的意义？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">规范行为。如果你对定义的接口非常了解，那么看起代码来都不用去看具体的实现细节（除非你在找bug），就知道它做的是什么。</span><br></pre></td></tr></table></figure>

<p><strong>泛型中extends和super的区别？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;? extends Self&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//参数类型上界是Self</span></span><br><span class="line">        a.add(<span class="keyword">new</span> Son());<span class="comment">//error 不能放入任何类型，因为编译器只知道a中应该放入Self的某个子类，但具体放哪种子类它并不知道，因此，除了null以外，不能放入任何类型</span></span><br><span class="line">        a.add(<span class="keyword">new</span> Self());<span class="comment">//error</span></span><br><span class="line">        a.add(<span class="keyword">new</span> Super());<span class="comment">//error</span></span><br><span class="line">        a.add(<span class="keyword">null</span>);<span class="comment">//ok</span></span><br><span class="line">        Self s1 = a.get(<span class="number">0</span>); <span class="comment">//返回类型是确定的Self类，因为&lt;? extends T&gt; 只能用于方法返回，告诉编译器此返参的类型的最小继承边界为T，T和T的父类都能接收，但是入参类型无法确定，只能接受null的传入</span></span><br><span class="line">        Super s2 = a.get(<span class="number">0</span>); <span class="comment">//Self类型可以用Super接收</span></span><br><span class="line">        Son s3 = a.get(<span class="number">0</span>); <span class="comment">//error:子类不能接收父类型参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Self&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//参数类型下界是Self</span></span><br><span class="line">        b.add(<span class="keyword">new</span> Son());<span class="comment">//ok 只能放入T类型，且满足T类型的超类至少是Self，换句话说，就是只能放入Self的子类型</span></span><br><span class="line">        b.add(<span class="keyword">new</span> Self());<span class="comment">//ok 本身类型也可以</span></span><br><span class="line">        b.add(<span class="keyword">new</span> Super());<span class="comment">//error 超类不可以</span></span><br><span class="line">        b.add(<span class="keyword">null</span>);<span class="comment">//ok</span></span><br><span class="line">        Object o1 = b.get(<span class="number">0</span>);<span class="comment">//返回类型是未知的， 因为&lt;? super T&gt;只能用于限定方法入参，告诉编译器入参只能是T或其子类型，而返参只能用Object类接收</span></span><br><span class="line">        Son o2 = b.get(<span class="number">0</span>);<span class="comment">//error</span></span><br><span class="line">        Self o3 = b.get(<span class="number">0</span>);<span class="comment">//error</span></span><br><span class="line">        Super o4 = b.get(<span class="number">0</span>);<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要记住 父类的引用可以指向子类 上面的行为就好理解了。</span></span><br><span class="line"><span class="comment">// &lt;? extends T&gt; 要存放 T 和 T 的子类，因为不知道具体存放那个子类型（无下限），所以存不进去，取的时候，只要是 T 和 T 的父类都可以。</span></span><br><span class="line"><span class="comment">// &lt;? super T&gt; 要存放 T 和 T 的父类，所以存放子类型和 T 肯定是没问题的，取的时候，不知道父类是谁（无上限），所以只能使用 Object 来接受。</span></span><br></pre></td></tr></table></figure>

<p><strong>父类的静态方法能否被子类重写？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以被继承，但是不能被重写。因为静态方法在编译时期就与类绑定了。</span><br></pre></td></tr></table></figure>

<p><strong>进程和线程的区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">链接：https://www.zhihu.com/question/25532384/answer/81152571</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</span><br><span class="line">========= 重要的东西出现了========</span><br><span class="line">进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =&gt; sCPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</span><br><span class="line">到此全文结束，再一个总结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</span><br></pre></td></tr></table></figure>

<p><strong>final，finally，finalize的区别?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final用于修饰类、成员变量和成员方法。</span><br><span class="line">finally是在异常处理时提供finally块来执行任何清除操作。</span><br><span class="line">finalize是方法名,finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的（并不保证），可以做一些资源清理工作。</span><br></pre></td></tr></table></figure>

<p><strong>序列化的方式？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serializable和Parcelable接口可以完成对象的序列化过程。</span><br></pre></td></tr></table></figure>

<p><strong>Serializable 和Parcelable 的区别？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Serializable接口是Java提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现的对象的序列化相当简单，只需要在类的生命中指定一个类似相面的标识即可自动实现默认的序列化过程。</span><br><span class="line"></span><br><span class="line">Parcelable接口是Android SDK提供的一种专门用于Android应用中对象的序列化和反序列化的方式，相比于Seriablizable具有更好的性能。实现Parcelable接口的对象就可以实现序列化并可以通过Intent和Binder传递。</span><br><span class="line"></span><br><span class="line">Parcelable 的效率要高些。Parcelable 是内存序列化，Serializable 是序列化到本地或者通过网络传输。</span><br></pre></td></tr></table></figure>

<p><strong>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>

<p><strong>静态内部类的设计意图？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果内部类不需要引用外部类的东西的话，那么就应该设计成静态的，因为这样会更加节省资源（类会延迟加载，没有外部指针等）。</span><br></pre></td></tr></table></figure>

<p><strong>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">成员内部类是最普通的内部类，它的定义为位于另一个类的内部，适配器。</span><br><span class="line"></span><br><span class="line">局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</span><br><span class="line"></span><br><span class="line">匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</span><br><span class="line"></span><br><span class="line">静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static，单利模式写法之一。</span><br></pre></td></tr></table></figure>

<p><strong>谈谈对kotlin的理解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还没接触</span><br></pre></td></tr></table></figure>

<p><strong>闭包和局部内部类的区别？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> InnerClass().execute();</span><br><span class="line">    System.out.println(<span class="string">"主方法已经over"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">看完上面的代码之后，有没有想过为什么线程里面还能够访问主线程的变量 s ？</span><br><span class="line"></span><br><span class="line">当变量是final时,编译器会将final局部变量&quot;复制&quot;一份,复制品直接作为局部内部中的数据成员.这样，当局部内部类访问局部变量时,其实真正访问的是这个局部变量的&quot;复制品&quot;。因此:当运行栈中的真正的局部变量死亡时,局部内部类对象仍可以访问局部变量(其实访问的是&quot;复制品&quot;)。而且，由于被final修饰的变量赋值后不能再修改，所以就保证了复制品与原始变量的一致。给人的感觉:好像是局部变量的&quot;生命期&quot;延长了。这就是java的闭包。</span><br><span class="line"></span><br><span class="line">闭包简单理解就是：闭包能够将一个方法作为一个变量去存储，这个方法有能力去访问所在类的自由变量。</span><br><span class="line">能够做到这些的在 Java 中就是内部类。</span><br><span class="line">将一个方法（execute）封装成一个变量（innerClass），然后等待执行。</span><br></pre></td></tr></table></figure>

<p><strong>string 转换成 integer的方式及原理？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">  <span class="comment">// 读取符号</span></span><br><span class="line">    <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">        negative = <span class="keyword">true</span>;</span><br><span class="line">        limit = Integer.MIN_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">multmin = limit / radix;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">    digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">    <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 不是数字</span></span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">      <span class="comment">// 因为 result 要乘以进制，判断是否会溢出</span></span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    result *= radix;</span><br><span class="line">    <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">      <span class="comment">// 判断加上新的数值是否会溢出</span></span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 因为负数 -1 ～ -2^32 ，所以计算的使用使用负数来表示范围。</span></span><br><span class="line">    result -= digit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>哪些情况下的对象会被垃圾回收机制处理掉？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不可达对象：</span><br><span class="line">软引用 + 弱引用+虚引用</span><br><span class="line">手动置空</span><br><span class="line">方法运行完之后的局部变量</span><br><span class="line">正确关闭的 activity 等</span><br><span class="line">集合调用 clear</span><br></pre></td></tr></table></figure>

<p><strong>讲一下常见编码方式？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ASCII应该是最熟悉的，使用了8位的二进制来表示英文的字母和字符。但是无法表示汉字和其他国的文字。</span><br><span class="line">ISO-8859-1 是基于ASCII码基础上扩展的，它总共能表示256个字符，涵盖了大多数西欧语言字符，也不支持中文。</span><br><span class="line"></span><br><span class="line">我们创造出了 GBK 等编码来表示汉字，但是问题是与其他国家的编码不相容。于是出现了 Unicode 解决方案。</span><br><span class="line"></span><br><span class="line">Unicode并不是一种编码方式，它是一个字符集，包括了全世界绝大多数文明的字符，而且还在不断的发展之中。</span><br><span class="line">Unicode定义了字符到数字的映射关系。比如字符“中”对应的数字十六进制为4E2D。UNICODE并没有规定要用用多少个字节表示字符，因为这是编码的范畴，字符集并不管。</span><br><span class="line"></span><br><span class="line">UTF-8 (Unicode Transformation Format)就是Unicode的一种实现。作为一种编码方式，我们前面提到过。其表示采用变长字节进行存储，比如英文字符就是用一个字节就行，对于汉字使用3个字节，按需使用。</span><br><span class="line"></span><br><span class="line">虽然有了UTF-8，但有些强迫症患者看着这种不规则存储实在是心里难受，所以同时也制定了UTF-16，常用的字符都用16位表示。</span><br></pre></td></tr></table></figure>

<p><strong>utf-8编码中的中文占几个字节?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">少数是汉字每个占用3个字节，多数占用4个字节。</span><br></pre></td></tr></table></figure>

<p><strong>静态代理和动态代理的区别，什么场景使用？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态代理：代理类的源代码里面由编写者确定了需要代理的类。（AIDL里有）</span><br><span class="line"></span><br><span class="line">动态代理类：动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。切面编程，插件化。</span><br></pre></td></tr></table></figure>

<p><strong>Java的异常体系。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thorwable类是所有异常和错误的超类。有两个子类Error和Exception，分别表示错误和异常。</span><br><span class="line"> </span><br><span class="line">Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。 </span><br><span class="line"></span><br><span class="line">Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 程序中应当尽可能去处理这些异常。 </span><br><span class="line"></span><br><span class="line">运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。 </span><br><span class="line"></span><br><span class="line">非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</span><br></pre></td></tr></table></figure>

<p><strong>谈谈你对解析与分派的认识。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://www.mamicode.com/info-detail-1321403.html</span><br><span class="line"></span><br><span class="line">在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，静态方法（invokestatic指令）、私有方法、实例构造方法、父类方法（这3个是invokespecial指令），它们在类加载的的解析阶段就回将符号引用解析为该方法的直接引用。</span><br><span class="line"></span><br><span class="line">静态分派：重载（根据静态类型判断）</span><br><span class="line">动态分派：重写（根据实际类型判断）</span><br></pre></td></tr></table></figure>

<p><strong>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object 的方法</span><br></pre></td></tr></table></figure>

<p><strong>Java中实现多态的机制是什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</span><br><span class="line"></span><br><span class="line">接口或者继承 + 动态分派</span><br></pre></td></tr></table></figure>

<p><strong>如何将一个Java对象序列化到文件里？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现 Serializable</span><br><span class="line">调用 ObjectOutputStream 的 writeObject 方法</span><br></pre></td></tr></table></figure>

<p><strong>说说你对Java反射的理解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反射机制指的是程序在运行时能够获取自身的信息。</span><br><span class="line">要理解反射首先要先理解 类 也是一个对象，可以用一个类来描述，就是 java.lang.Class。同样的类的成员变量可以看做一个类 Field，类的方法也可以看做一个类 Method。</span><br><span class="line"></span><br><span class="line">动态获取类的信息：先获取到 Class 对象，然后获取其 Field 和 Method 信息，在根据类变量来获取对应 Field 的值或者调用对应 Method。</span><br></pre></td></tr></table></figure>

<p><strong>说说你对Java注解的理解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">四个元注解：</span><br><span class="line">1.@Target，注解修饰的范围</span><br><span class="line"></span><br><span class="line">2.@Retention，注解的生命周期</span><br><span class="line"></span><br><span class="line">3.@Documented，可以被文档化</span><br><span class="line"></span><br><span class="line">4.@Inherited，子类可以继承父类的注解</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Qualifier注解可以被用在字段、方法、方法参数、类、接口、注解、枚举上，但是只有@Qualifier被用在类上的时候才能被它的子类继承，子类才可以获取到这个注解。</span></span><br></pre></td></tr></table></figure>

<p>自定义注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">dataType</span><span class="params">()</span> <span class="keyword">default</span> "<span class="title">varchar</span><span class="params">(<span class="number">20</span>)</span>"</span>;</span><br><span class="line">    <span class="function">String <span class="title">comment</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用反射来获取字段上注解的信息，最后合成 sql 语句</span></span><br></pre></td></tr></table></figure>

<p><strong>说说你对依赖注入的理解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在java开发中有时候我们的一个类需要依赖另外一个类，这种就是依赖关系。</span><br><span class="line">比如：我们使用的 ButterKnife，它是使用了注解来完成依赖注入。</span><br><span class="line">activity 的创建一般是需要用到 layout 里面的各种控件，一般我们都使用 findViewById 来完成控件的赋值，但是这样就造成了很多重复代码。为了解决这个问题，ButterKnife 就帮我们实现了 控件赋值 的这个过程，而这个过程就是 找到view然后赋值（所以严格意义上不算依赖注入），如果是控件的创建，那么就是严格的依赖注入了。</span><br><span class="line">依赖注入就是创建依赖对象不需要手动实例化了，可以使用工厂或者容器来实例化，达到解耦的目的。</span><br></pre></td></tr></table></figure>

<p><strong>说一下泛型原理，并举例说明。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。</span><br><span class="line"></span><br><span class="line">Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。</span><br><span class="line"></span><br><span class="line">如在代码中定义的List&lt;object&gt;和List&lt;String&gt;等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</span><br></pre></td></tr></table></figure>

<p><strong>Java中String的了解。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String 不可变</span><br><span class="line">有常量池</span><br><span class="line">对 String 的操作都会生成新的 String 对象。</span><br></pre></td></tr></table></figure>

<p><strong>String为什么要设计成不可变的？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">效率：常量池</span><br><span class="line">安全性：String 做参数时不可变是很重要的，特别是多线程编程的情况。</span><br></pre></td></tr></table></figure>

<p><strong>Object类的equal和hashCode方法重写，为什么？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>


        
      </div>
      
      
      
    </div>
    

    
    
    
  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">525k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">7:57</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
