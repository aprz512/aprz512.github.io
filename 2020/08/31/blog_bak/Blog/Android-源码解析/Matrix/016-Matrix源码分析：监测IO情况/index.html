<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="经过一个星期的 C++ 基本语法的学习，终于可以继续分析了，好不容易写了 15 篇，被个 C++ 拦住了就笑死人了。 IO的监测功能由以下3个库实现：123matrix-io-canarymatrix-android-libmatrix-android-commonsmatrix-io-canary 里面的是核心代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="016-Matrix源码分析：监测IO情况">
<meta property="og:url" content="http://aprz512.github.io/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/index.html">
<meta property="og:site_name" content="二手程序员">
<meta property="og:description" content="经过一个星期的 C++ 基本语法的学习，终于可以继续分析了，好不容易写了 15 篇，被个 C++ 拦住了就笑死人了。 IO的监测功能由以下3个库实现：123matrix-io-canarymatrix-android-libmatrix-android-commonsmatrix-io-canary 里面的是核心代码。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true">
<meta property="og:updated_time" content="2020-09-27T09:44:53.762Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="016-Matrix源码分析：监测IO情况">
<meta name="twitter:description" content="经过一个星期的 C++ 基本语法的学习，终于可以继续分析了，好不容易写了 15 篇，被个 C++ 拦住了就笑死人了。 IO的监测功能由以下3个库实现：123matrix-io-canarymatrix-android-libmatrix-android-commonsmatrix-io-canary 里面的是核心代码。">
<meta name="twitter:image" content="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true">
  <link rel="canonical" href="http://aprz512.github.io/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>016-Matrix源码分析：监测IO情况 | 二手程序员</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二手程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">21</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">20</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">218</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aprz512.github.io/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aprz512">
      <meta itemprop="description" content="博客建于2017年02月05日21:39:56">
      <meta itemprop="image" content="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="二手程序员">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">016-Matrix源码分析：监测IO情况

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2020-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-31T00:00:00+08:00">2020-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 17:44:53" itemprop="dateModified" datetime="2020-09-27T17:44:53+08:00">2020-09-27</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Matrix/" itemprop="url" rel="index"><span itemprop="name">Matrix</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/" itemprop="commentCount"></span></a>
  </span>
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>21k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>19 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>经过一个星期的 C++ 基本语法的学习，终于可以继续分析了，好不容易写了 15 篇，被个 C++ 拦住了就笑死人了。</p>
</blockquote><p>IO的监测功能由以下3个库实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix-io-canary</span><br><span class="line">matrix-android-lib</span><br><span class="line">matrix-android-commons</span><br></pre></td></tr></table></figure><p>matrix-io-canary 里面的是核心代码。</p><a id="more"></a>




<p>这个库里面提供了一下几个功能：</p>
<ul>
<li>主线程IO，设定了一些阈值，超过就报警（最大读写时间超过 13ms，一次连续读写时间超过 500ms）</li>
<li>重复读IO（这个感觉有点鸡肋，可能是我没搞懂使用场景）</li>
<li>buffer太小的IO行为</li>
</ul>
<p>在分析这些功能是如何实现的之前，我们想一下，该如何监测应用中的的IO呢？</p>
<p>我们通常读取文件，都是通过 FileInputStream 等类来实现的，他们的内部是调用了 native 函数，最终会调用到 <code>libjavacore.so</code> 中的 <code>read/write</code> 方法，所以，我们只需要 hook 这俩个函数就好了。所以，最终的问题转化为如何hook 指定 .so 中的函数？？？</p>
<p>解决上面的问题需要用到 elf 文件格式的知识，以及 .so 的加载与链接知识。这些在《程序员的自我修养-链接、装载与库》中都有详细的描述，可以看看，我花了几天时间差不多看明白了。这里就简单的说一下这个过程。</p>
<h3 id="so相关"><a href="#so相关" class="headerlink" title=".so相关"></a>.so相关</h3><blockquote>
<p>没有阅读 《程序员的自我修养-链接、装载与库》 这本书的相关章节的话，这段内容几乎看不懂。</p>
</blockquote>
<p>.so 是一个 ELF 文件格式的文件。</p>
<p>.so 是共享库，也就是说它加载到内存后，是可以多个进程共享的。但是这个文件的加载比较特殊，并不是与普通文件一样，一股脑的全部放到内存就行了。</p>
<p>简单的来说，它里面有多个段，指令（就是存放函数代码，它是只读的）放在一个段，这个是可以共享的。而有些段不是共享的，它是每个进程各自一份，比如全局偏移表（.got），这个里面存放的就是变量函数的地址，因为每个进程都有自己的虚拟内存，所以共享库函数的地址也是不一样的。</p>
<p>与 .got 相关的还有一个 .plt，它是用来懒绑定的，就是说函数到真正使用的时候，才会绑定地址，因为有的函数根本就不会被调用。</p>
<h3 id="hook-函数"><a href="#hook-函数" class="headerlink" title="hook 函数"></a>hook 函数</h3><p>这里的 hook 有两种选择，一种是 java 层，一种是 native 层。</p>
<p>但是 java 层有些缺点：</p>
<ul>
<li>兼容性差。Java Hook 需要每个 Android 版本去兼容，特别是 Android P 增加对非公开 API 限制。</li>
<li>无法监控 Native 代码。</li>
<li>I/O 操作调用非常频繁，因为使用动态代理和 Java 的大量字符串操作，导致性能比较差，无法达到线上使用的标准。</li>
</ul>
<p>所以，采用的是 native 的方式。最终是从 libc.so 中的这几个函数中选定 Hook 的目标函数（当然，遍历所有已经加载的 library，全部替换更好）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size); write_cuk</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不同版本的 Android 系统实现有所不同，在 Android 7.0 之后，我们还需要替换下面这三个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open64</span><br><span class="line">__read_chk</span><br><span class="line">__write_chk</span><br></pre></td></tr></table></figure>

<p>爱奇艺开源的 xhook 可以 hook .so 中的函数，Github 上有相关信息，有兴趣的可以去看源码。</p>
<p>先上一张图，再看一下使用方式：</p>
<p><img src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true" alt="https://github.com/aprz512/pic4aprz512/blob/master/Blog/Android-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Matrix/ba36f8e259427bde06bc44861905c63c.png?raw=true"></p>
<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><blockquote>
<p>iocanary::Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jboolean JNICALL</span><br><span class="line">    Java_com_tencent_matrix_iocanary_core_IOCanaryJniBridge_doHook(JNIEnv *env, jclass type) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TARGET_MODULE_COUNT; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* so_name = TARGET_MODULES[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>* soinfo = xhook_elf_open(so_name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 .so 里面 找到 open 函数，将open函数的地址指向 ProxyOpen，原来的函数地址保存到 original_open</span></span><br><span class="line">        <span class="comment">// void** 相当于一个泛型</span></span><br><span class="line">        xhook_hook_symbol(soinfo, <span class="string">"open"</span>, (<span class="keyword">void</span>*)ProxyOpen, (<span class="keyword">void</span>**)&amp;original_open);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        xhook_elf_close(soinfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用还是挺简单的，先打开 .so 文件，然后传递需要hook的函数名，以及俩个函数指针就好了，我们看看 ProxyOpen 函数：</p>
<blockquote>
<p>iocanary::ProxyOpen</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ProxyOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!IsMainThread()) &#123;</span><br><span class="line">        <span class="keyword">return</span> original_open(pathname, flags, mode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = original_open(pathname, flags, mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">-1</span>) &#123;</span><br><span class="line">        DoProxyOpenLogic(pathname, flags, mode, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，它只监测了<strong>主线程的IO</strong>（其他的代理方法都有这个逻辑，可能是其他线程有bug还是什么）。然后调用原来的 open 函数打开文件，拿到返回的文件描述符后，执行插入的代理逻辑：</p>
<blockquote>
<p>iocanary::DoProxyOpenLogic</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoProxyOpenLogic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> ret)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">    kJvm-&gt;GetEnv((<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="keyword">if</span> (env == <span class="literal">NULL</span> || !kInitSuc) &#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR, kTag, <span class="string">"ProxyOpen env null or kInitSuc:%d"</span>, kInitSuc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 java 层的 JavaContext 对象</span></span><br><span class="line">        jobject java_context_obj = env-&gt;CallStaticObjectMethod(kJavaBridgeClass, kMethodIDGetJavaContext);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == java_context_obj) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取java层堆栈信息</span></span><br><span class="line">        jstring j_stack = (jstring) env-&gt;GetObjectField(java_context_obj, kFieldIDStack);</span><br><span class="line">        <span class="comment">// 线程名</span></span><br><span class="line">        jstring j_thread_name = (jstring) env-&gt;GetObjectField(java_context_obj, kFieldIDThreadName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* thread_name = jstringToChars(env, j_thread_name);</span><br><span class="line">        <span class="keyword">char</span>* <span class="built_in">stack</span> = jstringToChars(env, j_stack);</span><br><span class="line">        <span class="comment">// 创建 C++ 层的 JavaContex 对象</span></span><br><span class="line">        <span class="function">JavaContext <span class="title">java_context</span><span class="params">(GetCurrentThreadId(), thread_name == <span class="literal">NULL</span> ? <span class="string">""</span> : thread_name, <span class="built_in">stack</span> == <span class="literal">NULL</span> ? <span class="string">""</span> : <span class="built_in">stack</span>)</span></span>;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">stack</span>);</span><br><span class="line">        <span class="built_in">free</span>(thread_name);</span><br><span class="line"></span><br><span class="line">        iocanary::IOCanary::Get().OnOpen(pathname, flags, mode, ret, java_context);</span><br><span class="line"></span><br><span class="line">        env-&gt;DeleteLocalRef(java_context_obj);</span><br><span class="line">        env-&gt;DeleteLocalRef(j_stack);</span><br><span class="line">        env-&gt;DeleteLocalRef(j_thread_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kJavaBridgeClass 等变量在 JNI_OnLoad 的时候就已经初始化好了。这些都是用来创建 java 层的对象的。</p>
<p>该函数就是创建出了一些必要的参数，然后调用了 OnOpen 方法，最终调用到</p>
<blockquote>
<p>IOInfoCollector::OnOpen</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> IOInfoCollector::OnOpen(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> open_ret,</span><br><span class="line">                             <span class="keyword">const</span> JavaContext &amp;java_context) &#123;</span><br><span class="line">    <span class="comment">//__android_log_print(ANDROID_LOG_DEBUG, kTag, "OnOpen fd:%d; path:%s", open_ret, pathname);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件打开失败返回 -1，成功返回文件描述符，太奇葩了</span></span><br><span class="line">    <span class="keyword">if</span> (open_ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里刚开始会觉得很奇怪啊，为啥要使用 返回值作为key？？？因为 open_ret 是文件的描述符</span></span><br><span class="line">    <span class="comment">// 文件已经被记录了</span></span><br><span class="line">    <span class="keyword">if</span> (info_map_.find(open_ret) != info_map_.end()) &#123;</span><br><span class="line">        <span class="comment">//__android_log_print(ANDROID_LOG_WARN, kTag, "OnOpen fd:%d already in info_map_", open_ret);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make_shared 会在堆上创建对象，返回一个智能指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; info = <span class="built_in">std</span>::make_shared&lt;IOInfo&gt;(pathname, java_context);</span><br><span class="line">    <span class="comment">// 记录</span></span><br><span class="line">    info_map_.insert(<span class="built_in">std</span>::make_pair(open_ret, info));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，每次打开一个文件的时候，都会将其记录到 map 中，key 是文件的路径，value 是一个IOInfo类型的指针。</p>
<h4 id="read-write"><a href="#read-write" class="headerlink" title="read/write"></a>read/write</h4><p>我们使用同样的方式，可以追踪到 read/write 的相关hook逻辑：</p>
<blockquote>
<p>IOInfoCollector::CountRWInfo</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">IOInfoCollector::CountRWInfo(<span class="keyword">int</span> fd, <span class="keyword">const</span> FileOpType &amp;fileOpType, <span class="keyword">long</span> op_size, <span class="keyword">long</span> rw_cost) &#123;</span><br><span class="line">    <span class="keyword">if</span> (info_map_.find(fd) == info_map_.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> now = GetSysTimeMicros();</span><br><span class="line"></span><br><span class="line">    info_map_[fd]-&gt;op_cnt_++;</span><br><span class="line">    info_map_[fd]-&gt;op_size_ += op_size;</span><br><span class="line">    info_map_[fd]-&gt;rw_cost_us_ += rw_cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录单次最大的读写时间</span></span><br><span class="line">    <span class="keyword">if</span> (rw_cost &gt; info_map_[fd]-&gt;max_once_rw_cost_time_μs_) &#123;</span><br><span class="line">        info_map_[fd]-&gt;max_once_rw_cost_time_μs_ = rw_cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果连续读写间隔小于   kContinualThreshold（8ms）</span></span><br><span class="line">    <span class="keyword">if</span> (info_map_[fd]-&gt;last_rw_time_μs_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (now - info_map_[fd]-&gt;last_rw_time_μs_) &lt; kContinualThreshold) &#123;</span><br><span class="line">        <span class="comment">// 本次连续读写时间</span></span><br><span class="line">        info_map_[fd]-&gt;current_continual_rw_time_μs_ += rw_cost;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        info_map_[fd]-&gt;current_continual_rw_time_μs_ = rw_cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info_map_[fd]-&gt;current_continual_rw_time_μs_ &gt;</span><br><span class="line">        info_map_[fd]-&gt;max_continual_rw_cost_time_μs_) &#123;</span><br><span class="line">        info_map_[fd]-&gt;max_continual_rw_cost_time_μs_ = info_map_[fd]-&gt;current_continual_rw_time_μs_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录读写时刻</span></span><br><span class="line">    info_map_[fd]-&gt;last_rw_time_μs_ = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录操作的 buffer 大小，这里是记录的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (info_map_[fd]-&gt;buffer_size_ &lt; op_size) &#123;</span><br><span class="line">        info_map_[fd]-&gt;buffer_size_ = op_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果对一个文件又读又写，记录第一次的读写类型？？？</span></span><br><span class="line">    <span class="keyword">if</span> (info_map_[fd]-&gt;op_type_ == FileOpType::kInit) &#123;</span><br><span class="line">        info_map_[fd]-&gt;op_type_ = fileOpType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面是记录了一些读写的数据。</p>
<h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><blockquote>
<p>IOInfoCollector::OnClose</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 fd 对应的文件信息，在 info_map_ 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; IOInfoCollector::OnClose(<span class="keyword">int</span> fd, <span class="keyword">int</span> close_ret) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info_map_.find(fd) == info_map_.end()) &#123;</span><br><span class="line">        <span class="comment">//__android_log_print(ANDROID_LOG_DEBUG, kTag, "OnClose fd:%d not in info_map_", fd);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从打开到关闭的耗时</span></span><br><span class="line">    info_map_[fd]-&gt;total_cost_μs_ = GetSysTimeMicros() - info_map_[fd]-&gt;start_time_μs_;</span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    info_map_[fd]-&gt;file_size_ = GetFileSize(info_map_[fd]-&gt;path_.c_str());</span><br><span class="line">    <span class="comment">// 其他信息在读写时记录了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; info = info_map_[fd];</span><br><span class="line">    info_map_.erase(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也记录了一些信息，注意，这里返回了指针，然后 map 里面的键值对被擦除了。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>经过上面对几个函数的hook，我们可以获取到读写文件时的详细信息。拿到这些信息之后，我们就可以进行相应的处理，判断该IO行为是否正常。</p>
<p>我们从 plugin 的 start 开始分析整个流程。</p>
<blockquote>
<p>com.tencent.matrix.iocanary.core.IOCanaryCore#initDetectorsAndHookers</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDetectorsAndHookers</span><span class="params">(IOConfig ioConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> ioConfig != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioConfig.isDetectFileIOInMainThread()</span><br><span class="line">        || ioConfig.isDetectFileIOBufferTooSmall()</span><br><span class="line">        || ioConfig.isDetectFileIORepeatReadSameFile()) &#123;</span><br><span class="line">        IOCanaryJniBridge.install(ioConfig, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监测 io 是否关闭了</span></span><br><span class="line">    <span class="comment">//if only detect io closeable leak use CloseGuardHooker is Better</span></span><br><span class="line">    <span class="keyword">if</span> (ioConfig.isDetectIOClosableLeak()) &#123;</span><br><span class="line">        mCloseGuardHooker = <span class="keyword">new</span> CloseGuardHooker(<span class="keyword">this</span>);</span><br><span class="line">        mCloseGuardHooker.hook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里只分析第一个 if 里面的东西，第二个 if 里面的东西最后分析。</p>
<p>在第一个 if 里面，就是判断了是否开启某些监测，开启了才调用相应代码。</p>
<p>install 函数里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(IOConfig config, OnJniIssuePublishListener listener)</span> </span>&#123;</span><br><span class="line">    MatrixLog.v(TAG, <span class="string">"install sIsTryInstall:%b"</span>, sIsTryInstall);</span><br><span class="line">    <span class="keyword">if</span> (sIsTryInstall) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 .so 文件</span></span><br><span class="line">    <span class="comment">//load lib</span></span><br><span class="line">    <span class="keyword">if</span> (!loadJni()) &#123;</span><br><span class="line">        MatrixLog.e(TAG, <span class="string">"install loadJni failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set listener</span></span><br><span class="line">    sOnIssuePublishListener = listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//set config</span></span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (config.isDetectFileIOInMainThread()) &#123;</span><br><span class="line">                <span class="comment">// 调用 native 方法</span></span><br><span class="line">                enableDetector(DetectorType.MAIN_THREAD_IO);</span><br><span class="line">                <span class="comment">// ms to μs</span></span><br><span class="line">                setConfig(ConfigKey.MAIN_THREAD_THRESHOLD, config.getFileMainThreadTriggerThreshold() * <span class="number">1000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (config.isDetectFileIOBufferTooSmall()) &#123;</span><br><span class="line">                enableDetector(DetectorType.SMALL_BUFFER);</span><br><span class="line">                setConfig(ConfigKey.SMALL_BUFFER_THRESHOLD, config.getFileBufferSmallThreshold());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (config.isDetectFileIORepeatReadSameFile()) &#123;</span><br><span class="line">                enableDetector(DetectorType.REPEAT_READ);</span><br><span class="line">                setConfig(ConfigKey.REPEAT_READ_THRESHOLD, config.getFileRepeatReadThreshold());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hook</span></span><br><span class="line">        doHook();</span><br><span class="line"></span><br><span class="line">        sIsTryInstall = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        MatrixLog.printErrStackTrace(TAG, e, <span class="string">"call jni method error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数做了这些事：</p>
<ul>
<li><p>先加载对应的 .so 库</p>
</li>
<li><p>根据 config 设置对应的监听，enableDetector 是一个native 代码，最终会调用到</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IOCanary::RegisterDetector(DetectorType type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> DetectorType::kDetectorMainThreadIO:</span><br><span class="line">            <span class="comment">// 添加到detector容器集合</span></span><br><span class="line">            detectors_.push_back(<span class="keyword">new</span> FileIOMainThreadDetector());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进行 hook，这里的 hook 就是上面说的 hook 函数部分了。</li>
</ul>
<p>这里，我们知道，监听设置了，但是监听什么时候被调用呢？我们看 IOCanary 的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IOCanary::IOCanary() &#123;</span><br><span class="line">    exit_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 创建一个线程，detect 是被调用的函数，其参数是 this（隐式参数）</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">detect_thread</span><span class="params">(&amp;IOCanary::Detect, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 分离线程，线程单独运行</span></span><br><span class="line">    detect_thread.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，它开启了一个线程，该线程运行的是 Detect 函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IOCanary::Detect() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Issue&gt; published_issues;</span><br><span class="line">    <span class="comment">// 只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”，</span></span><br><span class="line">    <span class="comment">// 就不必担心在哪里写delete p语句——实际上根本不需要编写这条语句，</span></span><br><span class="line">    <span class="comment">// 托管 p 的 shared_ptr 对象在消亡时会自动执行delete p。</span></span><br><span class="line">    <span class="comment">// 有点 java 的味道了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; file_io_info;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        published_issues.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = TakeFileIOInfo(file_io_info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// exit_ 为0， 就跳出了</span></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// detectors_ 是监听集合</span></span><br><span class="line">        <span class="comment">// 具体可见 IOCanary::RegisterDetector 方法</span></span><br><span class="line">        <span class="comment">// 在对一个文件操作完毕之后，open -&gt; read/write -&gt; close，才会回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> detector : detectors_) &#123;</span><br><span class="line">            detector-&gt;Detect(env_, *file_io_info, published_issues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用回调方法</span></span><br><span class="line">        <span class="comment">// 该监听是在 iocanary::JNI_OnLoad 里面设置的</span></span><br><span class="line">        <span class="keyword">if</span> (issued_callback_ &amp;&amp; !published_issues.empty()) &#123;</span><br><span class="line">            issued_callback_(published_issues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放指针</span></span><br><span class="line">        file_io_info = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面是一个生产者-消费者模式，Detect 扮演的是消费者的角色，它调用 TakeFileIOInfo 函数获取一个 IOInfo 的指针，然后对它进行处理，我们可以看到，在 for 里面，它将这个指针传递到了我们之前设置的监听函数的回调参数里面。这样，在监听的回调函数里面，我们就可以拿到本次IO的各种信息了。</p>
<p>这里是生产者-消费者模式，所以我们还要搞清楚，谁是生产者。搜索，queue_cv_ 变量，我们可以发现如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IOCanary::OnClose(<span class="keyword">int</span> fd, <span class="keyword">int</span> close_ret) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; info = collector_.OnClose(fd, close_ret);</span><br><span class="line">    <span class="keyword">if</span> (info == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OfferFileIOInfo(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> IOCanary::OfferFileIOInfo(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; file_io_info) &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex_);</span><br><span class="line">    queue_.push_back(file_io_info);</span><br><span class="line">    <span class="comment">// 通知等待线程，添加进去了一个元素</span></span><br><span class="line">    queue_cv_.notify_one();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 queue_ 里面获取队头的 file_io_info 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> IOCanary::TakeFileIOInfo(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOInfo&gt; &amp;file_io_info) &#123;</span><br><span class="line">    <span class="comment">// std::unique_lock对象以独占所有权的方式(unique owership)管理mutex对象的上锁和解锁操作，</span></span><br><span class="line">    <span class="comment">// 即在unique_lock对象的声明周期内，它所管理的锁对象会一直保持上锁状态；</span></span><br><span class="line">    <span class="comment">// 而unique_lock的生命周期结束之后，它所管理的锁对象会被解锁。</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(queue_mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，那就一直等待，开起来像是一个生产者-消费者模式</span></span><br><span class="line">    <span class="keyword">while</span> (queue_.empty()) &#123;</span><br><span class="line">        <span class="comment">// wait 会释放锁</span></span><br><span class="line">        queue_cv_.wait(lock);</span><br><span class="line">        <span class="keyword">if</span> (exit_) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为参数是引用，所以这里会改变传递进来的实参值</span></span><br><span class="line">    file_io_info = queue_.front();</span><br><span class="line">    <span class="comment">// pop 居然没有返回 pop 出来的值，难怪要多加一句</span></span><br><span class="line">    queue_.pop_front();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OnClose 是我们的 hook 函数的代码，它在文件关闭的时候会被调用，所以结论就是文件关闭的时候，会返回（上面提到过）一个 IOInfo 的指针，然后将它放到队列中，通知等待线程开始执行，最后就回调到了我们的监听代码中。</p>
<h3 id="主线程IO"><a href="#主线程IO" class="headerlink" title="主线程IO"></a>主线程IO</h3><p>我们看看主线程IO的监听代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FileIOMainThreadDetector::Detect(<span class="keyword">const</span> IOCanaryEnv &amp;env, <span class="keyword">const</span> IOInfo &amp;file_io_info,</span><br><span class="line">                                      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Issue&gt;&amp; issues) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetMainThreadId() == file_io_info.java_context_.thread_id_) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最大读写时间超过 13ms</span></span><br><span class="line">        <span class="keyword">if</span> (file_io_info.max_once_rw_cost_time_μs_ &gt; IOCanaryEnv::kPossibleNegativeThreshold) &#123;</span><br><span class="line">            type = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一次连续读写时间超过 500ms</span></span><br><span class="line">        <span class="keyword">if</span>(file_io_info.max_continual_rw_cost_time_μs_ &gt; env.GetMainThreadThreshold()) &#123;</span><br><span class="line">            type |= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">Issue <span class="title">issue</span><span class="params">(kType, file_io_info)</span></span>;</span><br><span class="line">            issue.repeat_read_cnt_ = type;  <span class="comment">//use repeat to record type</span></span><br><span class="line">            PublishIssue(issue, issues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没啥好说的，就是判断一些阈值而已。如果你想监测别的数据，可以自己设置一些监听。</p>
<h3 id="重复读"><a href="#重复读" class="headerlink" title="重复读"></a>重复读</h3><p>这个监听我就不贴代码了，感觉它现在有点鸡肋，我的 note 分支里面有详细注释，有兴趣可以查看。</p>
<p>其实，我觉得可以统计一下App在一次运行过程中，每个文件被读取的次数。反正你可以获取到每次IO的所有信息，想做什么就做什么。</p>
<h3 id="小-Buffer-的io"><a href="#小-Buffer-的io" class="headerlink" title="小 Buffer 的io"></a>小 Buffer 的io</h3><p>我们知道，对于文件系统是以block为单位读写，对于磁盘是以page 为单位读写，看起来即使我们在应用程序上面使用很小的Buffer，在底层应该差别不大，那是不是这样呢？</p>
<p>实际上不是的，因为如果 buffer 过小，会导致多次无用的系统调用，write与read的次数变多，这样性能就下降了，那么应该如何选择 buffer的大小呢？可以参考文件系统的 block size 的大小来决定。一般是 4K。</p>
<p>那么又来了一个问题？buffer搞很大会咋样呢？实际上如果你自己测试一下的话，会发现4K往上的话，收益就开始变小了，甚至会降低。所以一般推荐 4K 以上，也不要搞太大。</p>
<p>看一下监测小buffer的代码，很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FileIOSmallBufferDetector::Detect(<span class="keyword">const</span> IOCanaryEnv &amp;env, <span class="keyword">const</span> IOInfo &amp;file_io_info,</span><br><span class="line">                                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Issue&gt; &amp;issues) &#123;</span><br><span class="line">    <span class="comment">//__android_log_print(ANDROID_LOG_ERROR, "FileIOSmallBufferDetector", "Detect buffer_size:%d threshold:%d op_cnt:%d rw_cost:%d",</span></span><br><span class="line">    <span class="comment">//                  file_io_info.buffer_size_, env.GetSmallBufferThreshold(), file_io_info.op_cnt_, file_io_info.max_continual_rw_cost_time_μs_);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读写次数 &gt; 20</span></span><br><span class="line">    <span class="comment">// 读写总数量 / 读写次数 &lt; 4096</span></span><br><span class="line">    <span class="comment">// 最大连续读写耗时 &gt;= 13ms</span></span><br><span class="line">    <span class="keyword">if</span> (file_io_info.op_cnt_ &gt; env.kSmallBufferOpTimesThreshold</span><br><span class="line">        &amp;&amp; (file_io_info.op_size_ / file_io_info.op_cnt_) &lt; env.GetSmallBufferThreshold()</span><br><span class="line">        &amp;&amp; file_io_info.max_continual_rw_cost_time_μs_ &gt;= env.kPossibleNegativeThreshold) &#123;</span><br><span class="line"></span><br><span class="line">        PublishIssue(Issue(kType, file_io_info), issues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未关闭的文件"><a href="#未关闭的文件" class="headerlink" title="未关闭的文件"></a>未关闭的文件</h3><p>除了上面监测主线程的各种问题之外，该库还提供了一个特殊的功能，监测未关闭的文件操作。</p>
<p>其大致原理是使用了 CloseGuard 类，这个类的用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloseGuard mCloseGuard = CloseGuard.get();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">InputQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputQueue&gt;(<span class="keyword">this</span>), Looper.myQueue());</span><br><span class="line"></span><br><span class="line">       mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">       </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           dispose(<span class="keyword">true</span>);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">super</span>.finalize();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       dispose(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(<span class="keyword">boolean</span> finalized)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mCloseGuard != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (finalized) &#123;</span><br><span class="line">               mCloseGuard.warnIfOpen();</span><br><span class="line">           &#125;</span><br><span class="line">           mCloseGuard.close();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">           nativeDispose(mPtr);</span><br><span class="line">           mPtr = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>用法还是挺简单的，就是利用了 finalize 方法。</p>
<p>它先在构造方法里面，调用了 CloseGuard 的 open 方法，open方法里面记录了一个标识。假设，我们使用完该类后，没有调用该类的 dispose 方法，那么 CloseGuard  里面的标识就还存在，那么当该类被回收的时候，会触发 finalize 方法，然后执行到 CloseGuard.warnIfOpen 方法，这样就会弹出警告。</p>
<p>所以它的原理，其实就是利用了 finalize 来监测我们是否成对的调用了某些方法。</p>
<p>我们可以利用这个类，因为系统的很多类都使用了 CloseGuard ，我们开启严格模式后能监测一些问题，就是利用的这个原理。</p>
<p>所以，我们需要 hook 这个类，监测到未关闭的文件，就提出警告。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// hook 系统的 CloseGuard 类，该类是用于监测某些类是否正常关闭的，比如 cursor</span></span><br><span class="line">        <span class="comment">// 具体是先看一下 android.view.InputQueue 的源码就好了，几十行</span></span><br><span class="line">        <span class="comment">// 大致原理就是依赖 finalize 方法来监测是否有调用对应的  close 方法</span></span><br><span class="line">        <span class="comment">// 所以，我们使用反射开启这个类的功能，然后 hook 它，在里面做我们的逻辑</span></span><br><span class="line">        Class&lt;?&gt; closeGuardCls = Class.forName(<span class="string">"dalvik.system.CloseGuard"</span>);</span><br><span class="line">        Class&lt;?&gt; closeGuardReporterCls = Class.forName(<span class="string">"dalvik.system.CloseGuard$Reporter"</span>);</span><br><span class="line">        Method methodGetReporter = closeGuardCls.getDeclaredMethod(<span class="string">"getReporter"</span>);</span><br><span class="line">        Method methodSetReporter = closeGuardCls.getDeclaredMethod(<span class="string">"setReporter"</span>, closeGuardReporterCls);</span><br><span class="line">        Method methodSetEnabled = closeGuardCls.getDeclaredMethod(<span class="string">"setEnabled"</span>, <span class="keyword">boolean</span>.class);</span><br><span class="line"></span><br><span class="line">        sOriginalReporter = methodGetReporter.invoke(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        methodSetEnabled.invoke(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// open matrix close guard also</span></span><br><span class="line">        MatrixCloseGuard.setEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = closeGuardReporterCls.getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        methodSetReporter.invoke(<span class="keyword">null</span>, Proxy.newProxyInstance(classLoader,</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[]&#123;closeGuardReporterCls&#125;,</span><br><span class="line">                <span class="comment">// hook 类</span></span><br><span class="line">            <span class="keyword">new</span> IOCloseLeakDetector(issueListener, sOriginalReporter)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        MatrixLog.e(TAG, <span class="string">"tryHook exp=%s"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们在 IOCloseLeakDetector 里面，就可以处理问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MatrixLog.i(TAG, <span class="string">"invoke method: %s"</span>, method.getName());</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"report"</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPublished(stackKey)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里处理 issue</span></span><br><span class="line">                Issue ioIssue = <span class="keyword">new</span> Issue(SharePluginInfo.IssueType.ISSUE_IO_CLOSABLE_LEAK);</span><br><span class="line">                ioIssue.setKey(stackKey);</span><br><span class="line">                JSONObject content = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    content.put(SharePluginInfo.ISSUE_FILE_STACK, stackKey);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line">                    MatrixLog.e(TAG, <span class="string">"json content error: %s"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                ioIssue.setContent(content);</span><br><span class="line">                publishIssue(ioIssue);</span><br><span class="line">                MatrixLog.i(TAG, <span class="string">"close leak issue publish, key:%s"</span>, stackKey);</span><br><span class="line">                markPublished(stackKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(originalReporter, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里，就触发了 publishIssue 方法。</p>
<p>有一点需要注意，这里是开启了 CloseGuard，所以使用了 CloseGuard 的类都可以监测到，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">"android.view.InputQueue"</span>);</span><br><span class="line">    Object o = aClass.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//need to trigger gc to detect leak</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">        Runtime.getRuntime().runFinalization();</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>这里我们使用了，InputQueue，它里面使用了 CloseGuard，而我们没有调用其 dispose 方法，所以这个函数会被检测出来使用有问题。</p>
<h3 id="处理issue"><a href="#处理issue" class="headerlink" title="处理issue"></a>处理issue</h3><p>上面检测出来的问题，最终都会汇总到 com.tencent.matrix.plugin.Plugin#onDetectIssue 这个方法里面，然后对 Issue 进行处理，其实就是转为json，用于可视化展示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetectIssue</span><span class="params">(Issue issue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (issue.getTag() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// set default tag</span></span><br><span class="line">        issue.setTag(getTag());</span><br><span class="line">    &#125;</span><br><span class="line">    issue.setPlugin(<span class="keyword">this</span>);</span><br><span class="line">    JSONObject content = issue.getContent();</span><br><span class="line">    <span class="comment">// add tag and type for default</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (issue.getTag() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            content.put(Issue.ISSUE_REPORT_TAG, issue.getTag());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (issue.getType() != <span class="number">0</span>) &#123;</span><br><span class="line">            content.put(Issue.ISSUE_REPORT_TYPE, issue.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        content.put(Issue.ISSUE_REPORT_PROCESS, MatrixUtil.getProcessName(application));</span><br><span class="line">        content.put(Issue.ISSUE_REPORT_TIME, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">        MatrixLog.e(TAG, <span class="string">"json error"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的回调是整个 matrix 的一个回调，我们可以在这个回调里面进行个性化处理，比如上报后台之类的</span></span><br><span class="line">    <span class="comment">//MatrixLog.e(TAG, "detect issue:%s", issue);</span></span><br><span class="line">    pluginListener.onReportIssue(issue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://zhuanlan.zhihu.com/p/36426206" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36426206</a></p>

    </div>

    
    
    
      

        
      
        <div id="reward-container">
  <div>觉得不错，那就赞赏一下吧～</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="aprz512 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="aprz512 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>aprz512</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://aprz512.github.io/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/" title="016-Matrix源码分析：监测IO情况">http://aprz512.github.io/2020/08/31/blog_bak/Blog/Android-源码解析/Matrix/016-Matrix源码分析：监测IO情况/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/08/27/blog_bak/Blog/C++/番外篇：重定位/" rel="next" title="番外篇：重定位">
                  <i class="fa fa-chevron-left"></i> 番外篇：重定位
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/09/01/blog_bak/Blog/计算机原理/写入放大/" rel="prev" title="写入放大">
                  写入放大 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">218</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#so相关"><span class="nav-number">1.</span> <span class="nav-text">.so相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hook-函数"><span class="nav-number">2.</span> <span class="nav-text">hook 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#open"><span class="nav-number">2.1.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#read-write"><span class="nav-number">2.2.</span> <span class="nav-text">read/write</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#close"><span class="nav-number">2.3.</span> <span class="nav-text">close</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程"><span class="nav-number">3.</span> <span class="nav-text">流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程IO"><span class="nav-number">4.</span> <span class="nav-text">主线程IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复读"><span class="nav-number">5.</span> <span class="nav-text">重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小-Buffer-的io"><span class="nav-number">6.</span> <span class="nav-text">小 Buffer 的io</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未关闭的文件"><span class="nav-number">7.</span> <span class="nav-text">未关闭的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理issue"><span class="nav-number">8.</span> <span class="nav-text">处理issue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文档"><span class="nav-number">9.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">928k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">14:03</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>



<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
