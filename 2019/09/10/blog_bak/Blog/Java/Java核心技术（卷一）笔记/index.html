<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: true,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="第一章 Java程序设计概述面向对象设计用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。即时编译解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术（基础知识）笔记">
<meta property="og:url" content="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/index.html">
<meta property="og:site_name" content="二手程序员">
<meta property="og:description" content="第一章 Java程序设计概述面向对象设计用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。即时编译解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/exception.png">
<meta property="og:image" content="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/super.png">
<meta property="og:updated_time" content="2019-08-18T04:48:54.611Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java核心技术（基础知识）笔记">
<meta name="twitter:description" content="第一章 Java程序设计概述面向对象设计用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。即时编译解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。">
<meta name="twitter:image" content="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/exception.png">
  <link rel="canonical" href="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>
<link href="https://fonts.loli.net/css?family=EB+Garamond:400,400i,700,700i|Noto+Serif+SC:400,500,700&display=swap&subset=chinese-simplified" rel="stylesheet">

  <title>Java核心技术（基础知识）笔记 | 二手程序员</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二手程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">吹灭读书灯，一身都是月。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">22</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">12</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于我</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">188</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none"
             placeholder="搜索..." spellcheck="false"
             type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aprz512">
      <meta itemprop="description" content="博客建于2017年02月05日21:39:56">
      <meta itemprop="image" content="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="二手程序员">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java核心技术（基础知识）笔记

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-10 10:34:15" itemprop="dateCreated datePublished" datetime="2019-09-10T10:34:15+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-18 12:48:54" itemprop="dateModified" datetime="2019-08-18T12:48:54+08:00">2019-08-18</time>
              </span>
            
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/" itemprop="commentCount"></span></a>
  </span>
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>27k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>25 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="第一章-Java程序设计概述"><a href="#第一章-Java程序设计概述" class="headerlink" title="第一章 Java程序设计概述"></a>第一章 Java程序设计概述</h3><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p>用木匠打个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象”的木匠首先考虑的是所用的工具。</p><h4 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h4><p>解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。</p><a id="more"></a>

<p>字节码可以（在运行时刻）动态的翻译成对应运行这个应用的特定CPU机器码。</p>
<p>即时编译器还可以消除函数调用（即“内联”）。</p>
<h3 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h3><p>####一个简单的Java应用程序</p>
<p>根据Java语言规范，Java虚拟机将从指定类中的main方法开始执行。</p>
<p>不过，当main方法不是public时，有些版本的Java解释器也可以执行Java应用。这是因为Java虚拟机规范并没有要求main方法一定是public。这个问题已经得到了修复，在Java SE 1.4及以后的版本中强制main方法时public的。</p>
<p>####整形</p>
<p>从Java 7开始，加上前缀0B或者0b就可以写二进制数。例如：0b1001就是9。同样，从Java 7开始，还可以为数字字面量加下划线，如用1_000_000表示一百万。</p>
<p>####浮点类型</p>
<p>所有”非数值“的值都认为是不同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == Double.NaN) <span class="comment">// is never true</span></span><br></pre></td></tr></table></figure>

<p>可以使用 Double.isNaN() 来判断（长得帅的肯定会戳进去看一下源码，很有意思哦）。</p>
<p>浮点数不适用于无法接受舍入误差的金融计算中。例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">2.0</span> - <span class="number">1.9</span>; <span class="comment">// result = 0.10000000000000009</span></span><br></pre></td></tr></table></figure>

<p>这是因为二进制无法精确的表示 1/10。</p>
<p>可移植性是Java的设计目标之一。无论在哪个虚拟机上运行，同一运算应该得到同样的结果。对于浮点数的算术运算，实现这样的可移植性是相当困难的。double类型使用64位储存一个数值，而有些处理器使用80位浮点寄存器。这些寄存器增加了中间过程的计算精度。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ddoble w = x * y / z;</span><br></pre></td></tr></table></figure>

<p>使用严格浮点计算，截断中间数，可以了解一下 strictfp 关键字。</p>
<p>####char类型</p>
<p>转义字符\u可以出现在加引号的字符常量或字符串之外（其他的转义字符不行）。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String\u005B\u005D args)</span></span></span><br></pre></td></tr></table></figure>

<p>\u005B\u005D其实就是[]，所以上面的代码就是程序的入口main函数。（可以编译成class文件并运行，但是不被IDE识别）</p>
<p>Unicode转义字符会在解析代码之前得到处理，举个吓死人的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file in c:\user</span></span><br></pre></td></tr></table></figure>

<p>当你在代码里面加上这行注释的时候，点击运行按钮就会发现，编译过不了！！！我的理解是先会将文件里面的转义字符全部处理一下，当处理到这行注释的时候，发现了 <code>\u</code> 会当成转义字符来处理，但是 <code>\u</code> 后面的字符不合法，所以就报错了。</p>
<p>Unicode的基本平面，辅助平面，码点的概念，可以看维基百科。</p>
<p>一个字符可能有多个码点，一个char只能表示一个码点。</p>
<p>####运算符</p>
<p>整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或者NaN结果。</p>
<p>####数值类型之间的转换</p>
<p>两个操作数有一个是 double ，则两个数按照 double 处理，</p>
<p>否则，有一个是 float，则两个数按照 float 处理，</p>
<p>否则，有一个是 long，则两个数按照 long 处理，</p>
<p>否则，两个数按照 int 处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">byte</span> c = a + b; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">1</span>;</span><br><span class="line">a += <span class="number">1</span>; <span class="comment">// ok，因为 += 会自动进行强制转换</span></span><br></pre></td></tr></table></figure>

<p>####位运算符</p>
<p>处理整形类型时，可以直接对组成整形数值的各个位完成操作，浮点数不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">a &lt;&lt; 1; // ok</span><br><span class="line">double b = 3;</span><br><span class="line">b &lt;&lt; 1; // error</span><br></pre></td></tr></table></figure>

<p>位移运算符的右操作数要完成模32的运算（如果左操作是long型，则需要模64）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">35</span> 相当于 <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>####字符串</p>
<p>编译器可以让字符串共享，只有字符串常量是共享的，+或者substring等操作产生的结果并不是共享的。</p>
<p>####格式化输出：</p>
<p>使用参数索引来对一个参数进行多次格式化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">"%1$s %2$tB %2$te %2$tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>可以看到第二个索引对<code>new Date()</code>参数格式化了多次。使用<code>&lt;</code>标志也可以达到同样的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">"%s %tB %&lt;te %&lt;tY"</span>, <span class="string">"Due date:"</span>, <span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>####数组</p>
<p>Java中，允许数组长度为0，数组长度为0和null不同。</p>
<p>####数组排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a); <span class="comment">// 这个方法使用了优化的快速排序算法</span></span><br></pre></td></tr></table></figure>

<p>利用数组写一个抽彩游戏（这个算法还是很有想法的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    numbers[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = (<span class="keyword">int</span>)(Math.random() * n);</span><br><span class="line">    result[i] = numbers[r];</span><br><span class="line">    <span class="comment">// 最关键的代码，将上面随机出来的数用最后一个数覆盖</span></span><br><span class="line">    numbers[r] = numbers[n - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 将 n 减一，相当于去掉最后一个数</span></span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四章-类与对象"><a href="#第四章-类与对象" class="headerlink" title="第四章 类与对象"></a>第四章 类与对象</h3><p>####面向对象程序设计概述</p>
<p>OOP将数据放在第一位，然后再考虑操作数据的算法。</p>
<p>####对象</p>
<p>对象状态的改变必须通过调用方法实现，如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。</p>
<p>####类之间的关系</p>
<p>最常见的关系有：</p>
<ul>
<li>依赖（“use-a”）</li>
<li>聚合（“has-a”）</li>
<li>继承（“is-a”）</li>
</ul>
<p>####Java类库中的LocalDate类</p>
<p>将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。</p>
<p>####用户自定义类</p>
<p>在一个源文件中，只能有一个公有类，但可以有任意数目的非共有类。</p>
<p>第一眼看到这句话我是懵逼的，后来仔细看了代码，发现应该说的是非内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的源文件是Ok的。但是把Main2改成public的就不行。</p>
<p>####封装的优点</p>
<p>可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p>
<p>更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。</p>
<p>####静态常量</p>
<p>我们常使用的System类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 final 修饰的变量是不允许将别的值赋给它的，但是System类有这样的一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setOut</span><span class="params">(PrintStream out)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>它可以将System.out设置为不同的流，原因是setOut是一个本地方法，它可以绕过Java语言的存取控制机制。</p>
<p>####方法参数</p>
<p>Java程序设计语言总是采用按值调用。有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的，下面给出例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Car a, Car b)</span> </span>&#123;</span><br><span class="line">    Car temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果Java对对象采用的是按照引用传递，那么这个方法应该够实现交换数据的效果，但是，并没有。参数被初始化为对象引用的拷贝。</p>
<p>####初始化块</p>
<p>调用构造器的具体处理步骤：</p>
<ol>
<li>所有数据域被初始化为默认值（0，false或null）。</li>
<li><strong>按照在类声明中出现的顺序</strong>，依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li>
<li>执行这个构造器的主题。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main m = new Main(); 问，m.getA() 的值？</span></span><br></pre></td></tr></table></figure>

<h4 id="对象析构与-finalize-方法"><a href="#对象析构与-finalize-方法" class="headerlink" title="对象析构与 finalize 方法"></a>对象析构与 finalize 方法</h4><p>在实际应用中，不要依赖使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</p>
<p>我一直觉得，final，finally，finalize有啥区别，这个问题很傻×，因为他们毛关系没有，区别从何谈起。问问 final  与 volitile的区别吧！！！</p>
<p>####将类放入包中</p>
<p>假定有一个源文件开头有下列语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aprz;</span><br></pre></td></tr></table></figure>

<p>编译器在编译源文件的时候不检查目录结构，即使这个源文件没有在子目录 com/aprz 下，也可以进行编译。但是，最终的程序将无法运行。如果包与目录不匹配，虚拟机就找不到类。</p>
<p>####包作用域</p>
<p>如果，把一个类文件放置在类路径的某处的 java/awt 子目录下，那么我们就可以访问 java.awt 包的内部了。非常危险！</p>
<p>从 1.2 版开始，JDK 的实现者修改了类加载器，明确禁止加载用户自定义的、包名以“java”开始的类！</p>
<p>####类路径</p>
<p>javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录。如果没有设置类路径，那也并不会产生什么问题，默认的类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。</p>
<p>下面看一个类路径示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/classdir:.:/home/user/archives/archive.jar</span><br></pre></td></tr></table></figure>

<p>假定虚拟机要搜寻 <code>com.horstmann.corejava.Employee</code>类文件。它首先要查看储存在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。显然，在那里找不到相应的类文件，然后再查看类路径。然后查找一下文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/user/classdir/com/horstmann/corejava/Employee.class</span><br><span class="line">com/horstmann/corejava/Employee.class从当前目录开始</span><br><span class="line">com/horstmann/corejava/Employee.class inside /home/user/archives/archive.jar</span><br></pre></td></tr></table></figure>

<p>编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类。例如，假定源文件包含指令:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> com.horstmann.corejava.*;</span><br></pre></td></tr></table></figure>

<p>并且源代码引用了Employe类。<strong>编译器将试图查找jva.lang.Employee (因为java lang包被默认入）、java.util.Employee、com.hostmann.corejava.Employee和当前包中的Employee。</strong>对这个类路径的所有位置中所列出的每个类进行逐查看。 如果找到了一个以上的类，就会产生编译错误(因为类必须是唯一的， 而import语句的次序却无关紧要)。</p>
<p>编译器的任务不止这些，它还要查看源文件( Source files) 是否比类文件新。<strong>如果是这样的话，那么源文件就会自动地重新编译</strong>。</p>
<p>在前面已经知道，仅可以导入其他包中的公有类。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，<strong>编译器很容易定位公有类所在的源文件</strong>。当然，也可以从当前包中<strong>导入非公有类</strong>。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，<strong>编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类</strong>。</p>
<p>这一段很长，我只能说QQ的图片文字识别真的牛逼。</p>
<h3 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h3><h4 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h4><p>前缀“超”与“子”来源于计算机科学和数学理论中的集合语言的术语。</p>
<h4 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h4><p>尽管子类对象有父类的私有域，但是却无法在子类中访问这个域。（这句话是我总结的，可能并不严谨）</p>
<p>有些人（包括我）认为super与this应用是类似的概念，实际上，这样比较并不太恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个只是编译器调用超类方法的特殊关键字。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>虚拟机知道一个引用的对象类型，所以能够正确的调用相应的方法。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">B[] bs = <span class="keyword">new</span> B[<span class="number">8</span>];</span><br><span class="line">A[] as = bs;</span><br></pre></td></tr></table></figure>

<p>但是这样会有一个问题，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as[<span class="number">0</span>] = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>编译器是会接纳这个赋值操作的。由于bs与as指向同一个数组，当调用B中特有的方法时，就会出现错误。而且在运行时还会报出 ArrayStoreException 错误。</p>
<h4 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h4><ol>
<li>编译器查看对象的声明类型和方法名。假设调用 <code>x.f(param)</code>，且隐私参数<code>x</code>声明为<code>C</code>类的对象。编译器会一一列举所有<code>C</code>类中名为<code>f</code>的方法和其超类中访问属性为<code>public</code>且名为<code>f</code>的方法。</li>
<li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<em>重载解析</em>。</li>
</ol>
<p><u>允许子类将覆盖方法的返回类型定义为原返回类型的子类型。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Father <span class="title">find</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">// B.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Son <span class="title">find</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果是 private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式就是<em>静态绑定</em>。</li>
<li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法。这样一来，在真正调用的时候，虚拟机仅查找这个表就行了。</li>
</ol>
<h4 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h4><p>在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖而且很短，编译器就能够对它进行优化处理，这个过程为称为<em>内联</em>。例如，内联调用 <code>e.getName()</code>将被替换为访问<code>e.name</code>域。这是一项很有意义的改进，这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令的策略。然面，如果<code>getName</code>在另外个类中被覆盖， 那么编译器就无法知道覆盖的代码将会做什么操作，因此也就不能对它进行内联处理了。</p>
<p> 幸运的是，虚拟机中的即时编译器比传统编译器的处理能力强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法很简短、被频繁调用且没有真正被覆盖，那么即时编译器就会将这个方法进行内联处理。如果虚拟机加载了另外一个子类，而在这个子类中包含了对内联方法的覆盖，那么将会发生什么情况呢?优化器将取消对覆盖方法的内联。这个过程很慢，但却很少发生。</p>
<h4 id="Object：所有类的超类"><a href="#Object：所有类的超类" class="headerlink" title="Object：所有类的超类"></a>Object：所有类的超类</h4><p>所有的数组类型，不管时对象数组还是基本类型的数组都扩展了Object类。</p>
<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><p>在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p>
<h4 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h4><p>如果隐私和显式的参数不属于同一个类，equals方法将如何处理呢？这是一个很有争议的话题！</p>
<p>许多程序员喜欢使用 instanceof 进行检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做不但没有解决 otherObject 是子类的情况，并且还有可能会招来一些额外的麻烦。</p>
<p>Java语言规范要求 equals 方法具有下面的特性：</p>
<ol>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>对于任意非空引用x，x.equals(null)，应该返回false。</li>
</ol>
<p>就对称性来说，当参数不属于同一个类的时候需要仔细思考一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.quals(m);</span><br></pre></td></tr></table></figure>

<p>e 是父类，m是子类。如果这两个对象的实例域都一样，当使用 instanceof 操作符的时候，会返回 true，那么意味着，m.equals(e)，也会返回true。但是实际上，反过来调用是无法通过 instanceof 操作符的。</p>
<p>建议的规则：</p>
<ul>
<li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass进行检测</li>
<li>如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。</li>
</ul>
<p>一个完美equals方法的编写模板：</p>
<ol>
<li><p>显示参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量。</p>
</li>
<li><p>检测 this 与 otherObject 是否引用同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检测otheObject是否为null，如果为null，返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测。如果所有的子类拥有统一的语义，就使用instanceof检测。</p>
</li>
<li><p>将otherObject转换为相应类型的变量</p>
<p>ClassName other = (ClassName) otherObject;</p>
</li>
<li><p>开始对所有需要比较的域进行比较，如果在子类中重新定义equals，就要在其中包含调用 super.equals(other)。</p>
</li>
</ol>
<p>一种常见的错误是将equals方法的参数类型改为具体需要比较的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person p)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的方法不是覆盖，因为参数类型不一样，Object类中equal方法的参数是Object。</p>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"ok"</span>);</span><br><span class="line">StringBuffer tb = <span class="keyword">new</span> StringBuffer(<span class="string">"ok"</span>);</span><br></pre></td></tr></table></figure>

<p>注意，sb与tb的hashCode不一样，这是因为StringBuffer没有定义自己的hashCode方法。</p>
<p><u>equals方法相等则hashCode必须一致。</u></p>
<h4 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h4><p>一旦确定数组列表的大小不再发生变化，就可以调用 trimToSize 方法。这个方法将储存区域的大小调整为当权元素数量所需要的储存空间数目。垃圾回收器将回收多余的储存空间。</p>
<h4 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h4><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类。</p>
<p>自动装箱规范要求 boolean、byte、char &lt;= 127，介于-128~127之间的short和int被包装到固定的对象中。这句话乍一看很诡异，其实都是同一个意思。</p>
<p>char 的范围是从 0 ~ 65535。</p>
<h4 id="在运行时使用反射分析对象"><a href="#在运行时使用反射分析对象" class="headerlink" title="在运行时使用反射分析对象"></a>在运行时使用反射分析对象</h4><p>setAccessible方法时AccessibleObject类中的一个方法，它是Field、Method和Constructor类的公共超类。</p>
<p>利用get方法可以访问域的值，但是有一个需要解决的问题。如果域是一个String类型，把它当作Object返回没有什么问题，但是，假设这个域是double类型的，而Java中数值类型不是对象，该怎么办呢？其实反射机制会自动地将这个域值打包到相应的对象包装器中。invoke 方法也是如此。</p>
<h4 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h4><ol>
<li><p>将公共操作和域放在超类</p>
</li>
<li><p>不要使用受保护的域</p>
<p>protect 在某种程度上破坏了封装，因为同一个包类的代码也可以访问该域。</p>
<p>子类也可以随便访问超类的protect域。</p>
</li>
<li><p>使用继承实现“is-a”关系</p>
</li>
<li><p>除非所有继承的方法都有意义，否则不要使用继承</p>
</li>
<li><p>在覆盖方法时，不要改变预期的行为</p>
</li>
<li><p>使用多态，而非类型信息</p>
</li>
<li><p>不要过多的使用反射</p>
</li>
</ol>
<h3 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章 接口、lambda表达式与内部类"></a>第六章 接口、lambda表达式与内部类</h3><h4 id="Comparable-lt-T-gt-接口"><a href="#Comparable-lt-T-gt-接口" class="headerlink" title="Comparable&lt;T&gt; 接口"></a>Comparable&lt;T&gt; 接口</h4><ul>
<li><p>如果子类之间的比较含义不一样，那就属于不同类对象的非法比较。每个compareTo方法都应该在开始时进行下列检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getClass() != other.getClass) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果存在一种通用算法，它能够对两个不同的子类对象进行比较，则应该在超类中提供一个compareTo方法，并将这个方法声明为final。</p>
</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在Java SE8中，允许在接口中增加静态方法。只是有违于将接口作为抽象规范的初衷。</p>
<p>目前为止，通常的做饭都是将静态方法放在伴随类中。Collection/Collections……</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>可以为接口提供一个默认方法。必须用default修饰符标记这样的一个方法。</p>
<p>一般来说，这并没有太大的用处。但是当一个接口的方法特别多是就可以很有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fd</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，我们只关心其中的一两个方法。在Java SE8 中我们就可以将它声明为默认方法，什么也不做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fb</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fd</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fe</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，使用者就只需要覆盖真正关心的方法。</p>
<p>默认方法的一个重要作用是“接口演化”。以Collection接口为例，假设你有一个类实现了这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Collection</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>后来，在Java SE8中，又为这个接口增加了一个stream方法。</p>
<p>假设steam不是默认方法。那么Bag类将无法编译，因为它没有实现这个方法。<strong>为接口增加一个非默认方法不能保证源代码兼容。</strong></p>
<p>不过，如果不重新编译这个类，而是使用原来的包含这个类的JAR文件，这个类仍然可以正常加载。<strong>为接口增加方法可以保证二进制兼容。</strong>不过，如果调用了steam方法，就会抛出一个AbstractMethodError。</p>
<h4 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a>解决默认方法冲突</h4><p>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况呢？</p>
<ol>
<li>超类优先。如果超类提供了具体的方法，会忽略接口的默认方法。可以保证与Java SE7的兼容性。</li>
<li>接口冲突。如果一个接口提供了默认方法，另一个接口提供了一个同名且参数类型相同的方法（不管是不是默认的），必须覆盖这个方法来解决冲突。</li>
</ol>
<p><strong>千万不要让一个默认方法重新定义Object类中方法</strong>！！！</p>
<h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>clone方法是Object的一个protected方法，这说明你的代码不能直接调用这个方法。</p>
<p>默认的克隆操作是“浅拷贝”，并没有克隆对象中引用的其他对象。</p>
<p>Cloneable接口并没有什么作用，它只是一个标记，指示类设计者了解克隆过程，clone方法是从Object类中继承过来的。</p>
<p>必须当心子类的克隆。</p>
<h4 id="为什么引入lambda表达式"><a href="#为什么引入lambda表达式" class="headerlink" title="为什么引入lambda表达式"></a>为什么引入lambda表达式</h4><p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<h4 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h4><p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = </span><br><span class="line">    (first, second) -&gt; first.length() - second.length();</span><br></pre></td></tr></table></figure>

<p>无需指定lambda表达式的返回类型。lambda表达式的返回类型总是会由上下文推导得出。</p>
<p>如果，一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数式表达式"><a href="#函数式表达式" class="headerlink" title="函数式表达式"></a>函数式表达式</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口成为函数式接口。</p>
<p>最好把lambda表达式看作是一个函数，而不是一个对象，另外要接受lambda表达式可以传递到函数式接口。</p>
<p>不过，Java现在对lambda表达式能做的也只是转换为函数式接口。</p>
<p>Java API 在 java.util.function 包中定义了很多通用的函数式接口。例如：BiFunction&lt;T,U,R&gt;。</p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure>

<p>这样，看起来很简洁了，但是如果能把 println 方法传递到 Timer 的构造器就更好了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, System.out::println);</span><br></pre></td></tr></table></figure>

<p>表达式 System.out::println 是一个方法引用，它等价于 x-&gt; System.out.println(x);</p>
<p>方法引用的写法有3中：</p>
<ul>
<li>objcet::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>前两种情况，方法引用等价于提供方法参数的lambda表达式。</p>
<p>对于第三种情况，第一个参数会成为方法的目标。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String::compareToIgnoreCase 等价于</span><br><span class="line">(x, y) -&gt; x.compareToIgnoreCase(y);</span><br></pre></td></tr></table></figure>

<p>可以在方法引用种使用 this 与 super。</p>
<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><p>构造器引用与方法引用类似，只不过方法名为new。例如，Person::new是Person构造器的一个引用。但是它具体引用的是哪个构造器与上下文有关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = ..;</span><br><span class="line">Stream&lt;Person&gt; stream = names.steam().map(Person::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>map方法会调用Person(String) 构造器。</p>
<p>可以用数组类型建立构造器引用。例如，int[]::new 是一个构造器引用，<strong>它有一个参数：即数组的长度</strong>。</p>
<p>Java有一个限制，无法构造泛型类型T的数组。new T[] 会产生错误。</p>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>有时候，我们会在lambda表达式种访问外围方法或类中的变量。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">"ok"</span>;</span><br><span class="line">ActionListener listener = event -&gt; &#123;</span><br><span class="line">  	Sysout.out.println(text);  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000年之后</span></span><br><span class="line"><span class="keyword">new</span> Timer(delay, listener);</span><br></pre></td></tr></table></figure>

<p>仔细想想，这里会有问题。lambda表达式的代码可能会在很久之后才运行，那个时候，text可能已经不存在了。要了解发生了什么，我们先来了解lambda表达式的组成：</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值，这是指非参数而且不在代码中定义的变量。</li>
</ol>
<p><u>lambda表达式的数据结构必须存储自由变量的值。</u> 关于代码块与自由变量在别的语言里面有一个术语叫闭包。</p>
<p>lambda表达式引用了自由变量，无法对这个自由变量进行更改，因为会引发多线程问题。</p>
<p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init &#123;</span><br><span class="line">        ActionListener listener = event -&gt; &#123;</span><br><span class="line">            Sysout.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式会调用Application的toString，而不是 ActionListener的toString。</p>
<h4 id="处理lambda表达式"><a href="#处理lambda表达式" class="headerlink" title="处理lambda表达式"></a>处理lambda表达式</h4><p>如果设计你自己的接口，其中只有一个抽象方法，可以用 @FunctionalInterface 注解来标记这个接口。</p>
<h4 id="再谈Comparator"><a href="#再谈Comparator" class="headerlink" title="再谈Comparator"></a>再谈Comparator</h4><p>静态 comparing 方法取一个“键提取器”函数，它将类型T映射为一个可比较的类型。对要比较的对象应用这个函数，然后对返回的键完成比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(people, Comparator.comparing(Person::name));</span><br></pre></td></tr></table></figure>

<p>还有很多其他的方法，需要自己去戳源码。</p>
<h4 id="内部类的特殊规则语法"><a href="#内部类的特殊规则语法" class="headerlink" title="内部类的特殊规则语法"></a>内部类的特殊规则语法</h4><p>可以通过显示的命名将外围类引用设置为其他的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">In</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------</span><br><span class="line">Out o = <span class="keyword">new</span> Out();</span><br><span class="line">Out.In in = o.new In();</span><br></pre></td></tr></table></figure>

<p>非静态内部类的所有静态域都必须是final的。</p>
<p>非静态内部类不能有static方法。</p>
<p>非static的内部类，在外部类加载的时候，并不会加载它，所以它里面不能有静态变量或者静态方法。</p>
<ul>
<li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li>
<li>要使用某个类的static属性或者方法，那么这个类必须要加载到jvm中。 </li>
</ul>
<p>基于以上两点，可以看出，如果一个非static的内部类如果具有static的属性或者方法，那么就会出现一种情况：内部类未加载，但是却试图在内存中创建static的属性和方法，这当然是错误的。原因：类还不存在，但却希望操作它的属性和方法。</p>
<h4 id="内部类是否有用、必要和安全"><a href="#内部类是否有用、必要和安全" class="headerlink" title="内部类是否有用、必要和安全"></a>内部类是否有用、必要和安全</h4><p>内部类是一种编译器现象，与虚拟机无关。编译器将会把内部类翻译成用 $ 符号分隔外部类名与内部类名的常规类文件，而虚拟机对此一无所知。</p>
<p>内部类是如何访问外部的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">In</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这是编译器自动生成的方法，我们在内部类中调用a，实际上是使用了这个方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>(Out);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器。取而代之的是将构造参数传递给超类构造器。</p>
<p>对于静态方法的日志问题，如果我们希望在静态方法中输出当前类的类名，但是静态方法没有this，可以使用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;&#125;.getClass().getEnclosingClass();</span><br></pre></td></tr></table></figure>

<h4 id="代理的特性"><a href="#代理的特性" class="headerlink" title="代理的特性"></a>代理的特性</h4><p>所有的代理类都覆盖了Object类中的方法 toString、equals和hashCode。</p>
<p>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。如果使用同一个类加载器和接口数组调用两次 newProxyInstance 方法的话，那么只能得到同一个类的两个对象。</p>
<p>如果代理类实现的所有接口都是public的，那么代理类不属于某个特定的包。否则。所有非公有的接口都必须属于同一个包，代理类也属于这个包。</p>
<h3 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章 异常、断言和日志"></a>第七章 异常、断言和日志</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p><img src="exception.png" alt></p>
<p>Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。</p>
<p>Exception分为两个分支：</p>
<blockquote>
<p>一个分支派生于RuntimeException，另一个包含其他异常。</p>
</blockquote>
<p><strong>划分规则是</strong>：由程序错误导致的异常属于RuntimeException；而程序本身没有问题，但由于像IO错误这类问题的异常属于其他异常。</p>
<h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。</p>
<p>如果超类方法没有抛出任何受查异常，子类也不能抛出任何异常。</p>
<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续传递。</p>
<h4 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h4><p>在Java SE 7中，同一个catch子句中可以捕获多个异常类型。</p>
<blockquote>
<p>只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。</p>
<p>捕获多个异常类型时，异常变量隐含为final。</p>
</blockquote>
<h4 id="再次抛出异常与异常链"><a href="#再次抛出异常与异常链" class="headerlink" title="再次抛出异常与异常链"></a>再次抛出异常与异常链</h4><p>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (AException a) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BException(<span class="string">"msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，有一种更好的处理方法，并且将原始异常设置为新异常的“原因”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (AException a) &#123;</span><br><span class="line">    Throwable t = <span class="keyword">new</span> BException(<span class="string">"msg"</span>); </span><br><span class="line">    t.initCause(a);</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们调用 e.getCause() 就可以拿到原始异常。强烈推荐使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。</p>
<p>在Java SE 7之前，无法抛出声明异常之外的类型（虽然现在也是，但是编译器的行为不一样了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java SE 7之前，会有一个问题，编译器会指出这个方法可以抛出任何异常，而不仅仅是SQLException。</p>
<blockquote>
<p>现在编译器会跟踪到 e 来自 try 块。假设这个try中仅有的已检查异常是 SQLException的实例，另外，e没有被改变，那么这个方法就是合法的。</p>
</blockquote>
<h4 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h4><p>强烈建议解耦 try/catch 和 try/finally 语句块。这样可以提高代码的清晰度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设计方式不仅清楚，而且还有一个功能，可以捕获 finally 里面的异常。</p>
<p>当 finally 子句包含return语句时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> r = n * n;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法返回之前，finally 子句的内容将会执行。如果finally子句中也有一个return语句，这返回值将会覆盖原始的返回值。</p>
<p>finally 子句的异常可能会覆盖try中的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设try块中抛出了非IOException，而close方法也出了异常，那么最后抛出的是 close 方法的 IOException。一般我们对 try 块中的异常更感兴趣，但是这时异常已经被丢失了，除非给  close 也加上 try 语句，这样就会非常繁琐。</p>
<h4 id="带资源的-try-语句"><a href="#带资源的-try-语句" class="headerlink" title="带资源的 try 语句"></a>带资源的 try 语句</h4><p>如果资源属于一个实现了 AutoCloseable 接口的类，Java SE 7 为这种代码模式提供了一个很有用的快捷方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Resource res = ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 块退出时，或者存在一个异常，都会自动调用 <code>res.close();</code>，资源会被关闭。</p>
<p>这种 try 语句自身也可以带 catch 和 finally 语句，但是一般不用。</p>
<h3 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章 泛型程序设计"></a>第八章 泛型程序设计</h3><h4 id="定义简单泛型类"><a href="#定义简单泛型类" class="headerlink" title="定义简单泛型类"></a>定义简单泛型类</h4><p>泛型类可以看作普通类的工厂。</p>
<h4 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h4><p>一个类型变量或通配符可以有多个限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>限定类型用 &amp; 分隔，而逗号用来分隔类型变量。如果用一个类来做限定，它必须是限定列表中的第一个。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>虚拟机没有泛型对象，它会擦除类型变量，并替换为限定类型（无限定类型的变量用Object）。</p>
<p>如果有多个限定，会怎么样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span> &amp; <span class="title">Compareable</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>原始类型用 Serialzable 替换 T，编译器会在必要的时候将其强制转换为 Comparable。为了提高效率，应该将标签接口（没有方法的接口）放在边界列表的末尾。</p>
<p><u>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。</u></p>
<h4 id="翻译泛型方法"><a href="#翻译泛型方法" class="headerlink" title="翻译泛型方法"></a>翻译泛型方法</h4><p>假设我们有这样的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------</span><br><span class="line"><span class="comment">// 擦除之后，这里 T 擦除之后是 Object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个类继承它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="title">extend</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="title">extend</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 这里不是重写，只是展示有一个从父类继承过来的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是问题就来了，假设我使用父类引用子类的变量，然后调用 setSecond 方法，那么它本来应该走到子类的方法里面去，但是由于泛型的擦除，导致子类方法签名不一致了（父类是 Object，子类是 LocalDate）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">Pare&lt;LocalDate&gt; pair = date;</span><br><span class="line"><span class="comment">// 猜猜它会调用那个方法</span></span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>

<p>现在多态与泛型擦除出现了冲突，解决方法是需要编译器在 Date类中生成一个桥方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123;</span><br><span class="line">    setSecond((Date)second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，桥方法也会引出别的问题！</p>
<p>假设 Date 类覆盖了 getSecond 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="title">extend</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，Date 类里面就有两个同名方法了，参数一样，只有返回值不一样。编译器是不允许这样的，但是，在Java虚拟机中，用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机可以正确处理这样的情况。</p>
<p>如果你记忆力比较好的话，前面也提到过在覆盖父类的方法时，可以返回更加严格的类型，这也是利用的桥方法。</p>
<p>Java泛型转换的事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都用它们的限定类型替换</li>
<li>桥方法被合成类保持多态</li>
<li>为保持类型安全性，必要时插入强制类型转换</li>
</ul>
<h4 id="不能用基本类型实例化类型参数"><a href="#不能用基本类型实例化类型参数" class="headerlink" title="不能用基本类型实例化类型参数"></a>不能用基本类型实例化类型参数</h4><p>其原因是类型擦除，擦除之后，没有限定类型的使用 Object 代替，而 Object 不能引用基本类型。</p>
<h4 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a <span class="keyword">instanceof</span> Pair&lt;String&gt;)</span><br></pre></td></tr></table></figure>

<p>这里只是测试了 a 是否时一个 Pair 对象，与 String 毫无关系。</p>
<p>同样的道理，getClass 也总是返回原始类型。</p>
<h4 id="Varargs-警告"><a href="#Varargs-警告" class="headerlink" title="Varargs 警告"></a>Varargs 警告</h4><p>Java 不允许创建泛型数组，其原因可以自己研究研究（泛型擦除）。假设我们有这样方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection coll, T... ts)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ts 实际上时一个数组，考虑一下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; p1 = ...;</span><br><span class="line">Pair&lt;String&gt; p2 = ...;</span><br><span class="line">addAll(table, p1, p2);</span><br></pre></td></tr></table></figure>

<p>所以，Java虚拟机必须建立一个Pair&lt;String&gt; 数组，这就违反了不循序创建泛型数组的规定。不过对于这种情况，只是会显示一个警告。</p>
<h4 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h4><p>最好让用户提供一个数组构造器的表达式。</p>
<h4 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h4><p>不能在静态域中引用类型变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance; <span class="comment">// ERROR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为如果能使用的话，不同的实例会有不同的类型。</p>
<h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>泛型类扩展 Throwable 都是不合法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;&#125; <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>

<p>在异常规范中使用类型变量是合法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;&#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h4 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译器会认为t是一个非受查异常。</strong></p>
<p>再利用下面的代码就会把所有异常转换为编译器所认为的非受查异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> work</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在某些不允许抛出任何受查异常的方法中，就可以使用这个方法来抛出受查异常。</p>
<h4 id="注意擦除后的冲突"><a href="#注意擦除后的冲突" class="headerlink" title="注意擦除后的冲突"></a>注意擦除后的冲突</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦除之后，就是 <code>public boolean equals(Object t);</code> 与 Object 的方法重复了，会引发错误。</p>
<h4 id="通配符概念"><a href="#通配符概念" class="headerlink" title="通配符概念"></a>通配符概念</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(? extends Person)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这个 set 方法不能传递任何参数，因为编译器只知道需要某个 Person 的子类，但是不知道具体是什么类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void set(? super Person) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>该方法只能传递Person或者Person的子对象。</p>
<p>直观的讲，带有超类型限定的通配符可以向泛型写入，带有子类型限定的通配符可以从泛型对象读取。</p>
<p>举一个 super 限定符的应用：</p>
<blockquote>
<p>LocalDate 实现了 ChronoLocalDate，而 ChronoLocalDate 扩展了 Comparable&lt;ChronoLocalDate&gt;。</p>
</blockquote>
<blockquote>
<p>因此，LocalDate 实现的是 Comparable&lt;ChronoLocalDate&gt;，而不是 Comparable&lt;LocalDate&gt;。</p>
</blockquote>
<p>在这种情况下，可以使用超类限定符来救助（要注意泛型的 extends 与类的 extends 的不同意义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] a) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>上个图来意思意思：</p>
<p><img src="super.png" alt></p>
<h4 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? getFirst()</span><br><span class="line"></span><br><span class="line">void setFirst(?)</span><br></pre></td></tr></table></figure>

<p>getFirst 的返回值只能赋值给 Object。setFirst不能被调用，Object 也不行。</p>
<h4 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void swap(Pair&lt;?&gt; p)</span><br><span class="line"></span><br><span class="line">public staic &lt;T&gt; void swapHelper(Pair&lt;T&gt; p)</span><br></pre></td></tr></table></figure>

<p>比较有趣的是，可以在 swap 里面调用 swapHelper。这种情况下，参数 T 捕获通配符。</p>
<p><u>通配符捕获只有在有许多限制的情况下才是合法的，编译器必须能够确信通配符表达的是单个、确定的类型。</u></p>
<h3 id="第九章-集合"><a href="#第九章-集合" class="headerlink" title="第九章 集合"></a>第九章 集合</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>对 next 方法和 remove 方法的调用具有互相依赖性。</p>
<h4 id="集合框架中的接口"><a href="#集合框架中的接口" class="headerlink" title="集合框架中的接口"></a>集合框架中的接口</h4><p>List接口定义了多个用于随机访问的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br></pre></td></tr></table></figure>

<p>坦率的讲，集合框架的这个方面设计的很不好。</p>
<blockquote>
<p>集合框架中有两种类型的集合，其性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。而链表尽管也是有序的，但是随机访问会很慢，所以最好使用迭代器来遍历。所以如果原先就提供了两个接口就会容易理解些了。</p>
</blockquote>
<p>为了避免对链表完成随机访问操作，Java SE 1.4 引入了一个<u>标记</u>接口 RandomAccess。用来测试一个特定的集合是否支持高效的随机访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">    <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Set接口等同于Collection接口，不过其方法的行为有更严谨的定义。</p>
<ul>
<li>add 方法不允许增加重复的元素</li>
<li>equals 方法：只要两个集合包含相同的元素就认为是相等的，而不要求这些元素有相同的顺序</li>
<li>hashCode 方法：要保证含相同元素的两个集会得到相同的散列码</li>
</ul>
<p>既然两个接口的方法签名是一样的，为什么还要建立一个单独的接口呢？</p>
<blockquote>
<p>从概念上讲，并不是所有集合都是集。建立一个Set接口可以让程序员编写只接收集的方法。</p>
</blockquote>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>在 Java 程序设计语言中，所有链表实际上都是双向链接的。</p>
<p>ListIterator 是 Iterator 的一个子接口，它新增了一些方法。LinkedList 的 listIterator 方法会返回一个 ListIterator 的实例。注意，在使用 ListIterator 的 remove 方法时需要谨慎。</p>
<p>在调用 next 之后，remove 方法会删除迭代器左侧的元素，但是，如果调用 previous 会删除迭代器右侧的元素。</p>
<p>ConcurrentModificationException 异常的检测有一个特例：</p>
<p>链表只负责跟踪对列表的结构性修改，例如，添加元素，删除元素。set方法<u>不被视为</u>结构性修改。<strong>可以将多个迭代器附加给一个链表，所有的迭代器都调用set方法对现有的结点的内容进行修改。</strong></p>
<p><strong>不要使用</strong>下面的方法来遍历链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    Element e = get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 get 方法做了微小的优化（如果 i 大于 size()/2，会从后面开始遍历），但是这样写每次循环都要遍历一次。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>在 Java中，散列表用链表数组实现。</p>
<h4 id="树集"><a href="#树集" class="headerlink" title="树集"></a>树集</h4><p>Java SE 8 中使用的是红黑树。</p>
<p>将一个元素添加到树中要比添加到散列表中慢，不过与检查数组或链表中重复元素相比还是快很多。</p>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>优先级队列并没有对所有的元素进行排序。它使用了一个优雅且高效的数据结构——堆。</p>
<h4 id="映射-（Map）"><a href="#映射-（Map）" class="headerlink" title="映射 （Map）"></a>映射 （Map）</h4><p>总感觉翻译有点奇怪！！！</p>
<h4 id="更新映射项"><a href="#更新映射项" class="headerlink" title="更新映射项"></a>更新映射项</h4><p>看一个例子，统计单词出现的频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这会有一个问题，就是 get 可能会返回 null。于是可以这样写，给一个默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(word, counts.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>另一种方法就是先调用 putIfAbsent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">counts.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">counts.put(word, counts.get(word) + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>不过，还可以有更简单的方式，使用 merge 方法，可以简化这个常见的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.merge(word, <span class="number">1</span>, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>如果键值不存在，则将 word 置为 1，否则使用 Integer::sum 函数组合原值和 1。</p>
<h4 id="映射视图"><a href="#映射视图" class="headerlink" title="映射视图"></a>映射视图</h4><p>集合框架不认为Map本身是一个集合。</p>
<p>Map提供了方法用来获取映射视图，映射视图是实现了Collection接口或某个子接口的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<p>这3个方法会分别返回3个视图。要注意这些视图并不是 TreeSet 或者 HashSet 的实例，而是实现了 Set 接口的另外某个类的实例。</p>
<h4 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h4><p>再来说说 keySet 方法。初看起来，好像这个方法创建了一个新集，并将映射中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet 方法返回一个实现 Set 接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。</p>
<h4 id="轻量级集合包装器"><a href="#轻量级集合包装器" class="headerlink" title="轻量级集合包装器"></a>轻量级集合包装器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br></pre></td></tr></table></figure>

<p>asList 返回的并不是一个 ArrayList。它是一个视图对象，带有访问底层数组的 get 和 set 方法。改变数组大小的所有方法都会抛出一个 UnsupportedOperationException 异常。</p>
<h4 id="子范围"><a href="#子范围" class="headerlink" title="子范围"></a>子范围</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List group2 = staff.subList(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">group2.clear();</span><br></pre></td></tr></table></figure>

<p>元素自动的从 staff 列表中清除，并且 group2 为空。</p>
<h4 id="不可修改的视图"><a href="#不可修改的视图" class="headerlink" title="不可修改的视图"></a>不可修改的视图</h4><p>简而言之，就是对所有更改器方法直接抛出一个异常。</p>
<p><u>由于视图只是包装了接口而不是实际的集合对象，所以只能访问接口中定义的方法。</u></p>
<p>注意，视图并没有重新定义 Object 的 equals 和 hashCode 方法（内容是否相等的检测在分层结构的这一层上没有定义妥当）。</p>
<h4 id="受查视图"><a href="#受查视图" class="headerlink" title="受查视图"></a>受查视图</h4><p>“受查”视图用来对泛型类型发生问题时提供调试支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList rawList = strings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>

<p>这个错误在 add 的时候检测不到。相反，只有在调用 get 方法的时候才会抛出异常。受查视图可以探测这类问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; safeStrings = Collections.checkList(strings, String.class);</span><br><span class="line">ArrayList rawList = safeStrings;</span><br><span class="line">rawList.add(<span class="keyword">new</span> Date()); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>虚拟机在运行到 add 方法时，就会抛出异常。</p>
<h4 id="排序与混排"><a href="#排序与混排" class="headerlink" title="排序与混排"></a>排序与混排</h4><p>可以使用归并排序对链表进行高效的排序。但是Java中不是这样做的。它直接将所有元素转入一个数组，对数组进行排序，然后，再将排序后的序列复制会链表。</p>
<p>集合类库中使用的排序算法比快速排序要慢一些，快速排序时通用排序算法的传统选择。但是，归并排序有一个主要的优点：稳定，即不需要交换相同的元素。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>只有采用随机访问，二分查找才有意义。</p>
<h3 id="第十四章-并发"><a href="#第十四章-并发" class="headerlink" title="第十四章 并发"></a>第十四章 并发</h3><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>没有可以强制线程终止的方法。然而，interrupt 方法可以用来请求线程终止。</p>
<p>但是，如果线程被阻塞，就无法检测中断状态。</p>
<p>当在一个被阻塞的线程（sleep或者wait）上调用 interrupt 方法时，阻塞调用将会被 Interrupted Exception 异常中断。</p>
<p>如果在每次工作迭代之后都调用 sleep 方法（或者其他可中断方法），isInterrupted 检测既没有必要也没有用处。如果在中断状态被置位时调用 sleep 方法，它不会休眠。相反，它将清除这一状态并抛出InterruptedException。</p>
<p>不要将 InterruptedException 捕获在低层次上！</p>
<blockquote>
<p>要么捕获然后再次设置中断状态，要么直接抛出。</p>
</blockquote>
<h4 id="可运行线程"><a href="#可运行线程" class="headerlink" title="可运行线程"></a>可运行线程</h4><p>在任何给定时刻，一个可运行的线程可能在运行也可能没有运行（这就是为什么将这个状态称为可运行而不是运行）。</p>
<h4 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h4><p>被阻塞状态与等待状态是有很大不同的。其实这句话我还不太能够理解，是本质上不同，还是Java行为上不同？</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>每一个线程有一个优先级。默认情况下，一个线程继承它的父线程的优先级。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程应该永远不去访问固有资源，如文件，数据库，<u>因为它会在任何时候甚至在一个操作的中间发生中断。</u></p>
<p>setDaemon 必须在线程启动之前调用。</p>
<h4 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h4><p>线程的 run 方法不会抛出任何受查异常，非受查异常会导致线程终止。在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。</p>
<blockquote>
<p>setUncaughtExceptionHandler 方法会未任何线程安装一个默认的处理器。</p>
<p>也可以用Thread类的静态方法 setDefaultUncaughtExceptionHandler 为所有的线程安装一个默认的处理器。</p>
</blockquote>
<p>如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的 ThreadGroup 对象。</p>
<p>ThreadGroup 类实现 Thread.UncaughtExceptionHanlder 接口。它的 uncaughtException 方法做如下操作：</p>
<ol>
<li>如果该线程组有父线程组，那么父线程组的 uncaughtException 方法被调用。</li>
<li>否则，如果 Thread.getDefaultExceptionHandler 方法返回一个非空的处理器，则调用该处理器。</li>
<li>否则，如果 Throwable 是 ThreadDeath 的一个实例，什么都不做。</li>
<li>否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。</li>
</ol>
<h4 id="锁对象-（ReentrantLock）"><a href="#锁对象-（ReentrantLock）" class="headerlink" title="锁对象 （ReentrantLock）"></a>锁对象 （ReentrantLock）</h4><p>如果使用锁，就不能使用带资源的 try 语句。</p>
<blockquote>
<p>一是无法释放锁，二是会新创建一个变量。</p>
</blockquote>
<p> 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数来跟踪对lock方法的嵌套调用。</p>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p>使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。</p>
<p>一个锁对象可以有一个或多个相关的条件对象。你可以用 newCondition 方法获得一个条件对象。</p>
<p>signalAll 方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。</p>
<p>每一个对象有一个内部锁，并且该锁有一个内部条件。初学者常常对条件感到困惑，推荐先学习ReentrantLock 的 Condition。</p>
<p>wait、nofity、notifyAll 方法都需要当前线程持有锁，否则会抛出异常。</p>
<h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>举一个有趣的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Person&gt; pList = Collections.synchronizedList(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putIfAbsent</span><span class="params">(String key, Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pList.contains(p)) &#123;</span><br><span class="line">            pList.put(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        pList.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不管这个程序有什么意义，只问一个问题，这个类是线程安全的吗？</p>
<p>虽然看起来很像是线程安全的，但是实际上不是，因为 Collections.synchronizedList 使用的锁，肯定不是 Sync 的实例。</p>
<h4 id="Volatile-域"><a href="#Volatile-域" class="headerlink" title="Volatile 域"></a>Volatile 域</h4><p>仅仅为了读写一个或两个实例域就使用同步，显得开销过大了。Volatile 可以帮助我们在这种情况下避免使用锁。</p>
<p>先来看看多个线程为什么会出现值不一致的原因：</p>
<ul>
<li>多处理器的计算机能够暂时在寄存器或本地内存缓存区中保存内存的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。</li>
<li>编译器可以改变指令执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显示的修改指令时才会改变。然而，内存的值可以被另一个线程改变！</li>
</ul>
<p>早期的CPU使用的是总线锁的方式来保证 Volatile 域的一致性，现在都使用的是缓存一致性。</p>
<h4 id="final-变量"><a href="#final-变量" class="headerlink" title="final 变量"></a>final 变量</h4><p>如果在某个类中，将一个域声明为 final 类型，那么会起到这样的一个效果：</p>
<blockquote>
<p>其他的线程会在该类的构造函数执行完毕之后才能看到这个 final 域的值。</p>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为 volatile。</p>
<p>java.util.concurrent.atomic 包中有很多类使用了<u>很高级的机器级指令（不是使用锁）</u>来保证其他操作的原子性。</p>
<p>稍微提一下，使用 compareAndSet 实现乐观锁的常用写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    oldValue = largest.get();</span><br><span class="line">    newValue = Math.max(oldValue, observed);</span><br><span class="line">&#125; <span class="keyword">while</span> (!largest.compareAndSet(oldValue, newValue));</span><br></pre></td></tr></table></figure>

<p>compareAndSet 的工作原理：期望内存中的值是 oldValue，是则用 newValue 替换它，返回 true，不是则返回 false。</p>
<p>如果有大量线程要访问相同的原子值，函数性能会大幅下降，因为乐观更新需要太多次重试。</p>
<h4 id="锁测试与超时"><a href="#锁测试与超时" class="headerlink" title="锁测试与超时"></a>锁测试与超时</h4><p><u>lock 方法不能被中断，在获得锁之前会一直阻塞</u>，如果出现死锁，则 lock 方法无法终止。可以使用 tryLock 来响应中断。</p>
<p>tryLock 还有一个隐藏特性：这个方法会抢夺可用的锁，即使该锁有公平加锁策略，即便其他线程已经等待很久也是如此。</p>
<h4 id="为什么弃用-stop-和-suspend-方法"><a href="#为什么弃用-stop-和-suspend-方法" class="headerlink" title="为什么弃用 stop 和 suspend 方法"></a>为什么弃用 stop 和 suspend 方法</h4><p>stop 方法：该方法终止所有未结束的方法，包括 run 方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。</p>
<p>例如：从 A 转账到 B，线程突然被终止，钱已经转出去了，却没有进入 B 账户，那么 Bank 对象就被破坏了。</p>
<p>suspend 方法：如果用该方法挂起一个持有锁的线程，那么该锁在恢复之前是不可用的。如果调用 suspend 方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等着被恢复，而将其挂起的线程等待获得锁。</p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 是 ConcurrentHashMap 的实例</span></span><br><span class="line">Long oldValue = map.get(word);</span><br><span class="line">Long newValue = oldValue == <span class="keyword">null</span> ? <span class="number">1</span> : oldValue + <span class="number">1</span>;</span><br><span class="line">map.put(word, newValue);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，由于操作不是原子的，所以最终的结果不可预料。但是，要理解 ConcurrentHashMap 与 HashMap 的区别，这里的 get 与 put 都是原子操作，在多线程情况下不会破坏 map 的结构，而 HashMap 在多线程情况下会出现循环链表等问题。</p>
<p>ConcurrentHashMap 返回的迭代器具有弱一致性。这意味着迭代器不一定能反映出它们被构造之后的所有的修改（可以认为是某一特定时刻的快照），它们不会将同一个值返回两次，不会抛出 ConcurrentModificationException。</p>
<h4 id="CopyOnWriteArrayList-和-CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList-和-CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList 和 CopyOnWriteArraySet"></a>CopyOnWriteArrayList 和 CopyOnWriteArraySet</h4><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>调用 shutdown 方法，该线程池不再接收新任务。当所有任务完成后，线程池死亡。</p>
<p>调用 shutdownNow 方法，该线程池取消尚未开始的所有任务，并视图中断正在运行的线程。</p>
<h4 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h4><p>如果有大量的 Callable 要执行，可以使用这个类。</p>
<h4 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork-Join 框架"></a>Fork-Join 框架</h4><p>这个框架用来分解子任务，提高线程利用率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">RecursiveTasks</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (to - from &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// .....</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (from + to) / <span class="number">2</span>;</span><br><span class="line">            Counter first = <span class="keyword">new</span> Counter(values, from, mid, filter);</span><br><span class="line">            Counter second = <span class="keyword">new</span> Counter(values, mid, to, filter);</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line">            invokeAll(first, second);</span><br><span class="line">            <span class="comment">// 合并</span></span><br><span class="line">            <span class="keyword">return</span> first.join() + second.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>任何线程可以释放任何数量的许可，这可能会增加许可数目以至于超出初始数目。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2019/09/10/blog_bak/Blog/Java/CompletableFuture的使用/" rel="bookmark">CompletableFuture 的使用</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2019/09/10/blog_bak/Blog/Java/IO阻塞/" rel="bookmark">IO 阻塞</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2020/04/11/blog_bak/Blog/Java/HashMap的扩容原理/" rel="bookmark">HashMap的扩容原理(基于JDK1.8)</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2020/04/04/blog_bak/Blog/Java/Java Final 关键字/" rel="bookmark">Java Final 关键字</a></div>
      
    </li>
  
    <li class="popular-posts-item">
      
      
      <div class="popular-posts-title"><a href="/2020/04/11/blog_bak/Blog/Java/LinkedHashMap与LruCache/" rel="bookmark">LinkedHashMap与LruCache</a></div>
      
    </li>
  
  </ul>

        
      
        <div id="reward-container">
  <div>觉得不错，那就赞赏一下吧～</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpg" alt="aprz512 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="aprz512 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>aprz512</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/" title="Java核心技术（基础知识）笔记">http://aprz512.github.io/2019/09/10/blog_bak/Blog/Java/Java核心技术（卷一）笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"># Java</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/10/blog_bak/Blog/Android-JetPack/Navigation 的使用记录/" rel="next" title="Navigation 的使用记录">
                  <i class="fa fa-chevron-left"></i> Navigation 的使用记录
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/10/blog_bak/Blog/Android-高级/混合编译器/" rel="prev" title="混合编译器">
                  混合编译器 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="comments"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://github.com/aprz512/pic4aprz512/blob/master/Blog/avatar/avatar.jpeg?raw=true"
      alt="aprz512">
  <p class="site-author-name" itemprop="name">aprz512</p>
  <div class="site-description motion-element" itemprop="description">博客建于2017年02月05日21:39:56</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aprz512" title="GitHub &rarr; https://github.com/aprz512" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>




        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-Java程序设计概述"><span class="nav-number">1.</span> <span class="nav-text">第一章 Java程序设计概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象设计"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#即时编译"><span class="nav-number">1.2.</span> <span class="nav-text">即时编译</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-Java的基本程序设计结构"><span class="nav-number">2.</span> <span class="nav-text">第三章 Java的基本程序设计结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-类与对象"><span class="nav-number">3.</span> <span class="nav-text">第四章 类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象析构与-finalize-方法"><span class="nav-number">3.1.</span> <span class="nav-text">对象析构与 finalize 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五章-继承"><span class="nav-number">4.</span> <span class="nav-text">第五章 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类、超类和子类"><span class="nav-number">4.1.</span> <span class="nav-text">类、超类和子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖方法"><span class="nav-number">4.2.</span> <span class="nav-text">覆盖方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态绑定"><span class="nav-number">4.3.</span> <span class="nav-text">动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态"><span class="nav-number">4.4.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#理解方法调用"><span class="nav-number">4.5.</span> <span class="nav-text">理解方法调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻止继承：final类和方法"><span class="nav-number">4.6.</span> <span class="nav-text">阻止继承：final类和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object：所有类的超类"><span class="nav-number">4.7.</span> <span class="nav-text">Object：所有类的超类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals方法"><span class="nav-number">4.8.</span> <span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相等测试与继承"><span class="nav-number">4.9.</span> <span class="nav-text">相等测试与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode"><span class="nav-number">4.10.</span> <span class="nav-text">hashCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型数组列表"><span class="nav-number">4.11.</span> <span class="nav-text">泛型数组列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象包装器与自动装箱"><span class="nav-number">4.12.</span> <span class="nav-text">对象包装器与自动装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在运行时使用反射分析对象"><span class="nav-number">4.13.</span> <span class="nav-text">在运行时使用反射分析对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的设计技巧"><span class="nav-number">4.14.</span> <span class="nav-text">继承的设计技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-接口、lambda表达式与内部类"><span class="nav-number">5.</span> <span class="nav-text">第六章 接口、lambda表达式与内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparable-lt-T-gt-接口"><span class="nav-number">5.1.</span> <span class="nav-text">Comparable&lt;T&gt; 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法"><span class="nav-number">5.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认方法"><span class="nav-number">5.3.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决默认方法冲突"><span class="nav-number">5.4.</span> <span class="nav-text">解决默认方法冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象克隆"><span class="nav-number">5.5.</span> <span class="nav-text">对象克隆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么引入lambda表达式"><span class="nav-number">5.6.</span> <span class="nav-text">为什么引入lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda表达式的语法"><span class="nav-number">5.7.</span> <span class="nav-text">lambda表达式的语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式表达式"><span class="nav-number">5.8.</span> <span class="nav-text">函数式表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法引用"><span class="nav-number">5.9.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造器引用"><span class="nav-number">5.10.</span> <span class="nav-text">构造器引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量作用域"><span class="nav-number">5.11.</span> <span class="nav-text">变量作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理lambda表达式"><span class="nav-number">5.12.</span> <span class="nav-text">处理lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再谈Comparator"><span class="nav-number">5.13.</span> <span class="nav-text">再谈Comparator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类的特殊规则语法"><span class="nav-number">5.14.</span> <span class="nav-text">内部类的特殊规则语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类是否有用、必要和安全"><span class="nav-number">5.15.</span> <span class="nav-text">内部类是否有用、必要和安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">5.16.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理的特性"><span class="nav-number">5.17.</span> <span class="nav-text">代理的特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七章-异常、断言和日志"><span class="nav-number">6.</span> <span class="nav-text">第七章 异常、断言和日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常分类"><span class="nav-number">6.1.</span> <span class="nav-text">异常分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#声明受查异常"><span class="nav-number">6.2.</span> <span class="nav-text">声明受查异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获异常"><span class="nav-number">6.3.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获多个异常"><span class="nav-number">6.4.</span> <span class="nav-text">捕获多个异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再次抛出异常与异常链"><span class="nav-number">6.5.</span> <span class="nav-text">再次抛出异常与异常链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally子句"><span class="nav-number">6.6.</span> <span class="nav-text">finally子句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带资源的-try-语句"><span class="nav-number">6.7.</span> <span class="nav-text">带资源的 try 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第八章-泛型程序设计"><span class="nav-number">7.</span> <span class="nav-text">第八章 泛型程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义简单泛型类"><span class="nav-number">7.1.</span> <span class="nav-text">定义简单泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型变量的限定"><span class="nav-number">7.2.</span> <span class="nav-text">类型变量的限定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型擦除"><span class="nav-number">7.3.</span> <span class="nav-text">类型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#翻译泛型方法"><span class="nav-number">7.4.</span> <span class="nav-text">翻译泛型方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能用基本类型实例化类型参数"><span class="nav-number">7.5.</span> <span class="nav-text">不能用基本类型实例化类型参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时类型查询只适用于原始类型"><span class="nav-number">7.6.</span> <span class="nav-text">运行时类型查询只适用于原始类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Varargs-警告"><span class="nav-number">7.7.</span> <span class="nav-text">Varargs 警告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能构造泛型数组"><span class="nav-number">7.8.</span> <span class="nav-text">不能构造泛型数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型类的静态上下文中类型变量无效"><span class="nav-number">7.9.</span> <span class="nav-text">泛型类的静态上下文中类型变量无效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不能抛出或捕获泛型类的实例"><span class="nav-number">7.10.</span> <span class="nav-text">不能抛出或捕获泛型类的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可以消除对受查异常的检查"><span class="nav-number">7.11.</span> <span class="nav-text">可以消除对受查异常的检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意擦除后的冲突"><span class="nav-number">7.12.</span> <span class="nav-text">注意擦除后的冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符概念"><span class="nav-number">7.13.</span> <span class="nav-text">通配符概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无限定通配符"><span class="nav-number">7.14.</span> <span class="nav-text">无限定通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符捕获"><span class="nav-number">7.15.</span> <span class="nav-text">通配符捕获</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第九章-集合"><span class="nav-number">8.</span> <span class="nav-text">第九章 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-number">8.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合框架中的接口"><span class="nav-number">8.2.</span> <span class="nav-text">集合框架中的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">8.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表"><span class="nav-number">8.4.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树集"><span class="nav-number">8.5.</span> <span class="nav-text">树集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级队列"><span class="nav-number">8.6.</span> <span class="nav-text">优先级队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#映射-（Map）"><span class="nav-number">8.7.</span> <span class="nav-text">映射 （Map）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新映射项"><span class="nav-number">8.8.</span> <span class="nav-text">更新映射项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#映射视图"><span class="nav-number">8.9.</span> <span class="nav-text">映射视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#视图与包装器"><span class="nav-number">8.10.</span> <span class="nav-text">视图与包装器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级集合包装器"><span class="nav-number">8.11.</span> <span class="nav-text">轻量级集合包装器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子范围"><span class="nav-number">8.12.</span> <span class="nav-text">子范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不可修改的视图"><span class="nav-number">8.13.</span> <span class="nav-text">不可修改的视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#受查视图"><span class="nav-number">8.14.</span> <span class="nav-text">受查视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序与混排"><span class="nav-number">8.15.</span> <span class="nav-text">排序与混排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">8.16.</span> <span class="nav-text">二分查找</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十四章-并发"><span class="nav-number">9.</span> <span class="nav-text">第十四章 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断线程"><span class="nav-number">9.1.</span> <span class="nav-text">中断线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可运行线程"><span class="nav-number">9.2.</span> <span class="nav-text">可运行线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#被阻塞线程和等待线程"><span class="nav-number">9.3.</span> <span class="nav-text">被阻塞线程和等待线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程优先级"><span class="nav-number">9.4.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#守护线程"><span class="nav-number">9.5.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#未捕获异常处理器"><span class="nav-number">9.6.</span> <span class="nav-text">未捕获异常处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁对象-（ReentrantLock）"><span class="nav-number">9.7.</span> <span class="nav-text">锁对象 （ReentrantLock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件对象"><span class="nav-number">9.8.</span> <span class="nav-text">条件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步阻塞"><span class="nav-number">9.9.</span> <span class="nav-text">同步阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Volatile-域"><span class="nav-number">9.10.</span> <span class="nav-text">Volatile 域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final-变量"><span class="nav-number">9.11.</span> <span class="nav-text">final 变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性"><span class="nav-number">9.12.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁测试与超时"><span class="nav-number">9.13.</span> <span class="nav-text">锁测试与超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么弃用-stop-和-suspend-方法"><span class="nav-number">9.14.</span> <span class="nav-text">为什么弃用 stop 和 suspend 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">9.15.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CopyOnWriteArrayList-和-CopyOnWriteArraySet"><span class="nav-number">9.16.</span> <span class="nav-text">CopyOnWriteArrayList 和 CopyOnWriteArraySet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池"><span class="nav-number">9.17.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorCompletionService"><span class="nav-number">9.18.</span> <span class="nav-text">ExecutorCompletionService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fork-Join-框架"><span class="nav-number">9.19.</span> <span class="nav-text">Fork-Join 框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">9.20.</span> <span class="nav-text">信号量</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">773k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">11:43</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>



<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'g48OrtSq4q4MWp6EAEWbkAsT-gzGzoHsz',
    appKey: 'CXW8M63QPXbQ9qKMgHDy9Be2',
    placeholder: '说点什么吧',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
